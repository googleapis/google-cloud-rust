// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Defines an answer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Answer {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions/*/answers/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The state of the answer generation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::answer::State,

    /// The textual answer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub answer_text: std::string::String,

    /// A score in the range of [0, 1] describing how grounded the answer is by the
    /// reference chunks.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub grounding_score: std::option::Option<f64>,

    /// Citations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub citations: std::vec::Vec<crate::model::answer::Citation>,

    /// Optional. Grounding supports.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grounding_supports: std::vec::Vec<crate::model::answer::GroundingSupport>,

    /// References.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub references: std::vec::Vec<crate::model::answer::Reference>,

    /// Suggested related questions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub related_questions: std::vec::Vec<std::string::String>,

    /// Answer generation steps.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::answer::Step>,

    /// Query understanding information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_understanding_info: std::option::Option<crate::model::answer::QueryUnderstandingInfo>,

    /// Additional answer-skipped reasons. This provides the reason for ignored
    /// cases. If nothing is skipped, this field is not set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub answer_skipped_reasons: std::vec::Vec<crate::model::answer::AnswerSkippedReason>,

    /// Output only. Answer creation timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Answer completed timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub complete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Safety ratings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub safety_ratings: std::vec::Vec<crate::model::SafetyRating>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Answer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Answer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Answer::state].
    pub fn set_state<T: std::convert::Into<crate::model::answer::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [answer_text][crate::model::Answer::answer_text].
    pub fn set_answer_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_text = v.into();
        self
    }

    /// Sets the value of [grounding_score][crate::model::Answer::grounding_score].
    pub fn set_grounding_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.grounding_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [grounding_score][crate::model::Answer::grounding_score].
    pub fn set_or_clear_grounding_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.grounding_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [citations][crate::model::Answer::citations].
    pub fn set_citations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::answer::Citation>,
    {
        use std::iter::Iterator;
        self.citations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grounding_supports][crate::model::Answer::grounding_supports].
    pub fn set_grounding_supports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::answer::GroundingSupport>,
    {
        use std::iter::Iterator;
        self.grounding_supports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [references][crate::model::Answer::references].
    pub fn set_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::answer::Reference>,
    {
        use std::iter::Iterator;
        self.references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [related_questions][crate::model::Answer::related_questions].
    pub fn set_related_questions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.related_questions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [steps][crate::model::Answer::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::answer::Step>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [query_understanding_info][crate::model::Answer::query_understanding_info].
    pub fn set_query_understanding_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer::QueryUnderstandingInfo>,
    {
        self.query_understanding_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_understanding_info][crate::model::Answer::query_understanding_info].
    pub fn set_or_clear_query_understanding_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer::QueryUnderstandingInfo>,
    {
        self.query_understanding_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [answer_skipped_reasons][crate::model::Answer::answer_skipped_reasons].
    pub fn set_answer_skipped_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::answer::AnswerSkippedReason>,
    {
        use std::iter::Iterator;
        self.answer_skipped_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Answer::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Answer::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [complete_time][crate::model::Answer::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::Answer::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [safety_ratings][crate::model::Answer::safety_ratings].
    pub fn set_safety_ratings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SafetyRating>,
    {
        use std::iter::Iterator;
        self.safety_ratings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Answer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Answer"
    }
}

/// Defines additional types related to [Answer].
pub mod answer {
    #[allow(unused_imports)]
    use super::*;

    /// Citation info for a segment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Citation {
        /// Index indicates the start of the segment, measured in bytes (UTF-8
        /// unicode). If there are multi-byte characters,such as non-ASCII
        /// characters, the index measurement is longer than the string length.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub start_index: i64,

        /// End of the attributed segment, exclusive. Measured in bytes (UTF-8
        /// unicode). If there are multi-byte characters,such as non-ASCII
        /// characters, the index measurement is longer than the string length.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub end_index: i64,

        /// Citation sources for the attributed segment.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sources: std::vec::Vec<crate::model::answer::CitationSource>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Citation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_index][crate::model::answer::Citation::start_index].
        pub fn set_start_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.start_index = v.into();
            self
        }

        /// Sets the value of [end_index][crate::model::answer::Citation::end_index].
        pub fn set_end_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.end_index = v.into();
            self
        }

        /// Sets the value of [sources][crate::model::answer::Citation::sources].
        pub fn set_sources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::answer::CitationSource>,
        {
            use std::iter::Iterator;
            self.sources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Citation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Citation"
        }
    }

    /// Citation source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CitationSource {
        /// ID of the citation source.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub reference_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CitationSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reference_id][crate::model::answer::CitationSource::reference_id].
        pub fn set_reference_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.reference_id = v.into();
            self
        }
    }

    impl wkt::message::Message for CitationSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.CitationSource"
        }
    }

    /// Grounding support for a claim in `answer_text`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroundingSupport {
        /// Required. Index indicates the start of the claim, measured in bytes
        /// (UTF-8 unicode).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub start_index: i64,

        /// Required. End of the claim, exclusive.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub end_index: i64,

        /// A score in the range of [0, 1] describing how grounded is a specific
        /// claim by the references.
        /// Higher value means that the claim is better supported by the reference
        /// chunks.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
        pub grounding_score: std::option::Option<f64>,

        /// Indicates that this claim required grounding check. When the
        /// system decided this claim didn't require attribution/grounding check,
        /// this field is set to false. In that case, no grounding check was
        /// done for the claim and therefore `grounding_score`, `sources` is not
        /// returned.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub grounding_check_required: std::option::Option<bool>,

        /// Optional. Citation sources for the claim.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sources: std::vec::Vec<crate::model::answer::CitationSource>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroundingSupport {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_index][crate::model::answer::GroundingSupport::start_index].
        pub fn set_start_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.start_index = v.into();
            self
        }

        /// Sets the value of [end_index][crate::model::answer::GroundingSupport::end_index].
        pub fn set_end_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.end_index = v.into();
            self
        }

        /// Sets the value of [grounding_score][crate::model::answer::GroundingSupport::grounding_score].
        pub fn set_grounding_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.grounding_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [grounding_score][crate::model::answer::GroundingSupport::grounding_score].
        pub fn set_or_clear_grounding_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f64>,
        {
            self.grounding_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [grounding_check_required][crate::model::answer::GroundingSupport::grounding_check_required].
        pub fn set_grounding_check_required<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.grounding_check_required = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [grounding_check_required][crate::model::answer::GroundingSupport::grounding_check_required].
        pub fn set_or_clear_grounding_check_required<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.grounding_check_required = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sources][crate::model::answer::GroundingSupport::sources].
        pub fn set_sources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::answer::CitationSource>,
        {
            use std::iter::Iterator;
            self.sources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GroundingSupport {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.GroundingSupport"
        }
    }

    /// Reference.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Reference {
        /// Search result content.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub content: std::option::Option<crate::model::answer::reference::Content>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Reference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [content][crate::model::answer::Reference::content].
        ///
        /// Note that all the setters affecting `content` are mutually
        /// exclusive.
        pub fn set_content<
            T: std::convert::Into<std::option::Option<crate::model::answer::reference::Content>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.content = v.into();
            self
        }

        /// The value of [content][crate::model::answer::Reference::content]
        /// if it holds a `UnstructuredDocumentInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn unstructured_document_info(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::answer::reference::UnstructuredDocumentInfo>,
        > {
            #[allow(unreachable_patterns)]
            self.content.as_ref().and_then(|v| match v {
                crate::model::answer::reference::Content::UnstructuredDocumentInfo(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [content][crate::model::answer::Reference::content]
        /// to hold a `UnstructuredDocumentInfo`.
        ///
        /// Note that all the setters affecting `content` are
        /// mutually exclusive.
        pub fn set_unstructured_document_info<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::answer::reference::UnstructuredDocumentInfo>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.content = std::option::Option::Some(
                crate::model::answer::reference::Content::UnstructuredDocumentInfo(v.into()),
            );
            self
        }

        /// The value of [content][crate::model::answer::Reference::content]
        /// if it holds a `ChunkInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn chunk_info(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::answer::reference::ChunkInfo>>
        {
            #[allow(unreachable_patterns)]
            self.content.as_ref().and_then(|v| match v {
                crate::model::answer::reference::Content::ChunkInfo(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [content][crate::model::answer::Reference::content]
        /// to hold a `ChunkInfo`.
        ///
        /// Note that all the setters affecting `content` are
        /// mutually exclusive.
        pub fn set_chunk_info<
            T: std::convert::Into<std::boxed::Box<crate::model::answer::reference::ChunkInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.content = std::option::Option::Some(
                crate::model::answer::reference::Content::ChunkInfo(v.into()),
            );
            self
        }

        /// The value of [content][crate::model::answer::Reference::content]
        /// if it holds a `StructuredDocumentInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn structured_document_info(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::answer::reference::StructuredDocumentInfo>,
        > {
            #[allow(unreachable_patterns)]
            self.content.as_ref().and_then(|v| match v {
                crate::model::answer::reference::Content::StructuredDocumentInfo(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [content][crate::model::answer::Reference::content]
        /// to hold a `StructuredDocumentInfo`.
        ///
        /// Note that all the setters affecting `content` are
        /// mutually exclusive.
        pub fn set_structured_document_info<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::answer::reference::StructuredDocumentInfo>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.content = std::option::Option::Some(
                crate::model::answer::reference::Content::StructuredDocumentInfo(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Reference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Reference"
        }
    }

    /// Defines additional types related to [Reference].
    pub mod reference {
        #[allow(unused_imports)]
        use super::*;

        /// Unstructured document information.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct UnstructuredDocumentInfo {
            /// Document resource name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub document: std::string::String,

            /// URI for the document.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,

            /// Title.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            /// List of cited chunk contents derived from document content.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub chunk_contents: std::vec::Vec<
                crate::model::answer::reference::unstructured_document_info::ChunkContent,
            >,

            /// The structured JSON metadata for the document.
            /// It is populated from the struct data from the Chunk in search result.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub struct_data: std::option::Option<wkt::Struct>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl UnstructuredDocumentInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [document][crate::model::answer::reference::UnstructuredDocumentInfo::document].
            pub fn set_document<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.document = v.into();
                self
            }

            /// Sets the value of [uri][crate::model::answer::reference::UnstructuredDocumentInfo::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }

            /// Sets the value of [title][crate::model::answer::reference::UnstructuredDocumentInfo::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [chunk_contents][crate::model::answer::reference::UnstructuredDocumentInfo::chunk_contents].
            pub fn set_chunk_contents<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::answer::reference::unstructured_document_info::ChunkContent,
                    >,
            {
                use std::iter::Iterator;
                self.chunk_contents = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [struct_data][crate::model::answer::reference::UnstructuredDocumentInfo::struct_data].
            pub fn set_struct_data<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Struct>,
            {
                self.struct_data = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [struct_data][crate::model::answer::reference::UnstructuredDocumentInfo::struct_data].
            pub fn set_or_clear_struct_data<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Struct>,
            {
                self.struct_data = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for UnstructuredDocumentInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Reference.UnstructuredDocumentInfo"
            }
        }

        /// Defines additional types related to [UnstructuredDocumentInfo].
        pub mod unstructured_document_info {
            #[allow(unused_imports)]
            use super::*;

            /// Chunk content.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ChunkContent {
                /// Chunk textual content.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub content: std::string::String,

                /// Page identifier.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub page_identifier: std::string::String,

                /// The relevance of the chunk for a given query. Values range from 0.0
                /// (completely irrelevant) to 1.0 (completely relevant).
                /// This value is for informational purpose only. It may change for
                /// the same query and chunk at any time due to a model retraining or
                /// change in implementation.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                pub relevance_score: std::option::Option<f32>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ChunkContent {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [content][crate::model::answer::reference::unstructured_document_info::ChunkContent::content].
                pub fn set_content<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.content = v.into();
                    self
                }

                /// Sets the value of [page_identifier][crate::model::answer::reference::unstructured_document_info::ChunkContent::page_identifier].
                pub fn set_page_identifier<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.page_identifier = v.into();
                    self
                }

                /// Sets the value of [relevance_score][crate::model::answer::reference::unstructured_document_info::ChunkContent::relevance_score].
                pub fn set_relevance_score<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.relevance_score = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [relevance_score][crate::model::answer::reference::unstructured_document_info::ChunkContent::relevance_score].
                pub fn set_or_clear_relevance_score<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.relevance_score = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ChunkContent {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Reference.UnstructuredDocumentInfo.ChunkContent"
                }
            }
        }

        /// Chunk information.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ChunkInfo {
            /// Chunk resource name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub chunk: std::string::String,

            /// Chunk textual content.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub content: std::string::String,

            /// The relevance of the chunk for a given query. Values range from 0.0
            /// (completely irrelevant) to 1.0 (completely relevant).
            /// This value is for informational purpose only. It may change for
            /// the same query and chunk at any time due to a model retraining or
            /// change in implementation.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
            pub relevance_score: std::option::Option<f32>,

            /// Document metadata.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub document_metadata:
                std::option::Option<crate::model::answer::reference::chunk_info::DocumentMetadata>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ChunkInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [chunk][crate::model::answer::reference::ChunkInfo::chunk].
            pub fn set_chunk<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.chunk = v.into();
                self
            }

            /// Sets the value of [content][crate::model::answer::reference::ChunkInfo::content].
            pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.content = v.into();
                self
            }

            /// Sets the value of [relevance_score][crate::model::answer::reference::ChunkInfo::relevance_score].
            pub fn set_relevance_score<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<f32>,
            {
                self.relevance_score = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [relevance_score][crate::model::answer::reference::ChunkInfo::relevance_score].
            pub fn set_or_clear_relevance_score<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<f32>,
            {
                self.relevance_score = v.map(|x| x.into());
                self
            }

            /// Sets the value of [document_metadata][crate::model::answer::reference::ChunkInfo::document_metadata].
            pub fn set_document_metadata<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::answer::reference::chunk_info::DocumentMetadata,
                    >,
            {
                self.document_metadata = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [document_metadata][crate::model::answer::reference::ChunkInfo::document_metadata].
            pub fn set_or_clear_document_metadata<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::answer::reference::chunk_info::DocumentMetadata,
                    >,
            {
                self.document_metadata = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for ChunkInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Reference.ChunkInfo"
            }
        }

        /// Defines additional types related to [ChunkInfo].
        pub mod chunk_info {
            #[allow(unused_imports)]
            use super::*;

            /// Document metadata.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DocumentMetadata {
                /// Document resource name.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub document: std::string::String,

                /// URI for the document.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub uri: std::string::String,

                /// Title.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub title: std::string::String,

                /// Page identifier.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub page_identifier: std::string::String,

                /// The structured JSON metadata for the document.
                /// It is populated from the struct data from the Chunk in search result.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub struct_data: std::option::Option<wkt::Struct>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DocumentMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [document][crate::model::answer::reference::chunk_info::DocumentMetadata::document].
                pub fn set_document<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.document = v.into();
                    self
                }

                /// Sets the value of [uri][crate::model::answer::reference::chunk_info::DocumentMetadata::uri].
                pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.uri = v.into();
                    self
                }

                /// Sets the value of [title][crate::model::answer::reference::chunk_info::DocumentMetadata::title].
                pub fn set_title<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.title = v.into();
                    self
                }

                /// Sets the value of [page_identifier][crate::model::answer::reference::chunk_info::DocumentMetadata::page_identifier].
                pub fn set_page_identifier<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.page_identifier = v.into();
                    self
                }

                /// Sets the value of [struct_data][crate::model::answer::reference::chunk_info::DocumentMetadata::struct_data].
                pub fn set_struct_data<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Struct>,
                {
                    self.struct_data = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [struct_data][crate::model::answer::reference::chunk_info::DocumentMetadata::struct_data].
                pub fn set_or_clear_struct_data<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Struct>,
                {
                    self.struct_data = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for DocumentMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Reference.ChunkInfo.DocumentMetadata"
                }
            }
        }

        /// Structured search information.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct StructuredDocumentInfo {
            /// Document resource name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub document: std::string::String,

            /// Structured search data.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub struct_data: std::option::Option<wkt::Struct>,

            /// Output only. The title of the document.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            /// Output only. The URI of the document.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl StructuredDocumentInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [document][crate::model::answer::reference::StructuredDocumentInfo::document].
            pub fn set_document<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.document = v.into();
                self
            }

            /// Sets the value of [struct_data][crate::model::answer::reference::StructuredDocumentInfo::struct_data].
            pub fn set_struct_data<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Struct>,
            {
                self.struct_data = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [struct_data][crate::model::answer::reference::StructuredDocumentInfo::struct_data].
            pub fn set_or_clear_struct_data<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Struct>,
            {
                self.struct_data = v.map(|x| x.into());
                self
            }

            /// Sets the value of [title][crate::model::answer::reference::StructuredDocumentInfo::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [uri][crate::model::answer::reference::StructuredDocumentInfo::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        impl wkt::message::Message for StructuredDocumentInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Reference.StructuredDocumentInfo"
            }
        }

        /// Search result content.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Content {
            /// Unstructured document information.
            UnstructuredDocumentInfo(
                std::boxed::Box<crate::model::answer::reference::UnstructuredDocumentInfo>,
            ),
            /// Chunk information.
            ChunkInfo(std::boxed::Box<crate::model::answer::reference::ChunkInfo>),
            /// Structured document information.
            StructuredDocumentInfo(
                std::boxed::Box<crate::model::answer::reference::StructuredDocumentInfo>,
            ),
        }
    }

    /// Step information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Step {
        /// The state of the step.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub state: crate::model::answer::step::State,

        /// The description of the step.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// The thought of the step.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub thought: std::string::String,

        /// Actions.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub actions: std::vec::Vec<crate::model::answer::step::Action>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Step {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::answer::Step::state].
        pub fn set_state<T: std::convert::Into<crate::model::answer::step::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [description][crate::model::answer::Step::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [thought][crate::model::answer::Step::thought].
        pub fn set_thought<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.thought = v.into();
            self
        }

        /// Sets the value of [actions][crate::model::answer::Step::actions].
        pub fn set_actions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::answer::step::Action>,
        {
            use std::iter::Iterator;
            self.actions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Step {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Step"
        }
    }

    /// Defines additional types related to [Step].
    pub mod step {
        #[allow(unused_imports)]
        use super::*;

        /// Action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Action {
            /// Observation.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub observation: std::option::Option<crate::model::answer::step::action::Observation>,

            /// The action.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub action: std::option::Option<crate::model::answer::step::action::Action>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Action {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [observation][crate::model::answer::step::Action::observation].
            pub fn set_observation<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::answer::step::action::Observation>,
            {
                self.observation = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [observation][crate::model::answer::step::Action::observation].
            pub fn set_or_clear_observation<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::answer::step::action::Observation>,
            {
                self.observation = v.map(|x| x.into());
                self
            }

            /// Sets the value of [action][crate::model::answer::step::Action::action].
            ///
            /// Note that all the setters affecting `action` are mutually
            /// exclusive.
            pub fn set_action<
                T: std::convert::Into<std::option::Option<crate::model::answer::step::action::Action>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.action = v.into();
                self
            }

            /// The value of [action][crate::model::answer::step::Action::action]
            /// if it holds a `SearchAction`, `None` if the field is not set or
            /// holds a different branch.
            pub fn search_action(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::answer::step::action::SearchAction>,
            > {
                #[allow(unreachable_patterns)]
                self.action.as_ref().and_then(|v| match v {
                    crate::model::answer::step::action::Action::SearchAction(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [action][crate::model::answer::step::Action::action]
            /// to hold a `SearchAction`.
            ///
            /// Note that all the setters affecting `action` are
            /// mutually exclusive.
            pub fn set_search_action<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::answer::step::action::SearchAction>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.action = std::option::Option::Some(
                    crate::model::answer::step::action::Action::SearchAction(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Action {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Step.Action"
            }
        }

        /// Defines additional types related to [Action].
        pub mod action {
            #[allow(unused_imports)]
            use super::*;

            /// Search action.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct SearchAction {
                /// The query to search.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub query: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl SearchAction {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [query][crate::model::answer::step::action::SearchAction::query].
                pub fn set_query<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.query = v.into();
                    self
                }
            }

            impl wkt::message::Message for SearchAction {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Step.Action.SearchAction"
                }
            }

            /// Observation.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Observation {
                /// Search results observed by the search action, it can be snippets info
                /// or chunk info, depending on the citation type set by the user.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub search_results:
                    std::vec::Vec<crate::model::answer::step::action::observation::SearchResult>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Observation {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [search_results][crate::model::answer::step::action::Observation::search_results].
                pub fn set_search_results<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<
                            crate::model::answer::step::action::observation::SearchResult,
                        >,
                {
                    use std::iter::Iterator;
                    self.search_results = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for Observation {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Step.Action.Observation"
                }
            }

            /// Defines additional types related to [Observation].
            pub mod observation {
                #[allow(unused_imports)]
                use super::*;

                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct SearchResult {
                    /// Document resource name.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub document: std::string::String,

                    /// URI for the document.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub uri: std::string::String,

                    /// Title.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub title: std::string::String,

                    /// If citation_type is DOCUMENT_LEVEL_CITATION, populate document
                    /// level snippets.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub snippet_info: std::vec::Vec<
                        crate::model::answer::step::action::observation::search_result::SnippetInfo,
                    >,

                    /// If citation_type is CHUNK_LEVEL_CITATION and chunk mode is on,
                    /// populate chunk info.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub chunk_info: std::vec::Vec<
                        crate::model::answer::step::action::observation::search_result::ChunkInfo,
                    >,

                    /// Data representation.
                    /// The structured JSON data for the document.
                    /// It's populated from the struct data from the Document, or the
                    /// Chunk in search result.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub struct_data: std::option::Option<wkt::Struct>,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl SearchResult {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [document][crate::model::answer::step::action::observation::SearchResult::document].
                    pub fn set_document<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.document = v.into();
                        self
                    }

                    /// Sets the value of [uri][crate::model::answer::step::action::observation::SearchResult::uri].
                    pub fn set_uri<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.uri = v.into();
                        self
                    }

                    /// Sets the value of [title][crate::model::answer::step::action::observation::SearchResult::title].
                    pub fn set_title<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.title = v.into();
                        self
                    }

                    /// Sets the value of [snippet_info][crate::model::answer::step::action::observation::SearchResult::snippet_info].
                    pub fn set_snippet_info<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<crate::model::answer::step::action::observation::search_result::SnippetInfo>
                    {
                        use std::iter::Iterator;
                        self.snippet_info = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [chunk_info][crate::model::answer::step::action::observation::SearchResult::chunk_info].
                    pub fn set_chunk_info<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<crate::model::answer::step::action::observation::search_result::ChunkInfo>
                    {
                        use std::iter::Iterator;
                        self.chunk_info = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [struct_data][crate::model::answer::step::action::observation::SearchResult::struct_data].
                    pub fn set_struct_data<T>(mut self, v: T) -> Self
                    where
                        T: std::convert::Into<wkt::Struct>,
                    {
                        self.struct_data = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [struct_data][crate::model::answer::step::action::observation::SearchResult::struct_data].
                    pub fn set_or_clear_struct_data<T>(mut self, v: std::option::Option<T>) -> Self
                    where
                        T: std::convert::Into<wkt::Struct>,
                    {
                        self.struct_data = v.map(|x| x.into());
                        self
                    }
                }

                impl wkt::message::Message for SearchResult {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Step.Action.Observation.SearchResult"
                    }
                }

                /// Defines additional types related to [SearchResult].
                pub mod search_result {
                    #[allow(unused_imports)]
                    use super::*;

                    /// Snippet information.
                    #[serde_with::serde_as]
                    #[derive(
                        Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                    )]
                    #[serde(default, rename_all = "camelCase")]
                    #[non_exhaustive]
                    pub struct SnippetInfo {
                        /// Snippet content.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub snippet: std::string::String,

                        /// Status of the snippet defined by the search team.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub snippet_status: std::string::String,

                        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    impl SnippetInfo {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [snippet][crate::model::answer::step::action::observation::search_result::SnippetInfo::snippet].
                        pub fn set_snippet<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.snippet = v.into();
                            self
                        }

                        /// Sets the value of [snippet_status][crate::model::answer::step::action::observation::search_result::SnippetInfo::snippet_status].
                        pub fn set_snippet_status<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.snippet_status = v.into();
                            self
                        }
                    }

                    impl wkt::message::Message for SnippetInfo {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Step.Action.Observation.SearchResult.SnippetInfo"
                        }
                    }

                    /// Chunk information.
                    #[serde_with::serde_as]
                    #[derive(
                        Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                    )]
                    #[serde(default, rename_all = "camelCase")]
                    #[non_exhaustive]
                    pub struct ChunkInfo {
                        /// Chunk resource name.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub chunk: std::string::String,

                        /// Chunk textual content.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub content: std::string::String,

                        /// The relevance of the chunk for a given query. Values range from
                        /// 0.0 (completely irrelevant) to 1.0 (completely relevant).
                        /// This value is for informational purpose only. It may change for
                        /// the same query and chunk at any time due to a model retraining or
                        /// change in implementation.
                        #[serde(skip_serializing_if = "std::option::Option::is_none")]
                        #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                        pub relevance_score: std::option::Option<f32>,

                        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    impl ChunkInfo {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [chunk][crate::model::answer::step::action::observation::search_result::ChunkInfo::chunk].
                        pub fn set_chunk<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.chunk = v.into();
                            self
                        }

                        /// Sets the value of [content][crate::model::answer::step::action::observation::search_result::ChunkInfo::content].
                        pub fn set_content<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.content = v.into();
                            self
                        }

                        /// Sets the value of [relevance_score][crate::model::answer::step::action::observation::search_result::ChunkInfo::relevance_score].
                        pub fn set_relevance_score<T>(mut self, v: T) -> Self
                        where
                            T: std::convert::Into<f32>,
                        {
                            self.relevance_score = std::option::Option::Some(v.into());
                            self
                        }

                        /// Sets or clears the value of [relevance_score][crate::model::answer::step::action::observation::search_result::ChunkInfo::relevance_score].
                        pub fn set_or_clear_relevance_score<T>(
                            mut self,
                            v: std::option::Option<T>,
                        ) -> Self
                        where
                            T: std::convert::Into<f32>,
                        {
                            self.relevance_score = v.map(|x| x.into());
                            self
                        }
                    }

                    impl wkt::message::Message for ChunkInfo {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.Step.Action.Observation.SearchResult.ChunkInfo"
                        }
                    }
                }
            }

            /// The action.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Action {
                /// Search action.
                SearchAction(std::boxed::Box<crate::model::answer::step::action::SearchAction>),
            }
        }

        /// Enumeration of the state of the step.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unknown.
            Unspecified,
            /// Step is currently in progress.
            InProgress,
            /// Step currently failed.
            Failed,
            /// Step has succeeded.
            Succeeded,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::InProgress => std::option::Option::Some(1),
                    Self::Failed => std::option::Option::Some(2),
                    Self::Succeeded => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::InProgress,
                    2 => Self::Failed,
                    3 => Self::Succeeded,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "IN_PROGRESS" => Self::InProgress,
                    "FAILED" => Self::Failed,
                    "SUCCEEDED" => Self::Succeeded,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::InProgress => serializer.serialize_i32(1),
                    Self::Failed => serializer.serialize_i32(2),
                    Self::Succeeded => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.discoveryengine.v1.Answer.Step.State",
                ))
            }
        }
    }

    /// Query understanding information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueryUnderstandingInfo {
        /// Query classification information.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub query_classification_info:
            std::vec::Vec<crate::model::answer::query_understanding_info::QueryClassificationInfo>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryUnderstandingInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_classification_info][crate::model::answer::QueryUnderstandingInfo::query_classification_info].
        pub fn set_query_classification_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::answer::query_understanding_info::QueryClassificationInfo,
                >,
        {
            use std::iter::Iterator;
            self.query_classification_info = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for QueryUnderstandingInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.QueryUnderstandingInfo"
        }
    }

    /// Defines additional types related to [QueryUnderstandingInfo].
    pub mod query_understanding_info {
        #[allow(unused_imports)]
        use super::*;

        /// Query classification information.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct QueryClassificationInfo {
            /// Query classification type.
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub r#type:
                crate::model::answer::query_understanding_info::query_classification_info::Type,

            /// Classification output.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub positive: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl QueryClassificationInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::answer::query_understanding_info::QueryClassificationInfo::type].
            pub fn set_type<T: std::convert::Into<crate::model::answer::query_understanding_info::query_classification_info::Type>>(mut self, v: T) -> Self{
                self.r#type = v.into();
                self
            }

            /// Sets the value of [positive][crate::model::answer::query_understanding_info::QueryClassificationInfo::positive].
            pub fn set_positive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.positive = v.into();
                self
            }
        }

        impl wkt::message::Message for QueryClassificationInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.Answer.QueryUnderstandingInfo.QueryClassificationInfo"
            }
        }

        /// Defines additional types related to [QueryClassificationInfo].
        pub mod query_classification_info {
            #[allow(unused_imports)]
            use super::*;

            /// Query classification types.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// Unspecified query classification type.
                Unspecified,
                /// Adversarial query classification type.
                AdversarialQuery,
                /// Non-answer-seeking query classification type, for chit chat.
                NonAnswerSeekingQuery,
                /// Jail-breaking query classification type.
                JailBreakingQuery,
                /// Non-answer-seeking query classification type, for no clear intent.
                NonAnswerSeekingQueryV2,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Type::value] or
                /// [Type::name].
                UnknownValue(r#type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod r#type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Type {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::AdversarialQuery => std::option::Option::Some(1),
                        Self::NonAnswerSeekingQuery => std::option::Option::Some(2),
                        Self::JailBreakingQuery => std::option::Option::Some(3),
                        Self::NonAnswerSeekingQueryV2 => std::option::Option::Some(4),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                        Self::AdversarialQuery => std::option::Option::Some("ADVERSARIAL_QUERY"),
                        Self::NonAnswerSeekingQuery => {
                            std::option::Option::Some("NON_ANSWER_SEEKING_QUERY")
                        }
                        Self::JailBreakingQuery => std::option::Option::Some("JAIL_BREAKING_QUERY"),
                        Self::NonAnswerSeekingQueryV2 => {
                            std::option::Option::Some("NON_ANSWER_SEEKING_QUERY_V2")
                        }
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Type {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Type {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Type {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::AdversarialQuery,
                        2 => Self::NonAnswerSeekingQuery,
                        3 => Self::JailBreakingQuery,
                        4 => Self::NonAnswerSeekingQueryV2,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Type {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "TYPE_UNSPECIFIED" => Self::Unspecified,
                        "ADVERSARIAL_QUERY" => Self::AdversarialQuery,
                        "NON_ANSWER_SEEKING_QUERY" => Self::NonAnswerSeekingQuery,
                        "JAIL_BREAKING_QUERY" => Self::JailBreakingQuery,
                        "NON_ANSWER_SEEKING_QUERY_V2" => Self::NonAnswerSeekingQueryV2,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Type {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::AdversarialQuery => serializer.serialize_i32(1),
                        Self::NonAnswerSeekingQuery => serializer.serialize_i32(2),
                        Self::JailBreakingQuery => serializer.serialize_i32(3),
                        Self::NonAnswerSeekingQueryV2 => serializer.serialize_i32(4),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Type {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                        ".google.cloud.discoveryengine.v1.Answer.QueryUnderstandingInfo.QueryClassificationInfo.Type"))
                }
            }
        }
    }

    /// Enumeration of the state of the answer generation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unknown.
        Unspecified,
        /// Answer generation is currently in progress.
        InProgress,
        /// Answer generation currently failed.
        Failed,
        /// Answer generation has succeeded.
        Succeeded,
        /// Answer generation is currently in progress.
        Streaming,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Streaming => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Streaming => std::option::Option::Some("STREAMING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Failed,
                3 => Self::Succeeded,
                4 => Self::Streaming,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "STREAMING" => Self::Streaming,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Streaming => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.discoveryengine.v1.Answer.State",
            ))
        }
    }

    /// An enum for answer skipped reasons.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AnswerSkippedReason {
        /// Default value. The answer skipped reason is not specified.
        Unspecified,
        /// The adversarial query ignored case.
        AdversarialQueryIgnored,
        /// The non-answer seeking query ignored case
        ///
        /// Google skips the answer if the query is chit chat.
        NonAnswerSeekingQueryIgnored,
        /// The out-of-domain query ignored case.
        ///
        /// Google skips the answer if there are no high-relevance search results.
        OutOfDomainQueryIgnored,
        /// The potential policy violation case.
        ///
        /// Google skips the answer if there is a potential policy violation
        /// detected. This includes content that may be violent or toxic.
        PotentialPolicyViolation,
        /// The no relevant content case.
        ///
        /// Google skips the answer if there is no relevant content in the
        /// retrieved search results.
        NoRelevantContent,
        /// The jail-breaking query ignored case.
        ///
        /// For example, "Reply in the tone of a competing company's CEO".
        /// Google skips the answer if the query is classified as a jail-breaking
        /// query.
        JailBreakingQueryIgnored,
        /// The customer policy violation case.
        ///
        /// Google skips the summary if there is a customer policy violation
        /// detected. The policy is defined by the customer.
        CustomerPolicyViolation,
        /// The non-answer seeking query ignored case.
        ///
        /// Google skips the answer if the query doesn't have clear intent.
        NonAnswerSeekingQueryIgnoredV2,
        /// The low-grounded answer case.
        ///
        /// Google skips the answer if a well grounded answer was unable to be
        /// generated.
        LowGroundedAnswer,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AnswerSkippedReason::value] or
        /// [AnswerSkippedReason::name].
        UnknownValue(answer_skipped_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod answer_skipped_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AnswerSkippedReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AdversarialQueryIgnored => std::option::Option::Some(1),
                Self::NonAnswerSeekingQueryIgnored => std::option::Option::Some(2),
                Self::OutOfDomainQueryIgnored => std::option::Option::Some(3),
                Self::PotentialPolicyViolation => std::option::Option::Some(4),
                Self::NoRelevantContent => std::option::Option::Some(5),
                Self::JailBreakingQueryIgnored => std::option::Option::Some(6),
                Self::CustomerPolicyViolation => std::option::Option::Some(7),
                Self::NonAnswerSeekingQueryIgnoredV2 => std::option::Option::Some(8),
                Self::LowGroundedAnswer => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANSWER_SKIPPED_REASON_UNSPECIFIED"),
                Self::AdversarialQueryIgnored => {
                    std::option::Option::Some("ADVERSARIAL_QUERY_IGNORED")
                }
                Self::NonAnswerSeekingQueryIgnored => {
                    std::option::Option::Some("NON_ANSWER_SEEKING_QUERY_IGNORED")
                }
                Self::OutOfDomainQueryIgnored => {
                    std::option::Option::Some("OUT_OF_DOMAIN_QUERY_IGNORED")
                }
                Self::PotentialPolicyViolation => {
                    std::option::Option::Some("POTENTIAL_POLICY_VIOLATION")
                }
                Self::NoRelevantContent => std::option::Option::Some("NO_RELEVANT_CONTENT"),
                Self::JailBreakingQueryIgnored => {
                    std::option::Option::Some("JAIL_BREAKING_QUERY_IGNORED")
                }
                Self::CustomerPolicyViolation => {
                    std::option::Option::Some("CUSTOMER_POLICY_VIOLATION")
                }
                Self::NonAnswerSeekingQueryIgnoredV2 => {
                    std::option::Option::Some("NON_ANSWER_SEEKING_QUERY_IGNORED_V2")
                }
                Self::LowGroundedAnswer => std::option::Option::Some("LOW_GROUNDED_ANSWER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AnswerSkippedReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AnswerSkippedReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AnswerSkippedReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AdversarialQueryIgnored,
                2 => Self::NonAnswerSeekingQueryIgnored,
                3 => Self::OutOfDomainQueryIgnored,
                4 => Self::PotentialPolicyViolation,
                5 => Self::NoRelevantContent,
                6 => Self::JailBreakingQueryIgnored,
                7 => Self::CustomerPolicyViolation,
                8 => Self::NonAnswerSeekingQueryIgnoredV2,
                9 => Self::LowGroundedAnswer,
                _ => Self::UnknownValue(answer_skipped_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AnswerSkippedReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANSWER_SKIPPED_REASON_UNSPECIFIED" => Self::Unspecified,
                "ADVERSARIAL_QUERY_IGNORED" => Self::AdversarialQueryIgnored,
                "NON_ANSWER_SEEKING_QUERY_IGNORED" => Self::NonAnswerSeekingQueryIgnored,
                "OUT_OF_DOMAIN_QUERY_IGNORED" => Self::OutOfDomainQueryIgnored,
                "POTENTIAL_POLICY_VIOLATION" => Self::PotentialPolicyViolation,
                "NO_RELEVANT_CONTENT" => Self::NoRelevantContent,
                "JAIL_BREAKING_QUERY_IGNORED" => Self::JailBreakingQueryIgnored,
                "CUSTOMER_POLICY_VIOLATION" => Self::CustomerPolicyViolation,
                "NON_ANSWER_SEEKING_QUERY_IGNORED_V2" => Self::NonAnswerSeekingQueryIgnoredV2,
                "LOW_GROUNDED_ANSWER" => Self::LowGroundedAnswer,
                _ => Self::UnknownValue(answer_skipped_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AnswerSkippedReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AdversarialQueryIgnored => serializer.serialize_i32(1),
                Self::NonAnswerSeekingQueryIgnored => serializer.serialize_i32(2),
                Self::OutOfDomainQueryIgnored => serializer.serialize_i32(3),
                Self::PotentialPolicyViolation => serializer.serialize_i32(4),
                Self::NoRelevantContent => serializer.serialize_i32(5),
                Self::JailBreakingQueryIgnored => serializer.serialize_i32(6),
                Self::CustomerPolicyViolation => serializer.serialize_i32(7),
                Self::NonAnswerSeekingQueryIgnoredV2 => serializer.serialize_i32(8),
                Self::LowGroundedAnswer => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AnswerSkippedReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AnswerSkippedReason>::new(
                ".google.cloud.discoveryengine.v1.Answer.AnswerSkippedReason",
            ))
        }
    }
}

/// Chunk captures all raw metadata information of items to be recommended or
/// searched in the chunk mode.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Chunk {
    /// The full resource name of the chunk.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}/chunks/{chunk_id}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Unique chunk ID of the current chunk.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Content is a string from a document (parsed content).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// Output only. Represents the relevance score based on similarity.
    /// Higher score indicates higher chunk relevance.
    /// The score is in range [-1.0, 1.0].
    /// Only populated on
    /// [SearchResponse][google.cloud.discoveryengine.v1.SearchResponse].
    ///
    /// [google.cloud.discoveryengine.v1.SearchResponse]: crate::model::SearchResponse
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub relevance_score: std::option::Option<f64>,

    /// Metadata of the document from the current chunk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_metadata: std::option::Option<crate::model::chunk::DocumentMetadata>,

    /// Output only. This field is OUTPUT_ONLY.
    /// It contains derived data that are not in the original input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub derived_struct_data: std::option::Option<wkt::Struct>,

    /// Page span of the chunk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub page_span: std::option::Option<crate::model::chunk::PageSpan>,

    /// Output only. Metadata of the current chunk.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub chunk_metadata: std::option::Option<std::boxed::Box<crate::model::chunk::ChunkMetadata>>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Chunk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Chunk::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Chunk::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Chunk::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [relevance_score][crate::model::Chunk::relevance_score].
    pub fn set_relevance_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.relevance_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [relevance_score][crate::model::Chunk::relevance_score].
    pub fn set_or_clear_relevance_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.relevance_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_metadata][crate::model::Chunk::document_metadata].
    pub fn set_document_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::chunk::DocumentMetadata>,
    {
        self.document_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_metadata][crate::model::Chunk::document_metadata].
    pub fn set_or_clear_document_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::chunk::DocumentMetadata>,
    {
        self.document_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [derived_struct_data][crate::model::Chunk::derived_struct_data].
    pub fn set_derived_struct_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.derived_struct_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [derived_struct_data][crate::model::Chunk::derived_struct_data].
    pub fn set_or_clear_derived_struct_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.derived_struct_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_span][crate::model::Chunk::page_span].
    pub fn set_page_span<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::chunk::PageSpan>,
    {
        self.page_span = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_span][crate::model::Chunk::page_span].
    pub fn set_or_clear_page_span<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::chunk::PageSpan>,
    {
        self.page_span = v.map(|x| x.into());
        self
    }

    /// Sets the value of [chunk_metadata][crate::model::Chunk::chunk_metadata].
    pub fn set_chunk_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::chunk::ChunkMetadata>,
    {
        self.chunk_metadata = std::option::Option::Some(std::boxed::Box::new(v.into()));
        self
    }

    /// Sets or clears the value of [chunk_metadata][crate::model::Chunk::chunk_metadata].
    pub fn set_or_clear_chunk_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::chunk::ChunkMetadata>,
    {
        self.chunk_metadata = v.map(|x| std::boxed::Box::new(x.into()));
        self
    }
}

impl wkt::message::Message for Chunk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Chunk"
    }
}

/// Defines additional types related to [Chunk].
pub mod chunk {
    #[allow(unused_imports)]
    use super::*;

    /// Document metadata contains the information of the document of the current
    /// chunk.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DocumentMetadata {
        /// Uri of the document.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// Title of the document.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub title: std::string::String,

        /// Data representation.
        /// The structured JSON data for the document. It should conform to the
        /// registered [Schema][google.cloud.discoveryengine.v1.Schema] or an
        /// `INVALID_ARGUMENT` error is thrown.
        ///
        /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub struct_data: std::option::Option<wkt::Struct>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DocumentMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::chunk::DocumentMetadata::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [title][crate::model::chunk::DocumentMetadata::title].
        pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [struct_data][crate::model::chunk::DocumentMetadata::struct_data].
        pub fn set_struct_data<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.struct_data = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [struct_data][crate::model::chunk::DocumentMetadata::struct_data].
        pub fn set_or_clear_struct_data<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.struct_data = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DocumentMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Chunk.DocumentMetadata"
        }
    }

    /// Page span of the chunk.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PageSpan {
        /// The start page of the chunk.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub page_start: i32,

        /// The end page of the chunk.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub page_end: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PageSpan {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [page_start][crate::model::chunk::PageSpan::page_start].
        pub fn set_page_start<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.page_start = v.into();
            self
        }

        /// Sets the value of [page_end][crate::model::chunk::PageSpan::page_end].
        pub fn set_page_end<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.page_end = v.into();
            self
        }
    }

    impl wkt::message::Message for PageSpan {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Chunk.PageSpan"
        }
    }

    /// Metadata of the current chunk. This field is only populated on
    /// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
    /// API.
    ///
    /// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ChunkMetadata {
        /// The previous chunks of the current chunk. The number is controlled by
        /// [SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks].
        /// This field is only populated on
        /// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
        /// API.
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks]: crate::model::search_request::content_search_spec::ChunkSpec::num_previous_chunks
        /// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub previous_chunks: std::vec::Vec<crate::model::Chunk>,

        /// The next chunks of the current chunk. The number is controlled by
        /// [SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks].
        /// This field is only populated on
        /// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
        /// API.
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks]: crate::model::search_request::content_search_spec::ChunkSpec::num_next_chunks
        /// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub next_chunks: std::vec::Vec<crate::model::Chunk>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ChunkMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [previous_chunks][crate::model::chunk::ChunkMetadata::previous_chunks].
        pub fn set_previous_chunks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Chunk>,
        {
            use std::iter::Iterator;
            self.previous_chunks = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [next_chunks][crate::model::chunk::ChunkMetadata::next_chunks].
        pub fn set_next_chunks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Chunk>,
        {
            use std::iter::Iterator;
            self.next_chunks = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ChunkMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Chunk.ChunkMetadata"
        }
    }
}

/// A floating point interval.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Interval {
    /// The lower bound of the interval. If neither of the min fields are
    /// set, then the lower bound is negative infinity.
    ///
    /// This field must be not larger than max.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub min: std::option::Option<crate::model::interval::Min>,

    /// The upper bound of the interval. If neither of the max fields are
    /// set, then the upper bound is positive infinity.
    ///
    /// This field must be not smaller than min.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub max: std::option::Option<crate::model::interval::Max>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Interval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min][crate::model::Interval::min].
    ///
    /// Note that all the setters affecting `min` are mutually
    /// exclusive.
    pub fn set_min<T: std::convert::Into<std::option::Option<crate::model::interval::Min>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min = v.into();
        self
    }

    /// The value of [min][crate::model::Interval::min]
    /// if it holds a `Minimum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn minimum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.min.as_ref().and_then(|v| match v {
            crate::model::interval::Min::Minimum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [min][crate::model::Interval::min]
    /// to hold a `Minimum`.
    ///
    /// Note that all the setters affecting `min` are
    /// mutually exclusive.
    pub fn set_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min = std::option::Option::Some(crate::model::interval::Min::Minimum(v.into()));
        self
    }

    /// The value of [min][crate::model::Interval::min]
    /// if it holds a `ExclusiveMinimum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclusive_minimum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.min.as_ref().and_then(|v| match v {
            crate::model::interval::Min::ExclusiveMinimum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [min][crate::model::Interval::min]
    /// to hold a `ExclusiveMinimum`.
    ///
    /// Note that all the setters affecting `min` are
    /// mutually exclusive.
    pub fn set_exclusive_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min =
            std::option::Option::Some(crate::model::interval::Min::ExclusiveMinimum(v.into()));
        self
    }

    /// Sets the value of [max][crate::model::Interval::max].
    ///
    /// Note that all the setters affecting `max` are mutually
    /// exclusive.
    pub fn set_max<T: std::convert::Into<std::option::Option<crate::model::interval::Max>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max = v.into();
        self
    }

    /// The value of [max][crate::model::Interval::max]
    /// if it holds a `Maximum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn maximum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.max.as_ref().and_then(|v| match v {
            crate::model::interval::Max::Maximum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [max][crate::model::Interval::max]
    /// to hold a `Maximum`.
    ///
    /// Note that all the setters affecting `max` are
    /// mutually exclusive.
    pub fn set_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max = std::option::Option::Some(crate::model::interval::Max::Maximum(v.into()));
        self
    }

    /// The value of [max][crate::model::Interval::max]
    /// if it holds a `ExclusiveMaximum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclusive_maximum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.max.as_ref().and_then(|v| match v {
            crate::model::interval::Max::ExclusiveMaximum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [max][crate::model::Interval::max]
    /// to hold a `ExclusiveMaximum`.
    ///
    /// Note that all the setters affecting `max` are
    /// mutually exclusive.
    pub fn set_exclusive_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max =
            std::option::Option::Some(crate::model::interval::Max::ExclusiveMaximum(v.into()));
        self
    }
}

impl wkt::message::Message for Interval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Interval"
    }
}

/// Defines additional types related to [Interval].
pub mod interval {
    #[allow(unused_imports)]
    use super::*;

    /// The lower bound of the interval. If neither of the min fields are
    /// set, then the lower bound is negative infinity.
    ///
    /// This field must be not larger than max.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Min {
        /// Inclusive lower bound.
        Minimum(#[serde_as(as = "wkt::internal::F64")] f64),
        /// Exclusive lower bound.
        ExclusiveMinimum(#[serde_as(as = "wkt::internal::F64")] f64),
    }

    /// The upper bound of the interval. If neither of the max fields are
    /// set, then the upper bound is positive infinity.
    ///
    /// This field must be not smaller than min.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Max {
        /// Inclusive upper bound.
        Maximum(#[serde_as(as = "wkt::internal::F64")] f64),
        /// Exclusive upper bound.
        ExclusiveMaximum(#[serde_as(as = "wkt::internal::F64")] f64),
    }
}

/// A custom attribute that is not explicitly modeled in a resource, e.g.
/// [UserEvent][google.cloud.discoveryengine.v1.UserEvent].
///
/// [google.cloud.discoveryengine.v1.UserEvent]: crate::model::UserEvent
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomAttribute {
    /// The textual values of this custom attribute. For example, `["yellow",
    /// "green"]` when the key is "color".
    ///
    /// Empty string is not allowed. Otherwise, an `INVALID_ARGUMENT` error is
    /// returned.
    ///
    /// Exactly one of
    /// [CustomAttribute.text][google.cloud.discoveryengine.v1.CustomAttribute.text]
    /// or
    /// [CustomAttribute.numbers][google.cloud.discoveryengine.v1.CustomAttribute.numbers]
    /// should be set. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.CustomAttribute.numbers]: crate::model::CustomAttribute::numbers
    /// [google.cloud.discoveryengine.v1.CustomAttribute.text]: crate::model::CustomAttribute::text
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub text: std::vec::Vec<std::string::String>,

    /// The numerical values of this custom attribute. For example, `[2.3, 15.4]`
    /// when the key is "lengths_cm".
    ///
    /// Exactly one of
    /// [CustomAttribute.text][google.cloud.discoveryengine.v1.CustomAttribute.text]
    /// or
    /// [CustomAttribute.numbers][google.cloud.discoveryengine.v1.CustomAttribute.numbers]
    /// should be set. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.CustomAttribute.numbers]: crate::model::CustomAttribute::numbers
    /// [google.cloud.discoveryengine.v1.CustomAttribute.text]: crate::model::CustomAttribute::text
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<wkt::internal::F64>")]
    pub numbers: std::vec::Vec<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::CustomAttribute::text].
    pub fn set_text<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.text = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [numbers][crate::model::CustomAttribute::numbers].
    pub fn set_numbers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.numbers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CustomAttribute"
    }
}

/// Information of an end user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserInfo {
    /// Highly recommended for logged-in users. Unique identifier for logged-in
    /// user, such as a user name. Don't set for anonymous users.
    ///
    /// Always use a hashed value for this ID.
    ///
    /// Don't set the field to the same fixed ID for different users. This mixes
    /// the event history of those users together, which results in degraded
    /// model quality.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_id: std::string::String,

    /// User agent as included in the HTTP header.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// This should not be set when using the client side event reporting with
    /// GTM or JavaScript tag in
    /// [UserEventService.CollectUserEvent][google.cloud.discoveryengine.v1.UserEventService.CollectUserEvent]
    /// or if
    /// [UserEvent.direct_user_request][google.cloud.discoveryengine.v1.UserEvent.direct_user_request]
    /// is set.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent.direct_user_request]: crate::model::UserEvent::direct_user_request
    /// [google.cloud.discoveryengine.v1.UserEventService.CollectUserEvent]: crate::client::UserEventService::collect_user_event
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_agent: std::string::String,

    /// Optional. IANA time zone, e.g. Europe/Budapest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub time_zone: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_id][crate::model::UserInfo::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::UserInfo::user_agent].
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::UserInfo::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }
}

impl wkt::message::Message for UserInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UserInfo"
    }
}

/// Double list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DoubleList {
    /// Double values.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<wkt::internal::F64>")]
    pub values: std::vec::Vec<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DoubleList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::DoubleList::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DoubleList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DoubleList"
    }
}

/// Promotion proto includes uri and other helping information to display the
/// promotion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchLinkPromotion {
    /// Required. The title of the promotion.
    /// Maximum length: 160 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// Optional. The URL for the page the user wants to promote. Must be set for
    /// site search. For other verticals, this is optional.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Optional. The promotion thumbnail image url.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Optional. The Promotion description.
    /// Maximum length: 200 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. The enabled promotion will be returned for any serving configs
    /// associated with the parent of the control this promotion is attached to.
    ///
    /// This flag is used for basic site search only.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchLinkPromotion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::SearchLinkPromotion::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::SearchLinkPromotion::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::SearchLinkPromotion::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SearchLinkPromotion::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::SearchLinkPromotion::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for SearchLinkPromotion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SearchLinkPromotion"
    }
}

/// Suggestion deny list entry identifying the phrase to block from suggestions
/// and the applied operation for the phrase.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SuggestionDenyListEntry {
    /// Required. Phrase to block from suggestions served. Can be maximum 125
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub block_phrase: std::string::String,

    /// Required. The match operator to apply for this phrase. Whether to block the
    /// exact phrase, or block any suggestions containing this phrase.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub match_operator: crate::model::suggestion_deny_list_entry::MatchOperator,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SuggestionDenyListEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [block_phrase][crate::model::SuggestionDenyListEntry::block_phrase].
    pub fn set_block_phrase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.block_phrase = v.into();
        self
    }

    /// Sets the value of [match_operator][crate::model::SuggestionDenyListEntry::match_operator].
    pub fn set_match_operator<
        T: std::convert::Into<crate::model::suggestion_deny_list_entry::MatchOperator>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.match_operator = v.into();
        self
    }
}

impl wkt::message::Message for SuggestionDenyListEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SuggestionDenyListEntry"
    }
}

/// Defines additional types related to [SuggestionDenyListEntry].
pub mod suggestion_deny_list_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Operator for matching with the generated suggestions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MatchOperator {
        /// Default value. Should not be used
        Unspecified,
        /// If the suggestion is an exact match to the block_phrase, then block it.
        ExactMatch,
        /// If the suggestion contains the block_phrase, then block it.
        Contains,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MatchOperator::value] or
        /// [MatchOperator::name].
        UnknownValue(match_operator::UnknownValue),
    }

    #[doc(hidden)]
    pub mod match_operator {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MatchOperator {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ExactMatch => std::option::Option::Some(1),
                Self::Contains => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MATCH_OPERATOR_UNSPECIFIED"),
                Self::ExactMatch => std::option::Option::Some("EXACT_MATCH"),
                Self::Contains => std::option::Option::Some("CONTAINS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MatchOperator {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MatchOperator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MatchOperator {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ExactMatch,
                2 => Self::Contains,
                _ => Self::UnknownValue(match_operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MatchOperator {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MATCH_OPERATOR_UNSPECIFIED" => Self::Unspecified,
                "EXACT_MATCH" => Self::ExactMatch,
                "CONTAINS" => Self::Contains,
                _ => Self::UnknownValue(match_operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MatchOperator {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ExactMatch => serializer.serialize_i32(1),
                Self::Contains => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MatchOperator {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MatchOperator>::new(
                ".google.cloud.discoveryengine.v1.SuggestionDenyListEntry.MatchOperator",
            ))
        }
    }
}

/// Autocomplete suggestions that are imported from Customer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompletionSuggestion {
    /// Required. The suggestion text.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub suggestion: std::string::String,

    /// BCP-47 language code of this suggestion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// If two suggestions have the same groupId, they will not be
    /// returned together. Instead the one ranked higher will be returned. This can
    /// be used to deduplicate semantically identical suggestions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group_id: std::string::String,

    /// The score of this suggestion within its group.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub group_score: f64,

    /// Alternative matching phrases for this suggestion.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub alternative_phrases: std::vec::Vec<std::string::String>,

    /// Ranking metrics of this suggestion.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub ranking_info: std::option::Option<crate::model::completion_suggestion::RankingInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompletionSuggestion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [suggestion][crate::model::CompletionSuggestion::suggestion].
    pub fn set_suggestion<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.suggestion = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::CompletionSuggestion::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::CompletionSuggestion::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [group_score][crate::model::CompletionSuggestion::group_score].
    pub fn set_group_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.group_score = v.into();
        self
    }

    /// Sets the value of [alternative_phrases][crate::model::CompletionSuggestion::alternative_phrases].
    pub fn set_alternative_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.alternative_phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ranking_info][crate::model::CompletionSuggestion::ranking_info].
    ///
    /// Note that all the setters affecting `ranking_info` are mutually
    /// exclusive.
    pub fn set_ranking_info<
        T: std::convert::Into<std::option::Option<crate::model::completion_suggestion::RankingInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_info = v.into();
        self
    }

    /// The value of [ranking_info][crate::model::CompletionSuggestion::ranking_info]
    /// if it holds a `GlobalScore`, `None` if the field is not set or
    /// holds a different branch.
    pub fn global_score(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.ranking_info.as_ref().and_then(|v| match v {
            crate::model::completion_suggestion::RankingInfo::GlobalScore(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ranking_info][crate::model::CompletionSuggestion::ranking_info]
    /// to hold a `GlobalScore`.
    ///
    /// Note that all the setters affecting `ranking_info` are
    /// mutually exclusive.
    pub fn set_global_score<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.ranking_info = std::option::Option::Some(
            crate::model::completion_suggestion::RankingInfo::GlobalScore(v.into()),
        );
        self
    }

    /// The value of [ranking_info][crate::model::CompletionSuggestion::ranking_info]
    /// if it holds a `Frequency`, `None` if the field is not set or
    /// holds a different branch.
    pub fn frequency(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.ranking_info.as_ref().and_then(|v| match v {
            crate::model::completion_suggestion::RankingInfo::Frequency(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ranking_info][crate::model::CompletionSuggestion::ranking_info]
    /// to hold a `Frequency`.
    ///
    /// Note that all the setters affecting `ranking_info` are
    /// mutually exclusive.
    pub fn set_frequency<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.ranking_info = std::option::Option::Some(
            crate::model::completion_suggestion::RankingInfo::Frequency(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CompletionSuggestion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CompletionSuggestion"
    }
}

/// Defines additional types related to [CompletionSuggestion].
pub mod completion_suggestion {
    #[allow(unused_imports)]
    use super::*;

    /// Ranking metrics of this suggestion.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RankingInfo {
        /// Global score of this suggestion. Control how this suggestion would be
        /// scored / ranked.
        GlobalScore(#[serde_as(as = "wkt::internal::F64")] f64),
        /// Frequency of this suggestion. Will be used to rank suggestions when score
        /// is not available.
        Frequency(#[serde_as(as = "wkt::internal::I64")] i64),
    }
}

/// Request message for
/// [CompletionService.CompleteQuery][google.cloud.discoveryengine.v1.CompletionService.CompleteQuery]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.CompleteQuery]: crate::client::CompletionService::complete_query
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompleteQueryRequest {
    /// Required. The parent data store resource name for which the completion is
    /// performed, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_store: std::string::String,

    /// Required. The typeahead input used to fetch suggestions. Maximum length is
    /// 128 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Specifies the autocomplete data model. This overrides any model specified
    /// in the Configuration > Autocomplete section of the Cloud console. Currently
    /// supported values:
    ///
    /// * `document` - Using suggestions generated from user-imported documents.
    /// * `search-history` - Using suggestions generated from the past history of
    ///   [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
    ///   API calls. Do not use it when there is no traffic for Search API.
    /// * `user-event` - Using suggestions generated from user-imported search
    ///   events.
    /// * `document-completable` - Using suggestions taken directly from
    ///   user-imported document fields marked as completable.
    ///
    /// Default values:
    ///
    /// * `document` is the default model for regular dataStores.
    /// * `search-history` is the default model for site search dataStores.
    ///
    /// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_model: std::string::String,

    /// A unique identifier for tracking visitors. For example, this could be
    /// implemented with an HTTP cookie, which should be able to uniquely identify
    /// a visitor on a single device. This unique identifier should not change if
    /// the visitor logs in or out of the website.
    ///
    /// This field should NOT have a fixed value such as `unknown_visitor`.
    ///
    /// This should be the same identifier as
    /// [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]
    /// and
    /// [SearchRequest.user_pseudo_id][google.cloud.discoveryengine.v1.SearchRequest.user_pseudo_id].
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.user_pseudo_id]: crate::model::SearchRequest::user_pseudo_id
    /// [google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]: crate::model::UserEvent::user_pseudo_id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_pseudo_id: std::string::String,

    /// Indicates if tail suggestions should be returned if there are no
    /// suggestions that match the full query. Even if set to true, if there are
    /// suggestions that match the full query, those are returned and no
    /// tail suggestions are returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub include_tail_suggestions: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_store][crate::model::CompleteQueryRequest::data_store].
    pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_store = v.into();
        self
    }

    /// Sets the value of [query][crate::model::CompleteQueryRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [query_model][crate::model::CompleteQueryRequest::query_model].
    pub fn set_query_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_model = v.into();
        self
    }

    /// Sets the value of [user_pseudo_id][crate::model::CompleteQueryRequest::user_pseudo_id].
    pub fn set_user_pseudo_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_pseudo_id = v.into();
        self
    }

    /// Sets the value of [include_tail_suggestions][crate::model::CompleteQueryRequest::include_tail_suggestions].
    pub fn set_include_tail_suggestions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_tail_suggestions = v.into();
        self
    }
}

impl wkt::message::Message for CompleteQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CompleteQueryRequest"
    }
}

/// Response message for
/// [CompletionService.CompleteQuery][google.cloud.discoveryengine.v1.CompletionService.CompleteQuery]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.CompleteQuery]: crate::client::CompletionService::complete_query
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompleteQueryResponse {
    /// Results of the matched query suggestions. The result list is ordered and
    /// the first result is a top suggestion.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub query_suggestions: std::vec::Vec<crate::model::complete_query_response::QuerySuggestion>,

    /// True if the returned suggestions are all tail suggestions.
    ///
    /// For tail matching to be triggered, include_tail_suggestions in the request
    /// must be true and there must be no suggestions that match the full query.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub tail_match_triggered: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteQueryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_suggestions][crate::model::CompleteQueryResponse::query_suggestions].
    pub fn set_query_suggestions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::complete_query_response::QuerySuggestion>,
    {
        use std::iter::Iterator;
        self.query_suggestions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tail_match_triggered][crate::model::CompleteQueryResponse::tail_match_triggered].
    pub fn set_tail_match_triggered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.tail_match_triggered = v.into();
        self
    }
}

impl wkt::message::Message for CompleteQueryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CompleteQueryResponse"
    }
}

/// Defines additional types related to [CompleteQueryResponse].
pub mod complete_query_response {
    #[allow(unused_imports)]
    use super::*;

    /// Suggestions as search queries.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QuerySuggestion {
        /// The suggestion for the query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub suggestion: std::string::String,

        /// The unique document field paths that serve as the source of this
        /// suggestion if it was generated from completable fields.
        ///
        /// This field is only populated for the document-completable model.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub completable_field_paths: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QuerySuggestion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [suggestion][crate::model::complete_query_response::QuerySuggestion::suggestion].
        pub fn set_suggestion<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.suggestion = v.into();
            self
        }

        /// Sets the value of [completable_field_paths][crate::model::complete_query_response::QuerySuggestion::completable_field_paths].
        pub fn set_completable_field_paths<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.completable_field_paths = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for QuerySuggestion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.CompleteQueryResponse.QuerySuggestion"
        }
    }
}

/// Defines circumstances to be checked before allowing a behavior
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Condition {
    /// Search only
    /// A list of terms to match the query on.
    /// Cannot be set when
    /// [Condition.query_regex][google.cloud.discoveryengine.v1.Condition.query_regex]
    /// is set.
    ///
    /// Maximum of 10 query terms.
    ///
    /// [google.cloud.discoveryengine.v1.Condition.query_regex]: crate::model::Condition::query_regex
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub query_terms: std::vec::Vec<crate::model::condition::QueryTerm>,

    /// Range of time(s) specifying when condition is active.
    ///
    /// Maximum of 10 time ranges.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub active_time_range: std::vec::Vec<crate::model::condition::TimeRange>,

    /// Optional. Query regex to match the whole search query.
    /// Cannot be set when
    /// [Condition.query_terms][google.cloud.discoveryengine.v1.Condition.query_terms]
    /// is set. This is currently supporting promotion use case.
    ///
    /// [google.cloud.discoveryengine.v1.Condition.query_terms]: crate::model::Condition::query_terms
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_regex: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Condition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_terms][crate::model::Condition::query_terms].
    pub fn set_query_terms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::condition::QueryTerm>,
    {
        use std::iter::Iterator;
        self.query_terms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [active_time_range][crate::model::Condition::active_time_range].
    pub fn set_active_time_range<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::condition::TimeRange>,
    {
        use std::iter::Iterator;
        self.active_time_range = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [query_regex][crate::model::Condition::query_regex].
    pub fn set_query_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_regex = v.into();
        self
    }
}

impl wkt::message::Message for Condition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Condition"
    }
}

/// Defines additional types related to [Condition].
pub mod condition {
    #[allow(unused_imports)]
    use super::*;

    /// Matcher for search request query
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueryTerm {
        /// The specific query value to match against
        ///
        /// Must be lowercase, must be UTF-8.
        /// Can have at most 3 space separated terms if full_match is true.
        /// Cannot be an empty string.
        /// Maximum length of 5000 characters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        /// Whether the search query needs to exactly match the query term.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub full_match: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryTerm {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::condition::QueryTerm::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [full_match][crate::model::condition::QueryTerm::full_match].
        pub fn set_full_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.full_match = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryTerm {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Condition.QueryTerm"
        }
    }

    /// Used for time-dependent conditions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimeRange {
        /// Start of time range.
        ///
        /// Range is inclusive.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// End of time range.
        ///
        /// Range is inclusive.
        /// Must be in the future.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::condition::TimeRange::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::condition::TimeRange::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::condition::TimeRange::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::condition::TimeRange::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TimeRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Condition.TimeRange"
        }
    }
}

/// Defines a conditioned behavior to employ during serving.
/// Must be attached to a
/// [ServingConfig][google.cloud.discoveryengine.v1.ServingConfig] to be
/// considered at serving time. Permitted actions dependent on `SolutionType`.
///
/// [google.cloud.discoveryengine.v1.ServingConfig]: crate::model::ServingConfig
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Control {
    /// Immutable. Fully qualified name
    /// `projects/*/locations/global/dataStore/*/controls/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Human readable name. The identifier used in UI views.
    ///
    /// Must be UTF-8 encoded string. Length limit is 128 characters.
    /// Otherwise an INVALID ARGUMENT error is thrown.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. List of all
    /// [ServingConfig][google.cloud.discoveryengine.v1.ServingConfig] IDs this
    /// control is attached to. May take up to 10 minutes to update after changes.
    ///
    /// [google.cloud.discoveryengine.v1.ServingConfig]: crate::model::ServingConfig
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub associated_serving_config_ids: std::vec::Vec<std::string::String>,

    /// Required. Immutable. What solution the control belongs to.
    ///
    /// Must be compatible with vertical of resource.
    /// Otherwise an INVALID ARGUMENT error is thrown.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub solution_type: crate::model::SolutionType,

    /// Specifies the use case for the control.
    /// Affects what condition fields can be set.
    /// Only applies to
    /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
    /// Currently only allow one use case per control.
    /// Must be set when solution_type is
    /// [SolutionType.SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub use_cases: std::vec::Vec<crate::model::SearchUseCase>,

    /// Determines when the associated action will trigger.
    ///
    /// Omit to always apply the action.
    /// Currently only a single condition may be specified.
    /// Otherwise an INVALID ARGUMENT error is thrown.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<crate::model::Condition>,

    /// Actions are restricted by Vertical and Solution
    ///
    /// Required.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub action: std::option::Option<crate::model::control::Action>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Control {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Control::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Control::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [associated_serving_config_ids][crate::model::Control::associated_serving_config_ids].
    pub fn set_associated_serving_config_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.associated_serving_config_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [solution_type][crate::model::Control::solution_type].
    pub fn set_solution_type<T: std::convert::Into<crate::model::SolutionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.solution_type = v.into();
        self
    }

    /// Sets the value of [use_cases][crate::model::Control::use_cases].
    pub fn set_use_cases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchUseCase>,
    {
        use std::iter::Iterator;
        self.use_cases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::Control::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Condition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [action][crate::model::Control::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<T: std::convert::Into<std::option::Option<crate::model::control::Action>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::Control::action]
    /// if it holds a `BoostAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn boost_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::control::BoostAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::control::Action::BoostAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Control::action]
    /// to hold a `BoostAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_boost_action<
        T: std::convert::Into<std::boxed::Box<crate::model::control::BoostAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::control::Action::BoostAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Control::action]
    /// if it holds a `FilterAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filter_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::control::FilterAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::control::Action::FilterAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Control::action]
    /// to hold a `FilterAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_filter_action<
        T: std::convert::Into<std::boxed::Box<crate::model::control::FilterAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::control::Action::FilterAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Control::action]
    /// if it holds a `RedirectAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redirect_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::control::RedirectAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::control::Action::RedirectAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Control::action]
    /// to hold a `RedirectAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_redirect_action<
        T: std::convert::Into<std::boxed::Box<crate::model::control::RedirectAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::control::Action::RedirectAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Control::action]
    /// if it holds a `SynonymsAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn synonyms_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::control::SynonymsAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::control::Action::SynonymsAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Control::action]
    /// to hold a `SynonymsAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_synonyms_action<
        T: std::convert::Into<std::boxed::Box<crate::model::control::SynonymsAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::control::Action::SynonymsAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Control::action]
    /// if it holds a `PromoteAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn promote_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::control::PromoteAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::control::Action::PromoteAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Control::action]
    /// to hold a `PromoteAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_promote_action<
        T: std::convert::Into<std::boxed::Box<crate::model::control::PromoteAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::control::Action::PromoteAction(v.into()));
        self
    }
}

impl wkt::message::Message for Control {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Control"
    }
}

/// Defines additional types related to [Control].
pub mod control {
    #[allow(unused_imports)]
    use super::*;

    /// Adjusts order of products in returned list.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BoostAction {
        /// Strength of the boost, which should be in [-1, 1]. Negative
        /// boost means demotion. Default is 0.0 (No-op).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F32")]
        #[deprecated]
        pub boost: f32,

        /// Required. Specifies which products to apply the boost to.
        ///
        /// If no filter is provided all products will be boosted (No-op).
        /// Syntax documentation:
        /// <https://cloud.google.com/retail/docs/filter-and-order>
        /// Maximum length is 5000 characters.
        /// Otherwise an INVALID ARGUMENT error is thrown.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        /// Required. Specifies which data store's documents can be boosted by this
        /// control. Full data store name e.g.
        /// projects/123/locations/global/collections/default_collection/dataStores/default_data_store
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data_store: std::string::String,

        /// Constant value boost or custom ranking based boost specifications.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub boost_spec: std::option::Option<crate::model::control::boost_action::BoostSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BoostAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [boost][crate::model::control::BoostAction::boost].
        #[deprecated]
        pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.boost = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::control::BoostAction::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }

        /// Sets the value of [data_store][crate::model::control::BoostAction::data_store].
        pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_store = v.into();
            self
        }

        /// Sets the value of [boost_spec][crate::model::control::BoostAction::boost_spec].
        ///
        /// Note that all the setters affecting `boost_spec` are mutually
        /// exclusive.
        pub fn set_boost_spec<
            T: std::convert::Into<std::option::Option<crate::model::control::boost_action::BoostSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.boost_spec = v.into();
            self
        }

        /// The value of [boost_spec][crate::model::control::BoostAction::boost_spec]
        /// if it holds a `FixedBoost`, `None` if the field is not set or
        /// holds a different branch.
        pub fn fixed_boost(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.boost_spec.as_ref().and_then(|v| match v {
                crate::model::control::boost_action::BoostSpec::FixedBoost(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [boost_spec][crate::model::control::BoostAction::boost_spec]
        /// to hold a `FixedBoost`.
        ///
        /// Note that all the setters affecting `boost_spec` are
        /// mutually exclusive.
        pub fn set_fixed_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.boost_spec = std::option::Option::Some(
                crate::model::control::boost_action::BoostSpec::FixedBoost(v.into()),
            );
            self
        }

        /// The value of [boost_spec][crate::model::control::BoostAction::boost_spec]
        /// if it holds a `InterpolationBoostSpec`, `None` if the field is not set or
        /// holds a different branch.
        pub fn interpolation_boost_spec(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::control::boost_action::InterpolationBoostSpec>,
        > {
            #[allow(unreachable_patterns)]
            self.boost_spec.as_ref().and_then(|v| match v {
                crate::model::control::boost_action::BoostSpec::InterpolationBoostSpec(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [boost_spec][crate::model::control::BoostAction::boost_spec]
        /// to hold a `InterpolationBoostSpec`.
        ///
        /// Note that all the setters affecting `boost_spec` are
        /// mutually exclusive.
        pub fn set_interpolation_boost_spec<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::control::boost_action::InterpolationBoostSpec>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.boost_spec = std::option::Option::Some(
                crate::model::control::boost_action::BoostSpec::InterpolationBoostSpec(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for BoostAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Control.BoostAction"
        }
    }

    /// Defines additional types related to [BoostAction].
    pub mod boost_action {
        #[allow(unused_imports)]
        use super::*;

        /// Specification for custom ranking based on customer specified attribute
        /// value. It provides more controls for customized ranking than the simple
        /// (condition, boost) combination above.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct InterpolationBoostSpec {
            /// Optional. The name of the field whose value will be used to determine
            /// the boost amount.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub field_name: std::string::String,

            /// Optional. The attribute type to be used to determine the boost amount.
            /// The attribute value can be derived from the field value of the
            /// specified field_name. In the case of numerical it is straightforward
            /// i.e. attribute_value = numerical_field_value. In the case of freshness
            /// however, attribute_value = (time.now() - datetime_field_value).
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub attribute_type:
                crate::model::control::boost_action::interpolation_boost_spec::AttributeType,

            /// Optional. The interpolation type to be applied to connect the control
            /// points listed below.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub interpolation_type:
                crate::model::control::boost_action::interpolation_boost_spec::InterpolationType,

            /// Optional. The control points used to define the curve. The monotonic
            /// function (defined through the interpolation_type above) passes through
            /// the control points listed here.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub control_points: std::vec::Vec<
                crate::model::control::boost_action::interpolation_boost_spec::ControlPoint,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl InterpolationBoostSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [field_name][crate::model::control::boost_action::InterpolationBoostSpec::field_name].
            pub fn set_field_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.field_name = v.into();
                self
            }

            /// Sets the value of [attribute_type][crate::model::control::boost_action::InterpolationBoostSpec::attribute_type].
            pub fn set_attribute_type<T: std::convert::Into<crate::model::control::boost_action::interpolation_boost_spec::AttributeType>>(mut self, v: T) -> Self{
                self.attribute_type = v.into();
                self
            }

            /// Sets the value of [interpolation_type][crate::model::control::boost_action::InterpolationBoostSpec::interpolation_type].
            pub fn set_interpolation_type<T: std::convert::Into<crate::model::control::boost_action::interpolation_boost_spec::InterpolationType>>(mut self, v: T) -> Self{
                self.interpolation_type = v.into();
                self
            }

            /// Sets the value of [control_points][crate::model::control::boost_action::InterpolationBoostSpec::control_points].
            pub fn set_control_points<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::control::boost_action::interpolation_boost_spec::ControlPoint,
                    >,
            {
                use std::iter::Iterator;
                self.control_points = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for InterpolationBoostSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.Control.BoostAction.InterpolationBoostSpec"
            }
        }

        /// Defines additional types related to [InterpolationBoostSpec].
        pub mod interpolation_boost_spec {
            #[allow(unused_imports)]
            use super::*;

            /// The control points used to define the curve. The curve defined
            /// through these control points can only be monotonically increasing
            /// or decreasing(constant values are acceptable).
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ControlPoint {
                /// Optional. Can be one of:
                ///
                /// . The numerical field value.
                /// . The duration spec for freshness:
                ///   The value must be formatted as an XSD `dayTimeDuration` value (a
                ///   restricted subset of an ISO 8601 duration value). The pattern for
                ///   this is: `[nD][T[nH][nM][nS]]`.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub attribute_value: std::string::String,

                /// Optional. The value between -1 to 1 by which to boost the score if
                /// the attribute_value evaluates to the value specified above.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                #[serde_as(as = "wkt::internal::F32")]
                pub boost_amount: f32,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ControlPoint {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [attribute_value][crate::model::control::boost_action::interpolation_boost_spec::ControlPoint::attribute_value].
                pub fn set_attribute_value<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.attribute_value = v.into();
                    self
                }

                /// Sets the value of [boost_amount][crate::model::control::boost_action::interpolation_boost_spec::ControlPoint::boost_amount].
                pub fn set_boost_amount<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.boost_amount = v.into();
                    self
                }
            }

            impl wkt::message::Message for ControlPoint {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.Control.BoostAction.InterpolationBoostSpec.ControlPoint"
                }
            }

            /// The attribute(or function) for which the custom ranking is to be
            /// applied.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum AttributeType {
                /// Unspecified AttributeType.
                Unspecified,
                /// The value of the numerical field will be used to dynamically update
                /// the boost amount. In this case, the attribute_value (the x value)
                /// of the control point will be the actual value of the numerical
                /// field for which the boost_amount is specified.
                Numerical,
                /// For the freshness use case the attribute value will be the duration
                /// between the current time and the date in the datetime field
                /// specified. The value must be formatted as an XSD `dayTimeDuration`
                /// value (a restricted subset of an ISO 8601 duration value). The
                /// pattern for this is: `[nD][T[nH][nM][nS]]`.
                /// For example, `5D`, `3DT12H30M`, `T24H`.
                Freshness,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [AttributeType::value] or
                /// [AttributeType::name].
                UnknownValue(attribute_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod attribute_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl AttributeType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Numerical => std::option::Option::Some(1),
                        Self::Freshness => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("ATTRIBUTE_TYPE_UNSPECIFIED")
                        }
                        Self::Numerical => std::option::Option::Some("NUMERICAL"),
                        Self::Freshness => std::option::Option::Some("FRESHNESS"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for AttributeType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for AttributeType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for AttributeType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Numerical,
                        2 => Self::Freshness,
                        _ => Self::UnknownValue(attribute_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for AttributeType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "ATTRIBUTE_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "NUMERICAL" => Self::Numerical,
                        "FRESHNESS" => Self::Freshness,
                        _ => Self::UnknownValue(attribute_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for AttributeType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Numerical => serializer.serialize_i32(1),
                        Self::Freshness => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for AttributeType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttributeType>::new(
                        ".google.cloud.discoveryengine.v1.Control.BoostAction.InterpolationBoostSpec.AttributeType"))
                }
            }

            /// The interpolation type to be applied. Default will be linear
            /// (Piecewise Linear).
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum InterpolationType {
                /// Interpolation type is unspecified. In this case, it defaults to
                /// Linear.
                Unspecified,
                /// Piecewise linear interpolation will be applied.
                Linear,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [InterpolationType::value] or
                /// [InterpolationType::name].
                UnknownValue(interpolation_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod interpolation_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl InterpolationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Linear => std::option::Option::Some(1),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("INTERPOLATION_TYPE_UNSPECIFIED")
                        }
                        Self::Linear => std::option::Option::Some("LINEAR"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for InterpolationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for InterpolationType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for InterpolationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Linear,
                        _ => Self::UnknownValue(interpolation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for InterpolationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "INTERPOLATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "LINEAR" => Self::Linear,
                        _ => Self::UnknownValue(interpolation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for InterpolationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Linear => serializer.serialize_i32(1),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for InterpolationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<InterpolationType>::new(
                        ".google.cloud.discoveryengine.v1.Control.BoostAction.InterpolationBoostSpec.InterpolationType"))
                }
            }
        }

        /// Constant value boost or custom ranking based boost specifications.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum BoostSpec {
            /// Optional. Strength of the boost, which should be in [-1, 1]. Negative
            /// boost means demotion. Default is 0.0 (No-op).
            FixedBoost(#[serde_as(as = "wkt::internal::F32")] f32),
            /// Optional. Complex specification for custom ranking based on customer
            /// defined attribute value.
            InterpolationBoostSpec(
                std::boxed::Box<crate::model::control::boost_action::InterpolationBoostSpec>,
            ),
        }
    }

    /// Specified which products may be included in results.
    /// Uses same filter as boost.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FilterAction {
        /// Required. A filter to apply on the matching condition results.
        ///
        /// Required
        /// Syntax documentation:
        /// <https://cloud.google.com/retail/docs/filter-and-order>
        /// Maximum length is 5000 characters. Otherwise an INVALID
        /// ARGUMENT error is thrown.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        /// Required. Specifies which data store's documents can be filtered by this
        /// control. Full data store name e.g.
        /// projects/123/locations/global/collections/default_collection/dataStores/default_data_store
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data_store: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FilterAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::control::FilterAction::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }

        /// Sets the value of [data_store][crate::model::control::FilterAction::data_store].
        pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_store = v.into();
            self
        }
    }

    impl wkt::message::Message for FilterAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Control.FilterAction"
        }
    }

    /// Redirects a shopper to the provided URI.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RedirectAction {
        /// Required. The URI to which the shopper will be redirected.
        ///
        /// Required.
        /// URI must have length equal or less than 2000 characters.
        /// Otherwise an INVALID ARGUMENT error is thrown.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub redirect_uri: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RedirectAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redirect_uri][crate::model::control::RedirectAction::redirect_uri].
        pub fn set_redirect_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.redirect_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for RedirectAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Control.RedirectAction"
        }
    }

    /// Creates a set of terms that will act as synonyms of one another.
    ///
    /// Example: "happy" will also be considered as "glad", "glad" will also be
    /// considered as "happy".
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SynonymsAction {
        /// Defines a set of synonyms.
        /// Can specify up to 100 synonyms.
        /// Must specify at least 2 synonyms. Otherwise an INVALID ARGUMENT error is
        /// thrown.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub synonyms: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SynonymsAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [synonyms][crate::model::control::SynonymsAction::synonyms].
        pub fn set_synonyms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.synonyms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SynonymsAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Control.SynonymsAction"
        }
    }

    /// Promote certain links based on some trigger queries.
    ///
    /// Example: Promote shoe store link when searching for `shoe` keyword.
    /// The link can be outside of associated data store.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PromoteAction {
        /// Required. Data store with which this promotion is attached to.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data_store: std::string::String,

        /// Required. Promotion attached to this action.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub search_link_promotion: std::option::Option<crate::model::SearchLinkPromotion>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PromoteAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_store][crate::model::control::PromoteAction::data_store].
        pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_store = v.into();
            self
        }

        /// Sets the value of [search_link_promotion][crate::model::control::PromoteAction::search_link_promotion].
        pub fn set_search_link_promotion<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::SearchLinkPromotion>,
        {
            self.search_link_promotion = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [search_link_promotion][crate::model::control::PromoteAction::search_link_promotion].
        pub fn set_or_clear_search_link_promotion<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::SearchLinkPromotion>,
        {
            self.search_link_promotion = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PromoteAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Control.PromoteAction"
        }
    }

    /// Actions are restricted by Vertical and Solution
    ///
    /// Required.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Action {
        /// Defines a boost-type control
        BoostAction(std::boxed::Box<crate::model::control::BoostAction>),
        /// Defines a filter-type control
        /// Currently not supported by Recommendation
        FilterAction(std::boxed::Box<crate::model::control::FilterAction>),
        /// Defines a redirect-type control.
        RedirectAction(std::boxed::Box<crate::model::control::RedirectAction>),
        /// Treats a group of terms as synonyms of one another.
        SynonymsAction(std::boxed::Box<crate::model::control::SynonymsAction>),
        /// Promote certain links based on predefined trigger queries.
        ///
        /// This now only supports basic site search.
        PromoteAction(std::boxed::Box<crate::model::control::PromoteAction>),
    }
}

/// Request for CreateControl method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateControlRequest {
    /// Required. Full resource name of parent data store. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
    /// or
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Control to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub control: std::option::Option<crate::model::Control>,

    /// Required. The ID to use for the Control, which will become the final
    /// component of the Control's resource name.
    ///
    /// This value must be within 1-63 characters.
    /// Valid characters are /[a-z][0-9]-_/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub control_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateControlRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [control][crate::model::CreateControlRequest::control].
    pub fn set_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control][crate::model::CreateControlRequest::control].
    pub fn set_or_clear_control<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = v.map(|x| x.into());
        self
    }

    /// Sets the value of [control_id][crate::model::CreateControlRequest::control_id].
    pub fn set_control_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.control_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateControlRequest"
    }
}

/// Request for UpdateControl method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateControlRequest {
    /// Required. The Control to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub control: std::option::Option<crate::model::Control>,

    /// Optional. Indicates which fields in the provided
    /// [Control][google.cloud.discoveryengine.v1.Control] to update. The following
    /// are NOT supported:
    ///
    /// * [Control.name][google.cloud.discoveryengine.v1.Control.name]
    /// * [Control.solution_type][google.cloud.discoveryengine.v1.Control.solution_type]
    ///
    /// If not set or empty, all supported fields are updated.
    ///
    /// [google.cloud.discoveryengine.v1.Control]: crate::model::Control
    /// [google.cloud.discoveryengine.v1.Control.name]: crate::model::Control::name
    /// [google.cloud.discoveryengine.v1.Control.solution_type]: crate::model::Control::solution_type
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [control][crate::model::UpdateControlRequest::control].
    pub fn set_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control][crate::model::UpdateControlRequest::control].
    pub fn set_or_clear_control<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateControlRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateControlRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateControlRequest"
    }
}

/// Request for DeleteControl method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteControlRequest {
    /// Required. The resource name of the Control to delete. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteControlRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteControlRequest"
    }
}

/// Request for GetControl method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetControlRequest {
    /// Required. The resource name of the Control to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetControlRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetControlRequest"
    }
}

/// Request for ListControls method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListControlsRequest {
    /// Required. The data store resource name. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
    /// or
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListControls` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter to apply on the list results. Supported features:
    ///
    /// * List all the products under the parent branch if
    ///   [filter][google.cloud.discoveryengine.v1.ListControlsRequest.filter] is
    ///   unset. Currently this field is unsupported.
    ///
    /// [google.cloud.discoveryengine.v1.ListControlsRequest.filter]: crate::model::ListControlsRequest::filter
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListControlsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListControlsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListControlsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListControlsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListControlsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListControlsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListControlsRequest"
    }
}

/// Response for ListControls method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListControlsResponse {
    /// All the Controls for a given data store.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub controls: std::vec::Vec<crate::model::Control>,

    /// Pagination token, if not returned indicates the last page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListControlsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [controls][crate::model::ListControlsResponse::controls].
    pub fn set_controls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Control>,
    {
        use std::iter::Iterator;
        self.controls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListControlsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListControlsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListControlsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListControlsResponse {
    type PageItem = crate::model::Control;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.controls
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// External conversation proto definition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Conversation {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/global/collections/{collection}/dataStore/*/conversations/*`
    /// or
    /// `projects/{project}/locations/global/collections/{collection}/engines/*/conversations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The state of the Conversation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::conversation::State,

    /// A unique identifier for tracking users.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_pseudo_id: std::string::String,

    /// Conversation messages.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub messages: std::vec::Vec<crate::model::ConversationMessage>,

    /// Output only. The time the conversation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the conversation finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Conversation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Conversation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Conversation::state].
    pub fn set_state<T: std::convert::Into<crate::model::conversation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [user_pseudo_id][crate::model::Conversation::user_pseudo_id].
    pub fn set_user_pseudo_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_pseudo_id = v.into();
        self
    }

    /// Sets the value of [messages][crate::model::Conversation::messages].
    pub fn set_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversationMessage>,
    {
        use std::iter::Iterator;
        self.messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::Conversation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Conversation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Conversation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Conversation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Conversation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Conversation"
    }
}

/// Defines additional types related to [Conversation].
pub mod conversation {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of the state of the conversation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unknown.
        Unspecified,
        /// Conversation is currently open.
        InProgress,
        /// Conversation has been completed.
        Completed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Completed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "COMPLETED" => Self::Completed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Completed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.discoveryengine.v1.Conversation.State",
            ))
        }
    }
}

/// Defines a reply message to user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Reply {
    /// Summary based on search results.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub summary: std::option::Option<crate::model::search_response::Summary>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Reply {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summary][crate::model::Reply::summary].
    pub fn set_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_response::Summary>,
    {
        self.summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summary][crate::model::Reply::summary].
    pub fn set_or_clear_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_response::Summary>,
    {
        self.summary = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Reply {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Reply"
    }
}

/// Defines context of the conversation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversationContext {
    /// The current list of documents the user is seeing.
    /// It contains the document resource references.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub context_documents: std::vec::Vec<std::string::String>,

    /// The current active document the user opened.
    /// It contains the document resource reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub active_document: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context_documents][crate::model::ConversationContext::context_documents].
    pub fn set_context_documents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.context_documents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [active_document][crate::model::ConversationContext::active_document].
    pub fn set_active_document<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.active_document = v.into();
        self
    }
}

impl wkt::message::Message for ConversationContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ConversationContext"
    }
}

/// Defines text input.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TextInput {
    /// Text input.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub input: std::string::String,

    /// Conversation context of the input.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::ConversationContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input][crate::model::TextInput::input].
    pub fn set_input<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input = v.into();
        self
    }

    /// Sets the value of [context][crate::model::TextInput::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationContext>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::TextInput::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationContext>,
    {
        self.context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TextInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.TextInput"
    }
}

/// Defines a conversation message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversationMessage {
    /// Output only. Message creation timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub message: std::option::Option<crate::model::conversation_message::Message>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversationMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ConversationMessage::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConversationMessage::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::ConversationMessage::message].
    ///
    /// Note that all the setters affecting `message` are mutually
    /// exclusive.
    pub fn set_message<
        T: std::convert::Into<std::option::Option<crate::model::conversation_message::Message>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = v.into();
        self
    }

    /// The value of [message][crate::model::ConversationMessage::message]
    /// if it holds a `UserInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::TextInput>> {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::conversation_message::Message::UserInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ConversationMessage::message]
    /// to hold a `UserInput`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_user_input<T: std::convert::Into<std::boxed::Box<crate::model::TextInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::conversation_message::Message::UserInput(v.into()),
        );
        self
    }

    /// The value of [message][crate::model::ConversationMessage::message]
    /// if it holds a `Reply`, `None` if the field is not set or
    /// holds a different branch.
    pub fn reply(&self) -> std::option::Option<&std::boxed::Box<crate::model::Reply>> {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::conversation_message::Message::Reply(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ConversationMessage::message]
    /// to hold a `Reply`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_reply<T: std::convert::Into<std::boxed::Box<crate::model::Reply>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message =
            std::option::Option::Some(crate::model::conversation_message::Message::Reply(v.into()));
        self
    }
}

impl wkt::message::Message for ConversationMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ConversationMessage"
    }
}

/// Defines additional types related to [ConversationMessage].
pub mod conversation_message {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Message {
        /// User text input.
        UserInput(std::boxed::Box<crate::model::TextInput>),
        /// Search reply.
        Reply(std::boxed::Box<crate::model::Reply>),
    }
}

/// Request message for
/// [ConversationalSearchService.ConverseConversation][google.cloud.discoveryengine.v1.ConversationalSearchService.ConverseConversation]
/// method.
///
/// [google.cloud.discoveryengine.v1.ConversationalSearchService.ConverseConversation]: crate::client::ConversationalSearchService::converse_conversation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConverseConversationRequest {
    /// Required. The resource name of the Conversation to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`.
    /// Use
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/-`
    /// to activate auto session mode, which automatically creates a new
    /// conversation inside a ConverseConversation session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Current user input.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::TextInput>,

    /// The resource name of the Serving Config to use. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/servingConfigs/{serving_config_id}`
    /// If this is not set, the default serving config will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub serving_config: std::string::String,

    /// The conversation to be used by auto session only. The name field will be
    /// ignored as we automatically assign new name for the conversation in auto
    /// session.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// Whether to turn on safe search.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub safe_search: bool,

    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A specification for configuring the summary returned in the response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub summary_spec:
        std::option::Option<crate::model::search_request::content_search_spec::SummarySpec>,

    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the documents being filtered. Filter
    /// expression is case-sensitive. This will be used to filter search results
    /// which may affect the summary response.
    ///
    /// If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
    ///
    /// Filtering in Vertex AI Search is done by mapping the LHS filter key to a
    /// key property defined in the Vertex AI Search backend -- this mapping is
    /// defined by the customer in their schema. For example a media customer might
    /// have a field 'name' in their schema. In this case the filter would look
    /// like this: filter --> name:'ANY("king kong")'
    ///
    /// For more information about filtering including syntax and filter
    /// operators, see
    /// [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Boost specification to boost certain documents in search results which may
    /// affect the converse response. For more information on boosting, see
    /// [Boosting](https://cloud.google.com/retail/docs/boosting#boost)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub boost_spec: std::option::Option<crate::model::search_request::BoostSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConverseConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConverseConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::ConverseConversationRequest::query].
    pub fn set_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextInput>,
    {
        self.query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query][crate::model::ConverseConversationRequest::query].
    pub fn set_or_clear_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextInput>,
    {
        self.query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serving_config][crate::model::ConverseConversationRequest::serving_config].
    pub fn set_serving_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serving_config = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::ConverseConversationRequest::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::ConverseConversationRequest::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [safe_search][crate::model::ConverseConversationRequest::safe_search].
    pub fn set_safe_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.safe_search = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::ConverseConversationRequest::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [summary_spec][crate::model::ConverseConversationRequest::summary_spec].
    pub fn set_summary_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::content_search_spec::SummarySpec>,
    {
        self.summary_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summary_spec][crate::model::ConverseConversationRequest::summary_spec].
    pub fn set_or_clear_summary_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::content_search_spec::SummarySpec>,
    {
        self.summary_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::ConverseConversationRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [boost_spec][crate::model::ConverseConversationRequest::boost_spec].
    pub fn set_boost_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::BoostSpec>,
    {
        self.boost_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boost_spec][crate::model::ConverseConversationRequest::boost_spec].
    pub fn set_or_clear_boost_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::BoostSpec>,
    {
        self.boost_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ConverseConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ConverseConversationRequest"
    }
}

/// Response message for
/// [ConversationalSearchService.ConverseConversation][google.cloud.discoveryengine.v1.ConversationalSearchService.ConverseConversation]
/// method.
///
/// [google.cloud.discoveryengine.v1.ConversationalSearchService.ConverseConversation]: crate::client::ConversationalSearchService::converse_conversation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConverseConversationResponse {
    /// Answer to the current query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reply: std::option::Option<crate::model::Reply>,

    /// Updated conversation including the answer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// Search Results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub search_results: std::vec::Vec<crate::model::search_response::SearchResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConverseConversationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reply][crate::model::ConverseConversationResponse::reply].
    pub fn set_reply<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Reply>,
    {
        self.reply = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reply][crate::model::ConverseConversationResponse::reply].
    pub fn set_or_clear_reply<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Reply>,
    {
        self.reply = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation][crate::model::ConverseConversationResponse::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::ConverseConversationResponse::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [search_results][crate::model::ConverseConversationResponse::search_results].
    pub fn set_search_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_response::SearchResult>,
    {
        use std::iter::Iterator;
        self.search_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConverseConversationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ConverseConversationResponse"
    }
}

/// Request for CreateConversation method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConversationRequest {
    /// Required. Full resource name of parent data store. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The conversation to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation: std::option::Option<crate::model::Conversation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::CreateConversationRequest::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::CreateConversationRequest::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateConversationRequest"
    }
}

/// Request for UpdateConversation method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConversationRequest {
    /// Required. The Conversation to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// Indicates which fields in the provided
    /// [Conversation][google.cloud.discoveryengine.v1.Conversation] to update. The
    /// following are NOT supported:
    ///
    /// * [Conversation.name][google.cloud.discoveryengine.v1.Conversation.name]
    ///
    /// If not set or empty, all supported fields are updated.
    ///
    /// [google.cloud.discoveryengine.v1.Conversation]: crate::model::Conversation
    /// [google.cloud.discoveryengine.v1.Conversation.name]: crate::model::Conversation::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::UpdateConversationRequest::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::UpdateConversationRequest::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConversationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConversationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateConversationRequest"
    }
}

/// Request for DeleteConversation method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConversationRequest {
    /// Required. The resource name of the Conversation to delete. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteConversationRequest"
    }
}

/// Request for GetConversation method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConversationRequest {
    /// Required. The resource name of the Conversation to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetConversationRequest"
    }
}

/// Request for ListConversations method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversationsRequest {
    /// Required. The data store resource name. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListConversations` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter to apply on the list results. The supported features are:
    /// user_pseudo_id, state.
    ///
    /// Example:
    /// "user_pseudo_id = some_id"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `update_time`
    /// * `create_time`
    /// * `conversation_name`
    ///
    /// Example:
    /// "update_time desc"
    /// "create_time"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConversationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListConversationsRequest"
    }
}

/// Response for ListConversations method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversationsResponse {
    /// All the Conversations for a given data store.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conversations: std::vec::Vec<crate::model::Conversation>,

    /// Pagination token, if not returned indicates the last page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversations][crate::model::ListConversationsResponse::conversations].
    pub fn set_conversations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Conversation>,
    {
        use std::iter::Iterator;
        self.conversations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListConversationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationsResponse {
    type PageItem = crate::model::Conversation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ConversationalSearchService.AnswerQuery][google.cloud.discoveryengine.v1.ConversationalSearchService.AnswerQuery]
/// method.
///
/// [google.cloud.discoveryengine.v1.ConversationalSearchService.AnswerQuery]: crate::client::ConversationalSearchService::answer_query
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnswerQueryRequest {
    /// Required. The resource name of the Search serving config, such as
    /// `projects/*/locations/global/collections/default_collection/engines/*/servingConfigs/default_serving_config`,
    /// or
    /// `projects/*/locations/global/collections/default_collection/dataStores/*/servingConfigs/default_serving_config`.
    /// This field is used to identify the serving configuration name, set
    /// of models used to make the search.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub serving_config: std::string::String,

    /// Required. Current user query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query: std::option::Option<crate::model::Query>,

    /// The session resource name. Not required.
    ///
    /// When session field is not set, the API is in sessionless mode.
    ///
    /// We support auto session mode: users can use the wildcard symbol `-` as
    /// session ID.  A new ID will be automatically generated and assigned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session: std::string::String,

    /// Model specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub safety_spec: std::option::Option<crate::model::answer_query_request::SafetySpec>,

    /// Related questions specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub related_questions_spec:
        std::option::Option<crate::model::answer_query_request::RelatedQuestionsSpec>,

    /// Optional. Grounding specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub grounding_spec: std::option::Option<crate::model::answer_query_request::GroundingSpec>,

    /// Answer generation specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub answer_generation_spec:
        std::option::Option<crate::model::answer_query_request::AnswerGenerationSpec>,

    /// Search specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_spec: std::option::Option<crate::model::answer_query_request::SearchSpec>,

    /// Query understanding specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_understanding_spec:
        std::option::Option<crate::model::answer_query_request::QueryUnderstandingSpec>,

    /// Deprecated: This field is deprecated. Streaming Answer API will be
    /// supported.
    ///
    /// Asynchronous mode control.
    ///
    /// If enabled, the response will be returned with answer/session resource
    /// name without final answer. The API users need to do the polling to get
    /// the latest status of answer/session by calling
    /// [ConversationalSearchService.GetAnswer][google.cloud.discoveryengine.v1.ConversationalSearchService.GetAnswer]
    /// or
    /// [ConversationalSearchService.GetSession][google.cloud.discoveryengine.v1.ConversationalSearchService.GetSession]
    /// method.
    ///
    /// [google.cloud.discoveryengine.v1.ConversationalSearchService.GetAnswer]: crate::client::ConversationalSearchService::get_answer
    /// [google.cloud.discoveryengine.v1.ConversationalSearchService.GetSession]: crate::client::ConversationalSearchService::get_session
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub asynchronous_mode: bool,

    /// A unique identifier for tracking visitors. For example, this could be
    /// implemented with an HTTP cookie, which should be able to uniquely identify
    /// a visitor on a single device. This unique identifier should not change if
    /// the visitor logs in or out of the website.
    ///
    /// This field should NOT have a fixed value such as `unknown_visitor`.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an  `INVALID_ARGUMENT`  error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_pseudo_id: std::string::String,

    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. End user specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_user_spec: std::option::Option<crate::model::answer_query_request::EndUserSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnswerQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::AnswerQueryRequest::serving_config].
    pub fn set_serving_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serving_config = v.into();
        self
    }

    /// Sets the value of [query][crate::model::AnswerQueryRequest::query].
    pub fn set_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Query>,
    {
        self.query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query][crate::model::AnswerQueryRequest::query].
    pub fn set_or_clear_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Query>,
    {
        self.query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session][crate::model::AnswerQueryRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [safety_spec][crate::model::AnswerQueryRequest::safety_spec].
    pub fn set_safety_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::SafetySpec>,
    {
        self.safety_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [safety_spec][crate::model::AnswerQueryRequest::safety_spec].
    pub fn set_or_clear_safety_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::SafetySpec>,
    {
        self.safety_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [related_questions_spec][crate::model::AnswerQueryRequest::related_questions_spec].
    pub fn set_related_questions_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::RelatedQuestionsSpec>,
    {
        self.related_questions_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [related_questions_spec][crate::model::AnswerQueryRequest::related_questions_spec].
    pub fn set_or_clear_related_questions_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::RelatedQuestionsSpec>,
    {
        self.related_questions_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [grounding_spec][crate::model::AnswerQueryRequest::grounding_spec].
    pub fn set_grounding_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::GroundingSpec>,
    {
        self.grounding_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [grounding_spec][crate::model::AnswerQueryRequest::grounding_spec].
    pub fn set_or_clear_grounding_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::GroundingSpec>,
    {
        self.grounding_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [answer_generation_spec][crate::model::AnswerQueryRequest::answer_generation_spec].
    pub fn set_answer_generation_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::AnswerGenerationSpec>,
    {
        self.answer_generation_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_generation_spec][crate::model::AnswerQueryRequest::answer_generation_spec].
    pub fn set_or_clear_answer_generation_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::AnswerGenerationSpec>,
    {
        self.answer_generation_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [search_spec][crate::model::AnswerQueryRequest::search_spec].
    pub fn set_search_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::SearchSpec>,
    {
        self.search_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [search_spec][crate::model::AnswerQueryRequest::search_spec].
    pub fn set_or_clear_search_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::SearchSpec>,
    {
        self.search_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_understanding_spec][crate::model::AnswerQueryRequest::query_understanding_spec].
    pub fn set_query_understanding_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::QueryUnderstandingSpec>,
    {
        self.query_understanding_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_understanding_spec][crate::model::AnswerQueryRequest::query_understanding_spec].
    pub fn set_or_clear_query_understanding_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::QueryUnderstandingSpec>,
    {
        self.query_understanding_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [asynchronous_mode][crate::model::AnswerQueryRequest::asynchronous_mode].
    #[deprecated]
    pub fn set_asynchronous_mode<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.asynchronous_mode = v.into();
        self
    }

    /// Sets the value of [user_pseudo_id][crate::model::AnswerQueryRequest::user_pseudo_id].
    pub fn set_user_pseudo_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_pseudo_id = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::AnswerQueryRequest::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [end_user_spec][crate::model::AnswerQueryRequest::end_user_spec].
    pub fn set_end_user_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::EndUserSpec>,
    {
        self.end_user_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_user_spec][crate::model::AnswerQueryRequest::end_user_spec].
    pub fn set_or_clear_end_user_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_query_request::EndUserSpec>,
    {
        self.end_user_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnswerQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest"
    }
}

/// Defines additional types related to [AnswerQueryRequest].
pub mod answer_query_request {
    #[allow(unused_imports)]
    use super::*;

    /// Safety specification.
    /// There are two use cases:
    ///
    /// . when only safety_spec.enable is set, the BLOCK_LOW_AND_ABOVE threshold
    ///   will be applied for all categories.
    /// . when safety_spec.enable is set and some safety_settings are set, only
    ///   specified safety_settings are applied.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SafetySpec {
        /// Enable the safety filtering on the answer response. It is false by
        /// default.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enable: bool,

        /// Optional. Safety settings.
        /// This settings are effective only when the safety_spec.enable is true.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub safety_settings:
            std::vec::Vec<crate::model::answer_query_request::safety_spec::SafetySetting>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SafetySpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable][crate::model::answer_query_request::SafetySpec::enable].
        pub fn set_enable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable = v.into();
            self
        }

        /// Sets the value of [safety_settings][crate::model::answer_query_request::SafetySpec::safety_settings].
        pub fn set_safety_settings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::answer_query_request::safety_spec::SafetySetting>,
        {
            use std::iter::Iterator;
            self.safety_settings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SafetySpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SafetySpec"
        }
    }

    /// Defines additional types related to [SafetySpec].
    pub mod safety_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Safety settings.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SafetySetting {
            /// Required. Harm category.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub category: crate::model::HarmCategory,

            /// Required. The harm block threshold.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub threshold:
                crate::model::answer_query_request::safety_spec::safety_setting::HarmBlockThreshold,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SafetySetting {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [category][crate::model::answer_query_request::safety_spec::SafetySetting::category].
            pub fn set_category<T: std::convert::Into<crate::model::HarmCategory>>(
                mut self,
                v: T,
            ) -> Self {
                self.category = v.into();
                self
            }

            /// Sets the value of [threshold][crate::model::answer_query_request::safety_spec::SafetySetting::threshold].
            pub fn set_threshold<T: std::convert::Into<crate::model::answer_query_request::safety_spec::safety_setting::HarmBlockThreshold>>(mut self, v: T) -> Self{
                self.threshold = v.into();
                self
            }
        }

        impl wkt::message::Message for SafetySetting {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SafetySpec.SafetySetting"
            }
        }

        /// Defines additional types related to [SafetySetting].
        pub mod safety_setting {
            #[allow(unused_imports)]
            use super::*;

            /// Probability based thresholds levels for blocking.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum HarmBlockThreshold {
                /// Unspecified harm block threshold.
                Unspecified,
                /// Block low threshold and above (i.e. block more).
                BlockLowAndAbove,
                /// Block medium threshold and above.
                BlockMediumAndAbove,
                /// Block only high threshold (i.e. block less).
                BlockOnlyHigh,
                /// Block none.
                BlockNone,
                /// Turn off the safety filter.
                Off,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [HarmBlockThreshold::value] or
                /// [HarmBlockThreshold::name].
                UnknownValue(harm_block_threshold::UnknownValue),
            }

            #[doc(hidden)]
            pub mod harm_block_threshold {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl HarmBlockThreshold {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::BlockLowAndAbove => std::option::Option::Some(1),
                        Self::BlockMediumAndAbove => std::option::Option::Some(2),
                        Self::BlockOnlyHigh => std::option::Option::Some(3),
                        Self::BlockNone => std::option::Option::Some(4),
                        Self::Off => std::option::Option::Some(5),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("HARM_BLOCK_THRESHOLD_UNSPECIFIED")
                        }
                        Self::BlockLowAndAbove => std::option::Option::Some("BLOCK_LOW_AND_ABOVE"),
                        Self::BlockMediumAndAbove => {
                            std::option::Option::Some("BLOCK_MEDIUM_AND_ABOVE")
                        }
                        Self::BlockOnlyHigh => std::option::Option::Some("BLOCK_ONLY_HIGH"),
                        Self::BlockNone => std::option::Option::Some("BLOCK_NONE"),
                        Self::Off => std::option::Option::Some("OFF"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for HarmBlockThreshold {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for HarmBlockThreshold {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for HarmBlockThreshold {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::BlockLowAndAbove,
                        2 => Self::BlockMediumAndAbove,
                        3 => Self::BlockOnlyHigh,
                        4 => Self::BlockNone,
                        5 => Self::Off,
                        _ => Self::UnknownValue(harm_block_threshold::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for HarmBlockThreshold {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "HARM_BLOCK_THRESHOLD_UNSPECIFIED" => Self::Unspecified,
                        "BLOCK_LOW_AND_ABOVE" => Self::BlockLowAndAbove,
                        "BLOCK_MEDIUM_AND_ABOVE" => Self::BlockMediumAndAbove,
                        "BLOCK_ONLY_HIGH" => Self::BlockOnlyHigh,
                        "BLOCK_NONE" => Self::BlockNone,
                        "OFF" => Self::Off,
                        _ => Self::UnknownValue(harm_block_threshold::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for HarmBlockThreshold {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::BlockLowAndAbove => serializer.serialize_i32(1),
                        Self::BlockMediumAndAbove => serializer.serialize_i32(2),
                        Self::BlockOnlyHigh => serializer.serialize_i32(3),
                        Self::BlockNone => serializer.serialize_i32(4),
                        Self::Off => serializer.serialize_i32(5),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for HarmBlockThreshold {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmBlockThreshold>::new(
                        ".google.cloud.discoveryengine.v1.AnswerQueryRequest.SafetySpec.SafetySetting.HarmBlockThreshold"))
                }
            }
        }
    }

    /// Related questions specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RelatedQuestionsSpec {
        /// Enable related questions feature if true.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enable: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RelatedQuestionsSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable][crate::model::answer_query_request::RelatedQuestionsSpec::enable].
        pub fn set_enable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable = v.into();
            self
        }
    }

    impl wkt::message::Message for RelatedQuestionsSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.RelatedQuestionsSpec"
        }
    }

    /// Grounding specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroundingSpec {
        /// Optional. Specifies whether to include grounding_supports in the answer.
        /// The default value is `false`.
        ///
        /// When this field is set to `true`, returned answer will have
        /// `grounding_score` and will contain GroundingSupports for each claim.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub include_grounding_supports: bool,

        /// Optional. Specifies whether to enable the filtering based on grounding
        /// score and at what level.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub filtering_level: crate::model::answer_query_request::grounding_spec::FilteringLevel,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroundingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [include_grounding_supports][crate::model::answer_query_request::GroundingSpec::include_grounding_supports].
        pub fn set_include_grounding_supports<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.include_grounding_supports = v.into();
            self
        }

        /// Sets the value of [filtering_level][crate::model::answer_query_request::GroundingSpec::filtering_level].
        pub fn set_filtering_level<
            T: std::convert::Into<crate::model::answer_query_request::grounding_spec::FilteringLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.filtering_level = v.into();
            self
        }
    }

    impl wkt::message::Message for GroundingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.GroundingSpec"
        }
    }

    /// Defines additional types related to [GroundingSpec].
    pub mod grounding_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Level to filter based on answer grounding.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FilteringLevel {
            /// Default is no filter
            Unspecified,
            /// Filter answers based on a low threshold.
            Low,
            /// Filter answers based on a high threshold.
            High,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [FilteringLevel::value] or
            /// [FilteringLevel::name].
            UnknownValue(filtering_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod filtering_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl FilteringLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Low => std::option::Option::Some(1),
                    Self::High => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("FILTERING_LEVEL_UNSPECIFIED"),
                    Self::Low => std::option::Option::Some("FILTERING_LEVEL_LOW"),
                    Self::High => std::option::Option::Some("FILTERING_LEVEL_HIGH"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for FilteringLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for FilteringLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for FilteringLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Low,
                    2 => Self::High,
                    _ => Self::UnknownValue(filtering_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for FilteringLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "FILTERING_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "FILTERING_LEVEL_LOW" => Self::Low,
                    "FILTERING_LEVEL_HIGH" => Self::High,
                    _ => Self::UnknownValue(filtering_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for FilteringLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Low => serializer.serialize_i32(1),
                    Self::High => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for FilteringLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilteringLevel>::new(
                    ".google.cloud.discoveryengine.v1.AnswerQueryRequest.GroundingSpec.FilteringLevel"))
            }
        }
    }

    /// Answer generation specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AnswerGenerationSpec {
        /// Answer generation model specification.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub model_spec: std::option::Option<
            crate::model::answer_query_request::answer_generation_spec::ModelSpec,
        >,

        /// Answer generation prompt specification.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub prompt_spec: std::option::Option<
            crate::model::answer_query_request::answer_generation_spec::PromptSpec,
        >,

        /// Specifies whether to include citation metadata in the answer. The default
        /// value is `false`.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub include_citations: bool,

        /// Language code for Answer. Use language tags defined by
        /// [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
        /// Note: This is an experimental feature.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub answer_language_code: std::string::String,

        /// Specifies whether to filter out adversarial queries. The default value
        /// is `false`.
        ///
        /// Google employs search-query classification to detect adversarial
        /// queries. No answer is returned if the search query is classified as an
        /// adversarial query. For example, a user might ask a question regarding
        /// negative comments about the company or submit a query designed to
        /// generate unsafe, policy-violating output. If this field is set to
        /// `true`, we skip generating answers for adversarial queries and return
        /// fallback messages instead.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub ignore_adversarial_query: bool,

        /// Specifies whether to filter out queries that are not answer-seeking.
        /// The default value is `false`.
        ///
        /// Google employs search-query classification to detect answer-seeking
        /// queries. No answer is returned if the search query is classified as a
        /// non-answer seeking query. If this field is set to `true`, we skip
        /// generating answers for non-answer seeking queries and return
        /// fallback messages instead.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub ignore_non_answer_seeking_query: bool,

        /// Specifies whether to filter out queries that have low relevance.
        ///
        /// If this field is set to `false`, all search results are used regardless
        /// of relevance to generate answers. If set to `true` or unset, the behavior
        /// will be determined automatically by the service.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ignore_low_relevant_content: std::option::Option<bool>,

        /// Optional. Specifies whether to filter out jail-breaking queries. The
        /// default value is `false`.
        ///
        /// Google employs search-query classification to detect jail-breaking
        /// queries. No summary is returned if the search query is classified as a
        /// jail-breaking query. A user might add instructions to the query to
        /// change the tone, style, language, content of the answer, or ask the
        /// model to act as a different entity, e.g. "Reply in the tone of a
        /// competing company's CEO". If this field is set to `true`, we skip
        /// generating summaries for jail-breaking queries and return fallback
        /// messages instead.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub ignore_jail_breaking_query: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AnswerGenerationSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model_spec][crate::model::answer_query_request::AnswerGenerationSpec::model_spec].
        pub fn set_model_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::answer_query_request::answer_generation_spec::ModelSpec,
                >,
        {
            self.model_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [model_spec][crate::model::answer_query_request::AnswerGenerationSpec::model_spec].
        pub fn set_or_clear_model_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::answer_query_request::answer_generation_spec::ModelSpec,
                >,
        {
            self.model_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [prompt_spec][crate::model::answer_query_request::AnswerGenerationSpec::prompt_spec].
        pub fn set_prompt_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::answer_query_request::answer_generation_spec::PromptSpec,
                >,
        {
            self.prompt_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [prompt_spec][crate::model::answer_query_request::AnswerGenerationSpec::prompt_spec].
        pub fn set_or_clear_prompt_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::answer_query_request::answer_generation_spec::PromptSpec,
                >,
        {
            self.prompt_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_citations][crate::model::answer_query_request::AnswerGenerationSpec::include_citations].
        pub fn set_include_citations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.include_citations = v.into();
            self
        }

        /// Sets the value of [answer_language_code][crate::model::answer_query_request::AnswerGenerationSpec::answer_language_code].
        pub fn set_answer_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.answer_language_code = v.into();
            self
        }

        /// Sets the value of [ignore_adversarial_query][crate::model::answer_query_request::AnswerGenerationSpec::ignore_adversarial_query].
        pub fn set_ignore_adversarial_query<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.ignore_adversarial_query = v.into();
            self
        }

        /// Sets the value of [ignore_non_answer_seeking_query][crate::model::answer_query_request::AnswerGenerationSpec::ignore_non_answer_seeking_query].
        pub fn set_ignore_non_answer_seeking_query<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.ignore_non_answer_seeking_query = v.into();
            self
        }

        /// Sets the value of [ignore_low_relevant_content][crate::model::answer_query_request::AnswerGenerationSpec::ignore_low_relevant_content].
        pub fn set_ignore_low_relevant_content<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.ignore_low_relevant_content = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ignore_low_relevant_content][crate::model::answer_query_request::AnswerGenerationSpec::ignore_low_relevant_content].
        pub fn set_or_clear_ignore_low_relevant_content<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.ignore_low_relevant_content = v.map(|x| x.into());
            self
        }

        /// Sets the value of [ignore_jail_breaking_query][crate::model::answer_query_request::AnswerGenerationSpec::ignore_jail_breaking_query].
        pub fn set_ignore_jail_breaking_query<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.ignore_jail_breaking_query = v.into();
            self
        }
    }

    impl wkt::message::Message for AnswerGenerationSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.AnswerGenerationSpec"
        }
    }

    /// Defines additional types related to [AnswerGenerationSpec].
    pub mod answer_generation_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Answer Generation Model specification.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ModelSpec {
            /// Model version. If not set, it will use the default stable model.
            /// Allowed values are: stable, preview.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub model_version: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ModelSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [model_version][crate::model::answer_query_request::answer_generation_spec::ModelSpec::model_version].
            pub fn set_model_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.model_version = v.into();
                self
            }
        }

        impl wkt::message::Message for ModelSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.AnswerGenerationSpec.ModelSpec"
            }
        }

        /// Answer generation prompt specification.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct PromptSpec {
            /// Customized preamble.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub preamble: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl PromptSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [preamble][crate::model::answer_query_request::answer_generation_spec::PromptSpec::preamble].
            pub fn set_preamble<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.preamble = v.into();
                self
            }
        }

        impl wkt::message::Message for PromptSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.AnswerGenerationSpec.PromptSpec"
            }
        }
    }

    /// Search specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SearchSpec {
        /// Search parameters to control the search behavior.
        /// Or provide search result list to generate answer.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub input: std::option::Option<crate::model::answer_query_request::search_spec::Input>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SearchSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input][crate::model::answer_query_request::SearchSpec::input].
        ///
        /// Note that all the setters affecting `input` are mutually
        /// exclusive.
        pub fn set_input<
            T: std::convert::Into<
                    std::option::Option<crate::model::answer_query_request::search_spec::Input>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input = v.into();
            self
        }

        /// The value of [input][crate::model::answer_query_request::SearchSpec::input]
        /// if it holds a `SearchParams`, `None` if the field is not set or
        /// holds a different branch.
        pub fn search_params(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::answer_query_request::search_spec::SearchParams>,
        > {
            #[allow(unreachable_patterns)]
            self.input.as_ref().and_then(|v| match v {
                crate::model::answer_query_request::search_spec::Input::SearchParams(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input][crate::model::answer_query_request::SearchSpec::input]
        /// to hold a `SearchParams`.
        ///
        /// Note that all the setters affecting `input` are
        /// mutually exclusive.
        pub fn set_search_params<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::answer_query_request::search_spec::SearchParams>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input = std::option::Option::Some(
                crate::model::answer_query_request::search_spec::Input::SearchParams(v.into()),
            );
            self
        }

        /// The value of [input][crate::model::answer_query_request::SearchSpec::input]
        /// if it holds a `SearchResultList`, `None` if the field is not set or
        /// holds a different branch.
        pub fn search_result_list(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::answer_query_request::search_spec::SearchResultList>,
        > {
            #[allow(unreachable_patterns)]
            self.input.as_ref().and_then(|v| match v {
                crate::model::answer_query_request::search_spec::Input::SearchResultList(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [input][crate::model::answer_query_request::SearchSpec::input]
        /// to hold a `SearchResultList`.
        ///
        /// Note that all the setters affecting `input` are
        /// mutually exclusive.
        pub fn set_search_result_list<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::answer_query_request::search_spec::SearchResultList,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input = std::option::Option::Some(
                crate::model::answer_query_request::search_spec::Input::SearchResultList(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SearchSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec"
        }
    }

    /// Defines additional types related to [SearchSpec].
    pub mod search_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Search parameters.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SearchParams {
            /// Number of search results to return.
            /// The default value is 10.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub max_return_results: i32,

            /// The filter syntax consists of an expression language for constructing
            /// a predicate from one or more fields of the documents being filtered.
            /// Filter expression is case-sensitive. This will be used to filter
            /// search results which may affect the Answer response.
            ///
            /// If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
            ///
            /// Filtering in Vertex AI Search is done by mapping the LHS filter key
            /// to a key property defined in the Vertex AI Search backend -- this
            /// mapping is defined by the customer in their schema. For example a
            /// media customers might have a field 'name' in their schema. In this
            /// case the filter would look like this: filter --> name:'ANY("king
            /// kong")'
            ///
            /// For more information about filtering including syntax and filter
            /// operators, see
            /// [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub filter: std::string::String,

            /// Boost specification to boost certain documents in search results which
            /// may affect the answer query response. For more information on boosting,
            /// see [Boosting](https://cloud.google.com/retail/docs/boosting#boost)
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub boost_spec: std::option::Option<crate::model::search_request::BoostSpec>,

            /// The order in which documents are returned. Documents can be ordered
            /// by a field in an [Document][google.cloud.discoveryengine.v1.Document]
            /// object. Leave it unset if ordered by relevance. `order_by` expression
            /// is case-sensitive. For more information on ordering, see
            /// [Ordering](https://cloud.google.com/retail/docs/filter-and-order#order)
            ///
            /// If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
            ///
            /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub order_by: std::string::String,

            /// Specifies the search result mode. If unspecified, the
            /// search result mode defaults to `DOCUMENTS`.
            /// See [parse and chunk
            /// documents](https://cloud.google.com/generative-ai-app-builder/docs/parse-chunk-documents)
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub search_result_mode:
                crate::model::search_request::content_search_spec::SearchResultMode,

            /// Specs defining dataStores to filter on in a search call and
            /// configurations for those dataStores. This is only considered for
            /// engines with multiple dataStores use case. For single dataStore within
            /// an engine, they should use the specs at the top level.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub data_store_specs: std::vec::Vec<crate::model::search_request::DataStoreSpec>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SearchParams {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [max_return_results][crate::model::answer_query_request::search_spec::SearchParams::max_return_results].
            pub fn set_max_return_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_return_results = v.into();
                self
            }

            /// Sets the value of [filter][crate::model::answer_query_request::search_spec::SearchParams::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [boost_spec][crate::model::answer_query_request::search_spec::SearchParams::boost_spec].
            pub fn set_boost_spec<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::search_request::BoostSpec>,
            {
                self.boost_spec = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [boost_spec][crate::model::answer_query_request::search_spec::SearchParams::boost_spec].
            pub fn set_or_clear_boost_spec<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::search_request::BoostSpec>,
            {
                self.boost_spec = v.map(|x| x.into());
                self
            }

            /// Sets the value of [order_by][crate::model::answer_query_request::search_spec::SearchParams::order_by].
            pub fn set_order_by<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.order_by = v.into();
                self
            }

            /// Sets the value of [search_result_mode][crate::model::answer_query_request::search_spec::SearchParams::search_result_mode].
            pub fn set_search_result_mode<
                T: std::convert::Into<
                        crate::model::search_request::content_search_spec::SearchResultMode,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.search_result_mode = v.into();
                self
            }

            /// Sets the value of [data_store_specs][crate::model::answer_query_request::search_spec::SearchParams::data_store_specs].
            pub fn set_data_store_specs<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::search_request::DataStoreSpec>,
            {
                use std::iter::Iterator;
                self.data_store_specs = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for SearchParams {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchParams"
            }
        }

        /// Search result list.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SearchResultList {
            /// Search results.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub search_results: std::vec::Vec<
                crate::model::answer_query_request::search_spec::search_result_list::SearchResult,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SearchResultList {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [search_results][crate::model::answer_query_request::search_spec::SearchResultList::search_results].
            pub fn set_search_results<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::answer_query_request::search_spec::search_result_list::SearchResult>
            {
                use std::iter::Iterator;
                self.search_results = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for SearchResultList {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList"
            }
        }

        /// Defines additional types related to [SearchResultList].
        pub mod search_result_list {
            #[allow(unused_imports)]
            use super::*;

            /// Search result.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct SearchResult {

                /// Search result content.
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub content: std::option::Option<crate::model::answer_query_request::search_spec::search_result_list::search_result::Content>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl SearchResult {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [content][crate::model::answer_query_request::search_spec::search_result_list::SearchResult::content].
                ///
                /// Note that all the setters affecting `content` are mutually
                /// exclusive.
                pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::answer_query_request::search_spec::search_result_list::search_result::Content>>>(mut self, v: T) -> Self
                {
                    self.content = v.into();
                    self
                }

                /// The value of [content][crate::model::answer_query_request::search_spec::search_result_list::SearchResult::content]
                /// if it holds a `UnstructuredDocumentInfo`, `None` if the field is not set or
                /// holds a different branch.
                pub fn unstructured_document_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo>>{
                    #[allow(unreachable_patterns)]
                    self.content.as_ref().and_then(|v| match v {
                        crate::model::answer_query_request::search_spec::search_result_list::search_result::Content::UnstructuredDocumentInfo(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [content][crate::model::answer_query_request::search_spec::search_result_list::SearchResult::content]
                /// to hold a `UnstructuredDocumentInfo`.
                ///
                /// Note that all the setters affecting `content` are
                /// mutually exclusive.
                pub fn set_unstructured_document_info<T: std::convert::Into<std::boxed::Box<crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo>>>(mut self, v: T) -> Self{
                    self.content = std::option::Option::Some(
                        crate::model::answer_query_request::search_spec::search_result_list::search_result::Content::UnstructuredDocumentInfo(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [content][crate::model::answer_query_request::search_spec::search_result_list::SearchResult::content]
                /// if it holds a `ChunkInfo`, `None` if the field is not set or
                /// holds a different branch.
                pub fn chunk_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo>>{
                    #[allow(unreachable_patterns)]
                    self.content.as_ref().and_then(|v| match v {
                        crate::model::answer_query_request::search_spec::search_result_list::search_result::Content::ChunkInfo(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [content][crate::model::answer_query_request::search_spec::search_result_list::SearchResult::content]
                /// to hold a `ChunkInfo`.
                ///
                /// Note that all the setters affecting `content` are
                /// mutually exclusive.
                pub fn set_chunk_info<T: std::convert::Into<std::boxed::Box<crate::model::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo>>>(mut self, v: T) -> Self{
                    self.content = std::option::Option::Some(
                        crate::model::answer_query_request::search_spec::search_result_list::search_result::Content::ChunkInfo(
                            v.into()
                        )
                    );
                    self
                }
            }

            impl wkt::message::Message for SearchResult {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList.SearchResult"
                }
            }

            /// Defines additional types related to [SearchResult].
            pub mod search_result {
                #[allow(unused_imports)]
                use super::*;

                /// Unstructured document information.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct UnstructuredDocumentInfo {

                    /// Document resource name.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub document: std::string::String,

                    /// URI for the document.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub uri: std::string::String,

                    /// Title.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub title: std::string::String,

                    /// List of document contexts. The content will be used for Answer
                    /// Generation. This is supposed to be the main content of the document
                    /// that can be long and comprehensive.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub document_contexts: std::vec::Vec<crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::DocumentContext>,

                    /// List of extractive segments.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    pub extractive_segments: std::vec::Vec<crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveSegment>,

                    /// Deprecated: This field is deprecated and will have no effect on
                    /// the Answer generation.
                    /// Please use document_contexts and extractive_segments fields.
                    /// List of extractive answers.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    #[deprecated]
                    pub extractive_answers: std::vec::Vec<crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveAnswer>,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl UnstructuredDocumentInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [document][crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo::document].
                    pub fn set_document<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.document = v.into();
                        self
                    }

                    /// Sets the value of [uri][crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo::uri].
                    pub fn set_uri<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.uri = v.into();
                        self
                    }

                    /// Sets the value of [title][crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo::title].
                    pub fn set_title<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.title = v.into();
                        self
                    }

                    /// Sets the value of [document_contexts][crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo::document_contexts].
                    pub fn set_document_contexts<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::DocumentContext>
                    {
                        use std::iter::Iterator;
                        self.document_contexts = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [extractive_segments][crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo::extractive_segments].
                    pub fn set_extractive_segments<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveSegment>
                    {
                        use std::iter::Iterator;
                        self.extractive_segments = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [extractive_answers][crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo::extractive_answers].
                    #[deprecated]
                    pub fn set_extractive_answers<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveAnswer>
                    {
                        use std::iter::Iterator;
                        self.extractive_answers = v.into_iter().map(|i| i.into()).collect();
                        self
                    }
                }

                impl wkt::message::Message for UnstructuredDocumentInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList.SearchResult.UnstructuredDocumentInfo"
                    }
                }

                /// Defines additional types related to [UnstructuredDocumentInfo].
                pub mod unstructured_document_info {
                    #[allow(unused_imports)]
                    use super::*;

                    /// Document context.
                    #[serde_with::serde_as]
                    #[derive(
                        Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                    )]
                    #[serde(default, rename_all = "camelCase")]
                    #[non_exhaustive]
                    pub struct DocumentContext {
                        /// Page identifier.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub page_identifier: std::string::String,

                        /// Document content to be used for answer generation.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub content: std::string::String,

                        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    impl DocumentContext {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [page_identifier][crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::DocumentContext::page_identifier].
                        pub fn set_page_identifier<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.page_identifier = v.into();
                            self
                        }

                        /// Sets the value of [content][crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::DocumentContext::content].
                        pub fn set_content<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.content = v.into();
                            self
                        }
                    }

                    impl wkt::message::Message for DocumentContext {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList.SearchResult.UnstructuredDocumentInfo.DocumentContext"
                        }
                    }

                    /// Extractive segment.
                    /// [Guide](https://cloud.google.com/generative-ai-app-builder/docs/snippets#extractive-segments)
                    /// Answer generation will only use it if document_contexts is empty.
                    /// This is supposed to be shorter snippets.
                    #[serde_with::serde_as]
                    #[derive(
                        Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                    )]
                    #[serde(default, rename_all = "camelCase")]
                    #[non_exhaustive]
                    pub struct ExtractiveSegment {
                        /// Page identifier.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub page_identifier: std::string::String,

                        /// Extractive segment content.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub content: std::string::String,

                        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    impl ExtractiveSegment {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [page_identifier][crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveSegment::page_identifier].
                        pub fn set_page_identifier<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.page_identifier = v.into();
                            self
                        }

                        /// Sets the value of [content][crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveSegment::content].
                        pub fn set_content<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.content = v.into();
                            self
                        }
                    }

                    impl wkt::message::Message for ExtractiveSegment {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList.SearchResult.UnstructuredDocumentInfo.ExtractiveSegment"
                        }
                    }

                    /// Extractive answer.
                    /// [Guide](https://cloud.google.com/generative-ai-app-builder/docs/snippets#get-answers)
                    #[serde_with::serde_as]
                    #[derive(
                        Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                    )]
                    #[serde(default, rename_all = "camelCase")]
                    #[non_exhaustive]
                    pub struct ExtractiveAnswer {
                        /// Page identifier.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub page_identifier: std::string::String,

                        /// Extractive answer content.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub content: std::string::String,

                        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    impl ExtractiveAnswer {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [page_identifier][crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveAnswer::page_identifier].
                        pub fn set_page_identifier<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.page_identifier = v.into();
                            self
                        }

                        /// Sets the value of [content][crate::model::answer_query_request::search_spec::search_result_list::search_result::unstructured_document_info::ExtractiveAnswer::content].
                        pub fn set_content<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.content = v.into();
                            self
                        }
                    }

                    impl wkt::message::Message for ExtractiveAnswer {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList.SearchResult.UnstructuredDocumentInfo.ExtractiveAnswer"
                        }
                    }
                }

                /// Chunk information.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct ChunkInfo {

                    /// Chunk resource name.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub chunk: std::string::String,

                    /// Chunk textual content.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub content: std::string::String,

                    /// Metadata of the document from the current chunk.
                    #[serde(skip_serializing_if = "std::option::Option::is_none")]
                    pub document_metadata: std::option::Option<crate::model::answer_query_request::search_spec::search_result_list::search_result::chunk_info::DocumentMetadata>,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl ChunkInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [chunk][crate::model::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo::chunk].
                    pub fn set_chunk<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.chunk = v.into();
                        self
                    }

                    /// Sets the value of [content][crate::model::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo::content].
                    pub fn set_content<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.content = v.into();
                        self
                    }

                    /// Sets the value of [document_metadata][crate::model::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo::document_metadata].
                    pub fn set_document_metadata<T>(mut self, v: T) -> Self
                    where T: std::convert::Into<crate::model::answer_query_request::search_spec::search_result_list::search_result::chunk_info::DocumentMetadata>
                    {
                        self.document_metadata = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [document_metadata][crate::model::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo::document_metadata].
                    pub fn set_or_clear_document_metadata<T>(mut self, v: std::option::Option<T>) -> Self
                    where T: std::convert::Into<crate::model::answer_query_request::search_spec::search_result_list::search_result::chunk_info::DocumentMetadata>
                    {
                        self.document_metadata = v.map(|x| x.into());
                        self
                    }
                }

                impl wkt::message::Message for ChunkInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList.SearchResult.ChunkInfo"
                    }
                }

                /// Defines additional types related to [ChunkInfo].
                pub mod chunk_info {
                    #[allow(unused_imports)]
                    use super::*;

                    /// Document metadata contains the information of the document of the
                    /// current chunk.
                    #[serde_with::serde_as]
                    #[derive(
                        Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                    )]
                    #[serde(default, rename_all = "camelCase")]
                    #[non_exhaustive]
                    pub struct DocumentMetadata {
                        /// Uri of the document.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub uri: std::string::String,

                        /// Title of the document.
                        #[serde(skip_serializing_if = "std::string::String::is_empty")]
                        pub title: std::string::String,

                        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    impl DocumentMetadata {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [uri][crate::model::answer_query_request::search_spec::search_result_list::search_result::chunk_info::DocumentMetadata::uri].
                        pub fn set_uri<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.uri = v.into();
                            self
                        }

                        /// Sets the value of [title][crate::model::answer_query_request::search_spec::search_result_list::search_result::chunk_info::DocumentMetadata::title].
                        pub fn set_title<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.title = v.into();
                            self
                        }
                    }

                    impl wkt::message::Message for DocumentMetadata {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.SearchSpec.SearchResultList.SearchResult.ChunkInfo.DocumentMetadata"
                        }
                    }
                }

                /// Search result content.
                #[serde_with::serde_as]
                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum Content {
                    /// Unstructured document information.
                    UnstructuredDocumentInfo(std::boxed::Box<crate::model::answer_query_request::search_spec::search_result_list::search_result::UnstructuredDocumentInfo>),
                    /// Chunk information.
                    ChunkInfo(std::boxed::Box<crate::model::answer_query_request::search_spec::search_result_list::search_result::ChunkInfo>),
                }
            }
        }

        /// Search parameters to control the search behavior.
        /// Or provide search result list to generate answer.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Input {
            /// Search parameters.
            SearchParams(
                std::boxed::Box<crate::model::answer_query_request::search_spec::SearchParams>,
            ),
            /// Search result list.
            SearchResultList(
                std::boxed::Box<crate::model::answer_query_request::search_spec::SearchResultList>,
            ),
        }
    }

    /// Query understanding specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueryUnderstandingSpec {
        /// Query classification specification.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub query_classification_spec: std::option::Option<
            crate::model::answer_query_request::query_understanding_spec::QueryClassificationSpec,
        >,

        /// Query rephraser specification.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub query_rephraser_spec: std::option::Option<
            crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec,
        >,

        /// Optional. Whether to disable spell correction.
        /// The default value is `false`.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub disable_spell_correction: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryUnderstandingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_classification_spec][crate::model::answer_query_request::QueryUnderstandingSpec::query_classification_spec].
        pub fn set_query_classification_spec<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::QueryClassificationSpec>
        {
            self.query_classification_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_classification_spec][crate::model::answer_query_request::QueryUnderstandingSpec::query_classification_spec].
        pub fn set_or_clear_query_classification_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::QueryClassificationSpec>
        {
            self.query_classification_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [query_rephraser_spec][crate::model::answer_query_request::QueryUnderstandingSpec::query_rephraser_spec].
        pub fn set_query_rephraser_spec<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec>
        {
            self.query_rephraser_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_rephraser_spec][crate::model::answer_query_request::QueryUnderstandingSpec::query_rephraser_spec].
        pub fn set_or_clear_query_rephraser_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec>
        {
            self.query_rephraser_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [disable_spell_correction][crate::model::answer_query_request::QueryUnderstandingSpec::disable_spell_correction].
        pub fn set_disable_spell_correction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disable_spell_correction = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryUnderstandingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec"
        }
    }

    /// Defines additional types related to [QueryUnderstandingSpec].
    pub mod query_understanding_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Query classification specification.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct QueryClassificationSpec {

            /// Enabled query classification types.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub types: std::vec::Vec<crate::model::answer_query_request::query_understanding_spec::query_classification_spec::Type>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl QueryClassificationSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [types][crate::model::answer_query_request::query_understanding_spec::QueryClassificationSpec::types].
            pub fn set_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::query_classification_spec::Type>
            {
                use std::iter::Iterator;
                self.types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for QueryClassificationSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryClassificationSpec"
            }
        }

        /// Defines additional types related to [QueryClassificationSpec].
        pub mod query_classification_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Query classification types.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// Unspecified query classification type.
                Unspecified,
                /// Adversarial query classification type.
                AdversarialQuery,
                /// Non-answer-seeking query classification type, for chit chat.
                NonAnswerSeekingQuery,
                /// Jail-breaking query classification type.
                JailBreakingQuery,
                /// Non-answer-seeking query classification type, for no clear intent.
                NonAnswerSeekingQueryV2,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Type::value] or
                /// [Type::name].
                UnknownValue(r#type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod r#type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Type {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::AdversarialQuery => std::option::Option::Some(1),
                        Self::NonAnswerSeekingQuery => std::option::Option::Some(2),
                        Self::JailBreakingQuery => std::option::Option::Some(3),
                        Self::NonAnswerSeekingQueryV2 => std::option::Option::Some(4),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                        Self::AdversarialQuery => std::option::Option::Some("ADVERSARIAL_QUERY"),
                        Self::NonAnswerSeekingQuery => {
                            std::option::Option::Some("NON_ANSWER_SEEKING_QUERY")
                        }
                        Self::JailBreakingQuery => std::option::Option::Some("JAIL_BREAKING_QUERY"),
                        Self::NonAnswerSeekingQueryV2 => {
                            std::option::Option::Some("NON_ANSWER_SEEKING_QUERY_V2")
                        }
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Type {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Type {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Type {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::AdversarialQuery,
                        2 => Self::NonAnswerSeekingQuery,
                        3 => Self::JailBreakingQuery,
                        4 => Self::NonAnswerSeekingQueryV2,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Type {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "TYPE_UNSPECIFIED" => Self::Unspecified,
                        "ADVERSARIAL_QUERY" => Self::AdversarialQuery,
                        "NON_ANSWER_SEEKING_QUERY" => Self::NonAnswerSeekingQuery,
                        "JAIL_BREAKING_QUERY" => Self::JailBreakingQuery,
                        "NON_ANSWER_SEEKING_QUERY_V2" => Self::NonAnswerSeekingQueryV2,
                        _ => Self::UnknownValue(r#type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Type {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::AdversarialQuery => serializer.serialize_i32(1),
                        Self::NonAnswerSeekingQuery => serializer.serialize_i32(2),
                        Self::JailBreakingQuery => serializer.serialize_i32(3),
                        Self::NonAnswerSeekingQueryV2 => serializer.serialize_i32(4),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Type {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                        ".google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryClassificationSpec.Type"))
                }
            }
        }

        /// Query rephraser specification.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct QueryRephraserSpec {

            /// Disable query rephraser.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub disable: bool,

            /// Max rephrase steps.
            /// The max number is 5 steps.
            /// If not set or set to < 1, it will be set to 1 by default.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub max_rephrase_steps: i32,

            /// Optional. Query Rephraser Model specification.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_spec: std::option::Option<crate::model::answer_query_request::query_understanding_spec::query_rephraser_spec::ModelSpec>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl QueryRephraserSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [disable][crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec::disable].
            pub fn set_disable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable = v.into();
                self
            }

            /// Sets the value of [max_rephrase_steps][crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec::max_rephrase_steps].
            pub fn set_max_rephrase_steps<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_rephrase_steps = v.into();
                self
            }

            /// Sets the value of [model_spec][crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec::model_spec].
            pub fn set_model_spec<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::query_rephraser_spec::ModelSpec>
            {
                self.model_spec = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [model_spec][crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec::model_spec].
            pub fn set_or_clear_model_spec<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::query_rephraser_spec::ModelSpec>
            {
                self.model_spec = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for QueryRephraserSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec"
            }
        }

        /// Defines additional types related to [QueryRephraserSpec].
        pub mod query_rephraser_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Query Rephraser Model specification.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ModelSpec {

                /// Optional. Enabled query rephraser model type. If not set, it will use
                /// LARGE by default.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub model_type: crate::model::answer_query_request::query_understanding_spec::query_rephraser_spec::model_spec::ModelType,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ModelSpec {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [model_type][crate::model::answer_query_request::query_understanding_spec::query_rephraser_spec::ModelSpec::model_type].
                pub fn set_model_type<T: std::convert::Into<crate::model::answer_query_request::query_understanding_spec::query_rephraser_spec::model_spec::ModelType>>(mut self, v: T) -> Self{
                    self.model_type = v.into();
                    self
                }
            }

            impl wkt::message::Message for ModelSpec {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.ModelSpec"
                }
            }

            /// Defines additional types related to [ModelSpec].
            pub mod model_spec {
                #[allow(unused_imports)]
                use super::*;

                /// Query rephraser types. Currently only supports single-hop
                /// (max_rephrase_steps = 1) model selections. For multi-hop
                /// (max_rephrase_steps > 1), there is only one default model.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum ModelType {
                    /// Unspecified model type.
                    Unspecified,
                    /// Small query rephraser model. Gemini 1.0 XS model.
                    Small,
                    /// Large query rephraser model. Gemini 1.0 Pro model.
                    Large,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [ModelType::value] or
                    /// [ModelType::name].
                    UnknownValue(model_type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod model_type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl ModelType {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Small => std::option::Option::Some(1),
                            Self::Large => std::option::Option::Some(2),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("MODEL_TYPE_UNSPECIFIED")
                            }
                            Self::Small => std::option::Option::Some("SMALL"),
                            Self::Large => std::option::Option::Some("LARGE"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for ModelType {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for ModelType {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for ModelType {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Small,
                            2 => Self::Large,
                            _ => Self::UnknownValue(model_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for ModelType {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                            "SMALL" => Self::Small,
                            "LARGE" => Self::Large,
                            _ => Self::UnknownValue(model_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for ModelType {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Small => serializer.serialize_i32(1),
                            Self::Large => serializer.serialize_i32(2),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for ModelType {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                            ".google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.ModelSpec.ModelType"))
                    }
                }
            }
        }
    }

    /// End user specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EndUserSpec {
        /// Optional. End user metadata.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub end_user_metadata:
            std::vec::Vec<crate::model::answer_query_request::end_user_spec::EndUserMetaData>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EndUserSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [end_user_metadata][crate::model::answer_query_request::EndUserSpec::end_user_metadata].
        pub fn set_end_user_metadata<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::answer_query_request::end_user_spec::EndUserMetaData,
                >,
        {
            use std::iter::Iterator;
            self.end_user_metadata = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for EndUserSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.EndUserSpec"
        }
    }

    /// Defines additional types related to [EndUserSpec].
    pub mod end_user_spec {
        #[allow(unused_imports)]
        use super::*;

        /// End user metadata.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct EndUserMetaData {
            /// Search result content.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub content: std::option::Option<
                crate::model::answer_query_request::end_user_spec::end_user_meta_data::Content,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EndUserMetaData {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [content][crate::model::answer_query_request::end_user_spec::EndUserMetaData::content].
            ///
            /// Note that all the setters affecting `content` are mutually
            /// exclusive.
            pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::answer_query_request::end_user_spec::end_user_meta_data::Content>>>(mut self, v: T) -> Self
            {
                self.content = v.into();
                self
            }

            /// The value of [content][crate::model::answer_query_request::end_user_spec::EndUserMetaData::content]
            /// if it holds a `ChunkInfo`, `None` if the field is not set or
            /// holds a different branch.
            pub fn chunk_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::answer_query_request::end_user_spec::end_user_meta_data::ChunkInfo>>{
                #[allow(unreachable_patterns)]
                self.content.as_ref().and_then(|v| match v {
                    crate::model::answer_query_request::end_user_spec::end_user_meta_data::Content::ChunkInfo(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [content][crate::model::answer_query_request::end_user_spec::EndUserMetaData::content]
            /// to hold a `ChunkInfo`.
            ///
            /// Note that all the setters affecting `content` are
            /// mutually exclusive.
            pub fn set_chunk_info<T: std::convert::Into<std::boxed::Box<crate::model::answer_query_request::end_user_spec::end_user_meta_data::ChunkInfo>>>(mut self, v: T) -> Self{
                self.content = std::option::Option::Some(
                    crate::model::answer_query_request::end_user_spec::end_user_meta_data::Content::ChunkInfo(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for EndUserMetaData {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.EndUserSpec.EndUserMetaData"
            }
        }

        /// Defines additional types related to [EndUserMetaData].
        pub mod end_user_meta_data {
            #[allow(unused_imports)]
            use super::*;

            /// Chunk information.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ChunkInfo {

                /// Chunk textual content. It is limited to 8000 characters.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub content: std::string::String,

                /// Metadata of the document from the current chunk.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub document_metadata: std::option::Option<crate::model::answer_query_request::end_user_spec::end_user_meta_data::chunk_info::DocumentMetadata>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ChunkInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [content][crate::model::answer_query_request::end_user_spec::end_user_meta_data::ChunkInfo::content].
                pub fn set_content<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.content = v.into();
                    self
                }

                /// Sets the value of [document_metadata][crate::model::answer_query_request::end_user_spec::end_user_meta_data::ChunkInfo::document_metadata].
                pub fn set_document_metadata<T>(mut self, v: T) -> Self
                where T: std::convert::Into<crate::model::answer_query_request::end_user_spec::end_user_meta_data::chunk_info::DocumentMetadata>
                {
                    self.document_metadata = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [document_metadata][crate::model::answer_query_request::end_user_spec::end_user_meta_data::ChunkInfo::document_metadata].
                pub fn set_or_clear_document_metadata<T>(mut self, v: std::option::Option<T>) -> Self
                where T: std::convert::Into<crate::model::answer_query_request::end_user_spec::end_user_meta_data::chunk_info::DocumentMetadata>
                {
                    self.document_metadata = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ChunkInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.EndUserSpec.EndUserMetaData.ChunkInfo"
                }
            }

            /// Defines additional types related to [ChunkInfo].
            pub mod chunk_info {
                #[allow(unused_imports)]
                use super::*;

                /// Document metadata contains the information of the document of
                /// the current chunk.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct DocumentMetadata {
                    /// Title of the document.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub title: std::string::String,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl DocumentMetadata {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [title][crate::model::answer_query_request::end_user_spec::end_user_meta_data::chunk_info::DocumentMetadata::title].
                    pub fn set_title<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.title = v.into();
                        self
                    }
                }

                impl wkt::message::Message for DocumentMetadata {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryRequest.EndUserSpec.EndUserMetaData.ChunkInfo.DocumentMetadata"
                    }
                }
            }

            /// Search result content.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Content {
                /// Chunk information.
                ChunkInfo(std::boxed::Box<crate::model::answer_query_request::end_user_spec::end_user_meta_data::ChunkInfo>),
            }
        }
    }
}

/// Response message for
/// [ConversationalSearchService.AnswerQuery][google.cloud.discoveryengine.v1.ConversationalSearchService.AnswerQuery]
/// method.
///
/// [google.cloud.discoveryengine.v1.ConversationalSearchService.AnswerQuery]: crate::client::ConversationalSearchService::answer_query
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnswerQueryResponse {
    /// Answer resource object.
    /// If
    /// [AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.max_rephrase_steps][google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.max_rephrase_steps]
    /// is greater than 1, use
    /// [Answer.name][google.cloud.discoveryengine.v1.Answer.name] to fetch answer
    /// information using
    /// [ConversationalSearchService.GetAnswer][google.cloud.discoveryengine.v1.ConversationalSearchService.GetAnswer]
    /// API.
    ///
    /// [google.cloud.discoveryengine.v1.Answer.name]: crate::model::Answer::name
    /// [google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.max_rephrase_steps]: crate::model::answer_query_request::query_understanding_spec::QueryRephraserSpec::max_rephrase_steps
    /// [google.cloud.discoveryengine.v1.ConversationalSearchService.GetAnswer]: crate::client::ConversationalSearchService::get_answer
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub answer: std::option::Option<crate::model::Answer>,

    /// Session resource object.
    /// It will be only available when session field is set and valid in the
    /// [AnswerQueryRequest][google.cloud.discoveryengine.v1.AnswerQueryRequest]
    /// request.
    ///
    /// [google.cloud.discoveryengine.v1.AnswerQueryRequest]: crate::model::AnswerQueryRequest
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session: std::option::Option<crate::model::Session>,

    /// A global unique ID used for logging.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub answer_query_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnswerQueryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer][crate::model::AnswerQueryResponse::answer].
    pub fn set_answer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Answer>,
    {
        self.answer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer][crate::model::AnswerQueryResponse::answer].
    pub fn set_or_clear_answer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Answer>,
    {
        self.answer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session][crate::model::AnswerQueryResponse::session].
    pub fn set_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session][crate::model::AnswerQueryResponse::session].
    pub fn set_or_clear_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = v.map(|x| x.into());
        self
    }

    /// Sets the value of [answer_query_token][crate::model::AnswerQueryResponse::answer_query_token].
    pub fn set_answer_query_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.answer_query_token = v.into();
        self
    }
}

impl wkt::message::Message for AnswerQueryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.AnswerQueryResponse"
    }
}

/// Request for GetAnswer method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAnswerRequest {
    /// Required. The resource name of the Answer to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine_id}/sessions/{session_id}/answers/{answer_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAnswerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAnswerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAnswerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetAnswerRequest"
    }
}

/// Request for CreateSession method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSessionRequest {
    /// Required. Full resource name of parent data store. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The session to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session: std::option::Option<crate::model::Session>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_or_clear_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateSessionRequest"
    }
}

/// Request for UpdateSession method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSessionRequest {
    /// Required. The Session to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session: std::option::Option<crate::model::Session>,

    /// Indicates which fields in the provided
    /// [Session][google.cloud.discoveryengine.v1.Session] to update. The following
    /// are NOT supported:
    ///
    /// * [Session.name][google.cloud.discoveryengine.v1.Session.name]
    ///
    /// If not set or empty, all supported fields are updated.
    ///
    /// [google.cloud.discoveryengine.v1.Session]: crate::model::Session
    /// [google.cloud.discoveryengine.v1.Session.name]: crate::model::Session::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::UpdateSessionRequest::session].
    pub fn set_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session][crate::model::UpdateSessionRequest::session].
    pub fn set_or_clear_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSessionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSessionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateSessionRequest"
    }
}

/// Request for DeleteSession method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSessionRequest {
    /// Required. The resource name of the Session to delete. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteSessionRequest"
    }
}

/// Request for GetSession method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSessionRequest {
    /// Required. The resource name of the Session to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set to true, the full session including all answer details
    /// will be returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub include_answer_details: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [include_answer_details][crate::model::GetSessionRequest::include_answer_details].
    pub fn set_include_answer_details<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_answer_details = v.into();
        self
    }
}

impl wkt::message::Message for GetSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetSessionRequest"
    }
}

/// Request for ListSessions method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsRequest {
    /// Required. The data store resource name. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListSessions` call.
    /// Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter to apply on the list results. The supported features are:
    /// user_pseudo_id, state.
    ///
    /// Example:
    /// "user_pseudo_id = some_id"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `update_time`
    /// * `create_time`
    /// * `session_name`
    /// * `is_pinned`
    ///
    /// Example:
    ///
    /// * "update_time desc"
    /// * "create_time"
    /// * "is_pinned desc,update_time desc": list sessions by is_pinned first, then
    ///   by update_time.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSessionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSessionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListSessionsRequest"
    }
}

/// Response for ListSessions method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsResponse {
    /// All the Sessions for a given data store.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sessions: std::vec::Vec<crate::model::Session>,

    /// Pagination token, if not returned indicates the last page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sessions][crate::model::ListSessionsResponse::sessions].
    pub fn set_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Session>,
    {
        use std::iter::Iterator;
        self.sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionsResponse {
    type PageItem = crate::model::Session;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Metadata that describes a custom tuned model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomTuningModel {
    /// Required. The fully qualified resource name of the model.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/customTuningModels/{custom_tuning_model}`.
    ///
    /// Model must be an alpha-numerical string with limit of 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display name of the model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The version of the model.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub model_version: i64,

    /// The state that the model is in (e.g.`TRAINING` or `TRAINING_FAILED`).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub model_state: crate::model::custom_tuning_model::ModelState,

    /// Deprecated: Timestamp the Model was created at.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Timestamp the model training was initiated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub training_start_time: std::option::Option<wkt::Timestamp>,

    /// The metrics of the trained model.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, wkt::internal::F64>")]
    pub metrics: std::collections::HashMap<std::string::String, f64>,

    /// Currently this is only populated if the model state is
    /// `INPUT_VALIDATION_FAILED`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomTuningModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomTuningModel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomTuningModel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model_version][crate::model::CustomTuningModel::model_version].
    pub fn set_model_version<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.model_version = v.into();
        self
    }

    /// Sets the value of [model_state][crate::model::CustomTuningModel::model_state].
    pub fn set_model_state<T: std::convert::Into<crate::model::custom_tuning_model::ModelState>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CustomTuningModel::create_time].
    #[deprecated]
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CustomTuningModel::create_time].
    #[deprecated]
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [training_start_time][crate::model::CustomTuningModel::training_start_time].
    pub fn set_training_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.training_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [training_start_time][crate::model::CustomTuningModel::training_start_time].
    pub fn set_or_clear_training_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.training_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metrics][crate::model::CustomTuningModel::metrics].
    pub fn set_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [error_message][crate::model::CustomTuningModel::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }
}

impl wkt::message::Message for CustomTuningModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CustomTuningModel"
    }
}

/// Defines additional types related to [CustomTuningModel].
pub mod custom_tuning_model {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelState {
        /// Default value.
        Unspecified,
        /// The model is in a paused training state.
        TrainingPaused,
        /// The model is currently training.
        Training,
        /// The model has successfully completed training.
        TrainingComplete,
        /// The model is ready for serving.
        ReadyForServing,
        /// The model training failed.
        TrainingFailed,
        /// The model training finished successfully but metrics did not improve.
        NoImprovement,
        /// Input data validation failed. Model training didn't start.
        InputValidationFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelState::value] or
        /// [ModelState::name].
        UnknownValue(model_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod model_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ModelState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TrainingPaused => std::option::Option::Some(1),
                Self::Training => std::option::Option::Some(2),
                Self::TrainingComplete => std::option::Option::Some(3),
                Self::ReadyForServing => std::option::Option::Some(4),
                Self::TrainingFailed => std::option::Option::Some(5),
                Self::NoImprovement => std::option::Option::Some(6),
                Self::InputValidationFailed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_STATE_UNSPECIFIED"),
                Self::TrainingPaused => std::option::Option::Some("TRAINING_PAUSED"),
                Self::Training => std::option::Option::Some("TRAINING"),
                Self::TrainingComplete => std::option::Option::Some("TRAINING_COMPLETE"),
                Self::ReadyForServing => std::option::Option::Some("READY_FOR_SERVING"),
                Self::TrainingFailed => std::option::Option::Some("TRAINING_FAILED"),
                Self::NoImprovement => std::option::Option::Some("NO_IMPROVEMENT"),
                Self::InputValidationFailed => std::option::Option::Some("INPUT_VALIDATION_FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ModelState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ModelState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ModelState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TrainingPaused,
                2 => Self::Training,
                3 => Self::TrainingComplete,
                4 => Self::ReadyForServing,
                5 => Self::TrainingFailed,
                6 => Self::NoImprovement,
                7 => Self::InputValidationFailed,
                _ => Self::UnknownValue(model_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ModelState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_STATE_UNSPECIFIED" => Self::Unspecified,
                "TRAINING_PAUSED" => Self::TrainingPaused,
                "TRAINING" => Self::Training,
                "TRAINING_COMPLETE" => Self::TrainingComplete,
                "READY_FOR_SERVING" => Self::ReadyForServing,
                "TRAINING_FAILED" => Self::TrainingFailed,
                "NO_IMPROVEMENT" => Self::NoImprovement,
                "INPUT_VALIDATION_FAILED" => Self::InputValidationFailed,
                _ => Self::UnknownValue(model_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ModelState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TrainingPaused => serializer.serialize_i32(1),
                Self::Training => serializer.serialize_i32(2),
                Self::TrainingComplete => serializer.serialize_i32(3),
                Self::ReadyForServing => serializer.serialize_i32(4),
                Self::TrainingFailed => serializer.serialize_i32(5),
                Self::NoImprovement => serializer.serialize_i32(6),
                Self::InputValidationFailed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ModelState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelState>::new(
                ".google.cloud.discoveryengine.v1.CustomTuningModel.ModelState",
            ))
        }
    }
}

/// DataStore captures global settings and configs at the DataStore level.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataStore {
    /// Immutable. The full resource name of the data store.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The data store display name.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Immutable. The industry vertical that the data store registers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub industry_vertical: crate::model::IndustryVertical,

    /// The solutions that the data store enrolls. Available solutions for each
    /// [industry_vertical][google.cloud.discoveryengine.v1.DataStore.industry_vertical]:
    ///
    /// * `MEDIA`: `SOLUTION_TYPE_RECOMMENDATION` and `SOLUTION_TYPE_SEARCH`.
    /// * `SITE_SEARCH`: `SOLUTION_TYPE_SEARCH` is automatically enrolled. Other
    ///   solutions cannot be enrolled.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore.industry_vertical]: crate::model::DataStore::industry_vertical
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub solution_types: std::vec::Vec<crate::model::SolutionType>,

    /// Output only. The id of the default
    /// [Schema][google.cloud.discoveryengine.v1.Schema] associated to this data
    /// store.
    ///
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_schema_id: std::string::String,

    /// Immutable. The content config of the data store. If this field is unset,
    /// the server behavior defaults to
    /// [ContentConfig.NO_CONTENT][google.cloud.discoveryengine.v1.DataStore.ContentConfig.NO_CONTENT].
    ///
    /// [google.cloud.discoveryengine.v1.DataStore.ContentConfig.NO_CONTENT]: crate::model::data_store::ContentConfig::NoContent
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub content_config: crate::model::data_store::ContentConfig,

    /// Output only. Timestamp the
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore] was created at.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Configuration for advanced site search.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub advanced_site_search_config: std::option::Option<crate::model::AdvancedSiteSearchConfig>,

    /// Output only. Data size estimation for billing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub billing_estimation: std::option::Option<crate::model::data_store::BillingEstimation>,

    /// Config to store data store type configuration for workspace data. This
    /// must be set when
    /// [DataStore.content_config][google.cloud.discoveryengine.v1.DataStore.content_config]
    /// is set as
    /// [DataStore.ContentConfig.GOOGLE_WORKSPACE][google.cloud.discoveryengine.v1.DataStore.ContentConfig.GOOGLE_WORKSPACE].
    ///
    /// [google.cloud.discoveryengine.v1.DataStore.ContentConfig.GOOGLE_WORKSPACE]: crate::model::data_store::ContentConfig::GoogleWorkspace
    /// [google.cloud.discoveryengine.v1.DataStore.content_config]: crate::model::DataStore::content_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workspace_config: std::option::Option<crate::model::WorkspaceConfig>,

    /// Configuration for Document understanding and enrichment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document_processing_config: std::option::Option<crate::model::DocumentProcessingConfig>,

    /// The start schema to use for this
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore] when provisioning
    /// it. If unset, a default vertical specialized schema will be used.
    ///
    /// This field is only used by
    /// [CreateDataStore][google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore]
    /// API, and will be ignored if used in other APIs. This field will be omitted
    /// from all API responses including
    /// [CreateDataStore][google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore]
    /// API. To retrieve a schema of a
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], use
    /// [SchemaService.GetSchema][google.cloud.discoveryengine.v1.SchemaService.GetSchema]
    /// API instead.
    ///
    /// The provided schema will be validated against certain rules on schema.
    /// Learn more from [this
    /// doc](https://cloud.google.com/generative-ai-app-builder/docs/provide-schema).
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    /// [google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore]: crate::client::DataStoreService::create_data_store
    /// [google.cloud.discoveryengine.v1.SchemaService.GetSchema]: crate::client::SchemaService::get_schema
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub starting_schema: std::option::Option<crate::model::Schema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataStore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataStore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataStore::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [industry_vertical][crate::model::DataStore::industry_vertical].
    pub fn set_industry_vertical<T: std::convert::Into<crate::model::IndustryVertical>>(
        mut self,
        v: T,
    ) -> Self {
        self.industry_vertical = v.into();
        self
    }

    /// Sets the value of [solution_types][crate::model::DataStore::solution_types].
    pub fn set_solution_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SolutionType>,
    {
        use std::iter::Iterator;
        self.solution_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_schema_id][crate::model::DataStore::default_schema_id].
    pub fn set_default_schema_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_schema_id = v.into();
        self
    }

    /// Sets the value of [content_config][crate::model::DataStore::content_config].
    pub fn set_content_config<T: std::convert::Into<crate::model::data_store::ContentConfig>>(
        mut self,
        v: T,
    ) -> Self {
        self.content_config = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataStore::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DataStore::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advanced_site_search_config][crate::model::DataStore::advanced_site_search_config].
    pub fn set_advanced_site_search_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSiteSearchConfig>,
    {
        self.advanced_site_search_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_site_search_config][crate::model::DataStore::advanced_site_search_config].
    pub fn set_or_clear_advanced_site_search_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSiteSearchConfig>,
    {
        self.advanced_site_search_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [billing_estimation][crate::model::DataStore::billing_estimation].
    pub fn set_billing_estimation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_store::BillingEstimation>,
    {
        self.billing_estimation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [billing_estimation][crate::model::DataStore::billing_estimation].
    pub fn set_or_clear_billing_estimation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_store::BillingEstimation>,
    {
        self.billing_estimation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workspace_config][crate::model::DataStore::workspace_config].
    pub fn set_workspace_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkspaceConfig>,
    {
        self.workspace_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workspace_config][crate::model::DataStore::workspace_config].
    pub fn set_or_clear_workspace_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkspaceConfig>,
    {
        self.workspace_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_processing_config][crate::model::DataStore::document_processing_config].
    pub fn set_document_processing_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentProcessingConfig>,
    {
        self.document_processing_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_processing_config][crate::model::DataStore::document_processing_config].
    pub fn set_or_clear_document_processing_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentProcessingConfig>,
    {
        self.document_processing_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [starting_schema][crate::model::DataStore::starting_schema].
    pub fn set_starting_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.starting_schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [starting_schema][crate::model::DataStore::starting_schema].
    pub fn set_or_clear_starting_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.starting_schema = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DataStore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DataStore"
    }
}

/// Defines additional types related to [DataStore].
pub mod data_store {
    #[allow(unused_imports)]
    use super::*;

    /// Estimation of data size per data store.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BillingEstimation {
        /// Data size for structured data in terms of bytes.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub structured_data_size: i64,

        /// Data size for unstructured data in terms of bytes.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub unstructured_data_size: i64,

        /// Data size for websites in terms of bytes.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub website_data_size: i64,

        /// Last updated timestamp for structured data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub structured_data_update_time: std::option::Option<wkt::Timestamp>,

        /// Last updated timestamp for unstructured data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub unstructured_data_update_time: std::option::Option<wkt::Timestamp>,

        /// Last updated timestamp for websites.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub website_data_update_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BillingEstimation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [structured_data_size][crate::model::data_store::BillingEstimation::structured_data_size].
        pub fn set_structured_data_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.structured_data_size = v.into();
            self
        }

        /// Sets the value of [unstructured_data_size][crate::model::data_store::BillingEstimation::unstructured_data_size].
        pub fn set_unstructured_data_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.unstructured_data_size = v.into();
            self
        }

        /// Sets the value of [website_data_size][crate::model::data_store::BillingEstimation::website_data_size].
        pub fn set_website_data_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.website_data_size = v.into();
            self
        }

        /// Sets the value of [structured_data_update_time][crate::model::data_store::BillingEstimation::structured_data_update_time].
        pub fn set_structured_data_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.structured_data_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [structured_data_update_time][crate::model::data_store::BillingEstimation::structured_data_update_time].
        pub fn set_or_clear_structured_data_update_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.structured_data_update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [unstructured_data_update_time][crate::model::data_store::BillingEstimation::unstructured_data_update_time].
        pub fn set_unstructured_data_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.unstructured_data_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [unstructured_data_update_time][crate::model::data_store::BillingEstimation::unstructured_data_update_time].
        pub fn set_or_clear_unstructured_data_update_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.unstructured_data_update_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [website_data_update_time][crate::model::data_store::BillingEstimation::website_data_update_time].
        pub fn set_website_data_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.website_data_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [website_data_update_time][crate::model::data_store::BillingEstimation::website_data_update_time].
        pub fn set_or_clear_website_data_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.website_data_update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for BillingEstimation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.DataStore.BillingEstimation"
        }
    }

    /// Content config of the data store.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContentConfig {
        /// Default value.
        Unspecified,
        /// Only contains documents without any
        /// [Document.content][google.cloud.discoveryengine.v1.Document.content].
        ///
        /// [google.cloud.discoveryengine.v1.Document.content]: crate::model::Document::content
        NoContent,
        /// Only contains documents with
        /// [Document.content][google.cloud.discoveryengine.v1.Document.content].
        ///
        /// [google.cloud.discoveryengine.v1.Document.content]: crate::model::Document::content
        ContentRequired,
        /// The data store is used for public website search.
        PublicWebsite,
        /// The data store is used for workspace search. Details of workspace
        /// data store are specified in the
        /// [WorkspaceConfig][google.cloud.discoveryengine.v1.WorkspaceConfig].
        ///
        /// [google.cloud.discoveryengine.v1.WorkspaceConfig]: crate::model::WorkspaceConfig
        GoogleWorkspace,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContentConfig::value] or
        /// [ContentConfig::name].
        UnknownValue(content_config::UnknownValue),
    }

    #[doc(hidden)]
    pub mod content_config {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContentConfig {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoContent => std::option::Option::Some(1),
                Self::ContentRequired => std::option::Option::Some(2),
                Self::PublicWebsite => std::option::Option::Some(3),
                Self::GoogleWorkspace => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTENT_CONFIG_UNSPECIFIED"),
                Self::NoContent => std::option::Option::Some("NO_CONTENT"),
                Self::ContentRequired => std::option::Option::Some("CONTENT_REQUIRED"),
                Self::PublicWebsite => std::option::Option::Some("PUBLIC_WEBSITE"),
                Self::GoogleWorkspace => std::option::Option::Some("GOOGLE_WORKSPACE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContentConfig {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContentConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContentConfig {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoContent,
                2 => Self::ContentRequired,
                3 => Self::PublicWebsite,
                4 => Self::GoogleWorkspace,
                _ => Self::UnknownValue(content_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContentConfig {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTENT_CONFIG_UNSPECIFIED" => Self::Unspecified,
                "NO_CONTENT" => Self::NoContent,
                "CONTENT_REQUIRED" => Self::ContentRequired,
                "PUBLIC_WEBSITE" => Self::PublicWebsite,
                "GOOGLE_WORKSPACE" => Self::GoogleWorkspace,
                _ => Self::UnknownValue(content_config::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContentConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoContent => serializer.serialize_i32(1),
                Self::ContentRequired => serializer.serialize_i32(2),
                Self::PublicWebsite => serializer.serialize_i32(3),
                Self::GoogleWorkspace => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContentConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentConfig>::new(
                ".google.cloud.discoveryengine.v1.DataStore.ContentConfig",
            ))
        }
    }
}

/// Configuration data for advance site search.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdvancedSiteSearchConfig {
    /// If set true, initial indexing is disabled for the DataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disable_initial_index: std::option::Option<bool>,

    /// If set true, automatic refresh is disabled for the DataStore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disable_automatic_refresh: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedSiteSearchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable_initial_index][crate::model::AdvancedSiteSearchConfig::disable_initial_index].
    pub fn set_disable_initial_index<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disable_initial_index = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disable_initial_index][crate::model::AdvancedSiteSearchConfig::disable_initial_index].
    pub fn set_or_clear_disable_initial_index<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disable_initial_index = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disable_automatic_refresh][crate::model::AdvancedSiteSearchConfig::disable_automatic_refresh].
    pub fn set_disable_automatic_refresh<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disable_automatic_refresh = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disable_automatic_refresh][crate::model::AdvancedSiteSearchConfig::disable_automatic_refresh].
    pub fn set_or_clear_disable_automatic_refresh<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disable_automatic_refresh = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdvancedSiteSearchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.AdvancedSiteSearchConfig"
    }
}

/// Config to store data store type configuration for workspace data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkspaceConfig {
    /// The Google Workspace data source.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::workspace_config::Type,

    /// Obfuscated Dasher customer ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dasher_customer_id: std::string::String,

    /// Optional. The super admin service account for the workspace that will be
    /// used for access token generation. For now we only use it for Native Google
    /// Drive connector data ingestion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub super_admin_service_account: std::string::String,

    /// Optional. The super admin email address for the workspace that will be used
    /// for access token generation. For now we only use it for Native Google Drive
    /// connector data ingestion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub super_admin_email_address: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkspaceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::WorkspaceConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::workspace_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [dasher_customer_id][crate::model::WorkspaceConfig::dasher_customer_id].
    pub fn set_dasher_customer_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dasher_customer_id = v.into();
        self
    }

    /// Sets the value of [super_admin_service_account][crate::model::WorkspaceConfig::super_admin_service_account].
    pub fn set_super_admin_service_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.super_admin_service_account = v.into();
        self
    }

    /// Sets the value of [super_admin_email_address][crate::model::WorkspaceConfig::super_admin_email_address].
    pub fn set_super_admin_email_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.super_admin_email_address = v.into();
        self
    }
}

impl wkt::message::Message for WorkspaceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.WorkspaceConfig"
    }
}

/// Defines additional types related to [WorkspaceConfig].
pub mod workspace_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the type of Workspace App supported by this DataStore
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Defaults to an unspecified Workspace type.
        Unspecified,
        /// Workspace Data Store contains Drive data
        GoogleDrive,
        /// Workspace Data Store contains Mail data
        GoogleMail,
        /// Workspace Data Store contains Sites data
        GoogleSites,
        /// Workspace Data Store contains Calendar data
        GoogleCalendar,
        /// Workspace Data Store contains Chat data
        GoogleChat,
        /// Workspace Data Store contains Groups data
        GoogleGroups,
        /// Workspace Data Store contains Keep data
        GoogleKeep,
        /// Workspace Data Store contains People data
        GooglePeople,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleDrive => std::option::Option::Some(1),
                Self::GoogleMail => std::option::Option::Some(2),
                Self::GoogleSites => std::option::Option::Some(3),
                Self::GoogleCalendar => std::option::Option::Some(4),
                Self::GoogleChat => std::option::Option::Some(5),
                Self::GoogleGroups => std::option::Option::Some(6),
                Self::GoogleKeep => std::option::Option::Some(7),
                Self::GooglePeople => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::GoogleDrive => std::option::Option::Some("GOOGLE_DRIVE"),
                Self::GoogleMail => std::option::Option::Some("GOOGLE_MAIL"),
                Self::GoogleSites => std::option::Option::Some("GOOGLE_SITES"),
                Self::GoogleCalendar => std::option::Option::Some("GOOGLE_CALENDAR"),
                Self::GoogleChat => std::option::Option::Some("GOOGLE_CHAT"),
                Self::GoogleGroups => std::option::Option::Some("GOOGLE_GROUPS"),
                Self::GoogleKeep => std::option::Option::Some("GOOGLE_KEEP"),
                Self::GooglePeople => std::option::Option::Some("GOOGLE_PEOPLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleDrive,
                2 => Self::GoogleMail,
                3 => Self::GoogleSites,
                4 => Self::GoogleCalendar,
                5 => Self::GoogleChat,
                6 => Self::GoogleGroups,
                7 => Self::GoogleKeep,
                8 => Self::GooglePeople,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_DRIVE" => Self::GoogleDrive,
                "GOOGLE_MAIL" => Self::GoogleMail,
                "GOOGLE_SITES" => Self::GoogleSites,
                "GOOGLE_CALENDAR" => Self::GoogleCalendar,
                "GOOGLE_CHAT" => Self::GoogleChat,
                "GOOGLE_GROUPS" => Self::GoogleGroups,
                "GOOGLE_KEEP" => Self::GoogleKeep,
                "GOOGLE_PEOPLE" => Self::GooglePeople,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleDrive => serializer.serialize_i32(1),
                Self::GoogleMail => serializer.serialize_i32(2),
                Self::GoogleSites => serializer.serialize_i32(3),
                Self::GoogleCalendar => serializer.serialize_i32(4),
                Self::GoogleChat => serializer.serialize_i32(5),
                Self::GoogleGroups => serializer.serialize_i32(6),
                Self::GoogleKeep => serializer.serialize_i32(7),
                Self::GooglePeople => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.discoveryengine.v1.WorkspaceConfig.Type",
            ))
        }
    }
}

/// Request for
/// [DataStoreService.CreateDataStore][google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore]
/// method.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore]: crate::client::DataStoreService::create_data_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataStoreRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The [DataStore][google.cloud.discoveryengine.v1.DataStore] to
    /// create.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_store: std::option::Option<crate::model::DataStore>,

    /// Required. The ID to use for the
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], which will become
    /// the final component of the
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore]'s resource name.
    ///
    /// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
    /// standard with a length limit of 63 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_store_id: std::string::String,

    /// A boolean flag indicating whether user want to directly create an advanced
    /// data store for site search.
    /// If the data store is not configured as site
    /// search (GENERIC vertical and PUBLIC_WEBSITE content_config), this flag will
    /// be ignored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub create_advanced_site_search: bool,

    /// A boolean flag indicating whether to skip the default schema creation for
    /// the data store. Only enable this flag if you are certain that the default
    /// schema is incompatible with your use case.
    ///
    /// If set to true, you must manually create a schema for the data store before
    /// any documents can be ingested.
    ///
    /// This flag cannot be specified if `data_store.starting_schema` is specified.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_default_schema_creation: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataStoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_store][crate::model::CreateDataStoreRequest::data_store].
    pub fn set_data_store<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataStore>,
    {
        self.data_store = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_store][crate::model::CreateDataStoreRequest::data_store].
    pub fn set_or_clear_data_store<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataStore>,
    {
        self.data_store = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_store_id][crate::model::CreateDataStoreRequest::data_store_id].
    pub fn set_data_store_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_store_id = v.into();
        self
    }

    /// Sets the value of [create_advanced_site_search][crate::model::CreateDataStoreRequest::create_advanced_site_search].
    pub fn set_create_advanced_site_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.create_advanced_site_search = v.into();
        self
    }

    /// Sets the value of [skip_default_schema_creation][crate::model::CreateDataStoreRequest::skip_default_schema_creation].
    pub fn set_skip_default_schema_creation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_default_schema_creation = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateDataStoreRequest"
    }
}

/// Request message for
/// [DataStoreService.GetDataStore][google.cloud.discoveryengine.v1.DataStoreService.GetDataStore]
/// method.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.GetDataStore]: crate::client::DataStoreService::get_data_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataStoreRequest {
    /// Required. Full resource name of
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// If the caller does not have permission to access the
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested [DataStore][google.cloud.discoveryengine.v1.DataStore]
    /// does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetDataStoreRequest"
    }
}

/// Metadata related to the progress of the
/// [DataStoreService.CreateDataStore][google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore]: crate::client::DataStoreService::create_data_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataStoreMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataStoreMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateDataStoreMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateDataStoreMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CreateDataStoreMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CreateDataStoreMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateDataStoreMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateDataStoreMetadata"
    }
}

/// Request message for
/// [DataStoreService.ListDataStores][google.cloud.discoveryengine.v1.DataStoreService.ListDataStores]
/// method.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.ListDataStores]: crate::client::DataStoreService::list_data_stores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataStoresRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}`.
    ///
    /// If the caller does not have permission to list
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore]s under this
    /// location, regardless of whether or not this data store exists, a
    /// PERMISSION_DENIED error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of [DataStore][google.cloud.discoveryengine.v1.DataStore]s
    /// to return. If unspecified, defaults to 10. The maximum allowed value is 50.
    /// Values above 50 will be coerced to 50.
    ///
    /// If this field is negative, an INVALID_ARGUMENT is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token
    /// [ListDataStoresResponse.next_page_token][google.cloud.discoveryengine.v1.ListDataStoresResponse.next_page_token],
    /// received from a previous
    /// [DataStoreService.ListDataStores][google.cloud.discoveryengine.v1.DataStoreService.ListDataStores]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [DataStoreService.ListDataStores][google.cloud.discoveryengine.v1.DataStoreService.ListDataStores]
    /// must match the call that provided the page token. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStoreService.ListDataStores]: crate::client::DataStoreService::list_data_stores
    /// [google.cloud.discoveryengine.v1.ListDataStoresResponse.next_page_token]: crate::model::ListDataStoresResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter by solution type .
    /// For example: `filter = 'solution_type:SOLUTION_TYPE_SEARCH'`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataStoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataStoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataStoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataStoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataStoresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDataStoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListDataStoresRequest"
    }
}

/// Response message for
/// [DataStoreService.ListDataStores][google.cloud.discoveryengine.v1.DataStoreService.ListDataStores]
/// method.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.ListDataStores]: crate::client::DataStoreService::list_data_stores
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataStoresResponse {
    /// All the customer's [DataStore][google.cloud.discoveryengine.v1.DataStore]s.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_stores: std::vec::Vec<crate::model::DataStore>,

    /// A token that can be sent as
    /// [ListDataStoresRequest.page_token][google.cloud.discoveryengine.v1.ListDataStoresRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.discoveryengine.v1.ListDataStoresRequest.page_token]: crate::model::ListDataStoresRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataStoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_stores][crate::model::ListDataStoresResponse::data_stores].
    pub fn set_data_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataStore>,
    {
        use std::iter::Iterator;
        self.data_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataStoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataStoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListDataStoresResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataStoresResponse {
    type PageItem = crate::model::DataStore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_stores
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DataStoreService.DeleteDataStore][google.cloud.discoveryengine.v1.DataStoreService.DeleteDataStore]
/// method.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.DeleteDataStore]: crate::client::DataStoreService::delete_data_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataStoreRequest {
    /// Required. Full resource name of
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// If the caller does not have permission to delete the
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [DataStore][google.cloud.discoveryengine.v1.DataStore] to delete
    /// does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataStoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteDataStoreRequest"
    }
}

/// Request message for
/// [DataStoreService.UpdateDataStore][google.cloud.discoveryengine.v1.DataStoreService.UpdateDataStore]
/// method.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.UpdateDataStore]: crate::client::DataStoreService::update_data_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDataStoreRequest {
    /// Required. The [DataStore][google.cloud.discoveryengine.v1.DataStore] to
    /// update.
    ///
    /// If the caller does not have permission to update the
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [DataStore][google.cloud.discoveryengine.v1.DataStore] to update
    /// does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_store: std::option::Option<crate::model::DataStore>,

    /// Indicates which fields in the provided
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore] to update.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataStoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_store][crate::model::UpdateDataStoreRequest::data_store].
    pub fn set_data_store<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataStore>,
    {
        self.data_store = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_store][crate::model::UpdateDataStoreRequest::data_store].
    pub fn set_or_clear_data_store<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataStore>,
    {
        self.data_store = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataStoreRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDataStoreRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDataStoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateDataStoreRequest"
    }
}

/// Metadata related to the progress of the
/// [DataStoreService.DeleteDataStore][google.cloud.discoveryengine.v1.DataStoreService.DeleteDataStore]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.DataStoreService.DeleteDataStore]: crate::client::DataStoreService::delete_data_store
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataStoreMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataStoreMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeleteDataStoreMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteDataStoreMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteDataStoreMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeleteDataStoreMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteDataStoreMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteDataStoreMetadata"
    }
}

/// Document captures all raw metadata information of items to be recommended or
/// searched.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Document {
    /// Immutable. The full resource name of the document.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. The identifier of the document.
    ///
    /// Id should conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
    /// standard with a length limit of 128 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The identifier of the schema located in the same data store.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_id: std::string::String,

    /// The unstructured data linked to this document. Content must be set if this
    /// document is under a
    /// `CONTENT_REQUIRED` data store.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::document::Content>,

    /// The identifier of the parent document. Currently supports at most two level
    /// document hierarchy.
    ///
    /// Id should conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
    /// standard with a length limit of 63 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_document_id: std::string::String,

    /// Output only. This field is OUTPUT_ONLY.
    /// It contains derived data that are not in the original input document.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub derived_struct_data: std::option::Option<wkt::Struct>,

    /// Output only. The last time the document was indexed. If this field is set,
    /// the document could be returned in search results.
    ///
    /// This field is OUTPUT_ONLY. If this field is not populated, it means the
    /// document has never been indexed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The index status of the document.
    ///
    /// * If document is indexed successfully, the index_time field is populated.
    /// * Otherwise, if document is not indexed due to errors, the error_samples
    ///   field is populated.
    /// * Otherwise, if document's index is in progress, the pending_message field
    ///   is populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_status: std::option::Option<crate::model::document::IndexStatus>,

    /// Data representation. One of
    /// [struct_data][google.cloud.discoveryengine.v1.Document.struct_data] or
    /// [json_data][google.cloud.discoveryengine.v1.Document.json_data] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    ///
    /// [google.cloud.discoveryengine.v1.Document.json_data]: crate::model::Document::data
    /// [google.cloud.discoveryengine.v1.Document.struct_data]: crate::model::Document::data
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::document::Data>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Document {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Document::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Document::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [schema_id][crate::model::Document::schema_id].
    pub fn set_schema_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_id = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Document::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document::Content>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::Document::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document::Content>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent_document_id][crate::model::Document::parent_document_id].
    pub fn set_parent_document_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_document_id = v.into();
        self
    }

    /// Sets the value of [derived_struct_data][crate::model::Document::derived_struct_data].
    pub fn set_derived_struct_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.derived_struct_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [derived_struct_data][crate::model::Document::derived_struct_data].
    pub fn set_or_clear_derived_struct_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.derived_struct_data = v.map(|x| x.into());
        self
    }

    /// Sets the value of [index_time][crate::model::Document::index_time].
    pub fn set_index_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.index_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index_time][crate::model::Document::index_time].
    pub fn set_or_clear_index_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.index_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [index_status][crate::model::Document::index_status].
    pub fn set_index_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document::IndexStatus>,
    {
        self.index_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index_status][crate::model::Document::index_status].
    pub fn set_or_clear_index_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document::IndexStatus>,
    {
        self.index_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data][crate::model::Document::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::document::Data>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::Document::data]
    /// if it holds a `StructData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn struct_data(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::document::Data::StructData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::Document::data]
    /// to hold a `StructData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_struct_data<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = std::option::Option::Some(crate::model::document::Data::StructData(v.into()));
        self
    }

    /// The value of [data][crate::model::Document::data]
    /// if it holds a `JsonData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_data(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::document::Data::JsonData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::Document::data]
    /// to hold a `JsonData`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_json_data<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data = std::option::Option::Some(crate::model::document::Data::JsonData(v.into()));
        self
    }
}

impl wkt::message::Message for Document {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Document"
    }
}

/// Defines additional types related to [Document].
pub mod document {
    #[allow(unused_imports)]
    use super::*;

    /// Unstructured data linked to this document.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Content {
        /// The MIME type of the content. Supported types:
        ///
        /// * `application/pdf` (PDF, only native PDFs are supported for now)
        /// * `text/html` (HTML)
        /// * `application/vnd.openxmlformats-officedocument.wordprocessingml.document` (DOCX)
        /// * `application/vnd.openxmlformats-officedocument.presentationml.presentation` (PPTX)
        /// * `text/plain` (TXT)
        ///
        /// See <https://www.iana.org/assignments/media-types/media-types.xhtml>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub mime_type: std::string::String,

        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub content: std::option::Option<crate::model::document::content::Content>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Content {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mime_type][crate::model::document::Content::mime_type].
        pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mime_type = v.into();
            self
        }

        /// Sets the value of [content][crate::model::document::Content::content].
        ///
        /// Note that all the setters affecting `content` are mutually
        /// exclusive.
        pub fn set_content<
            T: std::convert::Into<std::option::Option<crate::model::document::content::Content>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.content = v.into();
            self
        }

        /// The value of [content][crate::model::document::Content::content]
        /// if it holds a `RawBytes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn raw_bytes(&self) -> std::option::Option<&::bytes::Bytes> {
            #[allow(unreachable_patterns)]
            self.content.as_ref().and_then(|v| match v {
                crate::model::document::content::Content::RawBytes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [content][crate::model::document::Content::content]
        /// to hold a `RawBytes`.
        ///
        /// Note that all the setters affecting `content` are
        /// mutually exclusive.
        pub fn set_raw_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.content = std::option::Option::Some(
                crate::model::document::content::Content::RawBytes(v.into()),
            );
            self
        }

        /// The value of [content][crate::model::document::Content::content]
        /// if it holds a `Uri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.content.as_ref().and_then(|v| match v {
                crate::model::document::content::Content::Uri(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [content][crate::model::document::Content::content]
        /// to hold a `Uri`.
        ///
        /// Note that all the setters affecting `content` are
        /// mutually exclusive.
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.content =
                std::option::Option::Some(crate::model::document::content::Content::Uri(v.into()));
            self
        }
    }

    impl wkt::message::Message for Content {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Document.Content"
        }
    }

    /// Defines additional types related to [Content].
    pub mod content {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Content {
            /// The content represented as a stream of bytes. The maximum length is
            /// 1,000,000 bytes (1 MB / ~0.95 MiB).
            ///
            /// Note: As with all `bytes` fields, this field is represented as pure
            /// binary in Protocol Buffers and base64-encoded string in JSON. For
            /// example, `abc123!?$*&()'-=@~` should be represented as
            /// `YWJjMTIzIT8kKiYoKSctPUB+` in JSON. See
            /// <https://developers.google.com/protocol-buffers/docs/proto3#json>.
            RawBytes(#[serde_as(as = "serde_with::base64::Base64")] ::bytes::Bytes),
            /// The URI of the content. Only Cloud Storage URIs (e.g.
            /// `gs://bucket-name/path/to/file`) are supported. The maximum file size
            /// is 2.5 MB for text-based formats, 200 MB for other formats.
            Uri(std::string::String),
        }
    }

    /// Index status of the document.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IndexStatus {
        /// The time when the document was indexed.
        /// If this field is populated, it means the document has been indexed.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub index_time: std::option::Option<wkt::Timestamp>,

        /// A sample of errors encountered while indexing the document.
        /// If this field is populated, the document is not indexed due to errors.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub error_samples: std::vec::Vec<rpc::model::Status>,

        /// Immutable. The message indicates the document index is in progress.
        /// If this field is populated, the document index is pending.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub pending_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IndexStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index_time][crate::model::document::IndexStatus::index_time].
        pub fn set_index_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.index_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [index_time][crate::model::document::IndexStatus::index_time].
        pub fn set_or_clear_index_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.index_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [error_samples][crate::model::document::IndexStatus::error_samples].
        pub fn set_error_samples<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<rpc::model::Status>,
        {
            use std::iter::Iterator;
            self.error_samples = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [pending_message][crate::model::document::IndexStatus::pending_message].
        pub fn set_pending_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.pending_message = v.into();
            self
        }
    }

    impl wkt::message::Message for IndexStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Document.IndexStatus"
        }
    }

    /// Data representation. One of
    /// [struct_data][google.cloud.discoveryengine.v1.Document.struct_data] or
    /// [json_data][google.cloud.discoveryengine.v1.Document.json_data] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    ///
    /// [google.cloud.discoveryengine.v1.Document.json_data]: crate::model::Document::data
    /// [google.cloud.discoveryengine.v1.Document.struct_data]: crate::model::Document::data
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// The structured JSON data for the document. It should conform to the
        /// registered [Schema][google.cloud.discoveryengine.v1.Schema] or an
        /// `INVALID_ARGUMENT` error is thrown.
        ///
        /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
        StructData(std::boxed::Box<wkt::Struct>),
        /// The JSON string representation of the document. It should conform to the
        /// registered [Schema][google.cloud.discoveryengine.v1.Schema] or an
        /// `INVALID_ARGUMENT` error is thrown.
        ///
        /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
        JsonData(std::string::String),
    }
}

/// A singleton resource of
/// [DataStore][google.cloud.discoveryengine.v1.DataStore]. If it's empty when
/// [DataStore][google.cloud.discoveryengine.v1.DataStore] is created and
/// [DataStore][google.cloud.discoveryengine.v1.DataStore] is set to
/// [DataStore.ContentConfig.CONTENT_REQUIRED][google.cloud.discoveryengine.v1.DataStore.ContentConfig.CONTENT_REQUIRED],
/// the default parser will default to digital parser.
///
/// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
/// [google.cloud.discoveryengine.v1.DataStore.ContentConfig.CONTENT_REQUIRED]: crate::model::data_store::ContentConfig::ContentRequired
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DocumentProcessingConfig {
    /// The full resource name of the Document Processing Config.
    /// Format:
    /// `projects/*/locations/*/collections/*/dataStores/*/documentProcessingConfig`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Whether chunking mode is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub chunking_config:
        std::option::Option<crate::model::document_processing_config::ChunkingConfig>,

    /// Configurations for default Document parser.
    /// If not specified, we will configure it as default DigitalParsingConfig, and
    /// the default parsing config will be applied to all file types for Document
    /// parsing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_parsing_config:
        std::option::Option<crate::model::document_processing_config::ParsingConfig>,

    /// Map from file type to override the default parsing configuration based on
    /// the file type. Supported keys:
    ///
    /// * `pdf`: Override parsing config for PDF files, either digital parsing, ocr
    ///   parsing or layout parsing is supported.
    /// * `html`: Override parsing config for HTML files, only digital parsing and
    ///   layout parsing are supported.
    /// * `docx`: Override parsing config for DOCX files, only digital parsing and
    ///   layout parsing are supported.
    /// * `pptx`: Override parsing config for PPTX files, only digital parsing and
    ///   layout parsing are supported.
    /// * `xlsm`: Override parsing config for XLSM files, only digital parsing and
    ///   layout parsing are supported.
    /// * `xlsx`: Override parsing config for XLSX files, only digital parsing and
    ///   layout parsing are supported.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub parsing_config_overrides: std::collections::HashMap<
        std::string::String,
        crate::model::document_processing_config::ParsingConfig,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentProcessingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DocumentProcessingConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [chunking_config][crate::model::DocumentProcessingConfig::chunking_config].
    pub fn set_chunking_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document_processing_config::ChunkingConfig>,
    {
        self.chunking_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [chunking_config][crate::model::DocumentProcessingConfig::chunking_config].
    pub fn set_or_clear_chunking_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document_processing_config::ChunkingConfig>,
    {
        self.chunking_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_parsing_config][crate::model::DocumentProcessingConfig::default_parsing_config].
    pub fn set_default_parsing_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document_processing_config::ParsingConfig>,
    {
        self.default_parsing_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_parsing_config][crate::model::DocumentProcessingConfig::default_parsing_config].
    pub fn set_or_clear_default_parsing_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document_processing_config::ParsingConfig>,
    {
        self.default_parsing_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parsing_config_overrides][crate::model::DocumentProcessingConfig::parsing_config_overrides].
    pub fn set_parsing_config_overrides<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::document_processing_config::ParsingConfig>,
    {
        use std::iter::Iterator;
        self.parsing_config_overrides = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for DocumentProcessingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentProcessingConfig"
    }
}

/// Defines additional types related to [DocumentProcessingConfig].
pub mod document_processing_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for chunking config.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ChunkingConfig {
        /// Additional configs that defines the behavior of the chunking.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub chunk_mode: std::option::Option<
            crate::model::document_processing_config::chunking_config::ChunkMode,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ChunkingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [chunk_mode][crate::model::document_processing_config::ChunkingConfig::chunk_mode].
        ///
        /// Note that all the setters affecting `chunk_mode` are mutually
        /// exclusive.
        pub fn set_chunk_mode<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::document_processing_config::chunking_config::ChunkMode,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.chunk_mode = v.into();
            self
        }

        /// The value of [chunk_mode][crate::model::document_processing_config::ChunkingConfig::chunk_mode]
        /// if it holds a `LayoutBasedChunkingConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn layout_based_chunking_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::document_processing_config::chunking_config::LayoutBasedChunkingConfig>>{
            #[allow(unreachable_patterns)]
            self.chunk_mode.as_ref().and_then(|v| match v {
                crate::model::document_processing_config::chunking_config::ChunkMode::LayoutBasedChunkingConfig(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [chunk_mode][crate::model::document_processing_config::ChunkingConfig::chunk_mode]
        /// to hold a `LayoutBasedChunkingConfig`.
        ///
        /// Note that all the setters affecting `chunk_mode` are
        /// mutually exclusive.
        pub fn set_layout_based_chunking_config<T: std::convert::Into<std::boxed::Box<crate::model::document_processing_config::chunking_config::LayoutBasedChunkingConfig>>>(mut self, v: T) -> Self{
            self.chunk_mode = std::option::Option::Some(
                crate::model::document_processing_config::chunking_config::ChunkMode::LayoutBasedChunkingConfig(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ChunkingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentProcessingConfig.ChunkingConfig"
        }
    }

    /// Defines additional types related to [ChunkingConfig].
    pub mod chunking_config {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration for the layout based chunking.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LayoutBasedChunkingConfig {
            /// The token size limit for each chunk.
            ///
            /// Supported values: 100-500 (inclusive).
            /// Default value: 500.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub chunk_size: i32,

            /// Whether to include appending different levels of headings to chunks
            /// from the middle of the document to prevent context loss.
            ///
            /// Default value: False.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub include_ancestor_headings: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LayoutBasedChunkingConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [chunk_size][crate::model::document_processing_config::chunking_config::LayoutBasedChunkingConfig::chunk_size].
            pub fn set_chunk_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.chunk_size = v.into();
                self
            }

            /// Sets the value of [include_ancestor_headings][crate::model::document_processing_config::chunking_config::LayoutBasedChunkingConfig::include_ancestor_headings].
            pub fn set_include_ancestor_headings<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.include_ancestor_headings = v.into();
                self
            }
        }

        impl wkt::message::Message for LayoutBasedChunkingConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentProcessingConfig.ChunkingConfig.LayoutBasedChunkingConfig"
            }
        }

        /// Additional configs that defines the behavior of the chunking.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum ChunkMode {
            /// Configuration for the layout based chunking.
            LayoutBasedChunkingConfig(std::boxed::Box<crate::model::document_processing_config::chunking_config::LayoutBasedChunkingConfig>),
        }
    }

    /// Related configurations applied to a specific type of document parser.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ParsingConfig {
        /// Configs for document processing types.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub type_dedicated_config: std::option::Option<
            crate::model::document_processing_config::parsing_config::TypeDedicatedConfig,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ParsingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [type_dedicated_config][crate::model::document_processing_config::ParsingConfig::type_dedicated_config].
        ///
        /// Note that all the setters affecting `type_dedicated_config` are mutually
        /// exclusive.
        pub fn set_type_dedicated_config<T: std::convert::Into<std::option::Option<crate::model::document_processing_config::parsing_config::TypeDedicatedConfig>>>(mut self, v: T) -> Self
        {
            self.type_dedicated_config = v.into();
            self
        }

        /// The value of [type_dedicated_config][crate::model::document_processing_config::ParsingConfig::type_dedicated_config]
        /// if it holds a `DigitalParsingConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn digital_parsing_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::document_processing_config::parsing_config::DigitalParsingConfig,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.type_dedicated_config.as_ref().and_then(|v| match v {
                crate::model::document_processing_config::parsing_config::TypeDedicatedConfig::DigitalParsingConfig(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [type_dedicated_config][crate::model::document_processing_config::ParsingConfig::type_dedicated_config]
        /// to hold a `DigitalParsingConfig`.
        ///
        /// Note that all the setters affecting `type_dedicated_config` are
        /// mutually exclusive.
        pub fn set_digital_parsing_config<T: std::convert::Into<std::boxed::Box<crate::model::document_processing_config::parsing_config::DigitalParsingConfig>>>(mut self, v: T) -> Self{
            self.type_dedicated_config = std::option::Option::Some(
                crate::model::document_processing_config::parsing_config::TypeDedicatedConfig::DigitalParsingConfig(
                    v.into()
                )
            );
            self
        }

        /// The value of [type_dedicated_config][crate::model::document_processing_config::ParsingConfig::type_dedicated_config]
        /// if it holds a `OcrParsingConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn ocr_parsing_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::document_processing_config::parsing_config::OcrParsingConfig,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.type_dedicated_config.as_ref().and_then(|v| match v {
                crate::model::document_processing_config::parsing_config::TypeDedicatedConfig::OcrParsingConfig(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [type_dedicated_config][crate::model::document_processing_config::ParsingConfig::type_dedicated_config]
        /// to hold a `OcrParsingConfig`.
        ///
        /// Note that all the setters affecting `type_dedicated_config` are
        /// mutually exclusive.
        pub fn set_ocr_parsing_config<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::document_processing_config::parsing_config::OcrParsingConfig,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.type_dedicated_config = std::option::Option::Some(
                crate::model::document_processing_config::parsing_config::TypeDedicatedConfig::OcrParsingConfig(
                    v.into()
                )
            );
            self
        }

        /// The value of [type_dedicated_config][crate::model::document_processing_config::ParsingConfig::type_dedicated_config]
        /// if it holds a `LayoutParsingConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn layout_parsing_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::document_processing_config::parsing_config::LayoutParsingConfig,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.type_dedicated_config.as_ref().and_then(|v| match v {
                crate::model::document_processing_config::parsing_config::TypeDedicatedConfig::LayoutParsingConfig(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [type_dedicated_config][crate::model::document_processing_config::ParsingConfig::type_dedicated_config]
        /// to hold a `LayoutParsingConfig`.
        ///
        /// Note that all the setters affecting `type_dedicated_config` are
        /// mutually exclusive.
        pub fn set_layout_parsing_config<T: std::convert::Into<std::boxed::Box<crate::model::document_processing_config::parsing_config::LayoutParsingConfig>>>(mut self, v: T) -> Self{
            self.type_dedicated_config = std::option::Option::Some(
                crate::model::document_processing_config::parsing_config::TypeDedicatedConfig::LayoutParsingConfig(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ParsingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentProcessingConfig.ParsingConfig"
        }
    }

    /// Defines additional types related to [ParsingConfig].
    pub mod parsing_config {
        #[allow(unused_imports)]
        use super::*;

        /// The digital parsing configurations for documents.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DigitalParsingConfig {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DigitalParsingConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for DigitalParsingConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentProcessingConfig.ParsingConfig.DigitalParsingConfig"
            }
        }

        /// The OCR parsing configurations for documents.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OcrParsingConfig {
            /// [DEPRECATED] This field is deprecated. To use the additional enhanced
            /// document elements processing, please switch to `layout_parsing_config`.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            #[deprecated]
            pub enhanced_document_elements: std::vec::Vec<std::string::String>,

            /// If true, will use native text instead of OCR text on pages containing
            /// native text.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub use_native_text: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl OcrParsingConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [enhanced_document_elements][crate::model::document_processing_config::parsing_config::OcrParsingConfig::enhanced_document_elements].
            #[deprecated]
            pub fn set_enhanced_document_elements<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.enhanced_document_elements = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [use_native_text][crate::model::document_processing_config::parsing_config::OcrParsingConfig::use_native_text].
            pub fn set_use_native_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.use_native_text = v.into();
                self
            }
        }

        impl wkt::message::Message for OcrParsingConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentProcessingConfig.ParsingConfig.OcrParsingConfig"
            }
        }

        /// The layout parsing configurations for documents.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct LayoutParsingConfig {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl LayoutParsingConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for LayoutParsingConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentProcessingConfig.ParsingConfig.LayoutParsingConfig"
            }
        }

        /// Configs for document processing types.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum TypeDedicatedConfig {
            /// Configurations applied to digital parser.
            DigitalParsingConfig(
                std::boxed::Box<
                    crate::model::document_processing_config::parsing_config::DigitalParsingConfig,
                >,
            ),
            /// Configurations applied to OCR parser. Currently it only applies to
            /// PDFs.
            OcrParsingConfig(
                std::boxed::Box<
                    crate::model::document_processing_config::parsing_config::OcrParsingConfig,
                >,
            ),
            /// Configurations applied to layout parser.
            LayoutParsingConfig(
                std::boxed::Box<
                    crate::model::document_processing_config::parsing_config::LayoutParsingConfig,
                >,
            ),
        }
    }
}

/// Request message for
/// [DocumentService.GetDocument][google.cloud.discoveryengine.v1.DocumentService.GetDocument]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.GetDocument]: crate::client::DocumentService::get_document
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDocumentRequest {
    /// Required. Full resource name of
    /// [Document][google.cloud.discoveryengine.v1.Document], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
    ///
    /// If the caller does not have permission to access the
    /// [Document][google.cloud.discoveryengine.v1.Document], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// If the requested [Document][google.cloud.discoveryengine.v1.Document] does
    /// not exist, a `NOT_FOUND` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDocumentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetDocumentRequest"
    }
}

/// Request message for
/// [DocumentService.ListDocuments][google.cloud.discoveryengine.v1.DocumentService.ListDocuments]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.ListDocuments]: crate::client::DocumentService::list_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDocumentsRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    /// Use `default_branch` as the branch ID, to list documents under the default
    /// branch.
    ///
    /// If the caller does not have permission to list
    /// [Document][google.cloud.discoveryengine.v1.Document]s under this branch,
    /// regardless of whether or not this branch exists, a `PERMISSION_DENIED`
    /// error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of [Document][google.cloud.discoveryengine.v1.Document]s to
    /// return. If unspecified, defaults to 100. The maximum allowed value is 1000.
    /// Values above 1000 are set to 1000.
    ///
    /// If this field is negative, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token
    /// [ListDocumentsResponse.next_page_token][google.cloud.discoveryengine.v1.ListDocumentsResponse.next_page_token],
    /// received from a previous
    /// [DocumentService.ListDocuments][google.cloud.discoveryengine.v1.DocumentService.ListDocuments]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [DocumentService.ListDocuments][google.cloud.discoveryengine.v1.DocumentService.ListDocuments]
    /// must match the call that provided the page token. Otherwise, an
    /// `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.DocumentService.ListDocuments]: crate::client::DocumentService::list_documents
    /// [google.cloud.discoveryengine.v1.ListDocumentsResponse.next_page_token]: crate::model::ListDocumentsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDocumentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDocumentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDocumentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListDocumentsRequest"
    }
}

/// Response message for
/// [DocumentService.ListDocuments][google.cloud.discoveryengine.v1.DocumentService.ListDocuments]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.ListDocuments]: crate::client::DocumentService::list_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDocumentsResponse {
    /// The [Document][google.cloud.discoveryengine.v1.Document]s.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub documents: std::vec::Vec<crate::model::Document>,

    /// A token that can be sent as
    /// [ListDocumentsRequest.page_token][google.cloud.discoveryengine.v1.ListDocumentsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.discoveryengine.v1.ListDocumentsRequest.page_token]: crate::model::ListDocumentsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [documents][crate::model::ListDocumentsResponse::documents].
    pub fn set_documents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Document>,
    {
        use std::iter::Iterator;
        self.documents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDocumentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListDocumentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDocumentsResponse {
    type PageItem = crate::model::Document;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.documents
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [DocumentService.CreateDocument][google.cloud.discoveryengine.v1.DocumentService.CreateDocument]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.CreateDocument]: crate::client::DocumentService::create_document
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDocumentRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The [Document][google.cloud.discoveryengine.v1.Document] to
    /// create.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// Required. The ID to use for the
    /// [Document][google.cloud.discoveryengine.v1.Document], which becomes the
    /// final component of the
    /// [Document.name][google.cloud.discoveryengine.v1.Document.name].
    ///
    /// If the caller does not have permission to create the
    /// [Document][google.cloud.discoveryengine.v1.Document], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// This field must be unique among all
    /// [Document][google.cloud.discoveryengine.v1.Document]s with the same
    /// [parent][google.cloud.discoveryengine.v1.CreateDocumentRequest.parent].
    /// Otherwise, an `ALREADY_EXISTS` error is returned.
    ///
    /// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
    /// standard with a length limit of 128 characters. Otherwise, an
    /// `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.CreateDocumentRequest.parent]: crate::model::CreateDocumentRequest::parent
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.Document.name]: crate::model::Document::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub document_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDocumentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [document][crate::model::CreateDocumentRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::CreateDocumentRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_id][crate::model::CreateDocumentRequest::document_id].
    pub fn set_document_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.document_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateDocumentRequest"
    }
}

/// Request message for
/// [DocumentService.UpdateDocument][google.cloud.discoveryengine.v1.DocumentService.UpdateDocument]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.UpdateDocument]: crate::client::DocumentService::update_document
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDocumentRequest {
    /// Required. The document to update/create.
    ///
    /// If the caller does not have permission to update the
    /// [Document][google.cloud.discoveryengine.v1.Document], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// If the [Document][google.cloud.discoveryengine.v1.Document] to update does
    /// not exist and
    /// [allow_missing][google.cloud.discoveryengine.v1.UpdateDocumentRequest.allow_missing]
    /// is not set, a `NOT_FOUND` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.UpdateDocumentRequest.allow_missing]: crate::model::UpdateDocumentRequest::allow_missing
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub document: std::option::Option<crate::model::Document>,

    /// If set to `true` and the
    /// [Document][google.cloud.discoveryengine.v1.Document] is not found, a new
    /// [Document][google.cloud.discoveryengine.v1.Document] is be created.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    /// Indicates which fields in the provided imported 'document' to update. If
    /// not set, by default updates all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::UpdateDocumentRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::UpdateDocumentRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateDocumentRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDocumentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDocumentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateDocumentRequest"
    }
}

/// Request message for
/// [DocumentService.DeleteDocument][google.cloud.discoveryengine.v1.DocumentService.DeleteDocument]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.DeleteDocument]: crate::client::DocumentService::delete_document
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDocumentRequest {
    /// Required. Full resource name of
    /// [Document][google.cloud.discoveryengine.v1.Document], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
    ///
    /// If the caller does not have permission to delete the
    /// [Document][google.cloud.discoveryengine.v1.Document], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// If the [Document][google.cloud.discoveryengine.v1.Document] to delete does
    /// not exist, a `NOT_FOUND` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDocumentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteDocumentRequest"
    }
}

/// Request message for
/// [DocumentService.BatchGetDocumentsMetadata][google.cloud.discoveryengine.v1.DocumentService.BatchGetDocumentsMetadata]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.BatchGetDocumentsMetadata]: crate::client::DocumentService::batch_get_documents_metadata
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchGetDocumentsMetadataRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Matcher for the
    /// [Document][google.cloud.discoveryengine.v1.Document]s.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub matcher: std::option::Option<crate::model::batch_get_documents_metadata_request::Matcher>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetDocumentsMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchGetDocumentsMetadataRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [matcher][crate::model::BatchGetDocumentsMetadataRequest::matcher].
    pub fn set_matcher<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::batch_get_documents_metadata_request::Matcher>,
    {
        self.matcher = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [matcher][crate::model::BatchGetDocumentsMetadataRequest::matcher].
    pub fn set_or_clear_matcher<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::batch_get_documents_metadata_request::Matcher>,
    {
        self.matcher = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchGetDocumentsMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataRequest"
    }
}

/// Defines additional types related to [BatchGetDocumentsMetadataRequest].
pub mod batch_get_documents_metadata_request {
    #[allow(unused_imports)]
    use super::*;

    /// Matcher for the [Document][google.cloud.discoveryengine.v1.Document]s by
    /// exact uris.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UrisMatcher {
        /// The exact URIs to match by.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub uris: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UrisMatcher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uris][crate::model::batch_get_documents_metadata_request::UrisMatcher::uris].
        pub fn set_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for UrisMatcher {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataRequest.UrisMatcher"
        }
    }

    /// Matcher for the [Document][google.cloud.discoveryengine.v1.Document]s by
    /// FHIR resource names.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FhirMatcher {
        /// Required. The FHIR resources to match by.
        /// Format:
        /// projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}/fhir/{resource_type}/{fhir_resource_id}
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub fhir_resources: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FhirMatcher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [fhir_resources][crate::model::batch_get_documents_metadata_request::FhirMatcher::fhir_resources].
        pub fn set_fhir_resources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.fhir_resources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FhirMatcher {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataRequest.FhirMatcher"
        }
    }

    /// Matcher for the [Document][google.cloud.discoveryengine.v1.Document]s.
    /// Currently supports matching by exact URIs.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Matcher {
        /// Matcher for the [Document][google.cloud.discoveryengine.v1.Document]s.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub matcher: std::option::Option<
            crate::model::batch_get_documents_metadata_request::matcher::Matcher,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Matcher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [matcher][crate::model::batch_get_documents_metadata_request::Matcher::matcher].
        ///
        /// Note that all the setters affecting `matcher` are mutually
        /// exclusive.
        pub fn set_matcher<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::batch_get_documents_metadata_request::matcher::Matcher,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.matcher = v.into();
            self
        }

        /// The value of [matcher][crate::model::batch_get_documents_metadata_request::Matcher::matcher]
        /// if it holds a `UrisMatcher`, `None` if the field is not set or
        /// holds a different branch.
        pub fn uris_matcher(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::batch_get_documents_metadata_request::UrisMatcher>,
        > {
            #[allow(unreachable_patterns)]
            self.matcher.as_ref().and_then(|v| match v {
                crate::model::batch_get_documents_metadata_request::matcher::Matcher::UrisMatcher(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [matcher][crate::model::batch_get_documents_metadata_request::Matcher::matcher]
        /// to hold a `UrisMatcher`.
        ///
        /// Note that all the setters affecting `matcher` are
        /// mutually exclusive.
        pub fn set_uris_matcher<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::batch_get_documents_metadata_request::UrisMatcher,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.matcher = std::option::Option::Some(
                crate::model::batch_get_documents_metadata_request::matcher::Matcher::UrisMatcher(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [matcher][crate::model::batch_get_documents_metadata_request::Matcher::matcher]
        /// if it holds a `FhirMatcher`, `None` if the field is not set or
        /// holds a different branch.
        pub fn fhir_matcher(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::batch_get_documents_metadata_request::FhirMatcher>,
        > {
            #[allow(unreachable_patterns)]
            self.matcher.as_ref().and_then(|v| match v {
                crate::model::batch_get_documents_metadata_request::matcher::Matcher::FhirMatcher(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [matcher][crate::model::batch_get_documents_metadata_request::Matcher::matcher]
        /// to hold a `FhirMatcher`.
        ///
        /// Note that all the setters affecting `matcher` are
        /// mutually exclusive.
        pub fn set_fhir_matcher<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::batch_get_documents_metadata_request::FhirMatcher,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.matcher = std::option::Option::Some(
                crate::model::batch_get_documents_metadata_request::matcher::Matcher::FhirMatcher(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for Matcher {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataRequest.Matcher"
        }
    }

    /// Defines additional types related to [Matcher].
    pub mod matcher {
        #[allow(unused_imports)]
        use super::*;

        /// Matcher for the [Document][google.cloud.discoveryengine.v1.Document]s.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Matcher {
            /// Matcher by exact URIs.
            UrisMatcher(
                std::boxed::Box<crate::model::batch_get_documents_metadata_request::UrisMatcher>,
            ),
            /// Matcher by FHIR resource names.
            FhirMatcher(
                std::boxed::Box<crate::model::batch_get_documents_metadata_request::FhirMatcher>,
            ),
        }
    }
}

/// Response message for
/// [DocumentService.BatchGetDocumentsMetadata][google.cloud.discoveryengine.v1.DocumentService.BatchGetDocumentsMetadata]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.BatchGetDocumentsMetadata]: crate::client::DocumentService::batch_get_documents_metadata
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchGetDocumentsMetadataResponse {
    /// The metadata of the [Document][google.cloud.discoveryengine.v1.Document]s.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub documents_metadata:
        std::vec::Vec<crate::model::batch_get_documents_metadata_response::DocumentMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetDocumentsMetadataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [documents_metadata][crate::model::BatchGetDocumentsMetadataResponse::documents_metadata].
    pub fn set_documents_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::batch_get_documents_metadata_response::DocumentMetadata,
            >,
    {
        use std::iter::Iterator;
        self.documents_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchGetDocumentsMetadataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataResponse"
    }
}

/// Defines additional types related to [BatchGetDocumentsMetadataResponse].
pub mod batch_get_documents_metadata_response {
    #[allow(unused_imports)]
    use super::*;

    /// The metadata of a [Document][google.cloud.discoveryengine.v1.Document].
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DocumentMetadata {
        /// The value of the matcher that was used to match the
        /// [Document][google.cloud.discoveryengine.v1.Document].
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub matcher_value: std::option::Option<
            crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue,
        >,

        /// The state of the document.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub state: crate::model::batch_get_documents_metadata_response::State,

        /// The timestamp of the last time the
        /// [Document][google.cloud.discoveryengine.v1.Document] was last indexed.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_refreshed_time: std::option::Option<wkt::Timestamp>,

        /// The data ingestion source of the
        /// [Document][google.cloud.discoveryengine.v1.Document].
        ///
        /// Allowed values are:
        ///
        /// * `batch`: Data ingested via Batch API, e.g., ImportDocuments.
        /// * `streaming` Data ingested via Streaming API, e.g., FHIR streaming.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data_ingestion_source: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DocumentMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [matcher_value][crate::model::batch_get_documents_metadata_response::DocumentMetadata::matcher_value].
        pub fn set_matcher_value<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue>
        {
            self.matcher_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [matcher_value][crate::model::batch_get_documents_metadata_response::DocumentMetadata::matcher_value].
        pub fn set_or_clear_matcher_value<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue>
        {
            self.matcher_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [state][crate::model::batch_get_documents_metadata_response::DocumentMetadata::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::batch_get_documents_metadata_response::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [last_refreshed_time][crate::model::batch_get_documents_metadata_response::DocumentMetadata::last_refreshed_time].
        pub fn set_last_refreshed_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_refreshed_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_refreshed_time][crate::model::batch_get_documents_metadata_response::DocumentMetadata::last_refreshed_time].
        pub fn set_or_clear_last_refreshed_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_refreshed_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data_ingestion_source][crate::model::batch_get_documents_metadata_response::DocumentMetadata::data_ingestion_source].
        pub fn set_data_ingestion_source<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.data_ingestion_source = v.into();
            self
        }
    }

    impl wkt::message::Message for DocumentMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataResponse.DocumentMetadata"
        }
    }

    /// Defines additional types related to [DocumentMetadata].
    pub mod document_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// The value of the matcher that was used to match the
        /// [Document][google.cloud.discoveryengine.v1.Document].
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MatcherValue {

            /// The value of the matcher that was used to match the
            /// [Document][google.cloud.discoveryengine.v1.Document].
            ///
            /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub matcher_value: std::option::Option<crate::model::batch_get_documents_metadata_response::document_metadata::matcher_value::MatcherValue>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MatcherValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [matcher_value][crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue::matcher_value].
            ///
            /// Note that all the setters affecting `matcher_value` are mutually
            /// exclusive.
            pub fn set_matcher_value<T: std::convert::Into<std::option::Option<crate::model::batch_get_documents_metadata_response::document_metadata::matcher_value::MatcherValue>>>(mut self, v: T) -> Self
            {
                self.matcher_value = v.into();
                self
            }

            /// The value of [matcher_value][crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue::matcher_value]
            /// if it holds a `Uri`, `None` if the field is not set or
            /// holds a different branch.
            pub fn uri(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.matcher_value.as_ref().and_then(|v| match v {
                    crate::model::batch_get_documents_metadata_response::document_metadata::matcher_value::MatcherValue::Uri(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [matcher_value][crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue::matcher_value]
            /// to hold a `Uri`.
            ///
            /// Note that all the setters affecting `matcher_value` are
            /// mutually exclusive.
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.matcher_value = std::option::Option::Some(
                    crate::model::batch_get_documents_metadata_response::document_metadata::matcher_value::MatcherValue::Uri(
                        v.into()
                    )
                );
                self
            }

            /// The value of [matcher_value][crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue::matcher_value]
            /// if it holds a `FhirResource`, `None` if the field is not set or
            /// holds a different branch.
            pub fn fhir_resource(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.matcher_value.as_ref().and_then(|v| match v {
                    crate::model::batch_get_documents_metadata_response::document_metadata::matcher_value::MatcherValue::FhirResource(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [matcher_value][crate::model::batch_get_documents_metadata_response::document_metadata::MatcherValue::matcher_value]
            /// to hold a `FhirResource`.
            ///
            /// Note that all the setters affecting `matcher_value` are
            /// mutually exclusive.
            pub fn set_fhir_resource<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.matcher_value = std::option::Option::Some(
                    crate::model::batch_get_documents_metadata_response::document_metadata::matcher_value::MatcherValue::FhirResource(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for MatcherValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataResponse.DocumentMetadata.MatcherValue"
            }
        }

        /// Defines additional types related to [MatcherValue].
        pub mod matcher_value {
            #[allow(unused_imports)]
            use super::*;

            /// The value of the matcher that was used to match the
            /// [Document][google.cloud.discoveryengine.v1.Document].
            ///
            /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
            #[serde_with::serde_as]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum MatcherValue {
                /// If match by URI, the URI of the
                /// [Document][google.cloud.discoveryengine.v1.Document].
                ///
                /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
                Uri(std::string::String),
                /// Format:
                /// projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}/fhir/{resource_type}/{fhir_resource_id}
                FhirResource(std::string::String),
            }
        }
    }

    /// The state of the [Document][google.cloud.discoveryengine.v1.Document].
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Should never be set.
        Unspecified,
        /// The [Document][google.cloud.discoveryengine.v1.Document] is indexed.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        Indexed,
        /// The [Document][google.cloud.discoveryengine.v1.Document] is not indexed
        /// because its URI is not in the
        /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite].
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
        NotInTargetSite,
        /// The [Document][google.cloud.discoveryengine.v1.Document] is not indexed.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        NotInIndex,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Indexed => std::option::Option::Some(1),
                Self::NotInTargetSite => std::option::Option::Some(2),
                Self::NotInIndex => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Indexed => std::option::Option::Some("INDEXED"),
                Self::NotInTargetSite => std::option::Option::Some("NOT_IN_TARGET_SITE"),
                Self::NotInIndex => std::option::Option::Some("NOT_IN_INDEX"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Indexed,
                2 => Self::NotInTargetSite,
                3 => Self::NotInIndex,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INDEXED" => Self::Indexed,
                "NOT_IN_TARGET_SITE" => Self::NotInTargetSite,
                "NOT_IN_INDEX" => Self::NotInIndex,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Indexed => serializer.serialize_i32(1),
                Self::NotInTargetSite => serializer.serialize_i32(2),
                Self::NotInIndex => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.discoveryengine.v1.BatchGetDocumentsMetadataResponse.State",
            ))
        }
    }
}

/// Metadata that describes the training and serving parameters of an
/// [Engine][google.cloud.discoveryengine.v1.Engine].
///
/// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Engine {
    /// Immutable. The fully qualified resource name of the engine.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
    /// engine should be 1-63 characters, and valid characters are
    /// /[a-z0-9][a-z0-9-_]*/. Otherwise, an INVALID_ARGUMENT error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The display name of the engine. Should be human readable. UTF-8
    /// encoded string with limit of 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Timestamp the Recommendation Engine was created at.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp the Recommendation Engine was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The data stores associated with this engine.
    ///
    /// For
    /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]
    /// and
    /// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION]
    /// type of engines, they can only associate with at most one data store.
    ///
    /// If [solution_type][google.cloud.discoveryengine.v1.Engine.solution_type] is
    /// [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT],
    /// multiple [DataStore][google.cloud.discoveryengine.v1.DataStore]s in the
    /// same [Collection][google.cloud.discoveryengine.v1.Collection] can be
    /// associated here.
    ///
    /// Note that when used in
    /// [CreateEngineRequest][google.cloud.discoveryengine.v1.CreateEngineRequest],
    /// one DataStore id must be provided as the system will use it for necessary
    /// initializations.
    ///
    /// [google.cloud.discoveryengine.v1.CreateEngineRequest]: crate::model::CreateEngineRequest
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    /// [google.cloud.discoveryengine.v1.Engine.solution_type]: crate::model::Engine::solution_type
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT]: crate::model::SolutionType::Chat
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_store_ids: std::vec::Vec<std::string::String>,

    /// Required. The solutions of the engine.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub solution_type: crate::model::SolutionType,

    /// The industry vertical that the engine registers.
    /// The restriction of the Engine industry vertical is based on
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore]: Vertical on Engine
    /// has to match vertical of the DataStore linked to the engine.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub industry_vertical: crate::model::IndustryVertical,

    /// Common config spec that specifies the metadata of the engine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub common_config: std::option::Option<crate::model::engine::CommonConfig>,

    /// Optional. Whether to disable analytics for searches performed on this
    /// engine.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disable_analytics: bool,

    /// Additional config specs that defines the behavior of the engine.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub engine_config: std::option::Option<crate::model::engine::EngineConfig>,

    /// Engine metadata to monitor the status of the engine.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub engine_metadata: std::option::Option<crate::model::engine::EngineMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Engine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Engine::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Engine::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Engine::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Engine::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Engine::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Engine::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_store_ids][crate::model::Engine::data_store_ids].
    pub fn set_data_store_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_store_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [solution_type][crate::model::Engine::solution_type].
    pub fn set_solution_type<T: std::convert::Into<crate::model::SolutionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.solution_type = v.into();
        self
    }

    /// Sets the value of [industry_vertical][crate::model::Engine::industry_vertical].
    pub fn set_industry_vertical<T: std::convert::Into<crate::model::IndustryVertical>>(
        mut self,
        v: T,
    ) -> Self {
        self.industry_vertical = v.into();
        self
    }

    /// Sets the value of [common_config][crate::model::Engine::common_config].
    pub fn set_common_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::engine::CommonConfig>,
    {
        self.common_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [common_config][crate::model::Engine::common_config].
    pub fn set_or_clear_common_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::engine::CommonConfig>,
    {
        self.common_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disable_analytics][crate::model::Engine::disable_analytics].
    pub fn set_disable_analytics<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_analytics = v.into();
        self
    }

    /// Sets the value of [engine_config][crate::model::Engine::engine_config].
    ///
    /// Note that all the setters affecting `engine_config` are mutually
    /// exclusive.
    pub fn set_engine_config<
        T: std::convert::Into<std::option::Option<crate::model::engine::EngineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.engine_config = v.into();
        self
    }

    /// The value of [engine_config][crate::model::Engine::engine_config]
    /// if it holds a `ChatEngineConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn chat_engine_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::engine::ChatEngineConfig>> {
        #[allow(unreachable_patterns)]
        self.engine_config.as_ref().and_then(|v| match v {
            crate::model::engine::EngineConfig::ChatEngineConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [engine_config][crate::model::Engine::engine_config]
    /// to hold a `ChatEngineConfig`.
    ///
    /// Note that all the setters affecting `engine_config` are
    /// mutually exclusive.
    pub fn set_chat_engine_config<
        T: std::convert::Into<std::boxed::Box<crate::model::engine::ChatEngineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.engine_config = std::option::Option::Some(
            crate::model::engine::EngineConfig::ChatEngineConfig(v.into()),
        );
        self
    }

    /// The value of [engine_config][crate::model::Engine::engine_config]
    /// if it holds a `SearchEngineConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn search_engine_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::engine::SearchEngineConfig>> {
        #[allow(unreachable_patterns)]
        self.engine_config.as_ref().and_then(|v| match v {
            crate::model::engine::EngineConfig::SearchEngineConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [engine_config][crate::model::Engine::engine_config]
    /// to hold a `SearchEngineConfig`.
    ///
    /// Note that all the setters affecting `engine_config` are
    /// mutually exclusive.
    pub fn set_search_engine_config<
        T: std::convert::Into<std::boxed::Box<crate::model::engine::SearchEngineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.engine_config = std::option::Option::Some(
            crate::model::engine::EngineConfig::SearchEngineConfig(v.into()),
        );
        self
    }

    /// Sets the value of [engine_metadata][crate::model::Engine::engine_metadata].
    ///
    /// Note that all the setters affecting `engine_metadata` are mutually
    /// exclusive.
    pub fn set_engine_metadata<
        T: std::convert::Into<std::option::Option<crate::model::engine::EngineMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.engine_metadata = v.into();
        self
    }

    /// The value of [engine_metadata][crate::model::Engine::engine_metadata]
    /// if it holds a `ChatEngineMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn chat_engine_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::engine::ChatEngineMetadata>> {
        #[allow(unreachable_patterns)]
        self.engine_metadata.as_ref().and_then(|v| match v {
            crate::model::engine::EngineMetadata::ChatEngineMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [engine_metadata][crate::model::Engine::engine_metadata]
    /// to hold a `ChatEngineMetadata`.
    ///
    /// Note that all the setters affecting `engine_metadata` are
    /// mutually exclusive.
    pub fn set_chat_engine_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::engine::ChatEngineMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.engine_metadata = std::option::Option::Some(
            crate::model::engine::EngineMetadata::ChatEngineMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Engine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Engine"
    }
}

/// Defines additional types related to [Engine].
pub mod engine {
    #[allow(unused_imports)]
    use super::*;

    /// Configurations for a Search Engine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SearchEngineConfig {
        /// The search feature tier of this engine.
        ///
        /// Different tiers might have different
        /// pricing. To learn more, check the pricing documentation.
        ///
        /// Defaults to
        /// [SearchTier.SEARCH_TIER_STANDARD][google.cloud.discoveryengine.v1.SearchTier.SEARCH_TIER_STANDARD]
        /// if not specified.
        ///
        /// [google.cloud.discoveryengine.v1.SearchTier.SEARCH_TIER_STANDARD]: crate::model::SearchTier::Standard
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub search_tier: crate::model::SearchTier,

        /// The add-on that this search engine enables.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub search_add_ons: std::vec::Vec<crate::model::SearchAddOn>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SearchEngineConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search_tier][crate::model::engine::SearchEngineConfig::search_tier].
        pub fn set_search_tier<T: std::convert::Into<crate::model::SearchTier>>(
            mut self,
            v: T,
        ) -> Self {
            self.search_tier = v.into();
            self
        }

        /// Sets the value of [search_add_ons][crate::model::engine::SearchEngineConfig::search_add_ons].
        pub fn set_search_add_ons<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::SearchAddOn>,
        {
            use std::iter::Iterator;
            self.search_add_ons = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SearchEngineConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Engine.SearchEngineConfig"
        }
    }

    /// Configurations for a Chat Engine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ChatEngineConfig {
        /// The configurationt generate the Dialogflow agent that is associated to
        /// this Engine.
        ///
        /// Note that these configurations are one-time consumed by
        /// and passed to Dialogflow service. It means they cannot be retrieved using
        /// [EngineService.GetEngine][google.cloud.discoveryengine.v1.EngineService.GetEngine]
        /// or
        /// [EngineService.ListEngines][google.cloud.discoveryengine.v1.EngineService.ListEngines]
        /// API after engine creation.
        ///
        /// [google.cloud.discoveryengine.v1.EngineService.GetEngine]: crate::client::EngineService::get_engine
        /// [google.cloud.discoveryengine.v1.EngineService.ListEngines]: crate::client::EngineService::list_engines
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub agent_creation_config:
            std::option::Option<crate::model::engine::chat_engine_config::AgentCreationConfig>,

        /// The resource name of an exist Dialogflow agent to link to this Chat
        /// Engine. Customers can either provide `agent_creation_config` to create
        /// agent or provide an agent name that links the agent with the Chat engine.
        ///
        /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
        /// ID>`.
        ///
        /// Note that the `dialogflow_agent_to_link` are one-time consumed by and
        /// passed to Dialogflow service. It means they cannot be retrieved using
        /// [EngineService.GetEngine][google.cloud.discoveryengine.v1.EngineService.GetEngine]
        /// or
        /// [EngineService.ListEngines][google.cloud.discoveryengine.v1.EngineService.ListEngines]
        /// API after engine creation. Use
        /// [ChatEngineMetadata.dialogflow_agent][google.cloud.discoveryengine.v1.Engine.ChatEngineMetadata.dialogflow_agent]
        /// for actual agent association after Engine is created.
        ///
        /// [google.cloud.discoveryengine.v1.Engine.ChatEngineMetadata.dialogflow_agent]: crate::model::engine::ChatEngineMetadata::dialogflow_agent
        /// [google.cloud.discoveryengine.v1.EngineService.GetEngine]: crate::client::EngineService::get_engine
        /// [google.cloud.discoveryengine.v1.EngineService.ListEngines]: crate::client::EngineService::list_engines
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dialogflow_agent_to_link: std::string::String,

        /// Optional. If the flag set to true, we allow the agent and engine are in
        /// different locations, otherwise the agent and engine are required to be in
        /// the same location. The flag is set to false by default.
        ///
        /// Note that the `allow_cross_region` are one-time consumed by and
        /// passed to
        /// [EngineService.CreateEngine][google.cloud.discoveryengine.v1.EngineService.CreateEngine].
        /// It means they cannot be retrieved using
        /// [EngineService.GetEngine][google.cloud.discoveryengine.v1.EngineService.GetEngine]
        /// or
        /// [EngineService.ListEngines][google.cloud.discoveryengine.v1.EngineService.ListEngines]
        /// API after engine creation.
        ///
        /// [google.cloud.discoveryengine.v1.EngineService.CreateEngine]: crate::client::EngineService::create_engine
        /// [google.cloud.discoveryengine.v1.EngineService.GetEngine]: crate::client::EngineService::get_engine
        /// [google.cloud.discoveryengine.v1.EngineService.ListEngines]: crate::client::EngineService::list_engines
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub allow_cross_region: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ChatEngineConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [agent_creation_config][crate::model::engine::ChatEngineConfig::agent_creation_config].
        pub fn set_agent_creation_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::engine::chat_engine_config::AgentCreationConfig>,
        {
            self.agent_creation_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [agent_creation_config][crate::model::engine::ChatEngineConfig::agent_creation_config].
        pub fn set_or_clear_agent_creation_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::engine::chat_engine_config::AgentCreationConfig>,
        {
            self.agent_creation_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [dialogflow_agent_to_link][crate::model::engine::ChatEngineConfig::dialogflow_agent_to_link].
        pub fn set_dialogflow_agent_to_link<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dialogflow_agent_to_link = v.into();
            self
        }

        /// Sets the value of [allow_cross_region][crate::model::engine::ChatEngineConfig::allow_cross_region].
        pub fn set_allow_cross_region<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_cross_region = v.into();
            self
        }
    }

    impl wkt::message::Message for ChatEngineConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Engine.ChatEngineConfig"
        }
    }

    /// Defines additional types related to [ChatEngineConfig].
    pub mod chat_engine_config {
        #[allow(unused_imports)]
        use super::*;

        /// Configurations for generating a Dialogflow agent.
        ///
        /// Note that these configurations are one-time consumed by
        /// and passed to Dialogflow service. It means they cannot be retrieved using
        /// [EngineService.GetEngine][google.cloud.discoveryengine.v1.EngineService.GetEngine]
        /// or
        /// [EngineService.ListEngines][google.cloud.discoveryengine.v1.EngineService.ListEngines]
        /// API after engine creation.
        ///
        /// [google.cloud.discoveryengine.v1.EngineService.GetEngine]: crate::client::EngineService::get_engine
        /// [google.cloud.discoveryengine.v1.EngineService.ListEngines]: crate::client::EngineService::list_engines
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AgentCreationConfig {
            /// Name of the company, organization or other entity that the agent
            /// represents. Used for knowledge connector LLM prompt and for knowledge
            /// search.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub business: std::string::String,

            /// Required. The default language of the agent as a language tag.
            /// See [Language
            /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
            /// for a list of the currently supported language codes.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub default_language_code: std::string::String,

            /// Required. The time zone of the agent from the [time zone
            /// database](https://www.iana.org/time-zones), e.g., America/New_York,
            /// Europe/Paris.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub time_zone: std::string::String,

            /// Agent location for Agent creation, supported values: global/us/eu.
            /// If not provided, us Engine will create Agent using us-central-1 by
            /// default; eu Engine will create Agent using eu-west-1 by default.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub location: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AgentCreationConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [business][crate::model::engine::chat_engine_config::AgentCreationConfig::business].
            pub fn set_business<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.business = v.into();
                self
            }

            /// Sets the value of [default_language_code][crate::model::engine::chat_engine_config::AgentCreationConfig::default_language_code].
            pub fn set_default_language_code<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.default_language_code = v.into();
                self
            }

            /// Sets the value of [time_zone][crate::model::engine::chat_engine_config::AgentCreationConfig::time_zone].
            pub fn set_time_zone<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.time_zone = v.into();
                self
            }

            /// Sets the value of [location][crate::model::engine::chat_engine_config::AgentCreationConfig::location].
            pub fn set_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.location = v.into();
                self
            }
        }

        impl wkt::message::Message for AgentCreationConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.Engine.ChatEngineConfig.AgentCreationConfig"
            }
        }
    }

    /// Common configurations for an Engine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CommonConfig {
        /// The name of the company, business or entity that is associated with the
        /// engine. Setting this may help improve LLM related features.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub company_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CommonConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [company_name][crate::model::engine::CommonConfig::company_name].
        pub fn set_company_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.company_name = v.into();
            self
        }
    }

    impl wkt::message::Message for CommonConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Engine.CommonConfig"
        }
    }

    /// Additional information of a Chat Engine.
    /// Fields in this message are output only.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ChatEngineMetadata {
        /// The resource name of a Dialogflow agent, that this Chat Engine refers
        /// to.
        ///
        /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
        /// ID>`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dialogflow_agent: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ChatEngineMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dialogflow_agent][crate::model::engine::ChatEngineMetadata::dialogflow_agent].
        pub fn set_dialogflow_agent<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dialogflow_agent = v.into();
            self
        }
    }

    impl wkt::message::Message for ChatEngineMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Engine.ChatEngineMetadata"
        }
    }

    /// Additional config specs that defines the behavior of the engine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EngineConfig {
        /// Configurations for the Chat Engine. Only applicable if
        /// [solution_type][google.cloud.discoveryengine.v1.Engine.solution_type] is
        /// [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT].
        ///
        /// [google.cloud.discoveryengine.v1.Engine.solution_type]: crate::model::Engine::solution_type
        /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT]: crate::model::SolutionType::Chat
        ChatEngineConfig(std::boxed::Box<crate::model::engine::ChatEngineConfig>),
        /// Configurations for the Search Engine. Only applicable if
        /// [solution_type][google.cloud.discoveryengine.v1.Engine.solution_type] is
        /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
        ///
        /// [google.cloud.discoveryengine.v1.Engine.solution_type]: crate::model::Engine::solution_type
        /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
        SearchEngineConfig(std::boxed::Box<crate::model::engine::SearchEngineConfig>),
    }

    /// Engine metadata to monitor the status of the engine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EngineMetadata {
        /// Output only. Additional information of the Chat Engine. Only applicable
        /// if [solution_type][google.cloud.discoveryengine.v1.Engine.solution_type]
        /// is
        /// [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT].
        ///
        /// [google.cloud.discoveryengine.v1.Engine.solution_type]: crate::model::Engine::solution_type
        /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT]: crate::model::SolutionType::Chat
        ChatEngineMetadata(std::boxed::Box<crate::model::engine::ChatEngineMetadata>),
    }
}

/// Request for
/// [EngineService.CreateEngine][google.cloud.discoveryengine.v1.EngineService.CreateEngine]
/// method.
///
/// [google.cloud.discoveryengine.v1.EngineService.CreateEngine]: crate::client::EngineService::create_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEngineRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The [Engine][google.cloud.discoveryengine.v1.Engine] to create.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub engine: std::option::Option<crate::model::Engine>,

    /// Required. The ID to use for the
    /// [Engine][google.cloud.discoveryengine.v1.Engine], which will become the
    /// final component of the [Engine][google.cloud.discoveryengine.v1.Engine]'s
    /// resource name.
    ///
    /// This field must conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
    /// standard with a length limit of 63 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEngineRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [engine][crate::model::CreateEngineRequest::engine].
    pub fn set_engine<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Engine>,
    {
        self.engine = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [engine][crate::model::CreateEngineRequest::engine].
    pub fn set_or_clear_engine<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Engine>,
    {
        self.engine = v.map(|x| x.into());
        self
    }

    /// Sets the value of [engine_id][crate::model::CreateEngineRequest::engine_id].
    pub fn set_engine_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateEngineRequest"
    }
}

/// Metadata related to the progress of the
/// [EngineService.CreateEngine][google.cloud.discoveryengine.v1.EngineService.CreateEngine]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.EngineService.CreateEngine]: crate::client::EngineService::create_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEngineMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEngineMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateEngineMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateEngineMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CreateEngineMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CreateEngineMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateEngineMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateEngineMetadata"
    }
}

/// Request message for
/// [EngineService.DeleteEngine][google.cloud.discoveryengine.v1.EngineService.DeleteEngine]
/// method.
///
/// [google.cloud.discoveryengine.v1.EngineService.DeleteEngine]: crate::client::EngineService::delete_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEngineRequest {
    /// Required. Full resource name of
    /// [Engine][google.cloud.discoveryengine.v1.Engine], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    ///
    /// If the caller does not have permission to delete the
    /// [Engine][google.cloud.discoveryengine.v1.Engine], regardless of whether or
    /// not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [Engine][google.cloud.discoveryengine.v1.Engine] to delete does not
    /// exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteEngineRequest"
    }
}

/// Metadata related to the progress of the
/// [EngineService.DeleteEngine][google.cloud.discoveryengine.v1.EngineService.DeleteEngine]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.EngineService.DeleteEngine]: crate::client::EngineService::delete_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEngineMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEngineMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeleteEngineMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteEngineMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteEngineMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeleteEngineMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteEngineMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteEngineMetadata"
    }
}

/// Request message for
/// [EngineService.GetEngine][google.cloud.discoveryengine.v1.EngineService.GetEngine]
/// method.
///
/// [google.cloud.discoveryengine.v1.EngineService.GetEngine]: crate::client::EngineService::get_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEngineRequest {
    /// Required. Full resource name of
    /// [Engine][google.cloud.discoveryengine.v1.Engine], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetEngineRequest"
    }
}

/// Request message for
/// [EngineService.ListEngines][google.cloud.discoveryengine.v1.EngineService.ListEngines]
/// method.
///
/// [google.cloud.discoveryengine.v1.EngineService.ListEngines]: crate::client::EngineService::list_engines
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnginesRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Not supported.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. Not supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter by solution type. For example:
    /// solution_type=SOLUTION_TYPE_SEARCH
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnginesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnginesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnginesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnginesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEnginesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListEnginesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListEnginesRequest"
    }
}

/// Response message for
/// [EngineService.ListEngines][google.cloud.discoveryengine.v1.EngineService.ListEngines]
/// method.
///
/// [google.cloud.discoveryengine.v1.EngineService.ListEngines]: crate::client::EngineService::list_engines
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnginesResponse {
    /// All the customer's [Engine][google.cloud.discoveryengine.v1.Engine]s.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub engines: std::vec::Vec<crate::model::Engine>,

    /// Not supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnginesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [engines][crate::model::ListEnginesResponse::engines].
    pub fn set_engines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Engine>,
    {
        use std::iter::Iterator;
        self.engines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEnginesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEnginesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListEnginesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnginesResponse {
    type PageItem = crate::model::Engine;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.engines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [EngineService.UpdateEngine][google.cloud.discoveryengine.v1.EngineService.UpdateEngine]
/// method.
///
/// [google.cloud.discoveryengine.v1.EngineService.UpdateEngine]: crate::client::EngineService::update_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEngineRequest {
    /// Required. The [Engine][google.cloud.discoveryengine.v1.Engine] to update.
    ///
    /// If the caller does not have permission to update the
    /// [Engine][google.cloud.discoveryengine.v1.Engine], regardless of whether or
    /// not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [Engine][google.cloud.discoveryengine.v1.Engine] to update does not
    /// exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub engine: std::option::Option<crate::model::Engine>,

    /// Indicates which fields in the provided
    /// [Engine][google.cloud.discoveryengine.v1.Engine] to update.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [engine][crate::model::UpdateEngineRequest::engine].
    pub fn set_engine<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Engine>,
    {
        self.engine = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [engine][crate::model::UpdateEngineRequest::engine].
    pub fn set_or_clear_engine<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Engine>,
    {
        self.engine = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEngineRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEngineRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateEngineRequest"
    }
}

/// Base structured datatype containing multi-part content of a message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundedGenerationContent {
    /// Producer of the content. Must be either `user` or `model`.
    ///
    /// Intended to be used for multi-turn conversations. Otherwise, it can be left
    /// unset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub role: std::string::String,

    /// Ordered `Parts` that constitute a single message.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parts: std::vec::Vec<crate::model::grounded_generation_content::Part>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GroundedGenerationContent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::GroundedGenerationContent::role].
    pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [parts][crate::model::GroundedGenerationContent::parts].
    pub fn set_parts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::grounded_generation_content::Part>,
    {
        use std::iter::Iterator;
        self.parts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GroundedGenerationContent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GroundedGenerationContent"
    }
}

/// Defines additional types related to [GroundedGenerationContent].
pub mod grounded_generation_content {
    #[allow(unused_imports)]
    use super::*;

    /// Single part of content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Part {
        /// Holder of data. It only supports text for now.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub data: std::option::Option<crate::model::grounded_generation_content::part::Data>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Part {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data][crate::model::grounded_generation_content::Part::data].
        ///
        /// Note that all the setters affecting `data` are mutually
        /// exclusive.
        pub fn set_data<
            T: std::convert::Into<
                    std::option::Option<crate::model::grounded_generation_content::part::Data>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.data = v.into();
            self
        }

        /// The value of [data][crate::model::grounded_generation_content::Part::data]
        /// if it holds a `Text`, `None` if the field is not set or
        /// holds a different branch.
        pub fn text(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.data.as_ref().and_then(|v| match v {
                crate::model::grounded_generation_content::part::Data::Text(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [data][crate::model::grounded_generation_content::Part::data]
        /// to hold a `Text`.
        ///
        /// Note that all the setters affecting `data` are
        /// mutually exclusive.
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data = std::option::Option::Some(
                crate::model::grounded_generation_content::part::Data::Text(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Part {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.GroundedGenerationContent.Part"
        }
    }

    /// Defines additional types related to [Part].
    pub mod part {
        #[allow(unused_imports)]
        use super::*;

        /// Holder of data. It only supports text for now.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Data {
            /// Inline text.
            Text(std::string::String),
        }
    }
}

/// Top-level message sent by the client for the `GenerateGroundedContent`
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateGroundedContentRequest {
    /// Required. Location resource.
    ///
    /// Format: `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Content of the system instruction for the current API.
    ///
    /// These instructions will take priority over any other prompt instructions
    /// if the selected model is supporting them.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_instruction: std::option::Option<crate::model::GroundedGenerationContent>,

    /// Content of the current conversation with the model.
    ///
    /// For single-turn queries, this is a single instance. For multi-turn queries,
    /// this is a repeated field that contains conversation history + latest
    /// request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub contents: std::vec::Vec<crate::model::GroundedGenerationContent>,

    /// Content generation specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub generation_spec:
        std::option::Option<crate::model::generate_grounded_content_request::GenerationSpec>,

    /// Grounding specification.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub grounding_spec:
        std::option::Option<crate::model::generate_grounded_content_request::GroundingSpec>,

    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateGroundedContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::GenerateGroundedContentRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [system_instruction][crate::model::GenerateGroundedContentRequest::system_instruction].
    pub fn set_system_instruction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GroundedGenerationContent>,
    {
        self.system_instruction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [system_instruction][crate::model::GenerateGroundedContentRequest::system_instruction].
    pub fn set_or_clear_system_instruction<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GroundedGenerationContent>,
    {
        self.system_instruction = v.map(|x| x.into());
        self
    }

    /// Sets the value of [contents][crate::model::GenerateGroundedContentRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroundedGenerationContent>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [generation_spec][crate::model::GenerateGroundedContentRequest::generation_spec].
    pub fn set_generation_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::generate_grounded_content_request::GenerationSpec>,
    {
        self.generation_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generation_spec][crate::model::GenerateGroundedContentRequest::generation_spec].
    pub fn set_or_clear_generation_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::generate_grounded_content_request::GenerationSpec>,
    {
        self.generation_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [grounding_spec][crate::model::GenerateGroundedContentRequest::grounding_spec].
    pub fn set_grounding_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::generate_grounded_content_request::GroundingSpec>,
    {
        self.grounding_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [grounding_spec][crate::model::GenerateGroundedContentRequest::grounding_spec].
    pub fn set_or_clear_grounding_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::generate_grounded_content_request::GroundingSpec>,
    {
        self.grounding_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_labels][crate::model::GenerateGroundedContentRequest::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for GenerateGroundedContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest"
    }
}

/// Defines additional types related to [GenerateGroundedContentRequest].
pub mod generate_grounded_content_request {
    #[allow(unused_imports)]
    use super::*;

    /// Content generation specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GenerationSpec {
        /// Specifies which Vertex model id to use for generation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub model_id: std::string::String,

        /// Language code for content. Use language tags defined by
        /// [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub language_code: std::string::String,

        /// If specified, custom value for the temperature will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
        pub temperature: std::option::Option<f32>,

        /// If specified, custom value for nucleus sampling will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
        pub top_p: std::option::Option<f32>,

        /// If specified, custom value for top-k sampling will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
        pub top_k: std::option::Option<i32>,

        /// If specified, custom value for frequency penalty will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
        pub frequency_penalty: std::option::Option<f32>,

        /// If specified, custom value for the seed will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
        pub seed: std::option::Option<i32>,

        /// If specified, custom value for presence penalty will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
        pub presence_penalty: std::option::Option<f32>,

        /// If specified, custom value for max output tokens will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
        pub max_output_tokens: std::option::Option<i32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GenerationSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model_id][crate::model::generate_grounded_content_request::GenerationSpec::model_id].
        pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model_id = v.into();
            self
        }

        /// Sets the value of [language_code][crate::model::generate_grounded_content_request::GenerationSpec::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }

        /// Sets the value of [temperature][crate::model::generate_grounded_content_request::GenerationSpec::temperature].
        pub fn set_temperature<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.temperature = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [temperature][crate::model::generate_grounded_content_request::GenerationSpec::temperature].
        pub fn set_or_clear_temperature<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.temperature = v.map(|x| x.into());
            self
        }

        /// Sets the value of [top_p][crate::model::generate_grounded_content_request::GenerationSpec::top_p].
        pub fn set_top_p<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.top_p = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [top_p][crate::model::generate_grounded_content_request::GenerationSpec::top_p].
        pub fn set_or_clear_top_p<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.top_p = v.map(|x| x.into());
            self
        }

        /// Sets the value of [top_k][crate::model::generate_grounded_content_request::GenerationSpec::top_k].
        pub fn set_top_k<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.top_k = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [top_k][crate::model::generate_grounded_content_request::GenerationSpec::top_k].
        pub fn set_or_clear_top_k<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.top_k = v.map(|x| x.into());
            self
        }

        /// Sets the value of [frequency_penalty][crate::model::generate_grounded_content_request::GenerationSpec::frequency_penalty].
        pub fn set_frequency_penalty<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.frequency_penalty = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [frequency_penalty][crate::model::generate_grounded_content_request::GenerationSpec::frequency_penalty].
        pub fn set_or_clear_frequency_penalty<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.frequency_penalty = v.map(|x| x.into());
            self
        }

        /// Sets the value of [seed][crate::model::generate_grounded_content_request::GenerationSpec::seed].
        pub fn set_seed<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.seed = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [seed][crate::model::generate_grounded_content_request::GenerationSpec::seed].
        pub fn set_or_clear_seed<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.seed = v.map(|x| x.into());
            self
        }

        /// Sets the value of [presence_penalty][crate::model::generate_grounded_content_request::GenerationSpec::presence_penalty].
        pub fn set_presence_penalty<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.presence_penalty = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [presence_penalty][crate::model::generate_grounded_content_request::GenerationSpec::presence_penalty].
        pub fn set_or_clear_presence_penalty<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.presence_penalty = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_output_tokens][crate::model::generate_grounded_content_request::GenerationSpec::max_output_tokens].
        pub fn set_max_output_tokens<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_output_tokens = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_output_tokens][crate::model::generate_grounded_content_request::GenerationSpec::max_output_tokens].
        pub fn set_or_clear_max_output_tokens<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_output_tokens = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for GenerationSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.GenerationSpec"
        }
    }

    /// Describes the options to customize dynamic retrieval.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DynamicRetrievalConfiguration {

        /// Specification for the predictor for dynamic retrieval.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub predictor: std::option::Option<crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::DynamicRetrievalPredictor>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DynamicRetrievalConfiguration {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [predictor][crate::model::generate_grounded_content_request::DynamicRetrievalConfiguration::predictor].
        pub fn set_predictor<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::DynamicRetrievalPredictor>
        {
            self.predictor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [predictor][crate::model::generate_grounded_content_request::DynamicRetrievalConfiguration::predictor].
        pub fn set_or_clear_predictor<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::DynamicRetrievalPredictor>
        {
            self.predictor = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DynamicRetrievalConfiguration {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.DynamicRetrievalConfiguration"
        }
    }

    /// Defines additional types related to [DynamicRetrievalConfiguration].
    pub mod dynamic_retrieval_configuration {
        #[allow(unused_imports)]
        use super::*;

        /// Describes the predictor settings for dynamic retrieval.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct DynamicRetrievalPredictor {

            /// The version of the predictor to be used in dynamic retrieval.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub version: crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::dynamic_retrieval_predictor::Version,

            /// The value of the threshold. If the predictor will predict a
            /// value smaller than this, it would suppress grounding in the source.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
            pub threshold: std::option::Option<f32>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DynamicRetrievalPredictor {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [version][crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::DynamicRetrievalPredictor::version].
            pub fn set_version<T: std::convert::Into<crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::dynamic_retrieval_predictor::Version>>(mut self, v: T) -> Self{
                self.version = v.into();
                self
            }

            /// Sets the value of [threshold][crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::DynamicRetrievalPredictor::threshold].
            pub fn set_threshold<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<f32>,
            {
                self.threshold = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [threshold][crate::model::generate_grounded_content_request::dynamic_retrieval_configuration::DynamicRetrievalPredictor::threshold].
            pub fn set_or_clear_threshold<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<f32>,
            {
                self.threshold = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for DynamicRetrievalPredictor {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.DynamicRetrievalConfiguration.DynamicRetrievalPredictor"
            }
        }

        /// Defines additional types related to [DynamicRetrievalPredictor].
        pub mod dynamic_retrieval_predictor {
            #[allow(unused_imports)]
            use super::*;

            /// The version of the predictor to be used in dynamic retrieval.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Version {
                /// Automatically choose the best version of the retrieval predictor.
                Unspecified,
                /// The V1 model which is evaluating each source independently.
                V1Independent,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Version::value] or
                /// [Version::name].
                UnknownValue(version::UnknownValue),
            }

            #[doc(hidden)]
            pub mod version {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Version {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::V1Independent => std::option::Option::Some(1),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("VERSION_UNSPECIFIED"),
                        Self::V1Independent => std::option::Option::Some("V1_INDEPENDENT"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Version {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Version {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Version {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::V1Independent,
                        _ => Self::UnknownValue(version::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Version {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "VERSION_UNSPECIFIED" => Self::Unspecified,
                        "V1_INDEPENDENT" => Self::V1Independent,
                        _ => Self::UnknownValue(version::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Version {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::V1Independent => serializer.serialize_i32(1),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Version {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Version>::new(
                        ".google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.DynamicRetrievalConfiguration.DynamicRetrievalPredictor.Version"))
                }
            }
        }
    }

    /// Grounding source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroundingSource {
        /// Sources.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub source: std::option::Option<
            crate::model::generate_grounded_content_request::grounding_source::Source,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroundingSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::generate_grounded_content_request::GroundingSource::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::generate_grounded_content_request::grounding_source::Source,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// if it holds a `InlineSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn inline_source(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::generate_grounded_content_request::grounding_source::InlineSource,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::generate_grounded_content_request::grounding_source::Source::InlineSource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// to hold a `InlineSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_inline_source<T: std::convert::Into<std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::InlineSource>>>(mut self, v: T) -> Self{
            self.source = std::option::Option::Some(
                crate::model::generate_grounded_content_request::grounding_source::Source::InlineSource(
                    v.into()
                )
            );
            self
        }

        /// The value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// if it holds a `SearchSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn search_source(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::generate_grounded_content_request::grounding_source::SearchSource,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::generate_grounded_content_request::grounding_source::Source::SearchSource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// to hold a `SearchSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_search_source<T: std::convert::Into<std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::SearchSource>>>(mut self, v: T) -> Self{
            self.source = std::option::Option::Some(
                crate::model::generate_grounded_content_request::grounding_source::Source::SearchSource(
                    v.into()
                )
            );
            self
        }

        /// The value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// if it holds a `GoogleSearchSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn google_search_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::GoogleSearchSource>>{
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::generate_grounded_content_request::grounding_source::Source::GoogleSearchSource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// to hold a `GoogleSearchSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_google_search_source<T: std::convert::Into<std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::GoogleSearchSource>>>(mut self, v: T) -> Self{
            self.source = std::option::Option::Some(
                crate::model::generate_grounded_content_request::grounding_source::Source::GoogleSearchSource(
                    v.into()
                )
            );
            self
        }

        /// The value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// if it holds a `EnterpriseWebRetrievalSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn enterprise_web_retrieval_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::EnterpriseWebRetrievalSource>>{
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::generate_grounded_content_request::grounding_source::Source::EnterpriseWebRetrievalSource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::generate_grounded_content_request::GroundingSource::source]
        /// to hold a `EnterpriseWebRetrievalSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_enterprise_web_retrieval_source<T: std::convert::Into<std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::EnterpriseWebRetrievalSource>>>(mut self, v: T) -> Self{
            self.source = std::option::Option::Some(
                crate::model::generate_grounded_content_request::grounding_source::Source::EnterpriseWebRetrievalSource(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for GroundingSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.GroundingSource"
        }
    }

    /// Defines additional types related to [GroundingSource].
    pub mod grounding_source {
        #[allow(unused_imports)]
        use super::*;

        /// Message to be used for grounding based on inline content.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct InlineSource {
            /// List of facts to be used for grounding.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub grounding_facts: std::vec::Vec<crate::model::GroundingFact>,

            /// Attributes associated with the content.
            ///
            /// Common attributes include `source` (indicating where the content was
            /// sourced from) and `author` (indicating the author of the content).
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl InlineSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [grounding_facts][crate::model::generate_grounded_content_request::grounding_source::InlineSource::grounding_facts].
            pub fn set_grounding_facts<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::GroundingFact>,
            {
                use std::iter::Iterator;
                self.grounding_facts = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [attributes][crate::model::generate_grounded_content_request::grounding_source::InlineSource::attributes].
            pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for InlineSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.GroundingSource.InlineSource"
            }
        }

        /// Message to be used for grounding with Vertex AI Search.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SearchSource {
            /// The resource name of the Engine to use.
            ///
            /// Format:
            /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub serving_config: std::string::String,

            /// Number of search results to return.
            ///
            /// The default value is 10. The maximumm allowed value is 10.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub max_result_count: i32,

            /// Filter expression to be applied to the search.
            ///
            /// The syntax is the same as
            /// [SearchRequest.filter][google.cloud.discoveryengine.v1.SearchRequest.filter].
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.filter]: crate::model::SearchRequest::filter
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub filter: std::string::String,

            /// If set, safe search is enabled in Vertex AI Search requests.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub safe_search: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SearchSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [serving_config][crate::model::generate_grounded_content_request::grounding_source::SearchSource::serving_config].
            pub fn set_serving_config<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.serving_config = v.into();
                self
            }

            /// Sets the value of [max_result_count][crate::model::generate_grounded_content_request::grounding_source::SearchSource::max_result_count].
            pub fn set_max_result_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_result_count = v.into();
                self
            }

            /// Sets the value of [filter][crate::model::generate_grounded_content_request::grounding_source::SearchSource::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }

            /// Sets the value of [safe_search][crate::model::generate_grounded_content_request::grounding_source::SearchSource::safe_search].
            pub fn set_safe_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.safe_search = v.into();
                self
            }
        }

        impl wkt::message::Message for SearchSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.GroundingSource.SearchSource"
            }
        }

        /// Google Search config parameters.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct GoogleSearchSource {
            /// Optional. Specifies the dynamic retrieval configuration for the given
            /// source.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub dynamic_retrieval_config: std::option::Option<
                crate::model::generate_grounded_content_request::DynamicRetrievalConfiguration,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GoogleSearchSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [dynamic_retrieval_config][crate::model::generate_grounded_content_request::grounding_source::GoogleSearchSource::dynamic_retrieval_config].
            pub fn set_dynamic_retrieval_config<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::generate_grounded_content_request::DynamicRetrievalConfiguration>
            {
                self.dynamic_retrieval_config = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [dynamic_retrieval_config][crate::model::generate_grounded_content_request::grounding_source::GoogleSearchSource::dynamic_retrieval_config].
            pub fn set_or_clear_dynamic_retrieval_config<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::generate_grounded_content_request::DynamicRetrievalConfiguration>
            {
                self.dynamic_retrieval_config = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for GoogleSearchSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.GroundingSource.GoogleSearchSource"
            }
        }

        /// Params for using enterprise web retrieval as grounding source.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct EnterpriseWebRetrievalSource {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EnterpriseWebRetrievalSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for EnterpriseWebRetrievalSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.GroundingSource.EnterpriseWebRetrievalSource"
            }
        }

        /// Sources.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Source {
            /// If set, grounding is performed with inline content.
            InlineSource(std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::InlineSource>),
            /// If set, grounding is performed with Vertex AI Search.
            SearchSource(std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::SearchSource>),
            /// If set, grounding is performed with Google Search.
            GoogleSearchSource(std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::GoogleSearchSource>),
            /// If set, grounding is performed with enterprise web retrieval.
            EnterpriseWebRetrievalSource(std::boxed::Box<crate::model::generate_grounded_content_request::grounding_source::EnterpriseWebRetrievalSource>),
        }
    }

    /// Grounding specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroundingSpec {
        /// Grounding sources.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub grounding_sources:
            std::vec::Vec<crate::model::generate_grounded_content_request::GroundingSource>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroundingSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [grounding_sources][crate::model::generate_grounded_content_request::GroundingSpec::grounding_sources].
        pub fn set_grounding_sources<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::generate_grounded_content_request::GroundingSource>,
        {
            use std::iter::Iterator;
            self.grounding_sources = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GroundingSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentRequest.GroundingSpec"
        }
    }
}

/// Response for the `GenerateGroundedContent` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateGroundedContentResponse {
    /// Generated candidates.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub candidates: std::vec::Vec<crate::model::generate_grounded_content_response::Candidate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateGroundedContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [candidates][crate::model::GenerateGroundedContentResponse::candidates].
    pub fn set_candidates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::generate_grounded_content_response::Candidate>,
    {
        use std::iter::Iterator;
        self.candidates = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerateGroundedContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse"
    }
}

/// Defines additional types related to [GenerateGroundedContentResponse].
pub mod generate_grounded_content_response {
    #[allow(unused_imports)]
    use super::*;

    /// A response candidate generated from the model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Candidate {
        /// Index of the candidate.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub index: i32,

        /// Content of the candidate.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub content: std::option::Option<crate::model::GroundedGenerationContent>,

        /// The overall grounding score for the candidate, in the range of [0, 1].
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
        pub grounding_score: std::option::Option<f32>,

        /// Grounding metadata for the generated content.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub grounding_metadata: std::option::Option<
            crate::model::generate_grounded_content_response::candidate::GroundingMetadata,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Candidate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index][crate::model::generate_grounded_content_response::Candidate::index].
        pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.index = v.into();
            self
        }

        /// Sets the value of [content][crate::model::generate_grounded_content_response::Candidate::content].
        pub fn set_content<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GroundedGenerationContent>,
        {
            self.content = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [content][crate::model::generate_grounded_content_response::Candidate::content].
        pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GroundedGenerationContent>,
        {
            self.content = v.map(|x| x.into());
            self
        }

        /// Sets the value of [grounding_score][crate::model::generate_grounded_content_response::Candidate::grounding_score].
        pub fn set_grounding_score<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.grounding_score = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [grounding_score][crate::model::generate_grounded_content_response::Candidate::grounding_score].
        pub fn set_or_clear_grounding_score<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.grounding_score = v.map(|x| x.into());
            self
        }

        /// Sets the value of [grounding_metadata][crate::model::generate_grounded_content_response::Candidate::grounding_metadata].
        pub fn set_grounding_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::generate_grounded_content_response::candidate::GroundingMetadata,
                >,
        {
            self.grounding_metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [grounding_metadata][crate::model::generate_grounded_content_response::Candidate::grounding_metadata].
        pub fn set_or_clear_grounding_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::generate_grounded_content_response::candidate::GroundingMetadata,
                >,
        {
            self.grounding_metadata = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Candidate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate"
        }
    }

    /// Defines additional types related to [Candidate].
    pub mod candidate {
        #[allow(unused_imports)]
        use super::*;

        /// Citation for the generated content.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct GroundingMetadata {

            /// Retrieval metadata to provide an understanding in the
            /// retrieval steps performed by the model. There can be multiple such
            /// messages which can correspond to different parts of the retrieval. This
            /// is a mechanism used to ensure transparency to our users.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub retrieval_metadata: std::vec::Vec<crate::model::generate_grounded_content_response::candidate::grounding_metadata::RetrievalMetadata>,

            /// List of chunks to be attributed across all claims in the candidate.
            /// These are derived from the grounding sources supplied in the request.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub support_chunks: std::vec::Vec<crate::model::FactChunk>,

            /// Web search queries for the following-up web search.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub web_search_queries: std::vec::Vec<std::string::String>,

            /// Google search entry for the following-up web searches.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub search_entry_point: std::option::Option<crate::model::generate_grounded_content_response::candidate::grounding_metadata::SearchEntryPoint>,

            /// GroundingSupport across all claims in the answer candidate.
            /// An support to a fact indicates that the claim is supported by
            /// the fact.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub grounding_support: std::vec::Vec<crate::model::generate_grounded_content_response::candidate::grounding_metadata::GroundingSupport>,

            /// Images from the web search.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub images: std::vec::Vec<crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GroundingMetadata {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [retrieval_metadata][crate::model::generate_grounded_content_response::candidate::GroundingMetadata::retrieval_metadata].
            pub fn set_retrieval_metadata<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::RetrievalMetadata>
            {
                use std::iter::Iterator;
                self.retrieval_metadata = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [support_chunks][crate::model::generate_grounded_content_response::candidate::GroundingMetadata::support_chunks].
            pub fn set_support_chunks<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::FactChunk>,
            {
                use std::iter::Iterator;
                self.support_chunks = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [web_search_queries][crate::model::generate_grounded_content_response::candidate::GroundingMetadata::web_search_queries].
            pub fn set_web_search_queries<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.web_search_queries = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [search_entry_point][crate::model::generate_grounded_content_response::candidate::GroundingMetadata::search_entry_point].
            pub fn set_search_entry_point<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::SearchEntryPoint>
            {
                self.search_entry_point = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [search_entry_point][crate::model::generate_grounded_content_response::candidate::GroundingMetadata::search_entry_point].
            pub fn set_or_clear_search_entry_point<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::SearchEntryPoint>
            {
                self.search_entry_point = v.map(|x| x.into());
                self
            }

            /// Sets the value of [grounding_support][crate::model::generate_grounded_content_response::candidate::GroundingMetadata::grounding_support].
            pub fn set_grounding_support<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::GroundingSupport>
            {
                use std::iter::Iterator;
                self.grounding_support = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [images][crate::model::generate_grounded_content_response::candidate::GroundingMetadata::images].
            pub fn set_images<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata>
            {
                use std::iter::Iterator;
                self.images = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for GroundingMetadata {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata"
            }
        }

        /// Defines additional types related to [GroundingMetadata].
        pub mod grounding_metadata {
            #[allow(unused_imports)]
            use super::*;

            /// Describes the metadata associated with a retrieval step.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct RetrievalMetadata {

                /// Describes the source to which the metadata is referring to.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub source: crate::model::generate_grounded_content_response::candidate::grounding_metadata::retrieval_metadata::Source,

                /// Metadata for dynamic retrieval.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub dynamic_retrieval_metadata: std::option::Option<crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalMetadata>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl RetrievalMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [source][crate::model::generate_grounded_content_response::candidate::grounding_metadata::RetrievalMetadata::source].
                pub fn set_source<T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::retrieval_metadata::Source>>(mut self, v: T) -> Self{
                    self.source = v.into();
                    self
                }

                /// Sets the value of [dynamic_retrieval_metadata][crate::model::generate_grounded_content_response::candidate::grounding_metadata::RetrievalMetadata::dynamic_retrieval_metadata].
                pub fn set_dynamic_retrieval_metadata<T>(mut self, v: T) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalMetadata>
                {
                    self.dynamic_retrieval_metadata = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [dynamic_retrieval_metadata][crate::model::generate_grounded_content_response::candidate::grounding_metadata::RetrievalMetadata::dynamic_retrieval_metadata].
                pub fn set_or_clear_dynamic_retrieval_metadata<T>(mut self, v: std::option::Option<T>) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalMetadata>
                {
                    self.dynamic_retrieval_metadata = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for RetrievalMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.RetrievalMetadata"
                }
            }

            /// Defines additional types related to [RetrievalMetadata].
            pub mod retrieval_metadata {
                #[allow(unused_imports)]
                use super::*;

                /// Describes the source to which the metadata is associated to.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Source {
                    /// Unspecified source.
                    Unspecified,
                    /// Vertex AI search.
                    VertexAiSearch,
                    /// Google Search.
                    GoogleSearch,
                    /// User inline provided content.
                    InlineContent,
                    /// Google Maps.
                    GoogleMaps,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [Source::value] or
                    /// [Source::name].
                    UnknownValue(source::UnknownValue),
                }

                #[doc(hidden)]
                pub mod source {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl Source {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::VertexAiSearch => std::option::Option::Some(1),
                            Self::GoogleSearch => std::option::Option::Some(3),
                            Self::InlineContent => std::option::Option::Some(2),
                            Self::GoogleMaps => std::option::Option::Some(4),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => std::option::Option::Some("SOURCE_UNSPECIFIED"),
                            Self::VertexAiSearch => std::option::Option::Some("VERTEX_AI_SEARCH"),
                            Self::GoogleSearch => std::option::Option::Some("GOOGLE_SEARCH"),
                            Self::InlineContent => std::option::Option::Some("INLINE_CONTENT"),
                            Self::GoogleMaps => std::option::Option::Some("GOOGLE_MAPS"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for Source {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for Source {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for Source {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::VertexAiSearch,
                            2 => Self::InlineContent,
                            3 => Self::GoogleSearch,
                            4 => Self::GoogleMaps,
                            _ => Self::UnknownValue(source::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for Source {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "SOURCE_UNSPECIFIED" => Self::Unspecified,
                            "VERTEX_AI_SEARCH" => Self::VertexAiSearch,
                            "GOOGLE_SEARCH" => Self::GoogleSearch,
                            "INLINE_CONTENT" => Self::InlineContent,
                            "GOOGLE_MAPS" => Self::GoogleMaps,
                            _ => Self::UnknownValue(source::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for Source {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::VertexAiSearch => serializer.serialize_i32(1),
                            Self::GoogleSearch => serializer.serialize_i32(3),
                            Self::InlineContent => serializer.serialize_i32(2),
                            Self::GoogleMaps => serializer.serialize_i32(4),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for Source {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Source>::new(
                            ".google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.RetrievalMetadata.Source"))
                    }
                }
            }

            /// Describes the metadata about dynamic retrieval.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DynamicRetrievalMetadata {

                /// Metadata for the dynamic retrieval predictor.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub predictor_metadata: std::option::Option<crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalPredictorMetadata>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DynamicRetrievalMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [predictor_metadata][crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalMetadata::predictor_metadata].
                pub fn set_predictor_metadata<T>(mut self, v: T) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalPredictorMetadata>
                {
                    self.predictor_metadata = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [predictor_metadata][crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalMetadata::predictor_metadata].
                pub fn set_or_clear_predictor_metadata<T>(mut self, v: std::option::Option<T>) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalPredictorMetadata>
                {
                    self.predictor_metadata = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for DynamicRetrievalMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.DynamicRetrievalMetadata"
                }
            }

            /// Describes the metadata about the dynamic retrieval predictor.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct DynamicRetrievalPredictorMetadata {

                /// The version of the predictor which was used in dynamic retrieval.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub version: crate::model::generate_grounded_content_response::candidate::grounding_metadata::dynamic_retrieval_predictor_metadata::Version,

                /// The value of the predictor. This should be between [0, 1] where
                /// a value of 0 means that the query would not benefit from grounding,
                /// while a value of 1.0 means that the query would benefit the most.
                /// In between values allow to differentiate between different usefulness
                /// scores for grounding.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                pub prediction: std::option::Option<f32>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DynamicRetrievalPredictorMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [version][crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalPredictorMetadata::version].
                pub fn set_version<T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::dynamic_retrieval_predictor_metadata::Version>>(mut self, v: T) -> Self{
                    self.version = v.into();
                    self
                }

                /// Sets the value of [prediction][crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalPredictorMetadata::prediction].
                pub fn set_prediction<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.prediction = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [prediction][crate::model::generate_grounded_content_response::candidate::grounding_metadata::DynamicRetrievalPredictorMetadata::prediction].
                pub fn set_or_clear_prediction<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.prediction = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for DynamicRetrievalPredictorMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.DynamicRetrievalPredictorMetadata"
                }
            }

            /// Defines additional types related to [DynamicRetrievalPredictorMetadata].
            pub mod dynamic_retrieval_predictor_metadata {
                #[allow(unused_imports)]
                use super::*;

                /// The version of the predictor which was used in dynamic retrieval.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Version {
                    /// Unspecified version, should never be used.
                    Unspecified,
                    /// The V1 model which is evaluating each source independently.
                    V1Independent,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [Version::value] or
                    /// [Version::name].
                    UnknownValue(version::UnknownValue),
                }

                #[doc(hidden)]
                pub mod version {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl Version {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::V1Independent => std::option::Option::Some(1),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => std::option::Option::Some("VERSION_UNSPECIFIED"),
                            Self::V1Independent => std::option::Option::Some("V1_INDEPENDENT"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for Version {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for Version {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for Version {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::V1Independent,
                            _ => Self::UnknownValue(version::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for Version {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "VERSION_UNSPECIFIED" => Self::Unspecified,
                            "V1_INDEPENDENT" => Self::V1Independent,
                            _ => Self::UnknownValue(version::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for Version {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::V1Independent => serializer.serialize_i32(1),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for Version {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Version>::new(
                            ".google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.DynamicRetrievalPredictorMetadata.Version"))
                    }
                }
            }

            /// Google search entry point.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct SearchEntryPoint {
                /// Web content snippet that can be embedded in a web page or an app
                /// webview.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub rendered_content: std::string::String,

                /// Base64 encoded JSON representing array of <search term, search url>
                /// tuple.
                #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
                #[serde_as(as = "serde_with::base64::Base64")]
                pub sdk_blob: ::bytes::Bytes,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl SearchEntryPoint {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [rendered_content][crate::model::generate_grounded_content_response::candidate::grounding_metadata::SearchEntryPoint::rendered_content].
                pub fn set_rendered_content<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.rendered_content = v.into();
                    self
                }

                /// Sets the value of [sdk_blob][crate::model::generate_grounded_content_response::candidate::grounding_metadata::SearchEntryPoint::sdk_blob].
                pub fn set_sdk_blob<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
                    self.sdk_blob = v.into();
                    self
                }
            }

            impl wkt::message::Message for SearchEntryPoint {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.SearchEntryPoint"
                }
            }

            /// Grounding info for a claim in the candidate and its support.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct GroundingSupport {
                /// Text for the claim in the candidate. Always provided when a
                /// support is found.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub claim_text: std::string::String,

                /// A list of indices (into 'support_chunks') specifying the
                /// citations associated with the claim. For instance [1,3,4] means
                /// that support_chunks[1], support_chunks[3],
                /// support_chunks[4] are the chunks attributed to the claim.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                #[serde_as(as = "std::vec::Vec<wkt::internal::I32>")]
                pub support_chunk_indices: std::vec::Vec<i32>,

                /// A score in the range of [0, 1] describing how grounded is a specific
                /// claim in the support chunks indicated.
                /// Higher value means that the claim is better supported by the chunks.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
                pub support_score: std::option::Option<f32>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GroundingSupport {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [claim_text][crate::model::generate_grounded_content_response::candidate::grounding_metadata::GroundingSupport::claim_text].
                pub fn set_claim_text<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.claim_text = v.into();
                    self
                }

                /// Sets the value of [support_chunk_indices][crate::model::generate_grounded_content_response::candidate::grounding_metadata::GroundingSupport::support_chunk_indices].
                pub fn set_support_chunk_indices<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<i32>,
                {
                    use std::iter::Iterator;
                    self.support_chunk_indices = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [support_score][crate::model::generate_grounded_content_response::candidate::grounding_metadata::GroundingSupport::support_score].
                pub fn set_support_score<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.support_score = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [support_score][crate::model::generate_grounded_content_response::candidate::grounding_metadata::GroundingSupport::support_score].
                pub fn set_or_clear_support_score<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<f32>,
                {
                    self.support_score = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for GroundingSupport {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.GroundingSupport"
                }
            }

            /// Metadata about an image from the web search.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ImageMetadata {

                /// Metadata about the full size image.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub image: std::option::Option<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image>,

                /// Metadata about the thumbnail.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub thumbnail: std::option::Option<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image>,

                /// The details about the website that the image is from.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub source: std::option::Option<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::WebsiteInfo>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ImageMetadata {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [image][crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata::image].
                pub fn set_image<T>(mut self, v: T) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image>
                {
                    self.image = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [image][crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata::image].
                pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image>
                {
                    self.image = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [thumbnail][crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata::thumbnail].
                pub fn set_thumbnail<T>(mut self, v: T) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image>
                {
                    self.thumbnail = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [thumbnail][crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata::thumbnail].
                pub fn set_or_clear_thumbnail<T>(mut self, v: std::option::Option<T>) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image>
                {
                    self.thumbnail = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [source][crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata::source].
                pub fn set_source<T>(mut self, v: T) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::WebsiteInfo>
                {
                    self.source = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [source][crate::model::generate_grounded_content_response::candidate::grounding_metadata::ImageMetadata::source].
                pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
                where T: std::convert::Into<crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::WebsiteInfo>
                {
                    self.source = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ImageMetadata {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.ImageMetadata"
                }
            }

            /// Defines additional types related to [ImageMetadata].
            pub mod image_metadata {
                #[allow(unused_imports)]
                use super::*;

                /// Metadata about the website that the image is from.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct WebsiteInfo {
                    /// The url of the website.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub uri: std::string::String,

                    /// The title of the website.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub title: std::string::String,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl WebsiteInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [uri][crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::WebsiteInfo::uri].
                    pub fn set_uri<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.uri = v.into();
                        self
                    }

                    /// Sets the value of [title][crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::WebsiteInfo::title].
                    pub fn set_title<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.title = v.into();
                        self
                    }
                }

                impl wkt::message::Message for WebsiteInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.ImageMetadata.WebsiteInfo"
                    }
                }

                /// Metadata about the image.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct Image {
                    /// The url of the image.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub uri: std::string::String,

                    /// The width of the image in pixels.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::I32")]
                    pub width: i32,

                    /// The height of the image in pixels.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::I32")]
                    pub height: i32,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl Image {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [uri][crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image::uri].
                    pub fn set_uri<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.uri = v.into();
                        self
                    }

                    /// Sets the value of [width][crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image::width].
                    pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                        self.width = v.into();
                        self
                    }

                    /// Sets the value of [height][crate::model::generate_grounded_content_response::candidate::grounding_metadata::image_metadata::Image::height].
                    pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                        self.height = v.into();
                        self
                    }
                }

                impl wkt::message::Message for Image {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.discoveryengine.v1.GenerateGroundedContentResponse.Candidate.GroundingMetadata.ImageMetadata.Image"
                    }
                }
            }
        }
    }
}

/// Specification for the grounding check.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckGroundingSpec {
    /// The threshold (in [0,1]) used for determining whether a fact must be
    /// cited for a claim in the answer candidate. Choosing a higher threshold
    /// will lead to fewer but very strong citations, while choosing a lower
    /// threshold may lead to more but somewhat weaker citations. If unset, the
    /// threshold will default to 0.6.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub citation_threshold: std::option::Option<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckGroundingSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [citation_threshold][crate::model::CheckGroundingSpec::citation_threshold].
    pub fn set_citation_threshold<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.citation_threshold = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [citation_threshold][crate::model::CheckGroundingSpec::citation_threshold].
    pub fn set_or_clear_citation_threshold<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.citation_threshold = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CheckGroundingSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CheckGroundingSpec"
    }
}

/// Request message for
/// [GroundedGenerationService.CheckGrounding][google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding]
/// method.
///
/// [google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding]: crate::client::GroundedGenerationService::check_grounding
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckGroundingRequest {
    /// Required. The resource name of the grounding config, such as
    /// `projects/*/locations/global/groundingConfigs/default_grounding_config`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub grounding_config: std::string::String,

    /// Answer candidate to check. It can have a maximum length of 4096 tokens.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub answer_candidate: std::string::String,

    /// List of facts for the grounding check.
    /// We support up to 200 facts.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub facts: std::vec::Vec<crate::model::GroundingFact>,

    /// Configuration of the grounding check.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub grounding_spec: std::option::Option<crate::model::CheckGroundingSpec>,

    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckGroundingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [grounding_config][crate::model::CheckGroundingRequest::grounding_config].
    pub fn set_grounding_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.grounding_config = v.into();
        self
    }

    /// Sets the value of [answer_candidate][crate::model::CheckGroundingRequest::answer_candidate].
    pub fn set_answer_candidate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.answer_candidate = v.into();
        self
    }

    /// Sets the value of [facts][crate::model::CheckGroundingRequest::facts].
    pub fn set_facts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GroundingFact>,
    {
        use std::iter::Iterator;
        self.facts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grounding_spec][crate::model::CheckGroundingRequest::grounding_spec].
    pub fn set_grounding_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CheckGroundingSpec>,
    {
        self.grounding_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [grounding_spec][crate::model::CheckGroundingRequest::grounding_spec].
    pub fn set_or_clear_grounding_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CheckGroundingSpec>,
    {
        self.grounding_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_labels][crate::model::CheckGroundingRequest::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CheckGroundingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CheckGroundingRequest"
    }
}

/// Response message for the
/// [GroundedGenerationService.CheckGrounding][google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding]
/// method.
///
/// [google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding]: crate::client::GroundedGenerationService::check_grounding
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckGroundingResponse {
    /// The support score for the input answer candidate.
    /// Higher the score, higher is the fraction of claims that are supported by
    /// the provided facts. This is always set when a response is returned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub support_score: std::option::Option<f32>,

    /// List of facts cited across all claims in the answer candidate.
    /// These are derived from the facts supplied in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cited_chunks: std::vec::Vec<crate::model::FactChunk>,

    /// List of facts cited across all claims in the answer candidate.
    /// These are derived from the facts supplied in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cited_facts: std::vec::Vec<crate::model::check_grounding_response::CheckGroundingFactChunk>,

    /// Claim texts and citation info across all claims in the answer candidate.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub claims: std::vec::Vec<crate::model::check_grounding_response::Claim>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckGroundingResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [support_score][crate::model::CheckGroundingResponse::support_score].
    pub fn set_support_score<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.support_score = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [support_score][crate::model::CheckGroundingResponse::support_score].
    pub fn set_or_clear_support_score<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.support_score = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cited_chunks][crate::model::CheckGroundingResponse::cited_chunks].
    pub fn set_cited_chunks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FactChunk>,
    {
        use std::iter::Iterator;
        self.cited_chunks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cited_facts][crate::model::CheckGroundingResponse::cited_facts].
    pub fn set_cited_facts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::check_grounding_response::CheckGroundingFactChunk>,
    {
        use std::iter::Iterator;
        self.cited_facts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [claims][crate::model::CheckGroundingResponse::claims].
    pub fn set_claims<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::check_grounding_response::Claim>,
    {
        use std::iter::Iterator;
        self.claims = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CheckGroundingResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CheckGroundingResponse"
    }
}

/// Defines additional types related to [CheckGroundingResponse].
pub mod check_grounding_response {
    #[allow(unused_imports)]
    use super::*;

    /// Fact chunk for grounding check.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CheckGroundingFactChunk {
        /// Text content of the fact chunk. Can be at most 10K characters long.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub chunk_text: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CheckGroundingFactChunk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [chunk_text][crate::model::check_grounding_response::CheckGroundingFactChunk::chunk_text].
        pub fn set_chunk_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.chunk_text = v.into();
            self
        }
    }

    impl wkt::message::Message for CheckGroundingFactChunk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.CheckGroundingResponse.CheckGroundingFactChunk"
        }
    }

    /// Text and citation info for a claim in the answer candidate.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Claim {
        /// Position indicating the start of the claim in the answer candidate,
        /// measured in bytes. Note that this is not measured in characters and,
        /// therefore, must be rendered in the user interface keeping in mind that
        /// some characters may take more than one byte. For example,
        /// if the claim text contains non-ASCII characters, the start and end
        /// positions vary when measured in characters
        /// (programming-language-dependent) and when measured in bytes
        /// (programming-language-independent).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
        pub start_pos: std::option::Option<i32>,

        /// Position indicating the end of the claim in the answer candidate,
        /// exclusive, in bytes. Note that this is not measured in characters and,
        /// therefore, must be rendered as such. For example, if the claim text
        /// contains non-ASCII characters, the start and end positions vary when
        /// measured in characters (programming-language-dependent) and when measured
        /// in bytes (programming-language-independent).
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
        pub end_pos: std::option::Option<i32>,

        /// Text for the claim in the answer candidate. Always provided regardless of
        /// whether citations or anti-citations are found.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub claim_text: std::string::String,

        /// A list of indices (into 'cited_chunks') specifying the citations
        /// associated with the claim. For instance [1,3,4] means that
        /// cited_chunks[1], cited_chunks[3], cited_chunks[4] are the facts cited
        /// supporting for the claim. A citation to a fact indicates that the claim
        /// is supported by the fact.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "std::vec::Vec<wkt::internal::I32>")]
        pub citation_indices: std::vec::Vec<i32>,

        /// Indicates that this claim required grounding check. When the system
        /// decided this claim doesn't require attribution/grounding check, this
        /// field will be set to false. In that case, no grounding check was done for
        /// the claim and therefore
        /// [citation_indices][google.cloud.discoveryengine.v1.CheckGroundingResponse.Claim.citation_indices]
        /// should not be returned.
        ///
        /// [google.cloud.discoveryengine.v1.CheckGroundingResponse.Claim.citation_indices]: crate::model::check_grounding_response::Claim::citation_indices
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub grounding_check_required: std::option::Option<bool>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Claim {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_pos][crate::model::check_grounding_response::Claim::start_pos].
        pub fn set_start_pos<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.start_pos = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_pos][crate::model::check_grounding_response::Claim::start_pos].
        pub fn set_or_clear_start_pos<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.start_pos = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_pos][crate::model::check_grounding_response::Claim::end_pos].
        pub fn set_end_pos<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.end_pos = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_pos][crate::model::check_grounding_response::Claim::end_pos].
        pub fn set_or_clear_end_pos<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.end_pos = v.map(|x| x.into());
            self
        }

        /// Sets the value of [claim_text][crate::model::check_grounding_response::Claim::claim_text].
        pub fn set_claim_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.claim_text = v.into();
            self
        }

        /// Sets the value of [citation_indices][crate::model::check_grounding_response::Claim::citation_indices].
        pub fn set_citation_indices<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.citation_indices = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [grounding_check_required][crate::model::check_grounding_response::Claim::grounding_check_required].
        pub fn set_grounding_check_required<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.grounding_check_required = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [grounding_check_required][crate::model::check_grounding_response::Claim::grounding_check_required].
        pub fn set_or_clear_grounding_check_required<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.grounding_check_required = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Claim {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.CheckGroundingResponse.Claim"
        }
    }
}

/// Grounding Fact.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GroundingFact {
    /// Text content of the fact. Can be at most 10K characters long.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fact_text: std::string::String,

    /// Attributes associated with the fact.
    /// Common attributes include `source` (indicating where the fact was sourced
    /// from), `author` (indicating the author of the fact), and so on.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub attributes: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GroundingFact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fact_text][crate::model::GroundingFact::fact_text].
    pub fn set_fact_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fact_text = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::GroundingFact::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for GroundingFact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GroundingFact"
    }
}

/// Fact Chunk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FactChunk {
    /// Text content of the fact chunk. Can be at most 10K characters long.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub chunk_text: std::string::String,

    /// Source from which this fact chunk was retrieved. If it was retrieved
    /// from the GroundingFacts provided in the request then this field will
    /// contain the index of the specific fact from which this chunk was
    /// retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    /// The index of this chunk. Currently, only used for the streaming mode.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub index: i32,

    /// More fine-grained information for the source reference.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub source_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FactChunk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [chunk_text][crate::model::FactChunk::chunk_text].
    pub fn set_chunk_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.chunk_text = v.into();
        self
    }

    /// Sets the value of [source][crate::model::FactChunk::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [index][crate::model::FactChunk::index].
    pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.index = v.into();
        self
    }

    /// Sets the value of [source_metadata][crate::model::FactChunk::source_metadata].
    pub fn set_source_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for FactChunk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.FactChunk"
    }
}

/// Cloud Storage location for input content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsSource {
    /// Required. Cloud Storage URIs to input files. Each URI can be up to
    /// 2000 characters long. URIs can match the full object path (for example,
    /// `gs://bucket/directory/object.json`) or a pattern matching one or more
    /// files, such as `gs://bucket/directory/*.json`.
    ///
    /// A request can contain at most 100 files (or 100,000 files if `data_schema`
    /// is `content`). Each file can be up to 2 GB (or 100 MB if `data_schema` is
    /// `content`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub input_uris: std::vec::Vec<std::string::String>,

    /// The schema to use when parsing the data from the source.
    ///
    /// Supported values for document imports:
    ///
    /// * `document` (default): One JSON
    ///   [Document][google.cloud.discoveryengine.v1.Document] per line. Each
    ///   document must
    ///   have a valid [Document.id][google.cloud.discoveryengine.v1.Document.id].
    /// * `content`: Unstructured data (e.g. PDF, HTML). Each file matched by
    ///   `input_uris` becomes a document, with the ID set to the first 128
    ///   bits of SHA256(URI) encoded as a hex string.
    /// * `custom`: One custom data JSON per row in arbitrary format that conforms
    ///   to the defined [Schema][google.cloud.discoveryengine.v1.Schema] of the
    ///   data store. This can only be used by the GENERIC Data Store vertical.
    /// * `csv`: A CSV file with header conforming to the defined
    ///   [Schema][google.cloud.discoveryengine.v1.Schema] of the
    ///   data store. Each entry after the header is imported as a Document.
    ///   This can only be used by the GENERIC Data Store vertical.
    ///
    /// Supported values for user event imports:
    ///
    /// * `user_event` (default): One JSON
    ///   [UserEvent][google.cloud.discoveryengine.v1.UserEvent] per line.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.Document.id]: crate::model::Document::id
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    /// [google.cloud.discoveryengine.v1.UserEvent]: crate::model::UserEvent
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_schema: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uris][crate::model::GcsSource::input_uris].
    pub fn set_input_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.input_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_schema][crate::model::GcsSource::data_schema].
    pub fn set_data_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_schema = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GcsSource"
    }
}

/// BigQuery source import data from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQuerySource {
    /// The project ID or the project number that contains the BigQuery source. Has
    /// a length limit of 128 characters. If not specified, inherits the project
    /// ID from the parent request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The BigQuery data set to copy the data from with a length limit
    /// of 1,024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. The BigQuery table to copy the data from with a length limit of
    /// 1,024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// BigQuery export to a specific Cloud Storage directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_staging_dir: std::string::String,

    /// The schema to use when parsing the data from the source.
    ///
    /// Supported values for user event imports:
    ///
    /// * `user_event` (default): One
    ///   [UserEvent][google.cloud.discoveryengine.v1.UserEvent] per row.
    ///
    /// Supported values for document imports:
    ///
    /// * `document` (default): One
    ///   [Document][google.cloud.discoveryengine.v1.Document] format per
    ///   row. Each document must have a valid
    ///   [Document.id][google.cloud.discoveryengine.v1.Document.id] and one of
    ///   [Document.json_data][google.cloud.discoveryengine.v1.Document.json_data]
    ///   or
    ///   [Document.struct_data][google.cloud.discoveryengine.v1.Document.struct_data].
    /// * `custom`: One custom data per row in arbitrary format that conforms to
    ///   the defined [Schema][google.cloud.discoveryengine.v1.Schema] of the data
    ///   store. This can only be used by the GENERIC Data Store vertical.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.Document.id]: crate::model::Document::id
    /// [google.cloud.discoveryengine.v1.Document.json_data]: crate::model::Document::data
    /// [google.cloud.discoveryengine.v1.Document.struct_data]: crate::model::Document::data
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    /// [google.cloud.discoveryengine.v1.UserEvent]: crate::model::UserEvent
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_schema: std::string::String,

    /// BigQuery table partition info. Leave this empty if the BigQuery table
    /// is not partitioned.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub partition: std::option::Option<crate::model::big_query_source::Partition>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQuerySource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BigQuerySource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::BigQuerySource::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BigQuerySource::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [gcs_staging_dir][crate::model::BigQuerySource::gcs_staging_dir].
    pub fn set_gcs_staging_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_staging_dir = v.into();
        self
    }

    /// Sets the value of [data_schema][crate::model::BigQuerySource::data_schema].
    pub fn set_data_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_schema = v.into();
        self
    }

    /// Sets the value of [partition][crate::model::BigQuerySource::partition].
    ///
    /// Note that all the setters affecting `partition` are mutually
    /// exclusive.
    pub fn set_partition<
        T: std::convert::Into<std::option::Option<crate::model::big_query_source::Partition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition = v.into();
        self
    }

    /// The value of [partition][crate::model::BigQuerySource::partition]
    /// if it holds a `PartitionDate`, `None` if the field is not set or
    /// holds a different branch.
    pub fn partition_date(&self) -> std::option::Option<&std::boxed::Box<gtype::model::Date>> {
        #[allow(unreachable_patterns)]
        self.partition.as_ref().and_then(|v| match v {
            crate::model::big_query_source::Partition::PartitionDate(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [partition][crate::model::BigQuerySource::partition]
    /// to hold a `PartitionDate`.
    ///
    /// Note that all the setters affecting `partition` are
    /// mutually exclusive.
    pub fn set_partition_date<T: std::convert::Into<std::boxed::Box<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.partition = std::option::Option::Some(
            crate::model::big_query_source::Partition::PartitionDate(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQuerySource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BigQuerySource"
    }
}

/// Defines additional types related to [BigQuerySource].
pub mod big_query_source {
    #[allow(unused_imports)]
    use super::*;

    /// BigQuery table partition info. Leave this empty if the BigQuery table
    /// is not partitioned.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Partition {
        /// BigQuery time partitioned table's _PARTITIONDATE in YYYY-MM-DD format.
        PartitionDate(std::boxed::Box<gtype::model::Date>),
    }
}

/// The Spanner source for importing data
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpannerSource {
    /// The project ID that contains the Spanner source. Has a length limit of 128
    /// characters. If not specified, inherits the project ID from the parent
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The instance ID of the source Spanner table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The database ID of the source Spanner table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,

    /// Required. The table name of the Spanner database that needs to be imported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Whether to apply data boost on Spanner export. Enabling this option will
    /// incur additional cost. More info can be found
    /// [here](https://cloud.google.com/spanner/docs/databoost/databoost-overview#billing_and_quotas).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_data_boost: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpannerSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SpannerSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::SpannerSource::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::SpannerSource::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::SpannerSource::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [enable_data_boost][crate::model::SpannerSource::enable_data_boost].
    pub fn set_enable_data_boost<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_data_boost = v.into();
        self
    }
}

impl wkt::message::Message for SpannerSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SpannerSource"
    }
}

/// The Bigtable Options object that contains information to support
/// the import.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigtableOptions {
    /// The field name used for saving row key value in the document. The name has
    /// to match the pattern `[a-zA-Z0-9][a-zA-Z0-9-_]*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_field_name: std::string::String,

    /// The mapping from family names to an object that contains column families
    /// level information for the given column family. If a family is not present
    /// in this map it will be ignored.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub families: std::collections::HashMap<
        std::string::String,
        crate::model::bigtable_options::BigtableColumnFamily,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigtableOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_field_name][crate::model::BigtableOptions::key_field_name].
    pub fn set_key_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_field_name = v.into();
        self
    }

    /// Sets the value of [families][crate::model::BigtableOptions::families].
    pub fn set_families<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::bigtable_options::BigtableColumnFamily>,
    {
        use std::iter::Iterator;
        self.families = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BigtableOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BigtableOptions"
    }
}

/// Defines additional types related to [BigtableOptions].
pub mod bigtable_options {
    #[allow(unused_imports)]
    use super::*;

    /// The column family of the Bigtable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigtableColumnFamily {
        /// The field name to use for this column family in the document. The
        /// name has to match the pattern `[a-zA-Z0-9][a-zA-Z0-9-_]*`. If not set,
        /// it is parsed from the family name with best effort. However, due to
        /// different naming patterns, field name collisions could happen, where
        /// parsing behavior is undefined.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub field_name: std::string::String,

        /// The encoding mode of the values when the type is not STRING.
        /// Acceptable encoding values are:
        ///
        /// * `TEXT`: indicates values are alphanumeric text strings.
        /// * `BINARY`: indicates values are encoded using `HBase Bytes.toBytes`
        ///   family of functions. This can be overridden for a specific column
        ///   by listing that column in `columns` and specifying an encoding for it.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub encoding: crate::model::bigtable_options::Encoding,

        /// The type of values in this column family.
        /// The values are expected to be encoded using `HBase Bytes.toBytes`
        /// function when the encoding value is set to `BINARY`.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub r#type: crate::model::bigtable_options::Type,

        /// The list of objects that contains column level information for each
        /// column. If a column is not present in this list it will be ignored.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub columns: std::vec::Vec<crate::model::bigtable_options::BigtableColumn>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigtableColumnFamily {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_name][crate::model::bigtable_options::BigtableColumnFamily::field_name].
        pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_name = v.into();
            self
        }

        /// Sets the value of [encoding][crate::model::bigtable_options::BigtableColumnFamily::encoding].
        pub fn set_encoding<T: std::convert::Into<crate::model::bigtable_options::Encoding>>(
            mut self,
            v: T,
        ) -> Self {
            self.encoding = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::bigtable_options::BigtableColumnFamily::type].
        pub fn set_type<T: std::convert::Into<crate::model::bigtable_options::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [columns][crate::model::bigtable_options::BigtableColumnFamily::columns].
        pub fn set_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::bigtable_options::BigtableColumn>,
        {
            use std::iter::Iterator;
            self.columns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BigtableColumnFamily {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.BigtableOptions.BigtableColumnFamily"
        }
    }

    /// The column of the Bigtable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigtableColumn {
        /// Required. Qualifier of the column. If it cannot be decoded with utf-8,
        /// use a base-64 encoded string instead.
        #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub qualifier: ::bytes::Bytes,

        /// The field name to use for this column in the document. The name has to
        /// match the pattern `[a-zA-Z0-9][a-zA-Z0-9-_]*`.
        /// If not set, it is parsed from the qualifier bytes with best effort.
        /// However, due to different naming patterns, field name collisions could
        /// happen, where parsing behavior is undefined.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub field_name: std::string::String,

        /// The encoding mode of the values when the type is not `STRING`.
        /// Acceptable encoding values are:
        ///
        /// * `TEXT`: indicates values are alphanumeric text strings.
        /// * `BINARY`: indicates values are encoded using `HBase Bytes.toBytes`
        ///   family of functions. This can be overridden for a specific column
        ///   by listing that column in `columns` and specifying an encoding for it.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub encoding: crate::model::bigtable_options::Encoding,

        /// The type of values in this column family.
        /// The values are expected to be encoded using `HBase Bytes.toBytes`
        /// function when the encoding value is set to `BINARY`.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub r#type: crate::model::bigtable_options::Type,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigtableColumn {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [qualifier][crate::model::bigtable_options::BigtableColumn::qualifier].
        pub fn set_qualifier<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.qualifier = v.into();
            self
        }

        /// Sets the value of [field_name][crate::model::bigtable_options::BigtableColumn::field_name].
        pub fn set_field_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field_name = v.into();
            self
        }

        /// Sets the value of [encoding][crate::model::bigtable_options::BigtableColumn::encoding].
        pub fn set_encoding<T: std::convert::Into<crate::model::bigtable_options::Encoding>>(
            mut self,
            v: T,
        ) -> Self {
            self.encoding = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::bigtable_options::BigtableColumn::type].
        pub fn set_type<T: std::convert::Into<crate::model::bigtable_options::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for BigtableColumn {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.BigtableOptions.BigtableColumn"
        }
    }

    /// The type of values in a Bigtable column or column family.
    /// The values are expected to be encoded using
    /// [HBase
    /// Bytes.toBytes](https://hbase.apache.org/1.4/apidocs/org/apache/hadoop/hbase/util/Bytes.html)
    /// function when the encoding value is set to `BINARY`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The type is unspecified.
        Unspecified,
        /// String type.
        String,
        /// Numerical type.
        Number,
        /// Integer type.
        Integer,
        /// Variable length integer type.
        VarInteger,
        /// BigDecimal type.
        BigNumeric,
        /// Boolean type.
        Boolean,
        /// JSON type.
        Json,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(1),
                Self::Number => std::option::Option::Some(2),
                Self::Integer => std::option::Option::Some(3),
                Self::VarInteger => std::option::Option::Some(4),
                Self::BigNumeric => std::option::Option::Some(5),
                Self::Boolean => std::option::Option::Some(6),
                Self::Json => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Number => std::option::Option::Some("NUMBER"),
                Self::Integer => std::option::Option::Some("INTEGER"),
                Self::VarInteger => std::option::Option::Some("VAR_INTEGER"),
                Self::BigNumeric => std::option::Option::Some("BIG_NUMERIC"),
                Self::Boolean => std::option::Option::Some("BOOLEAN"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::String,
                2 => Self::Number,
                3 => Self::Integer,
                4 => Self::VarInteger,
                5 => Self::BigNumeric,
                6 => Self::Boolean,
                7 => Self::Json,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "NUMBER" => Self::Number,
                "INTEGER" => Self::Integer,
                "VAR_INTEGER" => Self::VarInteger,
                "BIG_NUMERIC" => Self::BigNumeric,
                "BOOLEAN" => Self::Boolean,
                "JSON" => Self::Json,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(1),
                Self::Number => serializer.serialize_i32(2),
                Self::Integer => serializer.serialize_i32(3),
                Self::VarInteger => serializer.serialize_i32(4),
                Self::BigNumeric => serializer.serialize_i32(5),
                Self::Boolean => serializer.serialize_i32(6),
                Self::Json => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.discoveryengine.v1.BigtableOptions.Type",
            ))
        }
    }

    /// The encoding mode of a Bigtable column or column family.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Encoding {
        /// The encoding is unspecified.
        Unspecified,
        /// Text encoding.
        Text,
        /// Binary encoding.
        Binary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Encoding::value] or
        /// [Encoding::name].
        UnknownValue(encoding::UnknownValue),
    }

    #[doc(hidden)]
    pub mod encoding {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Encoding {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Text => std::option::Option::Some(1),
                Self::Binary => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENCODING_UNSPECIFIED"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Binary => std::option::Option::Some("BINARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Encoding {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Encoding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Encoding {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Text,
                2 => Self::Binary,
                _ => Self::UnknownValue(encoding::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Encoding {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENCODING_UNSPECIFIED" => Self::Unspecified,
                "TEXT" => Self::Text,
                "BINARY" => Self::Binary,
                _ => Self::UnknownValue(encoding::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Encoding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Text => serializer.serialize_i32(1),
                Self::Binary => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Encoding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Encoding>::new(
                ".google.cloud.discoveryengine.v1.BigtableOptions.Encoding",
            ))
        }
    }
}

/// The Cloud Bigtable source for importing data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigtableSource {
    /// The project ID that contains the Bigtable source. Has a length limit of 128
    /// characters. If not specified, inherits the project ID from the parent
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The instance ID of the Cloud Bigtable that needs to be imported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The table ID of the Cloud Bigtable that needs to be imported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. Bigtable options that contains information needed when parsing
    /// data into typed structures. For example, column type annotations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigtable_options: std::option::Option<crate::model::BigtableOptions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigtableSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BigtableSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::BigtableSource::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BigtableSource::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [bigtable_options][crate::model::BigtableSource::bigtable_options].
    pub fn set_bigtable_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BigtableOptions>,
    {
        self.bigtable_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigtable_options][crate::model::BigtableSource::bigtable_options].
    pub fn set_or_clear_bigtable_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BigtableOptions>,
    {
        self.bigtable_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BigtableSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BigtableSource"
    }
}

/// Cloud FhirStore source import data from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FhirStoreSource {
    /// Required. The full resource name of the FHIR store to import data from, in
    /// the format of
    /// `projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fhir_store: std::string::String,

    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// FhirStore export to a specific Cloud Storage directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_staging_dir: std::string::String,

    /// The FHIR resource types to import. The resource types should be a subset of
    /// all [supported FHIR resource
    /// types](https://cloud.google.com/generative-ai-app-builder/docs/fhir-schema-reference#resource-level-specification).
    /// Default to all supported FHIR resource types if empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_types: std::vec::Vec<std::string::String>,

    /// Optional. Whether to update the DataStore schema to the latest predefined
    /// schema.
    ///
    /// If true, the DataStore schema will be updated to include any FHIR fields
    /// or resource types that have been added since the last import and
    /// corresponding FHIR resources will be imported from the FHIR store.
    ///
    /// Note this field cannot be used in conjunction with `resource_types`. It
    /// should be used after initial import.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub update_from_latest_predefined_schema: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FhirStoreSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fhir_store][crate::model::FhirStoreSource::fhir_store].
    pub fn set_fhir_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fhir_store = v.into();
        self
    }

    /// Sets the value of [gcs_staging_dir][crate::model::FhirStoreSource::gcs_staging_dir].
    pub fn set_gcs_staging_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_staging_dir = v.into();
        self
    }

    /// Sets the value of [resource_types][crate::model::FhirStoreSource::resource_types].
    pub fn set_resource_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_from_latest_predefined_schema][crate::model::FhirStoreSource::update_from_latest_predefined_schema].
    pub fn set_update_from_latest_predefined_schema<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_from_latest_predefined_schema = v.into();
        self
    }
}

impl wkt::message::Message for FhirStoreSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.FhirStoreSource"
    }
}

/// Cloud SQL source import data from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlSource {
    /// The project ID that contains the Cloud SQL source. Has a length limit of
    /// 128 characters. If not specified, inherits the project ID from the parent
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Cloud SQL instance to copy the data from with a length limit
    /// of 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The Cloud SQL database to copy the data from with a length limit
    /// of 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,

    /// Required. The Cloud SQL table to copy the data from with a length limit of
    /// 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// Cloud SQL export to a specific Cloud Storage directory.
    ///
    /// Ensure that the Cloud SQL service account has the necessary Cloud
    /// Storage Admin permissions to access the specified Cloud Storage directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_staging_dir: std::string::String,

    /// Option for serverless export. Enabling this option will incur additional
    /// cost. More info can be found
    /// [here](https://cloud.google.com/sql/pricing#serverless).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub offload: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CloudSqlSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CloudSqlSource::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::CloudSqlSource::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::CloudSqlSource::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [gcs_staging_dir][crate::model::CloudSqlSource::gcs_staging_dir].
    pub fn set_gcs_staging_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_staging_dir = v.into();
        self
    }

    /// Sets the value of [offload][crate::model::CloudSqlSource::offload].
    pub fn set_offload<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.offload = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CloudSqlSource"
    }
}

/// AlloyDB source import data from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlloyDbSource {
    /// The project ID that contains the AlloyDB source.
    /// Has a length limit of 128 characters. If not specified, inherits the
    /// project ID from the parent request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The AlloyDB location to copy the data from with a length limit of
    /// 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location_id: std::string::String,

    /// Required. The AlloyDB cluster to copy the data from with a length limit of
    /// 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The AlloyDB database to copy the data from with a length limit of
    /// 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,

    /// Required. The AlloyDB table to copy the data from with a length limit of
    /// 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// AlloyDB export to a specific Cloud Storage directory.
    ///
    /// Ensure that the AlloyDB service account has the necessary Cloud
    /// Storage Admin permissions to access the specified Cloud Storage directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_staging_dir: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlloyDbSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::AlloyDbSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::AlloyDbSource::location_id].
    pub fn set_location_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::AlloyDbSource::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::AlloyDbSource::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::AlloyDbSource::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [gcs_staging_dir][crate::model::AlloyDbSource::gcs_staging_dir].
    pub fn set_gcs_staging_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_staging_dir = v.into();
        self
    }
}

impl wkt::message::Message for AlloyDbSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.AlloyDbSource"
    }
}

/// Firestore source import data from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FirestoreSource {
    /// The project ID that the Cloud SQL source is in with a length limit of 128
    /// characters. If not specified, inherits the project ID from the parent
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Firestore database to copy the data from with a length limit
    /// of 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_id: std::string::String,

    /// Required. The Firestore collection (or entity) to copy the data from with a
    /// length limit of 1,500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collection_id: std::string::String,

    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// Firestore export to a specific Cloud Storage directory.
    ///
    /// Ensure that the Firestore service account has the necessary Cloud
    /// Storage Admin permissions to access the specified Cloud Storage directory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_staging_dir: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FirestoreSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::FirestoreSource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [database_id][crate::model::FirestoreSource::database_id].
    pub fn set_database_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_id = v.into();
        self
    }

    /// Sets the value of [collection_id][crate::model::FirestoreSource::collection_id].
    pub fn set_collection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collection_id = v.into();
        self
    }

    /// Sets the value of [gcs_staging_dir][crate::model::FirestoreSource::gcs_staging_dir].
    pub fn set_gcs_staging_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_staging_dir = v.into();
        self
    }
}

impl wkt::message::Message for FirestoreSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.FirestoreSource"
    }
}

/// Configuration of destination for Import related errors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportErrorConfig {
    /// Required. Errors destination.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::import_error_config::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportErrorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ImportErrorConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::import_error_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ImportErrorConfig::destination]
    /// if it holds a `GcsPrefix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_prefix(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::import_error_config::Destination::GcsPrefix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ImportErrorConfig::destination]
    /// to hold a `GcsPrefix`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::import_error_config::Destination::GcsPrefix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportErrorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportErrorConfig"
    }
}

/// Defines additional types related to [ImportErrorConfig].
pub mod import_error_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Errors destination.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Cloud Storage prefix for import errors. This must be an empty,
        /// existing Cloud Storage directory. Import errors are written to
        /// sharded files in this directory, one per line, as a JSON-encoded
        /// `google.rpc.Status` message.
        GcsPrefix(std::string::String),
    }
}

/// Request message for the ImportUserEvents request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportUserEventsRequest {
    /// Required. Parent DataStore resource name, of the form
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The desired location of errors incurred during the Import. Cannot be set
    /// for inline user event imports.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    /// Required - The desired input source of the user event data.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_user_events_request::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportUserEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportUserEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [error_config][crate::model::ImportUserEventsRequest::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::ImportUserEventsRequest::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::ImportUserEventsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_user_events_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportUserEventsRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_user_events_request::InlineSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_user_events_request::Source::InlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportUserEventsRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<
        T: std::convert::Into<std::boxed::Box<crate::model::import_user_events_request::InlineSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_user_events_request::Source::InlineSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportUserEventsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_user_events_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportUserEventsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_user_events_request::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportUserEventsRequest::source]
    /// if it holds a `BigquerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_user_events_request::Source::BigquerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportUserEventsRequest::source]
    /// to hold a `BigquerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_bigquery_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_user_events_request::Source::BigquerySource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportUserEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportUserEventsRequest"
    }
}

/// Defines additional types related to [ImportUserEventsRequest].
pub mod import_user_events_request {
    #[allow(unused_imports)]
    use super::*;

    /// The inline source for the input config for ImportUserEvents method.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InlineSource {
        /// Required. A list of user events to import. Recommended max of 10k items.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub user_events: std::vec::Vec<crate::model::UserEvent>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InlineSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user_events][crate::model::import_user_events_request::InlineSource::user_events].
        pub fn set_user_events<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::UserEvent>,
        {
            use std::iter::Iterator;
            self.user_events = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InlineSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.ImportUserEventsRequest.InlineSource"
        }
    }

    /// Required - The desired input source of the user event data.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Inline source for the input content for UserEvents.
        InlineSource(std::boxed::Box<crate::model::import_user_events_request::InlineSource>),
        /// Cloud Storage location for the input content.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// BigQuery input source.
        BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
    }
}

/// Response of the ImportUserEventsRequest. If the long running
/// operation was successful, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportUserEventsResponse {
    /// A sample of errors encountered while processing the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// Echoes the destination for the complete errors if this field was set in
    /// the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    /// Count of user events imported with complete existing Documents.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub joined_events_count: i64,

    /// Count of user events imported, but with Document information not found
    /// in the existing Branch.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub unjoined_events_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportUserEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ImportUserEventsResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_config][crate::model::ImportUserEventsResponse::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::ImportUserEventsResponse::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [joined_events_count][crate::model::ImportUserEventsResponse::joined_events_count].
    pub fn set_joined_events_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.joined_events_count = v.into();
        self
    }

    /// Sets the value of [unjoined_events_count][crate::model::ImportUserEventsResponse::unjoined_events_count].
    pub fn set_unjoined_events_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.unjoined_events_count = v.into();
        self
    }
}

impl wkt::message::Message for ImportUserEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportUserEventsResponse"
    }
}

/// Metadata related to the progress of the Import operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportUserEventsMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Count of entries that were processed successfully.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub success_count: i64,

    /// Count of entries that encountered errors while processing.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub failure_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportUserEventsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ImportUserEventsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportUserEventsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ImportUserEventsMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ImportUserEventsMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [success_count][crate::model::ImportUserEventsMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::ImportUserEventsMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }
}

impl wkt::message::Message for ImportUserEventsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportUserEventsMetadata"
    }
}

/// Metadata related to the progress of the ImportDocuments operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDocumentsMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Count of entries that were processed successfully.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub success_count: i64,

    /// Count of entries that encountered errors while processing.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub failure_count: i64,

    /// Total count of entries that were processed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub total_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ImportDocumentsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportDocumentsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ImportDocumentsMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ImportDocumentsMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [success_count][crate::model::ImportDocumentsMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::ImportDocumentsMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }

    /// Sets the value of [total_count][crate::model::ImportDocumentsMetadata::total_count].
    pub fn set_total_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_count = v.into();
        self
    }
}

impl wkt::message::Message for ImportDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportDocumentsMetadata"
    }
}

/// Request message for Import methods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDocumentsRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    /// Requires create/update permission.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The desired location of errors incurred during the Import.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    /// The mode of reconciliation between existing documents and the documents to
    /// be imported. Defaults to
    /// [ReconciliationMode.INCREMENTAL][google.cloud.discoveryengine.v1.ImportDocumentsRequest.ReconciliationMode.INCREMENTAL].
    ///
    /// [google.cloud.discoveryengine.v1.ImportDocumentsRequest.ReconciliationMode.INCREMENTAL]: crate::model::import_documents_request::ReconciliationMode::Incremental
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciliation_mode: crate::model::import_documents_request::ReconciliationMode,

    /// Indicates which fields in the provided imported documents to update. If
    /// not set, the default is to update all fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Whether to automatically generate IDs for the documents if absent.
    ///
    /// If set to `true`,
    /// [Document.id][google.cloud.discoveryengine.v1.Document.id]s are
    /// automatically generated based on the hash of the payload, where IDs may not
    /// be consistent during multiple imports. In which case
    /// [ReconciliationMode.FULL][google.cloud.discoveryengine.v1.ImportDocumentsRequest.ReconciliationMode.FULL]
    /// is highly recommended to avoid duplicate contents. If unset or set to
    /// `false`, [Document.id][google.cloud.discoveryengine.v1.Document.id]s have
    /// to be specified using
    /// [id_field][google.cloud.discoveryengine.v1.ImportDocumentsRequest.id_field],
    /// otherwise, documents without IDs fail to be imported.
    ///
    /// Supported data sources:
    ///
    /// * [GcsSource][google.cloud.discoveryengine.v1.GcsSource].
    ///   [GcsSource.data_schema][google.cloud.discoveryengine.v1.GcsSource.data_schema]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * [BigQuerySource][google.cloud.discoveryengine.v1.BigQuerySource].
    ///   [BigQuerySource.data_schema][google.cloud.discoveryengine.v1.BigQuerySource.data_schema]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * [SpannerSource][google.cloud.discoveryengine.v1.SpannerSource].
    /// * [CloudSqlSource][google.cloud.discoveryengine.v1.CloudSqlSource].
    /// * [FirestoreSource][google.cloud.discoveryengine.v1.FirestoreSource].
    /// * [BigtableSource][google.cloud.discoveryengine.v1.BigtableSource].
    ///
    /// [google.cloud.discoveryengine.v1.BigQuerySource]: crate::model::BigQuerySource
    /// [google.cloud.discoveryengine.v1.BigQuerySource.data_schema]: crate::model::BigQuerySource::data_schema
    /// [google.cloud.discoveryengine.v1.BigtableSource]: crate::model::BigtableSource
    /// [google.cloud.discoveryengine.v1.CloudSqlSource]: crate::model::CloudSqlSource
    /// [google.cloud.discoveryengine.v1.Document.id]: crate::model::Document::id
    /// [google.cloud.discoveryengine.v1.FirestoreSource]: crate::model::FirestoreSource
    /// [google.cloud.discoveryengine.v1.GcsSource]: crate::model::GcsSource
    /// [google.cloud.discoveryengine.v1.GcsSource.data_schema]: crate::model::GcsSource::data_schema
    /// [google.cloud.discoveryengine.v1.ImportDocumentsRequest.ReconciliationMode.FULL]: crate::model::import_documents_request::ReconciliationMode::Full
    /// [google.cloud.discoveryengine.v1.ImportDocumentsRequest.id_field]: crate::model::ImportDocumentsRequest::id_field
    /// [google.cloud.discoveryengine.v1.SpannerSource]: crate::model::SpannerSource
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_generate_ids: bool,

    /// The field indicates the ID field or column to be used as unique IDs of
    /// the documents.
    ///
    /// For [GcsSource][google.cloud.discoveryengine.v1.GcsSource] it is the key of
    /// the JSON field. For instance, `my_id` for JSON `{"my_id": "some_uuid"}`.
    /// For others, it may be the column name of the table where the unique ids are
    /// stored.
    ///
    /// The values of the JSON field or the table column are used as the
    /// [Document.id][google.cloud.discoveryengine.v1.Document.id]s. The JSON field
    /// or the table column must be of string type, and the values must be set as
    /// valid strings conform to [RFC-1034](https://tools.ietf.org/html/rfc1034)
    /// with 1-63 characters. Otherwise, documents without valid IDs fail to be
    /// imported.
    ///
    /// Only set this field when
    /// [auto_generate_ids][google.cloud.discoveryengine.v1.ImportDocumentsRequest.auto_generate_ids]
    /// is unset or set as `false`. Otherwise, an INVALID_ARGUMENT error is thrown.
    ///
    /// If it is unset, a default value `_id` is used when importing from the
    /// allowed data sources.
    ///
    /// Supported data sources:
    ///
    /// * [GcsSource][google.cloud.discoveryengine.v1.GcsSource].
    ///   [GcsSource.data_schema][google.cloud.discoveryengine.v1.GcsSource.data_schema]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * [BigQuerySource][google.cloud.discoveryengine.v1.BigQuerySource].
    ///   [BigQuerySource.data_schema][google.cloud.discoveryengine.v1.BigQuerySource.data_schema]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * [SpannerSource][google.cloud.discoveryengine.v1.SpannerSource].
    /// * [CloudSqlSource][google.cloud.discoveryengine.v1.CloudSqlSource].
    /// * [FirestoreSource][google.cloud.discoveryengine.v1.FirestoreSource].
    /// * [BigtableSource][google.cloud.discoveryengine.v1.BigtableSource].
    ///
    /// [google.cloud.discoveryengine.v1.BigQuerySource]: crate::model::BigQuerySource
    /// [google.cloud.discoveryengine.v1.BigQuerySource.data_schema]: crate::model::BigQuerySource::data_schema
    /// [google.cloud.discoveryengine.v1.BigtableSource]: crate::model::BigtableSource
    /// [google.cloud.discoveryengine.v1.CloudSqlSource]: crate::model::CloudSqlSource
    /// [google.cloud.discoveryengine.v1.Document.id]: crate::model::Document::id
    /// [google.cloud.discoveryengine.v1.FirestoreSource]: crate::model::FirestoreSource
    /// [google.cloud.discoveryengine.v1.GcsSource]: crate::model::GcsSource
    /// [google.cloud.discoveryengine.v1.GcsSource.data_schema]: crate::model::GcsSource::data_schema
    /// [google.cloud.discoveryengine.v1.ImportDocumentsRequest.auto_generate_ids]: crate::model::ImportDocumentsRequest::auto_generate_ids
    /// [google.cloud.discoveryengine.v1.SpannerSource]: crate::model::SpannerSource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id_field: std::string::String,

    /// Optional. Whether to force refresh the unstructured content of the
    /// documents.
    ///
    /// If set to `true`, the content part of the documents will be refreshed
    /// regardless of the update status of the referencing content.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force_refresh_content: bool,

    /// Required. The source of the input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_documents_request::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportDocumentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [error_config][crate::model::ImportDocumentsRequest::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::ImportDocumentsRequest::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reconciliation_mode][crate::model::ImportDocumentsRequest::reconciliation_mode].
    pub fn set_reconciliation_mode<
        T: std::convert::Into<crate::model::import_documents_request::ReconciliationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reconciliation_mode = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::ImportDocumentsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::ImportDocumentsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_generate_ids][crate::model::ImportDocumentsRequest::auto_generate_ids].
    pub fn set_auto_generate_ids<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_generate_ids = v.into();
        self
    }

    /// Sets the value of [id_field][crate::model::ImportDocumentsRequest::id_field].
    pub fn set_id_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id_field = v.into();
        self
    }

    /// Sets the value of [force_refresh_content][crate::model::ImportDocumentsRequest::force_refresh_content].
    pub fn set_force_refresh_content<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_refresh_content = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_documents_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_documents_request::InlineSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::InlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<
        T: std::convert::Into<std::boxed::Box<crate::model::import_documents_request::InlineSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::InlineSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `BigquerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::BigquerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `BigquerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_bigquery_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::BigquerySource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `FhirStoreSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fhir_store_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FhirStoreSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::FhirStoreSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `FhirStoreSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_fhir_store_source<
        T: std::convert::Into<std::boxed::Box<crate::model::FhirStoreSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::FhirStoreSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `SpannerSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spanner_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SpannerSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::SpannerSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `SpannerSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_spanner_source<
        T: std::convert::Into<std::boxed::Box<crate::model::SpannerSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::SpannerSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `CloudSqlSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_sql_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::CloudSqlSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `CloudSqlSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_sql_source<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::CloudSqlSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `FirestoreSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn firestore_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FirestoreSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::FirestoreSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `FirestoreSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_firestore_source<
        T: std::convert::Into<std::boxed::Box<crate::model::FirestoreSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::FirestoreSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `AlloyDbSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alloy_db_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AlloyDbSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::AlloyDbSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `AlloyDbSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_alloy_db_source<
        T: std::convert::Into<std::boxed::Box<crate::model::AlloyDbSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::AlloyDbSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `BigtableSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigtable_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigtableSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::BigtableSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `BigtableSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_bigtable_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigtableSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::BigtableSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportDocumentsRequest"
    }
}

/// Defines additional types related to [ImportDocumentsRequest].
pub mod import_documents_request {
    #[allow(unused_imports)]
    use super::*;

    /// The inline source for the input config for ImportDocuments method.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InlineSource {
        /// Required. A list of documents to update/create. Each document must have a
        /// valid [Document.id][google.cloud.discoveryengine.v1.Document.id].
        /// Recommended max of 100 items.
        ///
        /// [google.cloud.discoveryengine.v1.Document.id]: crate::model::Document::id
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub documents: std::vec::Vec<crate::model::Document>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InlineSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [documents][crate::model::import_documents_request::InlineSource::documents].
        pub fn set_documents<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Document>,
        {
            use std::iter::Iterator;
            self.documents = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InlineSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.ImportDocumentsRequest.InlineSource"
        }
    }

    /// Indicates how imported documents are reconciled with the existing documents
    /// created or imported before.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReconciliationMode {
        /// Defaults to `INCREMENTAL`.
        Unspecified,
        /// Inserts new documents or updates existing documents.
        Incremental,
        /// Calculates diff and replaces the entire document dataset. Existing
        /// documents may be deleted if they are not present in the source location.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReconciliationMode::value] or
        /// [ReconciliationMode::name].
        UnknownValue(reconciliation_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reconciliation_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReconciliationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incremental => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECONCILIATION_MODE_UNSPECIFIED"),
                Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReconciliationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReconciliationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReconciliationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incremental,
                2 => Self::Full,
                _ => Self::UnknownValue(reconciliation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReconciliationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECONCILIATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "INCREMENTAL" => Self::Incremental,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(reconciliation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReconciliationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incremental => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReconciliationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReconciliationMode>::new(
                ".google.cloud.discoveryengine.v1.ImportDocumentsRequest.ReconciliationMode",
            ))
        }
    }

    /// Required. The source of the input.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Inline source for the input content for documents.
        InlineSource(std::boxed::Box<crate::model::import_documents_request::InlineSource>),
        /// Cloud Storage location for the input content.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// BigQuery input source.
        BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
        /// FhirStore input source.
        FhirStoreSource(std::boxed::Box<crate::model::FhirStoreSource>),
        /// Spanner input source.
        SpannerSource(std::boxed::Box<crate::model::SpannerSource>),
        /// Cloud SQL input source.
        CloudSqlSource(std::boxed::Box<crate::model::CloudSqlSource>),
        /// Firestore input source.
        FirestoreSource(std::boxed::Box<crate::model::FirestoreSource>),
        /// AlloyDB input source.
        AlloyDbSource(std::boxed::Box<crate::model::AlloyDbSource>),
        /// Cloud Bigtable input source.
        BigtableSource(std::boxed::Box<crate::model::BigtableSource>),
    }
}

/// Response of the
/// [ImportDocumentsRequest][google.cloud.discoveryengine.v1.ImportDocumentsRequest].
/// If the long running operation is done, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
///
/// [google.cloud.discoveryengine.v1.ImportDocumentsRequest]: crate::model::ImportDocumentsRequest
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportDocumentsResponse {
    /// A sample of errors encountered while processing the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// Echoes the destination for the complete errors in the request if set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ImportDocumentsResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_config][crate::model::ImportDocumentsResponse::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::ImportDocumentsResponse::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportDocumentsResponse"
    }
}

/// Request message for
/// [CompletionService.ImportSuggestionDenyListEntries][google.cloud.discoveryengine.v1.CompletionService.ImportSuggestionDenyListEntries]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.ImportSuggestionDenyListEntries]: crate::client::CompletionService::import_suggestion_deny_list_entries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportSuggestionDenyListEntriesRequest {
    /// Required. The parent data store resource name for which to import denylist
    /// entries. Follows pattern projects/*/locations/*/collections/*/dataStores/*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The source of the updated SuggestionDenyList.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source:
        std::option::Option<crate::model::import_suggestion_deny_list_entries_request::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportSuggestionDenyListEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportSuggestionDenyListEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportSuggestionDenyListEntriesRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::import_suggestion_deny_list_entries_request::Source,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportSuggestionDenyListEntriesRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::import_suggestion_deny_list_entries_request::InlineSource>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_suggestion_deny_list_entries_request::Source::InlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportSuggestionDenyListEntriesRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::import_suggestion_deny_list_entries_request::InlineSource,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_suggestion_deny_list_entries_request::Source::InlineSource(
                v.into(),
            ),
        );
        self
    }

    /// The value of [source][crate::model::ImportSuggestionDenyListEntriesRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_suggestion_deny_list_entries_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportSuggestionDenyListEntriesRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_suggestion_deny_list_entries_request::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportSuggestionDenyListEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportSuggestionDenyListEntriesRequest"
    }
}

/// Defines additional types related to [ImportSuggestionDenyListEntriesRequest].
pub mod import_suggestion_deny_list_entries_request {
    #[allow(unused_imports)]
    use super::*;

    /// The inline source for SuggestionDenyListEntry.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InlineSource {
        /// Required. A list of all denylist entries to import. Max of 1000 items.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub entries: std::vec::Vec<crate::model::SuggestionDenyListEntry>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InlineSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entries][crate::model::import_suggestion_deny_list_entries_request::InlineSource::entries].
        pub fn set_entries<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::SuggestionDenyListEntry>,
        {
            use std::iter::Iterator;
            self.entries = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InlineSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.ImportSuggestionDenyListEntriesRequest.InlineSource"
        }
    }

    /// The source of the updated SuggestionDenyList.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Inline source for the input content for suggestion deny list entries.
        InlineSource(
            std::boxed::Box<
                crate::model::import_suggestion_deny_list_entries_request::InlineSource,
            >,
        ),
        /// Cloud Storage location for the input content.
        ///
        /// Only 1 file can be specified that contains all entries to import.
        /// Supported values `gcs_source.schema` for autocomplete suggestion deny
        /// list entry imports:
        ///
        /// * `suggestion_deny_list` (default): One JSON [SuggestionDenyListEntry]
        ///   per line.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// Response message for
/// [CompletionService.ImportSuggestionDenyListEntries][google.cloud.discoveryengine.v1.CompletionService.ImportSuggestionDenyListEntries]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.ImportSuggestionDenyListEntries]: crate::client::CompletionService::import_suggestion_deny_list_entries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportSuggestionDenyListEntriesResponse {
    /// A sample of errors encountered while processing the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// Count of deny list entries successfully imported.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub imported_entries_count: i64,

    /// Count of deny list entries that failed to be imported.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub failed_entries_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportSuggestionDenyListEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ImportSuggestionDenyListEntriesResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [imported_entries_count][crate::model::ImportSuggestionDenyListEntriesResponse::imported_entries_count].
    pub fn set_imported_entries_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.imported_entries_count = v.into();
        self
    }

    /// Sets the value of [failed_entries_count][crate::model::ImportSuggestionDenyListEntriesResponse::failed_entries_count].
    pub fn set_failed_entries_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_entries_count = v.into();
        self
    }
}

impl wkt::message::Message for ImportSuggestionDenyListEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportSuggestionDenyListEntriesResponse"
    }
}

/// Metadata related to the progress of the ImportSuggestionDenyListEntries
/// operation. This is returned by the google.longrunning.Operation.metadata
/// field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportSuggestionDenyListEntriesMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportSuggestionDenyListEntriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ImportSuggestionDenyListEntriesMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportSuggestionDenyListEntriesMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ImportSuggestionDenyListEntriesMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ImportSuggestionDenyListEntriesMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportSuggestionDenyListEntriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportSuggestionDenyListEntriesMetadata"
    }
}

/// Request message for
/// [CompletionService.ImportCompletionSuggestions][google.cloud.discoveryengine.v1.CompletionService.ImportCompletionSuggestions]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.ImportCompletionSuggestions]: crate::client::CompletionService::import_completion_suggestions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportCompletionSuggestionsRequest {
    /// Required. The parent data store resource name for which to import customer
    /// autocomplete suggestions.
    ///
    /// Follows pattern `projects/*/locations/*/collections/*/dataStores/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The desired location of errors incurred during the Import.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    /// The source of the autocomplete suggestions.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_completion_suggestions_request::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportCompletionSuggestionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportCompletionSuggestionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [error_config][crate::model::ImportCompletionSuggestionsRequest::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::ImportCompletionSuggestionsRequest::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::ImportCompletionSuggestionsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_completion_suggestions_request::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportCompletionSuggestionsRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_source(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::import_completion_suggestions_request::InlineSource>,
    > {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_completion_suggestions_request::Source::InlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportCompletionSuggestionsRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<
        T: std::convert::Into<
                std::boxed::Box<crate::model::import_completion_suggestions_request::InlineSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_completion_suggestions_request::Source::InlineSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportCompletionSuggestionsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_completion_suggestions_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportCompletionSuggestionsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_completion_suggestions_request::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportCompletionSuggestionsRequest::source]
    /// if it holds a `BigquerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_completion_suggestions_request::Source::BigquerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportCompletionSuggestionsRequest::source]
    /// to hold a `BigquerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_bigquery_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_completion_suggestions_request::Source::BigquerySource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportCompletionSuggestionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportCompletionSuggestionsRequest"
    }
}

/// Defines additional types related to [ImportCompletionSuggestionsRequest].
pub mod import_completion_suggestions_request {
    #[allow(unused_imports)]
    use super::*;

    /// The inline source for CompletionSuggestions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InlineSource {
        /// Required. A list of all denylist entries to import. Max of 1000 items.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub suggestions: std::vec::Vec<crate::model::CompletionSuggestion>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InlineSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [suggestions][crate::model::import_completion_suggestions_request::InlineSource::suggestions].
        pub fn set_suggestions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::CompletionSuggestion>,
        {
            use std::iter::Iterator;
            self.suggestions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InlineSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.ImportCompletionSuggestionsRequest.InlineSource"
        }
    }

    /// The source of the autocomplete suggestions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Inline source for suggestion entries.
        InlineSource(
            std::boxed::Box<crate::model::import_completion_suggestions_request::InlineSource>,
        ),
        /// Cloud Storage location for the input content.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// BigQuery input source.
        BigquerySource(std::boxed::Box<crate::model::BigQuerySource>),
    }
}

/// Response of the
/// [CompletionService.ImportCompletionSuggestions][google.cloud.discoveryengine.v1.CompletionService.ImportCompletionSuggestions]
/// method. If the long running operation is done, this message is returned by
/// the google.longrunning.Operations.response field if the operation is
/// successful.
///
/// [google.cloud.discoveryengine.v1.CompletionService.ImportCompletionSuggestions]: crate::client::CompletionService::import_completion_suggestions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportCompletionSuggestionsResponse {
    /// A sample of errors encountered while processing the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// The desired location of errors incurred during the Import.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportCompletionSuggestionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ImportCompletionSuggestionsResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_config][crate::model::ImportCompletionSuggestionsResponse::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::ImportCompletionSuggestionsResponse::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportCompletionSuggestionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportCompletionSuggestionsResponse"
    }
}

/// Metadata related to the progress of the ImportCompletionSuggestions
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportCompletionSuggestionsMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Count of
    /// [CompletionSuggestion][google.cloud.discoveryengine.v1.CompletionSuggestion]s
    /// successfully imported.
    ///
    /// [google.cloud.discoveryengine.v1.CompletionSuggestion]: crate::model::CompletionSuggestion
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub success_count: i64,

    /// Count of
    /// [CompletionSuggestion][google.cloud.discoveryengine.v1.CompletionSuggestion]s
    /// that failed to be imported.
    ///
    /// [google.cloud.discoveryengine.v1.CompletionSuggestion]: crate::model::CompletionSuggestion
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub failure_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportCompletionSuggestionsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ImportCompletionSuggestionsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportCompletionSuggestionsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ImportCompletionSuggestionsMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ImportCompletionSuggestionsMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [success_count][crate::model::ImportCompletionSuggestionsMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::ImportCompletionSuggestionsMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }
}

impl wkt::message::Message for ImportCompletionSuggestionsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ImportCompletionSuggestionsMetadata"
    }
}

/// Metadata and configurations for a Google Cloud project in the service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Project {
    /// Output only. Full resource name of the project, for example
    /// `projects/{project}`.
    /// Note that when making requests, project number and project id are both
    /// acceptable, but the server will always respond in project number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when this project is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this project is successfully provisioned.
    /// Empty value means this project is still provisioning and is not ready for
    /// use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provision_completion_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A map of terms of services. The key is the `id` of
    /// [ServiceTerms][google.cloud.discoveryengine.v1.Project.ServiceTerms].
    ///
    /// [google.cloud.discoveryengine.v1.Project.ServiceTerms]: crate::model::project::ServiceTerms
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub service_terms_map:
        std::collections::HashMap<std::string::String, crate::model::project::ServiceTerms>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Project {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Project::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Project::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Project::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provision_completion_time][crate::model::Project::provision_completion_time].
    pub fn set_provision_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.provision_completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provision_completion_time][crate::model::Project::provision_completion_time].
    pub fn set_or_clear_provision_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.provision_completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_terms_map][crate::model::Project::service_terms_map].
    pub fn set_service_terms_map<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::project::ServiceTerms>,
    {
        use std::iter::Iterator;
        self.service_terms_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Project {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Project"
    }
}

/// Defines additional types related to [Project].
pub mod project {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata about the terms of service.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ServiceTerms {
        /// The unique identifier of this terms of service.
        /// Available terms:
        ///
        /// * `GA_DATA_USE_TERMS`: [Terms for data
        ///   use](https://cloud.google.com/retail/data-use-terms). When using this as
        ///   `id`, the acceptable
        ///   [version][google.cloud.discoveryengine.v1.Project.ServiceTerms.version]
        ///   to provide is `2022-11-23`.
        ///
        /// [google.cloud.discoveryengine.v1.Project.ServiceTerms.version]: crate::model::project::ServiceTerms::version
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// The version string of the terms of service.
        /// For acceptable values, see the comments for
        /// [id][google.cloud.discoveryengine.v1.Project.ServiceTerms.id] above.
        ///
        /// [google.cloud.discoveryengine.v1.Project.ServiceTerms.id]: crate::model::project::ServiceTerms::id
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub version: std::string::String,

        /// Whether the project has accepted/rejected the service terms or it is
        /// still pending.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub state: crate::model::project::service_terms::State,

        /// The last time when the project agreed to the terms of service.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub accept_time: std::option::Option<wkt::Timestamp>,

        /// The last time when the project declined or revoked the agreement to terms
        /// of service.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub decline_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServiceTerms {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::project::ServiceTerms::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [version][crate::model::project::ServiceTerms::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }

        /// Sets the value of [state][crate::model::project::ServiceTerms::state].
        pub fn set_state<T: std::convert::Into<crate::model::project::service_terms::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [accept_time][crate::model::project::ServiceTerms::accept_time].
        pub fn set_accept_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.accept_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [accept_time][crate::model::project::ServiceTerms::accept_time].
        pub fn set_or_clear_accept_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.accept_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [decline_time][crate::model::project::ServiceTerms::decline_time].
        pub fn set_decline_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.decline_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [decline_time][crate::model::project::ServiceTerms::decline_time].
        pub fn set_or_clear_decline_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.decline_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ServiceTerms {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Project.ServiceTerms"
        }
    }

    /// Defines additional types related to [ServiceTerms].
    pub mod service_terms {
        #[allow(unused_imports)]
        use super::*;

        /// The agreement states this terms of service.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// The default value of the enum. This value is not actually used.
            Unspecified,
            /// The project has given consent to the terms of service.
            TermsAccepted,
            /// The project is pending to review and accept the terms of service.
            TermsPending,
            /// The project has declined or revoked the agreement to terms of service.
            TermsDeclined,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::TermsAccepted => std::option::Option::Some(1),
                    Self::TermsPending => std::option::Option::Some(2),
                    Self::TermsDeclined => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::TermsAccepted => std::option::Option::Some("TERMS_ACCEPTED"),
                    Self::TermsPending => std::option::Option::Some("TERMS_PENDING"),
                    Self::TermsDeclined => std::option::Option::Some("TERMS_DECLINED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::TermsAccepted,
                    2 => Self::TermsPending,
                    3 => Self::TermsDeclined,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "TERMS_ACCEPTED" => Self::TermsAccepted,
                    "TERMS_PENDING" => Self::TermsPending,
                    "TERMS_DECLINED" => Self::TermsDeclined,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::TermsAccepted => serializer.serialize_i32(1),
                    Self::TermsPending => serializer.serialize_i32(2),
                    Self::TermsDeclined => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.discoveryengine.v1.Project.ServiceTerms.State",
                ))
            }
        }
    }
}

/// Request for
/// [ProjectService.ProvisionProject][google.cloud.discoveryengine.v1.ProjectService.ProvisionProject]
/// method.
///
/// [google.cloud.discoveryengine.v1.ProjectService.ProvisionProject]: crate::client::ProjectService::provision_project
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProvisionProjectRequest {
    /// Required. Full resource name of a
    /// [Project][google.cloud.discoveryengine.v1.Project], such as
    /// `projects/{project_id_or_number}`.
    ///
    /// [google.cloud.discoveryengine.v1.Project]: crate::model::Project
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Set to `true` to specify that caller has read and would like to
    /// give consent to the [Terms for data
    /// use](https://cloud.google.com/retail/data-use-terms).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub accept_data_use_terms: bool,

    /// Required. The version of the [Terms for data
    /// use](https://cloud.google.com/retail/data-use-terms) that caller has read
    /// and would like to give consent to.
    ///
    /// Acceptable version is `2022-11-23`, and this may change over time.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_use_terms_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProvisionProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProvisionProjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [accept_data_use_terms][crate::model::ProvisionProjectRequest::accept_data_use_terms].
    pub fn set_accept_data_use_terms<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.accept_data_use_terms = v.into();
        self
    }

    /// Sets the value of [data_use_terms_version][crate::model::ProvisionProjectRequest::data_use_terms_version].
    pub fn set_data_use_terms_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_use_terms_version = v.into();
        self
    }
}

impl wkt::message::Message for ProvisionProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ProvisionProjectRequest"
    }
}

/// Metadata associated with a project provision operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProvisionProjectMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProvisionProjectMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ProvisionProjectMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ProvisionProjectMetadata"
    }
}

/// Request message for PurgeUserEvents method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeUserEventsRequest {
    /// Required. The resource name of the catalog under which the events are
    /// created. The format is
    /// `projects/{project}/locations/global/collections/{collection}/dataStores/{dataStore}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The filter string to specify the events to be deleted with a
    /// length limit of 5,000 characters. The eligible fields for filtering are:
    ///
    /// * `eventType`: Double quoted
    ///   [UserEvent.event_type][google.cloud.discoveryengine.v1.UserEvent.event_type]
    ///   string.
    /// * `eventTime`: in ISO 8601 "zulu" format.
    /// * `userPseudoId`: Double quoted string. Specifying this will delete all
    ///   events associated with a visitor.
    /// * `userId`: Double quoted string. Specifying this will delete all events
    ///   associated with a user.
    ///
    /// Note: This API only supports purging a max range of 30 days.
    ///
    /// Examples:
    ///
    /// * Deleting all events in a time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z"
    ///   eventTime < "2012-04-23T18:30:43.511Z"`
    /// * Deleting specific eventType in a time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z"
    ///   eventTime < "2012-04-23T18:30:43.511Z" eventType = "search"`
    /// * Deleting all events for a specific visitor in a time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z"
    ///   eventTime < "2012-04-23T18:30:43.511Z" userPseudoId = "visitor1024"`
    /// * Deleting the past 30 days of events inside a DataStore:
    ///   `*`
    ///
    /// The filtering fields are assumed to have an implicit AND.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent.event_type]: crate::model::UserEvent::event_type
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The `force` field is currently not supported. Purge user event requests
    /// will permanently delete all purgeable events. Once the development is
    /// complete:
    /// If `force` is set to false, the method will return the expected
    /// purge count without deleting any user events. This field will default to
    /// false if not included in the request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeUserEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeUserEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeUserEventsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeUserEventsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for PurgeUserEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeUserEventsRequest"
    }
}

/// Response of the PurgeUserEventsRequest. If the long running operation is
/// successfully done, then this message is returned by the
/// google.longrunning.Operations.response field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeUserEventsResponse {
    /// The total count of events purged as a result of the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub purge_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeUserEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeUserEventsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }
}

impl wkt::message::Message for PurgeUserEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeUserEventsResponse"
    }
}

/// Metadata related to the progress of the PurgeUserEvents operation.
/// This will be returned by the google.longrunning.Operation.metadata field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeUserEventsMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Count of entries that were deleted successfully.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub success_count: i64,

    /// Count of entries that encountered errors while processing.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub failure_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeUserEventsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::PurgeUserEventsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PurgeUserEventsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PurgeUserEventsMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PurgeUserEventsMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [success_count][crate::model::PurgeUserEventsMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::PurgeUserEventsMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }
}

impl wkt::message::Message for PurgeUserEventsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeUserEventsMetadata"
    }
}

/// Configuration of destination for Purge related errors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeErrorConfig {
    /// Required. Errors destination.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::purge_error_config::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeErrorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::PurgeErrorConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::purge_error_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::PurgeErrorConfig::destination]
    /// if it holds a `GcsPrefix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_prefix(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::purge_error_config::Destination::GcsPrefix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::PurgeErrorConfig::destination]
    /// to hold a `GcsPrefix`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::purge_error_config::Destination::GcsPrefix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PurgeErrorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeErrorConfig"
    }
}

/// Defines additional types related to [PurgeErrorConfig].
pub mod purge_error_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Errors destination.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Cloud Storage prefix for purge errors. This must be an empty,
        /// existing Cloud Storage directory. Purge errors are written to
        /// sharded files in this directory, one per line, as a JSON-encoded
        /// `google.rpc.Status` message.
        GcsPrefix(std::string::String),
    }
}

/// Request message for
/// [DocumentService.PurgeDocuments][google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]
/// method.
///
/// [google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]: crate::client::DocumentService::purge_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeDocumentsRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Filter matching documents to purge. Only currently supported
    /// value is
    /// `*` (all items).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The desired location of errors incurred during the purge.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::PurgeErrorConfig>,

    /// Actually performs the purge. If `force` is set to false, return the
    /// expected purge count without deleting any documents.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    /// The desired input source for the purging documents based on document IDs.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::purge_documents_request::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeDocumentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeDocumentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [error_config][crate::model::PurgeDocumentsRequest::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PurgeErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::PurgeDocumentsRequest::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PurgeErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [force][crate::model::PurgeDocumentsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [source][crate::model::PurgeDocumentsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::purge_documents_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::PurgeDocumentsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::purge_documents_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::PurgeDocumentsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::purge_documents_request::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::PurgeDocumentsRequest::source]
    /// if it holds a `InlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::purge_documents_request::InlineSource>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::purge_documents_request::Source::InlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::PurgeDocumentsRequest::source]
    /// to hold a `InlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_inline_source<
        T: std::convert::Into<std::boxed::Box<crate::model::purge_documents_request::InlineSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::purge_documents_request::Source::InlineSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PurgeDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeDocumentsRequest"
    }
}

/// Defines additional types related to [PurgeDocumentsRequest].
pub mod purge_documents_request {
    #[allow(unused_imports)]
    use super::*;

    /// The inline source for the input config for
    /// [DocumentService.PurgeDocuments][google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]
    /// method.
    ///
    /// [google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]: crate::client::DocumentService::purge_documents
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InlineSource {
        /// Required. A list of full resource name of documents to purge. In the
        /// format
        /// `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
        /// Recommended max of 100 items.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub documents: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InlineSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [documents][crate::model::purge_documents_request::InlineSource::documents].
        pub fn set_documents<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.documents = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InlineSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeDocumentsRequest.InlineSource"
        }
    }

    /// The desired input source for the purging documents based on document IDs.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Cloud Storage location for the input content.
        /// Supported `data_schema`:
        ///
        /// * `document_id`: One valid
        ///   [Document.id][google.cloud.discoveryengine.v1.Document.id] per line.
        ///
        /// [google.cloud.discoveryengine.v1.Document.id]: crate::model::Document::id
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// Inline source for the input content for purge.
        InlineSource(std::boxed::Box<crate::model::purge_documents_request::InlineSource>),
    }
}

/// Response message for
/// [DocumentService.PurgeDocuments][google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]
/// method. If the long running operation is successfully done, then this message
/// is returned by the google.longrunning.Operations.response field.
///
/// [google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments]: crate::client::DocumentService::purge_documents
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeDocumentsResponse {
    /// The total count of documents purged as a result of the operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub purge_count: i64,

    /// A sample of document names that will be deleted. Only populated if `force`
    /// is set to false. A max of 100 names will be returned and the names are
    /// chosen at random.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub purge_sample: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeDocumentsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeDocumentsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PurgeDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeDocumentsResponse"
    }
}

/// Metadata related to the progress of the PurgeDocuments operation.
/// This will be returned by the google.longrunning.Operation.metadata field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeDocumentsMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Count of entries that were deleted successfully.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub success_count: i64,

    /// Count of entries that encountered errors while processing.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub failure_count: i64,

    /// Count of entries that were ignored as entries were not found.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub ignored_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeDocumentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::PurgeDocumentsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PurgeDocumentsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PurgeDocumentsMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PurgeDocumentsMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [success_count][crate::model::PurgeDocumentsMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::PurgeDocumentsMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }

    /// Sets the value of [ignored_count][crate::model::PurgeDocumentsMetadata::ignored_count].
    pub fn set_ignored_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.ignored_count = v.into();
        self
    }
}

impl wkt::message::Message for PurgeDocumentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeDocumentsMetadata"
    }
}

/// Request message for
/// [CompletionService.PurgeSuggestionDenyListEntries][google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries]: crate::client::CompletionService::purge_suggestion_deny_list_entries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeSuggestionDenyListEntriesRequest {
    /// Required. The parent data store resource name for which to import denylist
    /// entries. Follows pattern projects/*/locations/*/collections/*/dataStores/*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeSuggestionDenyListEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeSuggestionDenyListEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for PurgeSuggestionDenyListEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeSuggestionDenyListEntriesRequest"
    }
}

/// Response message for
/// [CompletionService.PurgeSuggestionDenyListEntries][google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries]: crate::client::CompletionService::purge_suggestion_deny_list_entries
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeSuggestionDenyListEntriesResponse {
    /// Number of suggestion deny list entries purged.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub purge_count: i64,

    /// A sample of errors encountered while processing the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeSuggestionDenyListEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeSuggestionDenyListEntriesResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [error_samples][crate::model::PurgeSuggestionDenyListEntriesResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PurgeSuggestionDenyListEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeSuggestionDenyListEntriesResponse"
    }
}

/// Metadata related to the progress of the PurgeSuggestionDenyListEntries
/// operation. This is returned by the google.longrunning.Operation.metadata
/// field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeSuggestionDenyListEntriesMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeSuggestionDenyListEntriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::PurgeSuggestionDenyListEntriesMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PurgeSuggestionDenyListEntriesMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PurgeSuggestionDenyListEntriesMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PurgeSuggestionDenyListEntriesMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PurgeSuggestionDenyListEntriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeSuggestionDenyListEntriesMetadata"
    }
}

/// Request message for
/// [CompletionService.PurgeCompletionSuggestions][google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions]: crate::client::CompletionService::purge_completion_suggestions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeCompletionSuggestionsRequest {
    /// Required. The parent data store resource name for which to purge completion
    /// suggestions. Follows pattern
    /// projects/*/locations/*/collections/*/dataStores/*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeCompletionSuggestionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeCompletionSuggestionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for PurgeCompletionSuggestionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeCompletionSuggestionsRequest"
    }
}

/// Response message for
/// [CompletionService.PurgeCompletionSuggestions][google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions]
/// method.
///
/// [google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions]: crate::client::CompletionService::purge_completion_suggestions
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeCompletionSuggestionsResponse {
    /// Whether the completion suggestions were successfully purged.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub purge_succeeded: bool,

    /// A sample of errors encountered while processing the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeCompletionSuggestionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_succeeded][crate::model::PurgeCompletionSuggestionsResponse::purge_succeeded].
    pub fn set_purge_succeeded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.purge_succeeded = v.into();
        self
    }

    /// Sets the value of [error_samples][crate::model::PurgeCompletionSuggestionsResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PurgeCompletionSuggestionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeCompletionSuggestionsResponse"
    }
}

/// Metadata related to the progress of the PurgeCompletionSuggestions
/// operation. This is returned by the google.longrunning.Operation.metadata
/// field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeCompletionSuggestionsMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeCompletionSuggestionsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::PurgeCompletionSuggestionsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PurgeCompletionSuggestionsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PurgeCompletionSuggestionsMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PurgeCompletionSuggestionsMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PurgeCompletionSuggestionsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PurgeCompletionSuggestionsMetadata"
    }
}

/// Record message for
/// [RankService.Rank][google.cloud.discoveryengine.v1.RankService.Rank] method.
///
/// [google.cloud.discoveryengine.v1.RankService.Rank]: crate::client::RankService::rank
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RankingRecord {
    /// The unique ID to represent the record.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The title of the record. Empty by default.
    /// At least one of
    /// [title][google.cloud.discoveryengine.v1.RankingRecord.title] or
    /// [content][google.cloud.discoveryengine.v1.RankingRecord.content] should be
    /// set otherwise an INVALID_ARGUMENT error is thrown.
    ///
    /// [google.cloud.discoveryengine.v1.RankingRecord.content]: crate::model::RankingRecord::content
    /// [google.cloud.discoveryengine.v1.RankingRecord.title]: crate::model::RankingRecord::title
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub title: std::string::String,

    /// The content of the record. Empty by default.
    /// At least one of
    /// [title][google.cloud.discoveryengine.v1.RankingRecord.title] or
    /// [content][google.cloud.discoveryengine.v1.RankingRecord.content] should be
    /// set otherwise an INVALID_ARGUMENT error is thrown.
    ///
    /// [google.cloud.discoveryengine.v1.RankingRecord.content]: crate::model::RankingRecord::content
    /// [google.cloud.discoveryengine.v1.RankingRecord.title]: crate::model::RankingRecord::title
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// The score of this record based on the given query and selected model.
    /// The score will be rounded to 2 decimal places. If the score is close to 0,
    /// it will be rounded to 0.0001 to avoid returning unset.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub score: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RankingRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RankingRecord::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [title][crate::model::RankingRecord::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [content][crate::model::RankingRecord::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [score][crate::model::RankingRecord::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for RankingRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RankingRecord"
    }
}

/// Request message for
/// [RankService.Rank][google.cloud.discoveryengine.v1.RankService.Rank] method.
///
/// [google.cloud.discoveryengine.v1.RankService.Rank]: crate::client::RankService::rank
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RankRequest {
    /// Required. The resource name of the rank service config, such as
    /// `projects/{project_num}/locations/{location}/rankingConfigs/default_ranking_config`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ranking_config: std::string::String,

    /// The identifier of the model to use. It is one of:
    ///
    /// * `semantic-ranker-512@latest`: Semantic ranking model with maximum input
    ///   token size 512.
    ///
    /// It is set to `semantic-ranker-512@latest` by default if unspecified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// The number of results to return. If this is unset or no bigger than zero,
    /// returns all results.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub top_n: i32,

    /// The query to use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Required. A list of records to rank. At most 200 records to rank.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub records: std::vec::Vec<crate::model::RankingRecord>,

    /// If true, the response will contain only record ID and score. By default, it
    /// is false, the response will contain record details.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ignore_record_details_in_response: bool,

    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RankRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ranking_config][crate::model::RankRequest::ranking_config].
    pub fn set_ranking_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ranking_config = v.into();
        self
    }

    /// Sets the value of [model][crate::model::RankRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [top_n][crate::model::RankRequest::top_n].
    pub fn set_top_n<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.top_n = v.into();
        self
    }

    /// Sets the value of [query][crate::model::RankRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [records][crate::model::RankRequest::records].
    pub fn set_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RankingRecord>,
    {
        use std::iter::Iterator;
        self.records = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignore_record_details_in_response][crate::model::RankRequest::ignore_record_details_in_response].
    pub fn set_ignore_record_details_in_response<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.ignore_record_details_in_response = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::RankRequest::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RankRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RankRequest"
    }
}

/// Response message for
/// [RankService.Rank][google.cloud.discoveryengine.v1.RankService.Rank] method.
///
/// [google.cloud.discoveryengine.v1.RankService.Rank]: crate::client::RankService::rank
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RankResponse {
    /// A list of records sorted by descending score.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub records: std::vec::Vec<crate::model::RankingRecord>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RankResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [records][crate::model::RankResponse::records].
    pub fn set_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RankingRecord>,
    {
        use std::iter::Iterator;
        self.records = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RankResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RankResponse"
    }
}

/// Request message for Recommend method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecommendRequest {
    /// Required. Full resource name of a
    /// [ServingConfig][google.cloud.discoveryengine.v1.ServingConfig]:
    /// `projects/*/locations/global/collections/*/engines/*/servingConfigs/*`, or
    /// `projects/*/locations/global/collections/*/dataStores/*/servingConfigs/*`
    ///
    /// One default serving config is created along with your recommendation engine
    /// creation. The engine ID is used as the ID of the default serving
    /// config. For example, for Engine
    /// `projects/*/locations/global/collections/*/engines/my-engine`, you can use
    /// `projects/*/locations/global/collections/*/engines/my-engine/servingConfigs/my-engine`
    /// for your
    /// [RecommendationService.Recommend][google.cloud.discoveryengine.v1.RecommendationService.Recommend]
    /// requests.
    ///
    /// [google.cloud.discoveryengine.v1.RecommendationService.Recommend]: crate::client::RecommendationService::recommend
    /// [google.cloud.discoveryengine.v1.ServingConfig]: crate::model::ServingConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub serving_config: std::string::String,

    /// Required. Context about the user, what they are looking at and what action
    /// they took to trigger the Recommend request. Note that this user event
    /// detail won't be ingested to userEvent logs. Thus, a separate userEvent
    /// write request is required for event logging.
    ///
    /// Don't set
    /// [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]
    /// or
    /// [UserEvent.user_info.user_id][google.cloud.discoveryengine.v1.UserInfo.user_id]
    /// to the same fixed ID for different users. If you are trying to receive
    /// non-personalized recommendations (not recommended; this can negatively
    /// impact model performance), instead set
    /// [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]
    /// to a random unique ID and leave
    /// [UserEvent.user_info.user_id][google.cloud.discoveryengine.v1.UserInfo.user_id]
    /// unset.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]: crate::model::UserEvent::user_pseudo_id
    /// [google.cloud.discoveryengine.v1.UserInfo.user_id]: crate::model::UserInfo::user_id
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_event: std::option::Option<crate::model::UserEvent>,

    /// Maximum number of results to return. Set this property
    /// to the number of recommendation results needed. If zero, the service
    /// chooses a reasonable default. The maximum allowed value is 100. Values
    /// above 100 are set to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Filter for restricting recommendation results with a length limit of 5,000
    /// characters. Currently, only filter expressions on the `filter_tags`
    /// attribute is supported.
    ///
    /// Examples:
    ///
    /// * `(filter_tags: ANY("Red", "Blue") OR filter_tags: ANY("Hot", "Cold"))`
    /// * `(filter_tags: ANY("Red", "Blue")) AND NOT (filter_tags: ANY("Green"))`
    ///
    /// If `attributeFilteringSyntax` is set to true under the `params` field, then
    /// attribute-based expressions are expected instead of the above described
    /// tag-based syntax. Examples:
    ///
    /// * (language: ANY("en", "es")) AND NOT (categories: ANY("Movie"))
    /// * (available: true) AND
    ///   (language: ANY("en", "es")) OR (categories: ANY("Movie"))
    ///
    /// If your filter blocks all results, the API returns generic
    /// (unfiltered) popular Documents. If you only want results strictly matching
    /// the filters, set `strictFiltering` to `true` in
    /// [RecommendRequest.params][google.cloud.discoveryengine.v1.RecommendRequest.params]
    /// to receive empty results instead.
    ///
    /// Note that the API never returns
    /// [Document][google.cloud.discoveryengine.v1.Document]s with `storageStatus`
    /// as `EXPIRED` or `DELETED` regardless of filter choices.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.RecommendRequest.params]: crate::model::RecommendRequest::params
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Use validate only mode for this recommendation query. If set to `true`, a
    /// fake model is used that returns arbitrary Document IDs.
    /// Note that the validate only mode should only be used for testing the API,
    /// or if the model is not ready.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Additional domain specific parameters for the recommendations.
    ///
    /// Allowed values:
    ///
    /// * `returnDocument`: Boolean. If set to `true`, the associated Document
    ///   object is returned in
    ///   [RecommendResponse.RecommendationResult.document][google.cloud.discoveryengine.v1.RecommendResponse.RecommendationResult.document].
    /// * `returnScore`: Boolean. If set to true, the recommendation score
    ///   corresponding to each returned Document is set in
    ///   [RecommendResponse.RecommendationResult.metadata][google.cloud.discoveryengine.v1.RecommendResponse.RecommendationResult.metadata].
    ///   The given score indicates the probability of a Document conversion given
    ///   the user's context and history.
    /// * `strictFiltering`: Boolean. True by default. If set to `false`, the
    ///   service
    ///   returns generic (unfiltered) popular Documents instead of empty if
    ///   your filter blocks all recommendation results.
    /// * `diversityLevel`: String. Default empty. If set to be non-empty, then
    ///   it needs to be one of:
    ///   * `no-diversity`
    ///   * `low-diversity`
    ///   * `medium-diversity`
    ///   * `high-diversity`
    ///   * `auto-diversity`
    ///     This gives request-level control and adjusts recommendation results
    ///     based on Document category.
    /// * `attributeFilteringSyntax`: Boolean. False by default. If set to true,
    ///   the `filter` field is interpreted according to the new,
    ///   attribute-based syntax.
    ///
    /// [google.cloud.discoveryengine.v1.RecommendResponse.RecommendationResult.document]: crate::model::recommend_response::RecommendationResult::document
    /// [google.cloud.discoveryengine.v1.RecommendResponse.RecommendationResult.metadata]: crate::model::recommend_response::RecommendationResult::metadata
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub params: std::collections::HashMap<std::string::String, wkt::Value>,

    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Requirements for
    /// labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommendRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::RecommendRequest::serving_config].
    pub fn set_serving_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serving_config = v.into();
        self
    }

    /// Sets the value of [user_event][crate::model::RecommendRequest::user_event].
    pub fn set_user_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_event][crate::model::RecommendRequest::user_event].
    pub fn set_or_clear_user_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::RecommendRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::RecommendRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RecommendRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [params][crate::model::RecommendRequest::params].
    pub fn set_params<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.params = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [user_labels][crate::model::RecommendRequest::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RecommendRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RecommendRequest"
    }
}

/// Response message for Recommend method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecommendResponse {
    /// A list of recommended Documents. The order represents the ranking (from the
    /// most relevant Document to the least).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::recommend_response::RecommendationResult>,

    /// A unique attribution token. This should be included in the
    /// [UserEvent][google.cloud.discoveryengine.v1.UserEvent] logs resulting from
    /// this recommendation, which enables accurate attribution of recommendation
    /// model performance.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent]: crate::model::UserEvent
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribution_token: std::string::String,

    /// IDs of documents in the request that were missing from the default Branch
    /// associated with the requested ServingConfig.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub missing_ids: std::vec::Vec<std::string::String>,

    /// True if
    /// [RecommendRequest.validate_only][google.cloud.discoveryengine.v1.RecommendRequest.validate_only]
    /// was set.
    ///
    /// [google.cloud.discoveryengine.v1.RecommendRequest.validate_only]: crate::model::RecommendRequest::validate_only
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommendResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::RecommendResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::recommend_response::RecommendationResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attribution_token][crate::model::RecommendResponse::attribution_token].
    pub fn set_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribution_token = v.into();
        self
    }

    /// Sets the value of [missing_ids][crate::model::RecommendResponse::missing_ids].
    pub fn set_missing_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [validate_only][crate::model::RecommendResponse::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for RecommendResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RecommendResponse"
    }
}

/// Defines additional types related to [RecommendResponse].
pub mod recommend_response {
    #[allow(unused_imports)]
    use super::*;

    /// RecommendationResult represents a generic recommendation result with
    /// associated metadata.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RecommendationResult {
        /// Resource ID of the recommended Document.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Set if `returnDocument` is set to true in
        /// [RecommendRequest.params][google.cloud.discoveryengine.v1.RecommendRequest.params].
        ///
        /// [google.cloud.discoveryengine.v1.RecommendRequest.params]: crate::model::RecommendRequest::params
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub document: std::option::Option<crate::model::Document>,

        /// Additional Document metadata or annotations.
        ///
        /// Possible values:
        ///
        /// * `score`: Recommendation score in double value. Is set if
        ///   `returnScore` is set to true in
        ///   [RecommendRequest.params][google.cloud.discoveryengine.v1.RecommendRequest.params].
        ///
        /// [google.cloud.discoveryengine.v1.RecommendRequest.params]: crate::model::RecommendRequest::params
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub metadata: std::collections::HashMap<std::string::String, wkt::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RecommendationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::recommend_response::RecommendationResult::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [document][crate::model::recommend_response::RecommendationResult::document].
        pub fn set_document<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Document>,
        {
            self.document = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [document][crate::model::recommend_response::RecommendationResult::document].
        pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Document>,
        {
            self.document = v.map(|x| x.into());
            self
        }

        /// Sets the value of [metadata][crate::model::recommend_response::RecommendationResult::metadata].
        pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for RecommendationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.RecommendResponse.RecommendationResult"
        }
    }
}

/// Safety rating corresponding to the generated content.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafetyRating {
    /// Output only. Harm category.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub category: crate::model::HarmCategory,

    /// Output only. Harm probability levels in the content.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub probability: crate::model::safety_rating::HarmProbability,

    /// Output only. Harm probability score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub probability_score: f32,

    /// Output only. Harm severity levels in the content.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub severity: crate::model::safety_rating::HarmSeverity,

    /// Output only. Harm severity score.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub severity_score: f32,

    /// Output only. Indicates whether the content was filtered out because of this
    /// rating.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub blocked: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SafetyRating {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::SafetyRating::category].
    pub fn set_category<T: std::convert::Into<crate::model::HarmCategory>>(mut self, v: T) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [probability][crate::model::SafetyRating::probability].
    pub fn set_probability<T: std::convert::Into<crate::model::safety_rating::HarmProbability>>(
        mut self,
        v: T,
    ) -> Self {
        self.probability = v.into();
        self
    }

    /// Sets the value of [probability_score][crate::model::SafetyRating::probability_score].
    pub fn set_probability_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.probability_score = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::SafetyRating::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::safety_rating::HarmSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [severity_score][crate::model::SafetyRating::severity_score].
    pub fn set_severity_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.severity_score = v.into();
        self
    }

    /// Sets the value of [blocked][crate::model::SafetyRating::blocked].
    pub fn set_blocked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.blocked = v.into();
        self
    }
}

impl wkt::message::Message for SafetyRating {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SafetyRating"
    }
}

/// Defines additional types related to [SafetyRating].
pub mod safety_rating {
    #[allow(unused_imports)]
    use super::*;

    /// Harm probability levels in the content.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HarmProbability {
        /// Harm probability unspecified.
        Unspecified,
        /// Negligible level of harm.
        Negligible,
        /// Low level of harm.
        Low,
        /// Medium level of harm.
        Medium,
        /// High level of harm.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HarmProbability::value] or
        /// [HarmProbability::name].
        UnknownValue(harm_probability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod harm_probability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HarmProbability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Negligible => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::High => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HARM_PROBABILITY_UNSPECIFIED"),
                Self::Negligible => std::option::Option::Some("NEGLIGIBLE"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HarmProbability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HarmProbability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HarmProbability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Negligible,
                2 => Self::Low,
                3 => Self::Medium,
                4 => Self::High,
                _ => Self::UnknownValue(harm_probability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HarmProbability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HARM_PROBABILITY_UNSPECIFIED" => Self::Unspecified,
                "NEGLIGIBLE" => Self::Negligible,
                "LOW" => Self::Low,
                "MEDIUM" => Self::Medium,
                "HIGH" => Self::High,
                _ => Self::UnknownValue(harm_probability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HarmProbability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Negligible => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::High => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HarmProbability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmProbability>::new(
                ".google.cloud.discoveryengine.v1.SafetyRating.HarmProbability",
            ))
        }
    }

    /// Harm severity levels.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HarmSeverity {
        /// Harm severity unspecified.
        Unspecified,
        /// Negligible level of harm severity.
        Negligible,
        /// Low level of harm severity.
        Low,
        /// Medium level of harm severity.
        Medium,
        /// High level of harm severity.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HarmSeverity::value] or
        /// [HarmSeverity::name].
        UnknownValue(harm_severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod harm_severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HarmSeverity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Negligible => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::High => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HARM_SEVERITY_UNSPECIFIED"),
                Self::Negligible => std::option::Option::Some("HARM_SEVERITY_NEGLIGIBLE"),
                Self::Low => std::option::Option::Some("HARM_SEVERITY_LOW"),
                Self::Medium => std::option::Option::Some("HARM_SEVERITY_MEDIUM"),
                Self::High => std::option::Option::Some("HARM_SEVERITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HarmSeverity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HarmSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HarmSeverity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Negligible,
                2 => Self::Low,
                3 => Self::Medium,
                4 => Self::High,
                _ => Self::UnknownValue(harm_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HarmSeverity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HARM_SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "HARM_SEVERITY_NEGLIGIBLE" => Self::Negligible,
                "HARM_SEVERITY_LOW" => Self::Low,
                "HARM_SEVERITY_MEDIUM" => Self::Medium,
                "HARM_SEVERITY_HIGH" => Self::High,
                _ => Self::UnknownValue(harm_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HarmSeverity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Negligible => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::High => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HarmSeverity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmSeverity>::new(
                ".google.cloud.discoveryengine.v1.SafetyRating.HarmSeverity",
            ))
        }
    }
}

/// Defines the structure and layout of a type of document data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schema {
    /// Immutable. The full resource name of the schema, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Schema representation. One of
    /// [struct_schema][google.cloud.discoveryengine.v1.Schema.struct_schema] or
    /// [json_schema][google.cloud.discoveryengine.v1.Schema.json_schema] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    ///
    /// [google.cloud.discoveryengine.v1.Schema.json_schema]: crate::model::Schema::schema
    /// [google.cloud.discoveryengine.v1.Schema.struct_schema]: crate::model::Schema::schema
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::schema::Schema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Schema::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::Schema::schema].
    ///
    /// Note that all the setters affecting `schema` are mutually
    /// exclusive.
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::schema::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }

    /// The value of [schema][crate::model::Schema::schema]
    /// if it holds a `StructSchema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn struct_schema(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::schema::Schema::StructSchema(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::Schema::schema]
    /// to hold a `StructSchema`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_struct_schema<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema =
            std::option::Option::Some(crate::model::schema::Schema::StructSchema(v.into()));
        self
    }

    /// The value of [schema][crate::model::Schema::schema]
    /// if it holds a `JsonSchema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json_schema(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.schema.as_ref().and_then(|v| match v {
            crate::model::schema::Schema::JsonSchema(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schema][crate::model::Schema::schema]
    /// to hold a `JsonSchema`.
    ///
    /// Note that all the setters affecting `schema` are
    /// mutually exclusive.
    pub fn set_json_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = std::option::Option::Some(crate::model::schema::Schema::JsonSchema(v.into()));
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Schema"
    }
}

/// Defines additional types related to [Schema].
pub mod schema {
    #[allow(unused_imports)]
    use super::*;

    /// Schema representation. One of
    /// [struct_schema][google.cloud.discoveryengine.v1.Schema.struct_schema] or
    /// [json_schema][google.cloud.discoveryengine.v1.Schema.json_schema] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    ///
    /// [google.cloud.discoveryengine.v1.Schema.json_schema]: crate::model::Schema::schema
    /// [google.cloud.discoveryengine.v1.Schema.struct_schema]: crate::model::Schema::schema
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Schema {
        /// The structured representation of the schema.
        StructSchema(std::boxed::Box<wkt::Struct>),
        /// The JSON representation of the schema.
        JsonSchema(std::string::String),
    }
}

/// Request message for
/// [SchemaService.GetSchema][google.cloud.discoveryengine.v1.SchemaService.GetSchema]
/// method.
///
/// [google.cloud.discoveryengine.v1.SchemaService.GetSchema]: crate::client::SchemaService::get_schema
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSchemaRequest {
    /// Required. The full resource name of the schema, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetSchemaRequest"
    }
}

/// Request message for
/// [SchemaService.ListSchemas][google.cloud.discoveryengine.v1.SchemaService.ListSchemas]
/// method.
///
/// [google.cloud.discoveryengine.v1.SchemaService.ListSchemas]: crate::client::SchemaService::list_schemas
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSchemasRequest {
    /// Required. The parent data store resource name, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of [Schema][google.cloud.discoveryengine.v1.Schema]s to
    /// return. The service may return fewer than this value.
    ///
    /// If unspecified, at most 100
    /// [Schema][google.cloud.discoveryengine.v1.Schema]s are returned.
    ///
    /// The maximum value is 1000; values above 1000 are set to 1000.
    ///
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous
    /// [SchemaService.ListSchemas][google.cloud.discoveryengine.v1.SchemaService.ListSchemas]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [SchemaService.ListSchemas][google.cloud.discoveryengine.v1.SchemaService.ListSchemas]
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.discoveryengine.v1.SchemaService.ListSchemas]: crate::client::SchemaService::list_schemas
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemasRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSchemasRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSchemasRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSchemasRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemasRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListSchemasRequest"
    }
}

/// Response message for
/// [SchemaService.ListSchemas][google.cloud.discoveryengine.v1.SchemaService.ListSchemas]
/// method.
///
/// [google.cloud.discoveryengine.v1.SchemaService.ListSchemas]: crate::client::SchemaService::list_schemas
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSchemasResponse {
    /// The [Schema][google.cloud.discoveryengine.v1.Schema]s.
    ///
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schemas: std::vec::Vec<crate::model::Schema>,

    /// A token that can be sent as
    /// [ListSchemasRequest.page_token][google.cloud.discoveryengine.v1.ListSchemasRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.discoveryengine.v1.ListSchemasRequest.page_token]: crate::model::ListSchemasRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSchemasResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schemas][crate::model::ListSchemasResponse::schemas].
    pub fn set_schemas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Schema>,
    {
        use std::iter::Iterator;
        self.schemas = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSchemasResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSchemasResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListSchemasResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSchemasResponse {
    type PageItem = crate::model::Schema;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.schemas
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [SchemaService.CreateSchema][google.cloud.discoveryengine.v1.SchemaService.CreateSchema]
/// method.
///
/// [google.cloud.discoveryengine.v1.SchemaService.CreateSchema]: crate::client::SchemaService::create_schema
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSchemaRequest {
    /// Required. The parent data store resource name, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The [Schema][google.cloud.discoveryengine.v1.Schema] to create.
    ///
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::Schema>,

    /// Required. The ID to use for the
    /// [Schema][google.cloud.discoveryengine.v1.Schema], which becomes the final
    /// component of the
    /// [Schema.name][google.cloud.discoveryengine.v1.Schema.name].
    ///
    /// This field should conform to
    /// [RFC-1034](https://tools.ietf.org/html/rfc1034) standard with a length
    /// limit of 63 characters.
    ///
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    /// [google.cloud.discoveryengine.v1.Schema.name]: crate::model::Schema::name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub schema_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSchemaRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::CreateSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::CreateSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schema_id][crate::model::CreateSchemaRequest::schema_id].
    pub fn set_schema_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateSchemaRequest"
    }
}

/// Request message for
/// [SchemaService.UpdateSchema][google.cloud.discoveryengine.v1.SchemaService.UpdateSchema]
/// method.
///
/// [google.cloud.discoveryengine.v1.SchemaService.UpdateSchema]: crate::client::SchemaService::update_schema
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSchemaRequest {
    /// Required. The [Schema][google.cloud.discoveryengine.v1.Schema] to update.
    ///
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::Schema>,

    /// If set to true, and the [Schema][google.cloud.discoveryengine.v1.Schema] is
    /// not found, a new [Schema][google.cloud.discoveryengine.v1.Schema] is
    /// created. In this situation, `update_mask` is ignored.
    ///
    /// [google.cloud.discoveryengine.v1.Schema]: crate::model::Schema
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [schema][crate::model::UpdateSchemaRequest::schema].
    pub fn set_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schema][crate::model::UpdateSchemaRequest::schema].
    pub fn set_or_clear_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Schema>,
    {
        self.schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateSchemaRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateSchemaRequest"
    }
}

/// Request message for
/// [SchemaService.DeleteSchema][google.cloud.discoveryengine.v1.SchemaService.DeleteSchema]
/// method.
///
/// [google.cloud.discoveryengine.v1.SchemaService.DeleteSchema]: crate::client::SchemaService::delete_schema
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSchemaRequest {
    /// Required. The full resource name of the schema, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSchemaRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSchemaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteSchemaRequest"
    }
}

/// Metadata for Create Schema LRO.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSchemaMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSchemaMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateSchemaMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateSchemaMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CreateSchemaMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CreateSchemaMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSchemaMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateSchemaMetadata"
    }
}

/// Metadata for UpdateSchema LRO.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSchemaMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSchemaMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::UpdateSchemaMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UpdateSchemaMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::UpdateSchemaMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::UpdateSchemaMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSchemaMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateSchemaMetadata"
    }
}

/// Metadata for DeleteSchema LRO.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSchemaMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSchemaMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeleteSchemaMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteSchemaMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteSchemaMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeleteSchemaMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteSchemaMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteSchemaMetadata"
    }
}

/// Request message for
/// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
/// method.
///
/// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchRequest {
    /// Required. The resource name of the Search serving config, such as
    /// `projects/*/locations/global/collections/default_collection/engines/*/servingConfigs/default_serving_config`,
    /// or
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
    /// This field is used to identify the serving configuration name, set
    /// of models used to make the search.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub serving_config: std::string::String,

    /// The branch resource name, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store/branches/0`.
    ///
    /// Use `default_branch` as the branch ID or leave this field empty, to search
    /// documents under the default branch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub branch: std::string::String,

    /// Raw search query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Raw image query.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image_query: std::option::Option<crate::model::search_request::ImageQuery>,

    /// Maximum number of [Document][google.cloud.discoveryengine.v1.Document]s to
    /// return. The maximum allowed value depends on the data type. Values above
    /// the maximum value are coerced to the maximum value.
    ///
    /// * Websites with basic indexing: Default `10`, Maximum `25`.
    /// * Websites with advanced indexing: Default `25`, Maximum `50`.
    /// * Other: Default `50`, Maximum `100`.
    ///
    /// If this field is negative, an  `INVALID_ARGUMENT` is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token received from a previous
    /// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
    /// must match the call that provided the page token. Otherwise, an
    /// `INVALID_ARGUMENT`  error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A 0-indexed integer that specifies the current offset (that is, starting
    /// result location, amongst the
    /// [Document][google.cloud.discoveryengine.v1.Document]s deemed by the API as
    /// relevant) in search results. This field is only considered if
    /// [page_token][google.cloud.discoveryengine.v1.SearchRequest.page_token] is
    /// unset.
    ///
    /// If this field is negative, an  `INVALID_ARGUMENT`  is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.SearchRequest.page_token]: crate::model::SearchRequest::page_token
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub offset: i32,

    /// The maximum number of results to return for OneBox.
    /// This applies to each OneBox type individually.
    /// Default number is 10.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub one_box_page_size: i32,

    /// Specifications that define the specific
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore]s to be searched,
    /// along with configurations for those data stores. This is only considered
    /// for [Engine][google.cloud.discoveryengine.v1.Engine]s with multiple data
    /// stores. For engines with a single data store, the specs directly under
    /// [SearchRequest][google.cloud.discoveryengine.v1.SearchRequest] should be
    /// used.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    /// [google.cloud.discoveryengine.v1.SearchRequest]: crate::model::SearchRequest
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_store_specs: std::vec::Vec<crate::model::search_request::DataStoreSpec>,

    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the documents being filtered. Filter
    /// expression is case-sensitive.
    ///
    /// If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
    ///
    /// Filtering in Vertex AI Search is done by mapping the LHS filter key to a
    /// key property defined in the Vertex AI Search backend -- this mapping is
    /// defined by the customer in their schema. For example a media customer might
    /// have a field 'name' in their schema. In this case the filter would look
    /// like this: filter --> name:'ANY("king kong")'
    ///
    /// For more information about filtering including syntax and filter
    /// operators, see
    /// [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The default filter that is applied when a user performs a search without
    /// checking any filters on the search page.
    ///
    /// The filter applied to every search request when quality improvement such as
    /// query expansion is needed. In the case a query does not have a sufficient
    /// amount of results this filter will be used to determine whether or not to
    /// enable the query expansion flow. The original filter will still be used for
    /// the query expanded search.
    /// This field is strongly recommended to achieve high search quality.
    ///
    /// For more information about filter syntax, see
    /// [SearchRequest.filter][google.cloud.discoveryengine.v1.SearchRequest.filter].
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.filter]: crate::model::SearchRequest::filter
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub canonical_filter: std::string::String,

    /// The order in which documents are returned. Documents can be ordered by
    /// a field in an [Document][google.cloud.discoveryengine.v1.Document] object.
    /// Leave it unset if ordered by relevance. `order_by` expression is
    /// case-sensitive.
    ///
    /// For more information on ordering the website search results, see
    /// [Order web search
    /// results](https://cloud.google.com/generative-ai-app-builder/docs/order-web-search-results).
    /// For more information on ordering the healthcare search results, see
    /// [Order healthcare search
    /// results](https://cloud.google.com/generative-ai-app-builder/docs/order-hc-results).
    /// If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Information about the end user.
    /// Highly recommended for analytics and personalization.
    /// [UserInfo.user_agent][google.cloud.discoveryengine.v1.UserInfo.user_agent]
    /// is used to deduce `device_type` for analytics.
    ///
    /// [google.cloud.discoveryengine.v1.UserInfo.user_agent]: crate::model::UserInfo::user_agent
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_info: std::option::Option<crate::model::UserInfo>,

    /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
    /// information, see [Standard
    /// fields](https://cloud.google.com/apis/design/standard_fields). This field
    /// helps to better interpret the query. If a value isn't specified, the query
    /// language code is automatically detected, which may not be accurate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Facet specifications for faceted search. If empty, no facets are returned.
    ///
    /// A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
    /// error is returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub facet_specs: std::vec::Vec<crate::model::search_request::FacetSpec>,

    /// Boost specification to boost certain documents.
    /// For more information on boosting, see
    /// [Boosting](https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub boost_spec: std::option::Option<crate::model::search_request::BoostSpec>,

    /// Additional search parameters.
    ///
    /// For public website search only, supported values are:
    ///
    /// * `user_country_code`: string. Default empty. If set to non-empty, results
    ///   are restricted or boosted based on the location provided.
    ///   For example, `user_country_code: "au"`
    ///
    /// * For available codes see [Country
    ///   Codes](https://developers.google.com/custom-search/docs/json_api_reference#countryCodes)
    ///
    /// * `search_type`: double. Default empty. Enables non-webpage searching
    ///   depending on the value. The only valid non-default value is 1,
    ///   which enables image searching.
    ///   For example, `search_type: 1`
    ///
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub params: std::collections::HashMap<std::string::String, wkt::Value>,

    /// The query expansion specification that specifies the conditions under which
    /// query expansion occurs.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_expansion_spec: std::option::Option<crate::model::search_request::QueryExpansionSpec>,

    /// The spell correction specification that specifies the mode under
    /// which spell correction takes effect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spell_correction_spec:
        std::option::Option<crate::model::search_request::SpellCorrectionSpec>,

    /// A unique identifier for tracking visitors. For example, this could be
    /// implemented with an HTTP cookie, which should be able to uniquely identify
    /// a visitor on a single device. This unique identifier should not change if
    /// the visitor logs in or out of the website.
    ///
    /// This field should NOT have a fixed value such as `unknown_visitor`.
    ///
    /// This should be the same identifier as
    /// [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]
    /// and
    /// [CompleteQueryRequest.user_pseudo_id][google.cloud.discoveryengine.v1.CompleteQueryRequest.user_pseudo_id]
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an  `INVALID_ARGUMENT`  error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.CompleteQueryRequest.user_pseudo_id]: crate::model::CompleteQueryRequest::user_pseudo_id
    /// [google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]: crate::model::UserEvent::user_pseudo_id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_pseudo_id: std::string::String,

    /// A specification for configuring the behavior of content search.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content_search_spec: std::option::Option<crate::model::search_request::ContentSearchSpec>,

    /// Whether to turn on safe search. This is only supported for
    /// website search.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub safe_search: bool,

    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Search as you type configuration. Only supported for the
    /// [IndustryVertical.MEDIA][google.cloud.discoveryengine.v1.IndustryVertical.MEDIA]
    /// vertical.
    ///
    /// [google.cloud.discoveryengine.v1.IndustryVertical.MEDIA]: crate::model::IndustryVertical::Media
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_as_you_type_spec:
        std::option::Option<crate::model::search_request::SearchAsYouTypeSpec>,

    /// Optional. Config for display feature, like match highlighting on search
    /// results.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub display_spec: std::option::Option<crate::model::search_request::DisplaySpec>,

    /// The session resource name. Optional.
    ///
    /// Session allows users to do multi-turn /search API calls or coordination
    /// between /search API calls and /answer API calls.
    ///
    /// Example #1 (multi-turn /search API calls):
    ///
    /// . Call /search API with the auto-session mode (see below).
    /// . Call /search API with the session ID generated in the first call.
    ///   Here, the previous search query gets considered in query
    ///   standing. I.e., if the first query is "How did Alphabet do in 2022?"
    ///   and the current query is "How about 2023?", the current query will
    ///   be interpreted as "How did Alphabet do in 2023?".
    ///
    /// Example #2 (coordination between /search API calls and /answer API calls):
    ///
    /// . Call /search API with the auto-session mode (see below).
    /// . Call /answer API with the session ID generated in the first call.
    ///   Here, the answer generation happens in the context of the search
    ///   results from the first search call.
    ///
    /// Auto-session mode: when `projects/.../sessions/-` is used, a new session
    /// gets automatically created. Otherwise, users can use the create-session API
    /// to create a session manually.
    ///
    /// Multi-turn Search feature is currently at private GA stage. Please use
    /// v1alpha or v1beta version instead before we launch this feature to public
    /// GA. Or ask for allowlisting through Google Support team.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session: std::string::String,

    /// Session specification.
    ///
    /// Can be used only when `session` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_spec: std::option::Option<crate::model::search_request::SessionSpec>,

    /// The relevance threshold of the search results.
    ///
    /// Default to Google defined threshold, leveraging a balance of
    /// precision and recall to deliver both highly accurate results and
    /// comprehensive coverage of relevant information.
    ///
    /// This feature is not supported for healthcare search.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub relevance_threshold: crate::model::search_request::RelevanceThreshold,

    /// Optional. The specification for returning the relevance score.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub relevance_score_spec: std::option::Option<crate::model::search_request::RelevanceScoreSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::SearchRequest::serving_config].
    pub fn set_serving_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serving_config = v.into();
        self
    }

    /// Sets the value of [branch][crate::model::SearchRequest::branch].
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.branch = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [image_query][crate::model::SearchRequest::image_query].
    pub fn set_image_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::ImageQuery>,
    {
        self.image_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_query][crate::model::SearchRequest::image_query].
    pub fn set_or_clear_image_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::ImageQuery>,
    {
        self.image_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::SearchRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [offset][crate::model::SearchRequest::offset].
    pub fn set_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.offset = v.into();
        self
    }

    /// Sets the value of [one_box_page_size][crate::model::SearchRequest::one_box_page_size].
    pub fn set_one_box_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.one_box_page_size = v.into();
        self
    }

    /// Sets the value of [data_store_specs][crate::model::SearchRequest::data_store_specs].
    pub fn set_data_store_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_request::DataStoreSpec>,
    {
        use std::iter::Iterator;
        self.data_store_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::SearchRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [canonical_filter][crate::model::SearchRequest::canonical_filter].
    pub fn set_canonical_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.canonical_filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [user_info][crate::model::SearchRequest::user_info].
    pub fn set_user_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_info][crate::model::SearchRequest::user_info].
    pub fn set_or_clear_user_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::SearchRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [facet_specs][crate::model::SearchRequest::facet_specs].
    pub fn set_facet_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_request::FacetSpec>,
    {
        use std::iter::Iterator;
        self.facet_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [boost_spec][crate::model::SearchRequest::boost_spec].
    pub fn set_boost_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::BoostSpec>,
    {
        self.boost_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boost_spec][crate::model::SearchRequest::boost_spec].
    pub fn set_or_clear_boost_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::BoostSpec>,
    {
        self.boost_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::SearchRequest::params].
    pub fn set_params<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.params = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [query_expansion_spec][crate::model::SearchRequest::query_expansion_spec].
    pub fn set_query_expansion_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::QueryExpansionSpec>,
    {
        self.query_expansion_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_expansion_spec][crate::model::SearchRequest::query_expansion_spec].
    pub fn set_or_clear_query_expansion_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::QueryExpansionSpec>,
    {
        self.query_expansion_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [spell_correction_spec][crate::model::SearchRequest::spell_correction_spec].
    pub fn set_spell_correction_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SpellCorrectionSpec>,
    {
        self.spell_correction_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spell_correction_spec][crate::model::SearchRequest::spell_correction_spec].
    pub fn set_or_clear_spell_correction_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SpellCorrectionSpec>,
    {
        self.spell_correction_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_pseudo_id][crate::model::SearchRequest::user_pseudo_id].
    pub fn set_user_pseudo_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_pseudo_id = v.into();
        self
    }

    /// Sets the value of [content_search_spec][crate::model::SearchRequest::content_search_spec].
    pub fn set_content_search_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::ContentSearchSpec>,
    {
        self.content_search_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content_search_spec][crate::model::SearchRequest::content_search_spec].
    pub fn set_or_clear_content_search_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::ContentSearchSpec>,
    {
        self.content_search_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [safe_search][crate::model::SearchRequest::safe_search].
    pub fn set_safe_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.safe_search = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::SearchRequest::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [search_as_you_type_spec][crate::model::SearchRequest::search_as_you_type_spec].
    pub fn set_search_as_you_type_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SearchAsYouTypeSpec>,
    {
        self.search_as_you_type_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [search_as_you_type_spec][crate::model::SearchRequest::search_as_you_type_spec].
    pub fn set_or_clear_search_as_you_type_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SearchAsYouTypeSpec>,
    {
        self.search_as_you_type_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_spec][crate::model::SearchRequest::display_spec].
    pub fn set_display_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::DisplaySpec>,
    {
        self.display_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_spec][crate::model::SearchRequest::display_spec].
    pub fn set_or_clear_display_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::DisplaySpec>,
    {
        self.display_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session][crate::model::SearchRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [session_spec][crate::model::SearchRequest::session_spec].
    pub fn set_session_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SessionSpec>,
    {
        self.session_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_spec][crate::model::SearchRequest::session_spec].
    pub fn set_or_clear_session_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SessionSpec>,
    {
        self.session_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [relevance_threshold][crate::model::SearchRequest::relevance_threshold].
    pub fn set_relevance_threshold<
        T: std::convert::Into<crate::model::search_request::RelevanceThreshold>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.relevance_threshold = v.into();
        self
    }

    /// Sets the value of [relevance_score_spec][crate::model::SearchRequest::relevance_score_spec].
    pub fn set_relevance_score_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::RelevanceScoreSpec>,
    {
        self.relevance_score_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [relevance_score_spec][crate::model::SearchRequest::relevance_score_spec].
    pub fn set_or_clear_relevance_score_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::RelevanceScoreSpec>,
    {
        self.relevance_score_spec = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest"
    }
}

/// Defines additional types related to [SearchRequest].
pub mod search_request {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the image query input.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImageQuery {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub image: std::option::Option<crate::model::search_request::image_query::Image>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImageQuery {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::search_request::ImageQuery::image].
        ///
        /// Note that all the setters affecting `image` are mutually
        /// exclusive.
        pub fn set_image<
            T: std::convert::Into<
                    std::option::Option<crate::model::search_request::image_query::Image>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.image = v.into();
            self
        }

        /// The value of [image][crate::model::search_request::ImageQuery::image]
        /// if it holds a `ImageBytes`, `None` if the field is not set or
        /// holds a different branch.
        pub fn image_bytes(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.image.as_ref().and_then(|v| match v {
                crate::model::search_request::image_query::Image::ImageBytes(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [image][crate::model::search_request::ImageQuery::image]
        /// to hold a `ImageBytes`.
        ///
        /// Note that all the setters affecting `image` are
        /// mutually exclusive.
        pub fn set_image_bytes<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = std::option::Option::Some(
                crate::model::search_request::image_query::Image::ImageBytes(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ImageQuery {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ImageQuery"
        }
    }

    /// Defines additional types related to [ImageQuery].
    pub mod image_query {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Image {
            /// Base64 encoded image bytes. Supported image formats: JPEG, PNG, and
            /// BMP.
            ImageBytes(std::string::String),
        }
    }

    /// A struct to define data stores to filter on in a search call and
    /// configurations for those data stores. Otherwise, an `INVALID_ARGUMENT`
    /// error is returned.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataStoreSpec {
        /// Required. Full resource name of
        /// [DataStore][google.cloud.discoveryengine.v1.DataStore], such as
        /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
        ///
        /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub data_store: std::string::String,

        /// Optional. Filter specification to filter documents in the data store
        /// specified by data_store field. For more information on filtering, see
        /// [Filtering](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        /// Optional. Boost specification to boost certain documents.
        /// For more information on boosting, see
        /// [Boosting](https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results)
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub boost_spec: std::option::Option<crate::model::search_request::BoostSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataStoreSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [data_store][crate::model::search_request::DataStoreSpec::data_store].
        pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.data_store = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::search_request::DataStoreSpec::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }

        /// Sets the value of [boost_spec][crate::model::search_request::DataStoreSpec::boost_spec].
        pub fn set_boost_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_request::BoostSpec>,
        {
            self.boost_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [boost_spec][crate::model::search_request::DataStoreSpec::boost_spec].
        pub fn set_or_clear_boost_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_request::BoostSpec>,
        {
            self.boost_spec = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DataStoreSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.DataStoreSpec"
        }
    }

    /// A facet specification to perform faceted search.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FacetSpec {
        /// Required. The facet key specification.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub facet_key: std::option::Option<crate::model::search_request::facet_spec::FacetKey>,

        /// Maximum facet values that are returned for this facet. If
        /// unspecified, defaults to 20. The maximum allowed value is 300. Values
        /// above 300 are coerced to 300.
        /// For aggregation in healthcare search, when the [FacetKey.key] is
        /// "healthcare_aggregation_key", the limit will be overridden to
        /// 10,000 internally, regardless of the value set here.
        ///
        /// If this field is negative, an  `INVALID_ARGUMENT`  is returned.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub limit: i32,

        /// List of keys to exclude when faceting.
        ///
        /// By default,
        /// [FacetKey.key][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key]
        /// is not excluded from the filter unless it is listed in this field.
        ///
        /// Listing a facet key in this field allows its values to appear as facet
        /// results, even when they are filtered out of search results. Using this
        /// field does not affect what search results are returned.
        ///
        /// For example, suppose there are 100 documents with the color facet "Red"
        /// and 200 documents with the color facet "Blue". A query containing the
        /// filter "color:ANY("Red")" and having "color" as
        /// [FacetKey.key][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key]
        /// would by default return only "Red" documents in the search results, and
        /// also return "Red" with count 100 as the only color facet. Although there
        /// are also blue documents available, "Blue" would not be shown as an
        /// available facet value.
        ///
        /// If "color" is listed in "excludedFilterKeys", then the query returns the
        /// facet values "Red" with count 100 and "Blue" with count 200, because the
        /// "color" key is now excluded from the filter. Because this field doesn't
        /// affect search results, the search results are still correctly filtered to
        /// return only "Red" documents.
        ///
        /// A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
        /// error is returned.
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key]: crate::model::search_request::facet_spec::FacetKey::key
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub excluded_filter_keys: std::vec::Vec<std::string::String>,

        /// Enables dynamic position for this facet. If set to true, the position of
        /// this facet among all facets in the response is determined automatically.
        /// If dynamic facets are enabled, it is ordered together.
        /// If set to false, the position of this facet in the
        /// response is the same as in the request, and it is ranked before
        /// the facets with dynamic position enable and all dynamic facets.
        ///
        /// For example, you may always want to have rating facet returned in
        /// the response, but it's not necessarily to always display the rating facet
        /// at the top. In that case, you can set enable_dynamic_position to true so
        /// that the position of rating facet in response is determined
        /// automatically.
        ///
        /// Another example, assuming you have the following facets in the request:
        ///
        /// * "rating", enable_dynamic_position = true
        ///
        /// * "price", enable_dynamic_position = false
        ///
        /// * "brands", enable_dynamic_position = false
        ///
        ///
        /// And also you have a dynamic facets enabled, which generates a facet
        /// `gender`. Then the final order of the facets in the response can be
        /// ("price", "brands", "rating", "gender") or ("price", "brands", "gender",
        /// "rating") depends on how API orders "gender" and "rating" facets.
        /// However, notice that "price" and "brands" are always
        /// ranked at first and second position because their enable_dynamic_position
        /// is false.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enable_dynamic_position: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FacetSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [facet_key][crate::model::search_request::FacetSpec::facet_key].
        pub fn set_facet_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_request::facet_spec::FacetKey>,
        {
            self.facet_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [facet_key][crate::model::search_request::FacetSpec::facet_key].
        pub fn set_or_clear_facet_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_request::facet_spec::FacetKey>,
        {
            self.facet_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [limit][crate::model::search_request::FacetSpec::limit].
        pub fn set_limit<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.limit = v.into();
            self
        }

        /// Sets the value of [excluded_filter_keys][crate::model::search_request::FacetSpec::excluded_filter_keys].
        pub fn set_excluded_filter_keys<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_filter_keys = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [enable_dynamic_position][crate::model::search_request::FacetSpec::enable_dynamic_position].
        pub fn set_enable_dynamic_position<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_dynamic_position = v.into();
            self
        }
    }

    impl wkt::message::Message for FacetSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.FacetSpec"
        }
    }

    /// Defines additional types related to [FacetSpec].
    pub mod facet_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how a facet is computed.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FacetKey {
            /// Required. Supported textual and numerical facet keys in
            /// [Document][google.cloud.discoveryengine.v1.Document] object, over which
            /// the facet values are computed. Facet key is case-sensitive.
            ///
            /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub key: std::string::String,

            /// Set only if values should be bucketed into intervals. Must be set
            /// for facets with numerical values. Must not be set for facet with text
            /// values. Maximum number of intervals is 30.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub intervals: std::vec::Vec<crate::model::Interval>,

            /// Only get facet for the given restricted values. Only supported on
            /// textual fields. For example, suppose "category" has three values
            /// "Action > 2022", "Action > 2021" and "Sci-Fi > 2022". If set
            /// "restricted_values" to "Action > 2022", the "category" facet only
            /// contains "Action > 2022". Only supported on textual fields. Maximum
            /// is 10.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub restricted_values: std::vec::Vec<std::string::String>,

            /// Only get facet values that start with the given string prefix. For
            /// example, suppose "category" has three values "Action > 2022",
            /// "Action > 2021" and "Sci-Fi > 2022". If set "prefixes" to "Action", the
            /// "category" facet only contains "Action > 2022" and "Action > 2021".
            /// Only supported on textual fields. Maximum is 10.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub prefixes: std::vec::Vec<std::string::String>,

            /// Only get facet values that contain the given strings. For example,
            /// suppose "category" has three values "Action > 2022",
            /// "Action > 2021" and "Sci-Fi > 2022". If set "contains" to "2022", the
            /// "category" facet only contains "Action > 2022" and "Sci-Fi > 2022".
            /// Only supported on textual fields. Maximum is 10.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub contains: std::vec::Vec<std::string::String>,

            /// True to make facet keys case insensitive when getting faceting
            /// values with prefixes or contains; false otherwise.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub case_insensitive: bool,

            /// The order in which documents are returned.
            ///
            /// Allowed values are:
            ///
            /// * "count desc", which means order by
            ///   [SearchResponse.Facet.values.count][google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.count]
            ///   descending.
            ///
            /// * "value desc", which means order by
            ///   [SearchResponse.Facet.values.value][google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.value]
            ///   descending.
            ///   Only applies to textual facets.
            ///
            ///
            /// If not set, textual values are sorted in [natural
            /// order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical
            /// intervals are sorted in the order given by
            /// [FacetSpec.FacetKey.intervals][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals].
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals]: crate::model::search_request::facet_spec::FacetKey::intervals
            /// [google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.count]: crate::model::search_response::facet::FacetValue::count
            /// [google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.value]: crate::model::search_response::facet::FacetValue::facet_value
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub order_by: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FacetKey {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::search_request::facet_spec::FacetKey::key].
            pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.key = v.into();
                self
            }

            /// Sets the value of [intervals][crate::model::search_request::facet_spec::FacetKey::intervals].
            pub fn set_intervals<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Interval>,
            {
                use std::iter::Iterator;
                self.intervals = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [restricted_values][crate::model::search_request::facet_spec::FacetKey::restricted_values].
            pub fn set_restricted_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.restricted_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [prefixes][crate::model::search_request::facet_spec::FacetKey::prefixes].
            pub fn set_prefixes<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.prefixes = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [contains][crate::model::search_request::facet_spec::FacetKey::contains].
            pub fn set_contains<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.contains = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [case_insensitive][crate::model::search_request::facet_spec::FacetKey::case_insensitive].
            pub fn set_case_insensitive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.case_insensitive = v.into();
                self
            }

            /// Sets the value of [order_by][crate::model::search_request::facet_spec::FacetKey::order_by].
            pub fn set_order_by<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.order_by = v.into();
                self
            }
        }

        impl wkt::message::Message for FacetKey {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey"
            }
        }
    }

    /// Boost specification to boost certain documents.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BoostSpec {
        /// Condition boost specifications. If a document matches multiple conditions
        /// in the specifications, boost scores from these specifications are all
        /// applied and combined in a non-linear way. Maximum number of
        /// specifications is 20.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub condition_boost_specs:
            std::vec::Vec<crate::model::search_request::boost_spec::ConditionBoostSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BoostSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition_boost_specs][crate::model::search_request::BoostSpec::condition_boost_specs].
        pub fn set_condition_boost_specs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::search_request::boost_spec::ConditionBoostSpec>,
        {
            use std::iter::Iterator;
            self.condition_boost_specs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for BoostSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.BoostSpec"
        }
    }

    /// Defines additional types related to [BoostSpec].
    pub mod boost_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Boost applies to documents which match a condition.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ConditionBoostSpec {
            /// An expression which specifies a boost condition. The syntax and
            /// supported fields are the same as a filter expression. See
            /// [SearchRequest.filter][google.cloud.discoveryengine.v1.SearchRequest.filter]
            /// for detail syntax and limitations.
            ///
            /// Examples:
            ///
            /// * To boost documents with document ID "doc_1" or "doc_2", and
            ///   color "Red" or "Blue":
            ///   `(document_id: ANY("doc_1", "doc_2")) AND (color: ANY("Red", "Blue"))`
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.filter]: crate::model::SearchRequest::filter
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub condition: std::string::String,

            /// Strength of the condition boost, which should be in [-1, 1]. Negative
            /// boost means demotion. Default is 0.0.
            ///
            /// Setting to 1.0 gives the document a big promotion. However, it does
            /// not necessarily mean that the boosted document will be the top result
            /// at all times, nor that other documents will be excluded. Results
            /// could still be shown even when none of them matches the condition.
            /// And results that are significantly more relevant to the search query
            /// can still trump your heavily favored but irrelevant documents.
            ///
            /// Setting to -1.0 gives the document a big demotion. However, results
            /// that are deeply relevant might still be shown. The document will have
            /// an upstream battle to get a fairly high ranking, but it is not
            /// blocked out completely.
            ///
            /// Setting to 0.0 means no boost applied. The boosting condition is
            /// ignored. Only one of the (condition, boost) combination or the
            /// boost_control_spec below are set. If both are set then the global boost
            /// is ignored and the more fine-grained boost_control_spec is applied.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F32")]
            pub boost: f32,

            /// Complex specification for custom ranking based on customer defined
            /// attribute value.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub boost_control_spec: std::option::Option<
                crate::model::search_request::boost_spec::condition_boost_spec::BoostControlSpec,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ConditionBoostSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [condition][crate::model::search_request::boost_spec::ConditionBoostSpec::condition].
            pub fn set_condition<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.condition = v.into();
                self
            }

            /// Sets the value of [boost][crate::model::search_request::boost_spec::ConditionBoostSpec::boost].
            pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.boost = v.into();
                self
            }

            /// Sets the value of [boost_control_spec][crate::model::search_request::boost_spec::ConditionBoostSpec::boost_control_spec].
            pub fn set_boost_control_spec<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::search_request::boost_spec::condition_boost_spec::BoostControlSpec>
            {
                self.boost_control_spec = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [boost_control_spec][crate::model::search_request::boost_spec::ConditionBoostSpec::boost_control_spec].
            pub fn set_or_clear_boost_control_spec<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::search_request::boost_spec::condition_boost_spec::BoostControlSpec>
            {
                self.boost_control_spec = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for ConditionBoostSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.BoostSpec.ConditionBoostSpec"
            }
        }

        /// Defines additional types related to [ConditionBoostSpec].
        pub mod condition_boost_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Specification for custom ranking based on customer specified attribute
            /// value. It provides more controls for customized ranking than the simple
            /// (condition, boost) combination above.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct BoostControlSpec {

                /// The name of the field whose value will be used to determine the
                /// boost amount.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub field_name: std::string::String,

                /// The attribute type to be used to determine the boost amount. The
                /// attribute value can be derived from the field value of the specified
                /// field_name. In the case of numerical it is straightforward i.e.
                /// attribute_value = numerical_field_value. In the case of freshness
                /// however, attribute_value = (time.now() - datetime_field_value).
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub attribute_type: crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::AttributeType,

                /// The interpolation type to be applied to connect the control points
                /// listed below.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                pub interpolation_type: crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType,

                /// The control points used to define the curve. The monotonic function
                /// (defined through the interpolation_type above) passes through the
                /// control points listed here.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub control_points: std::vec::Vec<crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl BoostControlSpec {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [field_name][crate::model::search_request::boost_spec::condition_boost_spec::BoostControlSpec::field_name].
                pub fn set_field_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.field_name = v.into();
                    self
                }

                /// Sets the value of [attribute_type][crate::model::search_request::boost_spec::condition_boost_spec::BoostControlSpec::attribute_type].
                pub fn set_attribute_type<T: std::convert::Into<crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::AttributeType>>(mut self, v: T) -> Self{
                    self.attribute_type = v.into();
                    self
                }

                /// Sets the value of [interpolation_type][crate::model::search_request::boost_spec::condition_boost_spec::BoostControlSpec::interpolation_type].
                pub fn set_interpolation_type<T: std::convert::Into<crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType>>(mut self, v: T) -> Self{
                    self.interpolation_type = v.into();
                    self
                }

                /// Sets the value of [control_points][crate::model::search_request::boost_spec::condition_boost_spec::BoostControlSpec::control_points].
                pub fn set_control_points<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>
                {
                    use std::iter::Iterator;
                    self.control_points = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            impl wkt::message::Message for BoostControlSpec {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.BoostSpec.ConditionBoostSpec.BoostControlSpec"
                }
            }

            /// Defines additional types related to [BoostControlSpec].
            pub mod boost_control_spec {
                #[allow(unused_imports)]
                use super::*;

                /// The control points used to define the curve. The curve defined
                /// through these control points can only be monotonically increasing
                /// or decreasing(constant values are acceptable).
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct ControlPoint {
                    /// Can be one of:
                    ///
                    /// . The numerical field value.
                    /// . The duration spec for freshness:
                    ///   The value must be formatted as an XSD `dayTimeDuration` value (a
                    ///   restricted subset of an ISO 8601 duration value). The pattern for
                    ///   this is: `[nD][T[nH][nM][nS]]`.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub attribute_value: std::string::String,

                    /// The value between -1 to 1 by which to boost the score if the
                    /// attribute_value evaluates to the value specified above.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F32")]
                    pub boost_amount: f32,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl ControlPoint {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [attribute_value][crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint::attribute_value].
                    pub fn set_attribute_value<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.attribute_value = v.into();
                        self
                    }

                    /// Sets the value of [boost_amount][crate::model::search_request::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint::boost_amount].
                    pub fn set_boost_amount<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                        self.boost_amount = v.into();
                        self
                    }
                }

                impl wkt::message::Message for ControlPoint {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.BoostSpec.ConditionBoostSpec.BoostControlSpec.ControlPoint"
                    }
                }

                /// The attribute(or function) for which the custom ranking is to be
                /// applied.
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum AttributeType {
                    /// Unspecified AttributeType.
                    Unspecified,
                    /// The value of the numerical field will be used to dynamically update
                    /// the boost amount. In this case, the attribute_value (the x value)
                    /// of the control point will be the actual value of the numerical
                    /// field for which the boost_amount is specified.
                    Numerical,
                    /// For the freshness use case the attribute value will be the duration
                    /// between the current time and the date in the datetime field
                    /// specified. The value must be formatted as an XSD `dayTimeDuration`
                    /// value (a restricted subset of an ISO 8601 duration value). The
                    /// pattern for this is: `[nD][T[nH][nM][nS]]`.
                    /// For example, `5D`, `3DT12H30M`, `T24H`.
                    Freshness,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [AttributeType::value] or
                    /// [AttributeType::name].
                    UnknownValue(attribute_type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod attribute_type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl AttributeType {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Numerical => std::option::Option::Some(1),
                            Self::Freshness => std::option::Option::Some(2),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("ATTRIBUTE_TYPE_UNSPECIFIED")
                            }
                            Self::Numerical => std::option::Option::Some("NUMERICAL"),
                            Self::Freshness => std::option::Option::Some("FRESHNESS"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for AttributeType {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for AttributeType {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for AttributeType {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Numerical,
                            2 => Self::Freshness,
                            _ => Self::UnknownValue(attribute_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for AttributeType {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "ATTRIBUTE_TYPE_UNSPECIFIED" => Self::Unspecified,
                            "NUMERICAL" => Self::Numerical,
                            "FRESHNESS" => Self::Freshness,
                            _ => Self::UnknownValue(attribute_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for AttributeType {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Numerical => serializer.serialize_i32(1),
                            Self::Freshness => serializer.serialize_i32(2),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for AttributeType {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttributeType>::new(
                            ".google.cloud.discoveryengine.v1.SearchRequest.BoostSpec.ConditionBoostSpec.BoostControlSpec.AttributeType"))
                    }
                }

                /// The interpolation type to be applied. Default will be linear
                /// (Piecewise Linear).
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum InterpolationType {
                    /// Interpolation type is unspecified. In this case, it defaults to
                    /// Linear.
                    Unspecified,
                    /// Piecewise linear interpolation will be applied.
                    Linear,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [InterpolationType::value] or
                    /// [InterpolationType::name].
                    UnknownValue(interpolation_type::UnknownValue),
                }

                #[doc(hidden)]
                pub mod interpolation_type {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl InterpolationType {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::Linear => std::option::Option::Some(1),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("INTERPOLATION_TYPE_UNSPECIFIED")
                            }
                            Self::Linear => std::option::Option::Some("LINEAR"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for InterpolationType {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for InterpolationType {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for InterpolationType {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::Linear,
                            _ => Self::UnknownValue(interpolation_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for InterpolationType {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "INTERPOLATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                            "LINEAR" => Self::Linear,
                            _ => Self::UnknownValue(interpolation_type::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for InterpolationType {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::Linear => serializer.serialize_i32(1),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for InterpolationType {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InterpolationType>::new(
                            ".google.cloud.discoveryengine.v1.SearchRequest.BoostSpec.ConditionBoostSpec.BoostControlSpec.InterpolationType"))
                    }
                }
            }
        }
    }

    /// Specification to determine under which conditions query expansion should
    /// occur.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueryExpansionSpec {
        /// The condition under which query expansion should occur. Default to
        /// [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED]: crate::model::search_request::query_expansion_spec::Condition::Disabled
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub condition: crate::model::search_request::query_expansion_spec::Condition,

        /// Whether to pin unexpanded results. If this field is set to true,
        /// unexpanded products are always at the top of the search results, followed
        /// by the expanded results.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub pin_unexpanded_results: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryExpansionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::search_request::QueryExpansionSpec::condition].
        pub fn set_condition<
            T: std::convert::Into<crate::model::search_request::query_expansion_spec::Condition>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [pin_unexpanded_results][crate::model::search_request::QueryExpansionSpec::pin_unexpanded_results].
        pub fn set_pin_unexpanded_results<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.pin_unexpanded_results = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryExpansionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec"
        }
    }

    /// Defines additional types related to [QueryExpansionSpec].
    pub mod query_expansion_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Enum describing under which condition query expansion should occur.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Condition {
            /// Unspecified query expansion condition. In this case, server behavior
            /// defaults to
            /// [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED]: crate::model::search_request::query_expansion_spec::Condition::Disabled
            Unspecified,
            /// Disabled query expansion. Only the exact search query is used, even if
            /// [SearchResponse.total_size][google.cloud.discoveryengine.v1.SearchResponse.total_size]
            /// is zero.
            ///
            /// [google.cloud.discoveryengine.v1.SearchResponse.total_size]: crate::model::SearchResponse::total_size
            Disabled,
            /// Automatic query expansion built by the Search API.
            Auto,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Condition::value] or
            /// [Condition::name].
            UnknownValue(condition::UnknownValue),
        }

        #[doc(hidden)]
        pub mod condition {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Condition {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Disabled => std::option::Option::Some(1),
                    Self::Auto => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CONDITION_UNSPECIFIED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Condition {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Condition {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Condition {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Disabled,
                    2 => Self::Auto,
                    _ => Self::UnknownValue(condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Condition {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONDITION_UNSPECIFIED" => Self::Unspecified,
                    "DISABLED" => Self::Disabled,
                    "AUTO" => Self::Auto,
                    _ => Self::UnknownValue(condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Condition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Disabled => serializer.serialize_i32(1),
                    Self::Auto => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Condition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Condition>::new(
                    ".google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition",
                ))
            }
        }
    }

    /// The specification for query spell correction.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SpellCorrectionSpec {
        /// The mode under which spell correction
        /// replaces the original search query. Defaults to
        /// [Mode.AUTO][google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO]: crate::model::search_request::spell_correction_spec::Mode::Auto
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub mode: crate::model::search_request::spell_correction_spec::Mode,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SpellCorrectionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mode][crate::model::search_request::SpellCorrectionSpec::mode].
        pub fn set_mode<
            T: std::convert::Into<crate::model::search_request::spell_correction_spec::Mode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }
    }

    impl wkt::message::Message for SpellCorrectionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec"
        }
    }

    /// Defines additional types related to [SpellCorrectionSpec].
    pub mod spell_correction_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Enum describing under which mode spell correction should occur.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Unspecified spell correction mode. In this case, server behavior
            /// defaults to
            /// [Mode.AUTO][google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO]: crate::model::search_request::spell_correction_spec::Mode::Auto
            Unspecified,
            /// Search API tries to find a spelling suggestion. If a suggestion is
            /// found, it is put in the
            /// [SearchResponse.corrected_query][google.cloud.discoveryengine.v1.SearchResponse.corrected_query].
            /// The spelling suggestion won't be used as the search query.
            ///
            /// [google.cloud.discoveryengine.v1.SearchResponse.corrected_query]: crate::model::SearchResponse::corrected_query
            SuggestionOnly,
            /// Automatic spell correction built by the Search API. Search will
            /// be based on the corrected query if found.
            Auto,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SuggestionOnly => std::option::Option::Some(1),
                    Self::Auto => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::SuggestionOnly => std::option::Option::Some("SUGGESTION_ONLY"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SuggestionOnly,
                    2 => Self::Auto,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "SUGGESTION_ONLY" => Self::SuggestionOnly,
                    "AUTO" => Self::Auto,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SuggestionOnly => serializer.serialize_i32(1),
                    Self::Auto => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode",
                ))
            }
        }
    }

    /// A specification for configuring the behavior of content search.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ContentSearchSpec {
        /// If `snippetSpec` is not specified, snippets are not included in the
        /// search response.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub snippet_spec:
            std::option::Option<crate::model::search_request::content_search_spec::SnippetSpec>,

        /// If `summarySpec` is not specified, summaries are not included in the
        /// search response.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub summary_spec:
            std::option::Option<crate::model::search_request::content_search_spec::SummarySpec>,

        /// If there is no extractive_content_spec provided, there will be no
        /// extractive answer in the search response.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub extractive_content_spec: std::option::Option<
            crate::model::search_request::content_search_spec::ExtractiveContentSpec,
        >,

        /// Specifies the search result mode. If unspecified, the
        /// search result mode defaults to `DOCUMENTS`.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub search_result_mode: crate::model::search_request::content_search_spec::SearchResultMode,

        /// Specifies the chunk spec to be returned from the search response.
        /// Only available if the
        /// [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
        /// is set to
        /// [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]: crate::model::search_request::content_search_spec::SearchResultMode::Chunks
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]: crate::model::search_request::ContentSearchSpec::search_result_mode
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub chunk_spec:
            std::option::Option<crate::model::search_request::content_search_spec::ChunkSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ContentSearchSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [snippet_spec][crate::model::search_request::ContentSearchSpec::snippet_spec].
        pub fn set_snippet_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_request::content_search_spec::SnippetSpec>,
        {
            self.snippet_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [snippet_spec][crate::model::search_request::ContentSearchSpec::snippet_spec].
        pub fn set_or_clear_snippet_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_request::content_search_spec::SnippetSpec>,
        {
            self.snippet_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [summary_spec][crate::model::search_request::ContentSearchSpec::summary_spec].
        pub fn set_summary_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_request::content_search_spec::SummarySpec>,
        {
            self.summary_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [summary_spec][crate::model::search_request::ContentSearchSpec::summary_spec].
        pub fn set_or_clear_summary_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_request::content_search_spec::SummarySpec>,
        {
            self.summary_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [extractive_content_spec][crate::model::search_request::ContentSearchSpec::extractive_content_spec].
        pub fn set_extractive_content_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::search_request::content_search_spec::ExtractiveContentSpec,
                >,
        {
            self.extractive_content_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [extractive_content_spec][crate::model::search_request::ContentSearchSpec::extractive_content_spec].
        pub fn set_or_clear_extractive_content_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::search_request::content_search_spec::ExtractiveContentSpec,
                >,
        {
            self.extractive_content_spec = v.map(|x| x.into());
            self
        }

        /// Sets the value of [search_result_mode][crate::model::search_request::ContentSearchSpec::search_result_mode].
        pub fn set_search_result_mode<
            T: std::convert::Into<crate::model::search_request::content_search_spec::SearchResultMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.search_result_mode = v.into();
            self
        }

        /// Sets the value of [chunk_spec][crate::model::search_request::ContentSearchSpec::chunk_spec].
        pub fn set_chunk_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_request::content_search_spec::ChunkSpec>,
        {
            self.chunk_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [chunk_spec][crate::model::search_request::ContentSearchSpec::chunk_spec].
        pub fn set_or_clear_chunk_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_request::content_search_spec::ChunkSpec>,
        {
            self.chunk_spec = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ContentSearchSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec"
        }
    }

    /// Defines additional types related to [ContentSearchSpec].
    pub mod content_search_spec {
        #[allow(unused_imports)]
        use super::*;

        /// A specification for configuring snippets in a search response.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SnippetSpec {
            /// [DEPRECATED] This field is deprecated. To control snippet return, use
            /// `return_snippet` field. For backwards compatibility, we will return
            /// snippet if max_snippet_count > 0.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            #[deprecated]
            pub max_snippet_count: i32,

            /// [DEPRECATED] This field is deprecated and will have no affect on the
            /// snippet.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[deprecated]
            pub reference_only: bool,

            /// If `true`, then return snippet. If no snippet can be generated, we
            /// return "No snippet is available for this page." A `snippet_status` with
            /// `SUCCESS` or `NO_SNIPPET_AVAILABLE` will also be returned.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub return_snippet: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SnippetSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [max_snippet_count][crate::model::search_request::content_search_spec::SnippetSpec::max_snippet_count].
            #[deprecated]
            pub fn set_max_snippet_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_snippet_count = v.into();
                self
            }

            /// Sets the value of [reference_only][crate::model::search_request::content_search_spec::SnippetSpec::reference_only].
            #[deprecated]
            pub fn set_reference_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.reference_only = v.into();
                self
            }

            /// Sets the value of [return_snippet][crate::model::search_request::content_search_spec::SnippetSpec::return_snippet].
            pub fn set_return_snippet<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.return_snippet = v.into();
                self
            }
        }

        impl wkt::message::Message for SnippetSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SnippetSpec"
            }
        }

        /// A specification for configuring a summary returned in a search
        /// response.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SummarySpec {
            /// The number of top results to generate the summary from. If the number
            /// of results returned is less than `summaryResultCount`, the summary is
            /// generated from all of the results.
            ///
            /// At most 10 results for documents mode, or 50 for chunks mode, can be
            /// used to generate a summary. The chunks mode is used when
            /// [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
            /// is set to
            /// [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS].
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]: crate::model::search_request::content_search_spec::SearchResultMode::Chunks
            /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]: crate::model::search_request::ContentSearchSpec::search_result_mode
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub summary_result_count: i32,

            /// Specifies whether to include citations in the summary. The default
            /// value is `false`.
            ///
            /// When this field is set to `true`, summaries include in-line citation
            /// numbers.
            ///
            /// Example summary including citations:
            ///
            /// BigQuery is Google Cloud's fully managed and completely serverless
            /// enterprise data warehouse [1]. BigQuery supports all data types, works
            /// across clouds, and has built-in machine learning and business
            /// intelligence, all within a unified platform [2, 3].
            ///
            /// The citation numbers refer to the returned search results and are
            /// 1-indexed. For example, [1] means that the sentence is attributed to
            /// the first search result. [2, 3] means that the sentence is attributed
            /// to both the second and third search results.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub include_citations: bool,

            /// Specifies whether to filter out adversarial queries. The default value
            /// is `false`.
            ///
            /// Google employs search-query classification to detect adversarial
            /// queries. No summary is returned if the search query is classified as an
            /// adversarial query. For example, a user might ask a question regarding
            /// negative comments about the company or submit a query designed to
            /// generate unsafe, policy-violating output. If this field is set to
            /// `true`, we skip generating summaries for adversarial queries and return
            /// fallback messages instead.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub ignore_adversarial_query: bool,

            /// Specifies whether to filter out queries that are not summary-seeking.
            /// The default value is `false`.
            ///
            /// Google employs search-query classification to detect summary-seeking
            /// queries. No summary is returned if the search query is classified as a
            /// non-summary seeking query. For example, `why is the sky blue` and `Who
            /// is the best soccer player in the world?` are summary-seeking queries,
            /// but `SFO airport` and `world cup 2026` are not. They are most likely
            /// navigational queries. If this field is set to `true`, we skip
            /// generating summaries for non-summary seeking queries and return
            /// fallback messages instead.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub ignore_non_summary_seeking_query: bool,

            /// Specifies whether to filter out queries that have low relevance. The
            /// default value is `false`.
            ///
            /// If this field is set to `false`, all search results are used regardless
            /// of relevance to generate answers. If set to `true`, only queries with
            /// high relevance search results will generate answers.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub ignore_low_relevant_content: bool,

            /// Optional. Specifies whether to filter out jail-breaking queries. The
            /// default value is `false`.
            ///
            /// Google employs search-query classification to detect jail-breaking
            /// queries. No summary is returned if the search query is classified as a
            /// jail-breaking query. A user might add instructions to the query to
            /// change the tone, style, language, content of the answer, or ask the
            /// model to act as a different entity, e.g. "Reply in the tone of a
            /// competing company's CEO". If this field is set to `true`, we skip
            /// generating summaries for jail-breaking queries and return fallback
            /// messages instead.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub ignore_jail_breaking_query: bool,

            /// If specified, the spec will be used to modify the prompt provided to
            /// the LLM.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_prompt_spec: std::option::Option<
                crate::model::search_request::content_search_spec::summary_spec::ModelPromptSpec,
            >,

            /// Language code for Summary. Use language tags defined by
            /// [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
            /// Note: This is an experimental feature.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub language_code: std::string::String,

            /// If specified, the spec will be used to modify the model specification
            /// provided to the LLM.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub model_spec: std::option::Option<
                crate::model::search_request::content_search_spec::summary_spec::ModelSpec,
            >,

            /// If true, answer will be generated from most relevant chunks from top
            /// search results. This feature will improve summary quality.
            /// Note that with this feature enabled, not all top search results
            /// will be referenced and included in the reference list, so the citation
            /// source index only points to the search results listed in the reference
            /// list.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub use_semantic_chunks: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SummarySpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [summary_result_count][crate::model::search_request::content_search_spec::SummarySpec::summary_result_count].
            pub fn set_summary_result_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.summary_result_count = v.into();
                self
            }

            /// Sets the value of [include_citations][crate::model::search_request::content_search_spec::SummarySpec::include_citations].
            pub fn set_include_citations<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.include_citations = v.into();
                self
            }

            /// Sets the value of [ignore_adversarial_query][crate::model::search_request::content_search_spec::SummarySpec::ignore_adversarial_query].
            pub fn set_ignore_adversarial_query<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.ignore_adversarial_query = v.into();
                self
            }

            /// Sets the value of [ignore_non_summary_seeking_query][crate::model::search_request::content_search_spec::SummarySpec::ignore_non_summary_seeking_query].
            pub fn set_ignore_non_summary_seeking_query<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.ignore_non_summary_seeking_query = v.into();
                self
            }

            /// Sets the value of [ignore_low_relevant_content][crate::model::search_request::content_search_spec::SummarySpec::ignore_low_relevant_content].
            pub fn set_ignore_low_relevant_content<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.ignore_low_relevant_content = v.into();
                self
            }

            /// Sets the value of [ignore_jail_breaking_query][crate::model::search_request::content_search_spec::SummarySpec::ignore_jail_breaking_query].
            pub fn set_ignore_jail_breaking_query<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.ignore_jail_breaking_query = v.into();
                self
            }

            /// Sets the value of [model_prompt_spec][crate::model::search_request::content_search_spec::SummarySpec::model_prompt_spec].
            pub fn set_model_prompt_spec<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::search_request::content_search_spec::summary_spec::ModelPromptSpec>
            {
                self.model_prompt_spec = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [model_prompt_spec][crate::model::search_request::content_search_spec::SummarySpec::model_prompt_spec].
            pub fn set_or_clear_model_prompt_spec<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::search_request::content_search_spec::summary_spec::ModelPromptSpec>
            {
                self.model_prompt_spec = v.map(|x| x.into());
                self
            }

            /// Sets the value of [language_code][crate::model::search_request::content_search_spec::SummarySpec::language_code].
            pub fn set_language_code<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.language_code = v.into();
                self
            }

            /// Sets the value of [model_spec][crate::model::search_request::content_search_spec::SummarySpec::model_spec].
            pub fn set_model_spec<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::search_request::content_search_spec::summary_spec::ModelSpec,
                    >,
            {
                self.model_spec = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [model_spec][crate::model::search_request::content_search_spec::SummarySpec::model_spec].
            pub fn set_or_clear_model_spec<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::search_request::content_search_spec::summary_spec::ModelSpec,
                    >,
            {
                self.model_spec = v.map(|x| x.into());
                self
            }

            /// Sets the value of [use_semantic_chunks][crate::model::search_request::content_search_spec::SummarySpec::use_semantic_chunks].
            pub fn set_use_semantic_chunks<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.use_semantic_chunks = v.into();
                self
            }
        }

        impl wkt::message::Message for SummarySpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec"
            }
        }

        /// Defines additional types related to [SummarySpec].
        pub mod summary_spec {
            #[allow(unused_imports)]
            use super::*;

            /// Specification of the prompt to use with the model.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ModelPromptSpec {
                /// Text at the beginning of the prompt that instructs the assistant.
                /// Examples are available in the user guide.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub preamble: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ModelPromptSpec {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [preamble][crate::model::search_request::content_search_spec::summary_spec::ModelPromptSpec::preamble].
                pub fn set_preamble<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.preamble = v.into();
                    self
                }
            }

            impl wkt::message::Message for ModelPromptSpec {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ModelPromptSpec"
                }
            }

            /// Specification of the model.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ModelSpec {
                /// The model version used to generate the summary.
                ///
                /// Supported values are:
                ///
                /// * `stable`: string. Default value when no value is specified. Uses a
                ///   generally available, fine-tuned model. For more information, see
                ///   [Answer generation model versions and
                ///   lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
                /// * `preview`: string. (Public preview) Uses a preview model. For more
                ///   information, see
                ///   [Answer generation model versions and
                ///   lifecycle](https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models).
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub version: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ModelSpec {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [version][crate::model::search_request::content_search_spec::summary_spec::ModelSpec::version].
                pub fn set_version<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.version = v.into();
                    self
                }
            }

            impl wkt::message::Message for ModelSpec {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ModelSpec"
                }
            }
        }

        /// A specification for configuring the extractive content in a search
        /// response.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ExtractiveContentSpec {
            /// The maximum number of extractive answers returned in each search
            /// result.
            ///
            /// An extractive answer is a verbatim answer extracted from the original
            /// document, which provides a precise and contextually relevant answer to
            /// the search query.
            ///
            /// If the number of matching answers is less than the
            /// `max_extractive_answer_count`, return all of the answers. Otherwise,
            /// return the `max_extractive_answer_count`.
            ///
            /// At most five answers are returned for each
            /// [SearchResult][google.cloud.discoveryengine.v1.SearchResponse.SearchResult].
            ///
            /// [google.cloud.discoveryengine.v1.SearchResponse.SearchResult]: crate::model::search_response::SearchResult
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub max_extractive_answer_count: i32,

            /// The max number of extractive segments returned in each search result.
            /// Only applied if the
            /// [DataStore][google.cloud.discoveryengine.v1.DataStore] is set to
            /// [DataStore.ContentConfig.CONTENT_REQUIRED][google.cloud.discoveryengine.v1.DataStore.ContentConfig.CONTENT_REQUIRED]
            /// or
            /// [DataStore.solution_types][google.cloud.discoveryengine.v1.DataStore.solution_types]
            /// is
            /// [SOLUTION_TYPE_CHAT][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT].
            ///
            /// An extractive segment is a text segment extracted from the original
            /// document that is relevant to the search query, and, in general, more
            /// verbose than an extractive answer. The segment could then be used as
            /// input for LLMs to generate summaries and answers.
            ///
            /// If the number of matching segments is less than
            /// `max_extractive_segment_count`, return all of the segments. Otherwise,
            /// return the `max_extractive_segment_count`.
            ///
            /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
            /// [google.cloud.discoveryengine.v1.DataStore.ContentConfig.CONTENT_REQUIRED]: crate::model::data_store::ContentConfig::ContentRequired
            /// [google.cloud.discoveryengine.v1.DataStore.solution_types]: crate::model::DataStore::solution_types
            /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT]: crate::model::SolutionType::Chat
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub max_extractive_segment_count: i32,

            /// Specifies whether to return the confidence score from the extractive
            /// segments in each search result. This feature is available only for new
            /// or allowlisted data stores. To allowlist your data store,
            /// contact your Customer Engineer. The default value is `false`.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub return_extractive_segment_score: bool,

            /// Specifies whether to also include the adjacent from each selected
            /// segments.
            /// Return at most `num_previous_segments` segments before each selected
            /// segments.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub num_previous_segments: i32,

            /// Return at most `num_next_segments` segments after each selected
            /// segments.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub num_next_segments: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ExtractiveContentSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [max_extractive_answer_count][crate::model::search_request::content_search_spec::ExtractiveContentSpec::max_extractive_answer_count].
            pub fn set_max_extractive_answer_count<T: std::convert::Into<i32>>(
                mut self,
                v: T,
            ) -> Self {
                self.max_extractive_answer_count = v.into();
                self
            }

            /// Sets the value of [max_extractive_segment_count][crate::model::search_request::content_search_spec::ExtractiveContentSpec::max_extractive_segment_count].
            pub fn set_max_extractive_segment_count<T: std::convert::Into<i32>>(
                mut self,
                v: T,
            ) -> Self {
                self.max_extractive_segment_count = v.into();
                self
            }

            /// Sets the value of [return_extractive_segment_score][crate::model::search_request::content_search_spec::ExtractiveContentSpec::return_extractive_segment_score].
            pub fn set_return_extractive_segment_score<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.return_extractive_segment_score = v.into();
                self
            }

            /// Sets the value of [num_previous_segments][crate::model::search_request::content_search_spec::ExtractiveContentSpec::num_previous_segments].
            pub fn set_num_previous_segments<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.num_previous_segments = v.into();
                self
            }

            /// Sets the value of [num_next_segments][crate::model::search_request::content_search_spec::ExtractiveContentSpec::num_next_segments].
            pub fn set_num_next_segments<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.num_next_segments = v.into();
                self
            }
        }

        impl wkt::message::Message for ExtractiveContentSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ExtractiveContentSpec"
            }
        }

        /// Specifies the chunk spec to be returned from the search response.
        /// Only available if the
        /// [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
        /// is set to
        /// [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]: crate::model::search_request::content_search_spec::SearchResultMode::Chunks
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]: crate::model::search_request::ContentSearchSpec::search_result_mode
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ChunkSpec {
            /// The number of previous chunks to be returned of the current chunk. The
            /// maximum allowed value is 3.
            /// If not specified, no previous chunks will be returned.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub num_previous_chunks: i32,

            /// The number of next chunks to be returned of the current chunk. The
            /// maximum allowed value is 3.
            /// If not specified, no next chunks will be returned.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I32")]
            pub num_next_chunks: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ChunkSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [num_previous_chunks][crate::model::search_request::content_search_spec::ChunkSpec::num_previous_chunks].
            pub fn set_num_previous_chunks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.num_previous_chunks = v.into();
                self
            }

            /// Sets the value of [num_next_chunks][crate::model::search_request::content_search_spec::ChunkSpec::num_next_chunks].
            pub fn set_num_next_chunks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.num_next_chunks = v.into();
                self
            }
        }

        impl wkt::message::Message for ChunkSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ChunkSpec"
            }
        }

        /// Specifies the search result mode. If unspecified, the
        /// search result mode defaults to `DOCUMENTS`.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SearchResultMode {
            /// Default value.
            Unspecified,
            /// Returns documents in the search result.
            Documents,
            /// Returns chunks in the search result. Only available if the
            /// [DocumentProcessingConfig.chunking_config][google.cloud.discoveryengine.v1.DocumentProcessingConfig.chunking_config]
            /// is specified.
            ///
            /// [google.cloud.discoveryengine.v1.DocumentProcessingConfig.chunking_config]: crate::model::DocumentProcessingConfig::chunking_config
            Chunks,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SearchResultMode::value] or
            /// [SearchResultMode::name].
            UnknownValue(search_result_mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod search_result_mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SearchResultMode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Documents => std::option::Option::Some(1),
                    Self::Chunks => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SEARCH_RESULT_MODE_UNSPECIFIED")
                    }
                    Self::Documents => std::option::Option::Some("DOCUMENTS"),
                    Self::Chunks => std::option::Option::Some("CHUNKS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SearchResultMode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SearchResultMode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SearchResultMode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Documents,
                    2 => Self::Chunks,
                    _ => Self::UnknownValue(search_result_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SearchResultMode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SEARCH_RESULT_MODE_UNSPECIFIED" => Self::Unspecified,
                    "DOCUMENTS" => Self::Documents,
                    "CHUNKS" => Self::Chunks,
                    _ => Self::UnknownValue(search_result_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SearchResultMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Documents => serializer.serialize_i32(1),
                    Self::Chunks => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SearchResultMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchResultMode>::new(
                    ".google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode"))
            }
        }
    }

    /// Specification for search as you type in search requests.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SearchAsYouTypeSpec {
        /// The condition under which search as you type should occur.
        /// Default to
        /// [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED].
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED]: crate::model::search_request::search_as_you_type_spec::Condition::Disabled
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub condition: crate::model::search_request::search_as_you_type_spec::Condition,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SearchAsYouTypeSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::search_request::SearchAsYouTypeSpec::condition].
        pub fn set_condition<
            T: std::convert::Into<crate::model::search_request::search_as_you_type_spec::Condition>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = v.into();
            self
        }
    }

    impl wkt::message::Message for SearchAsYouTypeSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec"
        }
    }

    /// Defines additional types related to [SearchAsYouTypeSpec].
    pub mod search_as_you_type_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Enum describing under which condition search as you type should occur.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Condition {
            /// Server behavior defaults to
            /// [Condition.DISABLED][google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED].
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED]: crate::model::search_request::search_as_you_type_spec::Condition::Disabled
            Unspecified,
            /// Disables Search As You Type.
            Disabled,
            /// Enables Search As You Type.
            Enabled,
            /// Automatic switching between search-as-you-type and standard search
            /// modes, ideal for single-API implementations (e.g., debouncing).
            Auto,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Condition::value] or
            /// [Condition::name].
            UnknownValue(condition::UnknownValue),
        }

        #[doc(hidden)]
        pub mod condition {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Condition {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Disabled => std::option::Option::Some(1),
                    Self::Enabled => std::option::Option::Some(2),
                    Self::Auto => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CONDITION_UNSPECIFIED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::Enabled => std::option::Option::Some("ENABLED"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Condition {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Condition {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Condition {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Disabled,
                    2 => Self::Enabled,
                    3 => Self::Auto,
                    _ => Self::UnknownValue(condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Condition {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONDITION_UNSPECIFIED" => Self::Unspecified,
                    "DISABLED" => Self::Disabled,
                    "ENABLED" => Self::Enabled,
                    "AUTO" => Self::Auto,
                    _ => Self::UnknownValue(condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Condition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Disabled => serializer.serialize_i32(1),
                    Self::Enabled => serializer.serialize_i32(2),
                    Self::Auto => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Condition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Condition>::new(
                    ".google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition",
                ))
            }
        }
    }

    /// Specifies features for display, like match highlighting.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DisplaySpec {
        /// The condition under which match highlighting should occur.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub match_highlighting_condition:
            crate::model::search_request::display_spec::MatchHighlightingCondition,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DisplaySpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [match_highlighting_condition][crate::model::search_request::DisplaySpec::match_highlighting_condition].
        pub fn set_match_highlighting_condition<
            T: std::convert::Into<
                    crate::model::search_request::display_spec::MatchHighlightingCondition,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.match_highlighting_condition = v.into();
            self
        }
    }

    impl wkt::message::Message for DisplaySpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.DisplaySpec"
        }
    }

    /// Defines additional types related to [DisplaySpec].
    pub mod display_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Enum describing under which condition match highlighting should occur.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MatchHighlightingCondition {
            /// Server behavior is the same as `MATCH_HIGHLIGHTING_DISABLED`.
            Unspecified,
            /// Disables match highlighting on all documents.
            MatchHighlightingDisabled,
            /// Enables match highlighting on all documents.
            MatchHighlightingEnabled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MatchHighlightingCondition::value] or
            /// [MatchHighlightingCondition::name].
            UnknownValue(match_highlighting_condition::UnknownValue),
        }

        #[doc(hidden)]
        pub mod match_highlighting_condition {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl MatchHighlightingCondition {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::MatchHighlightingDisabled => std::option::Option::Some(1),
                    Self::MatchHighlightingEnabled => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("MATCH_HIGHLIGHTING_CONDITION_UNSPECIFIED")
                    }
                    Self::MatchHighlightingDisabled => {
                        std::option::Option::Some("MATCH_HIGHLIGHTING_DISABLED")
                    }
                    Self::MatchHighlightingEnabled => {
                        std::option::Option::Some("MATCH_HIGHLIGHTING_ENABLED")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for MatchHighlightingCondition {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for MatchHighlightingCondition {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for MatchHighlightingCondition {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::MatchHighlightingDisabled,
                    2 => Self::MatchHighlightingEnabled,
                    _ => Self::UnknownValue(match_highlighting_condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for MatchHighlightingCondition {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MATCH_HIGHLIGHTING_CONDITION_UNSPECIFIED" => Self::Unspecified,
                    "MATCH_HIGHLIGHTING_DISABLED" => Self::MatchHighlightingDisabled,
                    "MATCH_HIGHLIGHTING_ENABLED" => Self::MatchHighlightingEnabled,
                    _ => Self::UnknownValue(match_highlighting_condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for MatchHighlightingCondition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::MatchHighlightingDisabled => serializer.serialize_i32(1),
                    Self::MatchHighlightingEnabled => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for MatchHighlightingCondition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MatchHighlightingCondition>::new(
                    ".google.cloud.discoveryengine.v1.SearchRequest.DisplaySpec.MatchHighlightingCondition"))
            }
        }
    }

    /// Session specification.
    ///
    /// Multi-turn Search feature is currently at private GA stage. Please use
    /// v1alpha or v1beta version instead before we launch this feature to public
    /// GA. Or ask for allowlisting through Google Support team.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SessionSpec {
        /// If set, the search result gets stored to the "turn" specified by this
        /// query ID.
        ///
        /// Example: Let's say the session looks like this:
        /// session {
        /// name: ".../sessions/xxx"
        /// turns {
        /// query { text: "What is foo?" query_id: ".../questions/yyy" }
        /// answer: "Foo is ..."
        /// }
        /// turns {
        /// query { text: "How about bar then?" query_id: ".../questions/zzz" }
        /// }
        /// }
        ///
        /// The user can call /search API with a request like this:
        ///
        /// session: ".../sessions/xxx"
        /// session_spec { query_id: ".../questions/zzz" }
        ///
        /// Then, the API stores the search result, associated with the last turn.
        /// The stored search result can be used by a subsequent /answer API call
        /// (with the session ID and the query ID specified). Also, it is possible
        /// to call /search and /answer in parallel with the same session ID & query
        /// ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub query_id: std::string::String,

        /// The number of top search results to persist. The persisted search results
        /// can be used for the subsequent /answer api call.
        ///
        /// This field is similar to the `summary_result_count` field in
        /// [SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count].
        ///
        /// At most 10 results for documents mode, or 50 for chunks mode.
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count]: crate::model::search_request::content_search_spec::SummarySpec::summary_result_count
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
        pub search_result_persistence_count: std::option::Option<i32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_id][crate::model::search_request::SessionSpec::query_id].
        pub fn set_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query_id = v.into();
            self
        }

        /// Sets the value of [search_result_persistence_count][crate::model::search_request::SessionSpec::search_result_persistence_count].
        pub fn set_search_result_persistence_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.search_result_persistence_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [search_result_persistence_count][crate::model::search_request::SessionSpec::search_result_persistence_count].
        pub fn set_or_clear_search_result_persistence_count<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.search_result_persistence_count = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SessionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.SessionSpec"
        }
    }

    /// The specification for returning the document relevance score.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RelevanceScoreSpec {
        /// Optional. Whether to return the relevance score for search results.
        /// The higher the score, the more relevant the document is to the query.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub return_relevance_score: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RelevanceScoreSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [return_relevance_score][crate::model::search_request::RelevanceScoreSpec::return_relevance_score].
        pub fn set_return_relevance_score<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.return_relevance_score = v.into();
            self
        }
    }

    impl wkt::message::Message for RelevanceScoreSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchRequest.RelevanceScoreSpec"
        }
    }

    /// The relevance threshold of the search results. The higher relevance
    /// threshold is, the higher relevant results are shown and the less number of
    /// results are returned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RelevanceThreshold {
        /// Default value. In this case, server behavior defaults to Google defined
        /// threshold.
        Unspecified,
        /// Lowest relevance threshold.
        Lowest,
        /// Low relevance threshold.
        Low,
        /// Medium relevance threshold.
        Medium,
        /// High relevance threshold.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RelevanceThreshold::value] or
        /// [RelevanceThreshold::name].
        UnknownValue(relevance_threshold::UnknownValue),
    }

    #[doc(hidden)]
    pub mod relevance_threshold {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RelevanceThreshold {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Lowest => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::High => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RELEVANCE_THRESHOLD_UNSPECIFIED"),
                Self::Lowest => std::option::Option::Some("LOWEST"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RelevanceThreshold {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RelevanceThreshold {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RelevanceThreshold {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Lowest,
                2 => Self::Low,
                3 => Self::Medium,
                4 => Self::High,
                _ => Self::UnknownValue(relevance_threshold::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RelevanceThreshold {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RELEVANCE_THRESHOLD_UNSPECIFIED" => Self::Unspecified,
                "LOWEST" => Self::Lowest,
                "LOW" => Self::Low,
                "MEDIUM" => Self::Medium,
                "HIGH" => Self::High,
                _ => Self::UnknownValue(relevance_threshold::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RelevanceThreshold {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Lowest => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::High => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RelevanceThreshold {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RelevanceThreshold>::new(
                ".google.cloud.discoveryengine.v1.SearchRequest.RelevanceThreshold",
            ))
        }
    }
}

/// Response message for
/// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
/// method.
///
/// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchResponse {
    /// A list of matched documents. The order represents the ranking.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::search_response::SearchResult>,

    /// Results of facets requested by user.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub facets: std::vec::Vec<crate::model::search_response::Facet>,

    /// The estimated total count of matched items irrespective of pagination. The
    /// count of [results][google.cloud.discoveryengine.v1.SearchResponse.results]
    /// returned by pagination may be less than the
    /// [total_size][google.cloud.discoveryengine.v1.SearchResponse.total_size]
    /// that matches.
    ///
    /// [google.cloud.discoveryengine.v1.SearchResponse.results]: crate::model::SearchResponse::results
    /// [google.cloud.discoveryengine.v1.SearchResponse.total_size]: crate::model::SearchResponse::total_size
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub total_size: i32,

    /// A unique search token. This should be included in the
    /// [UserEvent][google.cloud.discoveryengine.v1.UserEvent] logs resulting from
    /// this search, which enables accurate attribution of search model
    /// performance. This also helps to identify a request during the customer
    /// support scenarios.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent]: crate::model::UserEvent
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribution_token: std::string::String,

    /// The URI of a customer-defined redirect page. If redirect action is
    /// triggered, no search is performed, and only
    /// [redirect_uri][google.cloud.discoveryengine.v1.SearchResponse.redirect_uri]
    /// and
    /// [attribution_token][google.cloud.discoveryengine.v1.SearchResponse.attribution_token]
    /// are set in the response.
    ///
    /// [google.cloud.discoveryengine.v1.SearchResponse.attribution_token]: crate::model::SearchResponse::attribution_token
    /// [google.cloud.discoveryengine.v1.SearchResponse.redirect_uri]: crate::model::SearchResponse::redirect_uri
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub redirect_uri: std::string::String,

    /// A token that can be sent as
    /// [SearchRequest.page_token][google.cloud.discoveryengine.v1.SearchRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.page_token]: crate::model::SearchRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Contains the spell corrected query, if found. If the spell correction type
    /// is AUTOMATIC, then the search results are based on corrected_query.
    /// Otherwise the original query is used for search.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub corrected_query: std::string::String,

    /// A summary as part of the search results.
    /// This field is only returned if
    /// [SearchRequest.ContentSearchSpec.summary_spec][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.summary_spec]
    /// is set.
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.summary_spec]: crate::model::search_request::ContentSearchSpec::summary_spec
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub summary: std::option::Option<crate::model::search_response::Summary>,

    /// Query expansion information for the returned results.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_expansion_info:
        std::option::Option<crate::model::search_response::QueryExpansionInfo>,

    /// Session information.
    ///
    /// Only set if
    /// [SearchRequest.session][google.cloud.discoveryengine.v1.SearchRequest.session]
    /// is provided. See its description for more details.
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.session]: crate::model::SearchRequest::session
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_info: std::option::Option<crate::model::search_response::SessionInfo>,

    /// Promotions for site search.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub search_link_promotions: std::vec::Vec<crate::model::SearchLinkPromotion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_response::SearchResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [facets][crate::model::SearchResponse::facets].
    pub fn set_facets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_response::Facet>,
    {
        use std::iter::Iterator;
        self.facets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_size][crate::model::SearchResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [attribution_token][crate::model::SearchResponse::attribution_token].
    pub fn set_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribution_token = v.into();
        self
    }

    /// Sets the value of [redirect_uri][crate::model::SearchResponse::redirect_uri].
    pub fn set_redirect_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redirect_uri = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [corrected_query][crate::model::SearchResponse::corrected_query].
    pub fn set_corrected_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.corrected_query = v.into();
        self
    }

    /// Sets the value of [summary][crate::model::SearchResponse::summary].
    pub fn set_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_response::Summary>,
    {
        self.summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summary][crate::model::SearchResponse::summary].
    pub fn set_or_clear_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_response::Summary>,
    {
        self.summary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_expansion_info][crate::model::SearchResponse::query_expansion_info].
    pub fn set_query_expansion_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_response::QueryExpansionInfo>,
    {
        self.query_expansion_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_expansion_info][crate::model::SearchResponse::query_expansion_info].
    pub fn set_or_clear_query_expansion_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_response::QueryExpansionInfo>,
    {
        self.query_expansion_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_info][crate::model::SearchResponse::session_info].
    pub fn set_session_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_response::SessionInfo>,
    {
        self.session_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_info][crate::model::SearchResponse::session_info].
    pub fn set_or_clear_session_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_response::SessionInfo>,
    {
        self.session_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [search_link_promotions][crate::model::SearchResponse::search_link_promotions].
    pub fn set_search_link_promotions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchLinkPromotion>,
    {
        use std::iter::Iterator;
        self.search_link_promotions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchResponse {
    type PageItem = crate::model::search_response::Facet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.facets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Defines additional types related to [SearchResponse].
pub mod search_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the search results.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SearchResult {
        /// [Document.id][google.cloud.discoveryengine.v1.Document.id] of the
        /// searched [Document][google.cloud.discoveryengine.v1.Document].
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        /// [google.cloud.discoveryengine.v1.Document.id]: crate::model::Document::id
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// The document data snippet in the search response. Only fields that are
        /// marked as `retrievable` are populated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub document: std::option::Option<crate::model::Document>,

        /// The chunk data in the search response if the
        /// [SearchRequest.ContentSearchSpec.search_result_mode][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]
        /// is set to
        /// [CHUNKS][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS].
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS]: crate::model::search_request::content_search_spec::SearchResultMode::Chunks
        /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode]: crate::model::search_request::ContentSearchSpec::search_result_mode
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub chunk: std::option::Option<crate::model::Chunk>,

        /// Output only. Google provided available scores.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub model_scores: std::collections::HashMap<std::string::String, crate::model::DoubleList>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SearchResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::search_response::SearchResult::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [document][crate::model::search_response::SearchResult::document].
        pub fn set_document<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Document>,
        {
            self.document = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [document][crate::model::search_response::SearchResult::document].
        pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Document>,
        {
            self.document = v.map(|x| x.into());
            self
        }

        /// Sets the value of [chunk][crate::model::search_response::SearchResult::chunk].
        pub fn set_chunk<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Chunk>,
        {
            self.chunk = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [chunk][crate::model::search_response::SearchResult::chunk].
        pub fn set_or_clear_chunk<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Chunk>,
        {
            self.chunk = v.map(|x| x.into());
            self
        }

        /// Sets the value of [model_scores][crate::model::search_response::SearchResult::model_scores].
        pub fn set_model_scores<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::DoubleList>,
        {
            use std::iter::Iterator;
            self.model_scores = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for SearchResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.SearchResult"
        }
    }

    /// A facet result.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Facet {
        /// The key for this facet. For example, `"colors"` or `"price"`. It matches
        /// [SearchRequest.FacetSpec.FacetKey.key][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key].
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key]: crate::model::search_request::facet_spec::FacetKey::key
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// The facet values for this field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<crate::model::search_response::facet::FacetValue>,

        /// Whether the facet is dynamically generated.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub dynamic_facet: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Facet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::search_response::Facet::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [values][crate::model::search_response::Facet::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::search_response::facet::FacetValue>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dynamic_facet][crate::model::search_response::Facet::dynamic_facet].
        pub fn set_dynamic_facet<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.dynamic_facet = v.into();
            self
        }
    }

    impl wkt::message::Message for Facet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Facet"
        }
    }

    /// Defines additional types related to [Facet].
    pub mod facet {
        #[allow(unused_imports)]
        use super::*;

        /// A facet value which contains value names and their count.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FacetValue {
            /// Number of items that have this facet value.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I64")]
            pub count: i64,

            /// A facet value which contains values.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub facet_value:
                std::option::Option<crate::model::search_response::facet::facet_value::FacetValue>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FacetValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [count][crate::model::search_response::facet::FacetValue::count].
            pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.count = v.into();
                self
            }

            /// Sets the value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value].
            ///
            /// Note that all the setters affecting `facet_value` are mutually
            /// exclusive.
            pub fn set_facet_value<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::search_response::facet::facet_value::FacetValue,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.facet_value = v.into();
                self
            }

            /// The value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// if it holds a `Value`, `None` if the field is not set or
            /// holds a different branch.
            pub fn value(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.facet_value.as_ref().and_then(|v| match v {
                    crate::model::search_response::facet::facet_value::FacetValue::Value(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// to hold a `Value`.
            ///
            /// Note that all the setters affecting `facet_value` are
            /// mutually exclusive.
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.facet_value = std::option::Option::Some(
                    crate::model::search_response::facet::facet_value::FacetValue::Value(v.into()),
                );
                self
            }

            /// The value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// if it holds a `Interval`, `None` if the field is not set or
            /// holds a different branch.
            pub fn interval(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::Interval>> {
                #[allow(unreachable_patterns)]
                self.facet_value.as_ref().and_then(|v| match v {
                    crate::model::search_response::facet::facet_value::FacetValue::Interval(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// to hold a `Interval`.
            ///
            /// Note that all the setters affecting `facet_value` are
            /// mutually exclusive.
            pub fn set_interval<T: std::convert::Into<std::boxed::Box<crate::model::Interval>>>(
                mut self,
                v: T,
            ) -> Self {
                self.facet_value = std::option::Option::Some(
                    crate::model::search_response::facet::facet_value::FacetValue::Interval(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for FacetValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue"
            }
        }

        /// Defines additional types related to [FacetValue].
        pub mod facet_value {
            #[allow(unused_imports)]
            use super::*;

            /// A facet value which contains values.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum FacetValue {
                /// Text value of a facet, such as "Black" for facet "colors".
                Value(std::string::String),
                /// Interval value for a facet, such as [10, 20) for facet "price". It
                /// matches
                /// [SearchRequest.FacetSpec.FacetKey.intervals][google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals].
                ///
                /// [google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals]: crate::model::search_request::facet_spec::FacetKey::intervals
                Interval(std::boxed::Box<crate::model::Interval>),
            }
        }
    }

    /// Summary of the top N search results specified by the summary spec.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Summary {
        /// The summary content.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub summary_text: std::string::String,

        /// Additional summary-skipped reasons. This provides the reason for ignored
        /// cases. If nothing is skipped, this field is not set.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub summary_skipped_reasons:
            std::vec::Vec<crate::model::search_response::summary::SummarySkippedReason>,

        /// A collection of Safety Attribute categories and their associated
        /// confidence scores.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub safety_attributes:
            std::option::Option<crate::model::search_response::summary::SafetyAttributes>,

        /// Summary with metadata information.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub summary_with_metadata:
            std::option::Option<crate::model::search_response::summary::SummaryWithMetadata>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Summary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [summary_text][crate::model::search_response::Summary::summary_text].
        pub fn set_summary_text<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.summary_text = v.into();
            self
        }

        /// Sets the value of [summary_skipped_reasons][crate::model::search_response::Summary::summary_skipped_reasons].
        pub fn set_summary_skipped_reasons<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::search_response::summary::SummarySkippedReason>,
        {
            use std::iter::Iterator;
            self.summary_skipped_reasons = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [safety_attributes][crate::model::search_response::Summary::safety_attributes].
        pub fn set_safety_attributes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_response::summary::SafetyAttributes>,
        {
            self.safety_attributes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [safety_attributes][crate::model::search_response::Summary::safety_attributes].
        pub fn set_or_clear_safety_attributes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_response::summary::SafetyAttributes>,
        {
            self.safety_attributes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [summary_with_metadata][crate::model::search_response::Summary::summary_with_metadata].
        pub fn set_summary_with_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_response::summary::SummaryWithMetadata>,
        {
            self.summary_with_metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [summary_with_metadata][crate::model::search_response::Summary::summary_with_metadata].
        pub fn set_or_clear_summary_with_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_response::summary::SummaryWithMetadata>,
        {
            self.summary_with_metadata = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Summary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary"
        }
    }

    /// Defines additional types related to [Summary].
    pub mod summary {
        #[allow(unused_imports)]
        use super::*;

        /// Safety Attribute categories and their associated confidence scores.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SafetyAttributes {
            /// The display names of Safety Attribute categories associated with the
            /// generated content. Order matches the Scores.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub categories: std::vec::Vec<std::string::String>,

            /// The confidence scores of the each category, higher
            /// value means higher confidence. Order matches the Categories.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            #[serde_as(as = "std::vec::Vec<wkt::internal::F32>")]
            pub scores: std::vec::Vec<f32>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SafetyAttributes {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [categories][crate::model::search_response::summary::SafetyAttributes::categories].
            pub fn set_categories<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.categories = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [scores][crate::model::search_response::summary::SafetyAttributes::scores].
            pub fn set_scores<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<f32>,
            {
                use std::iter::Iterator;
                self.scores = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for SafetyAttributes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary.SafetyAttributes"
            }
        }

        /// Citation metadata.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CitationMetadata {
            /// Citations for segments.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub citations: std::vec::Vec<crate::model::search_response::summary::Citation>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CitationMetadata {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [citations][crate::model::search_response::summary::CitationMetadata::citations].
            pub fn set_citations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::search_response::summary::Citation>,
            {
                use std::iter::Iterator;
                self.citations = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for CitationMetadata {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary.CitationMetadata"
            }
        }

        /// Citation info for a segment.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Citation {
            /// Index indicates the start of the segment, measured in bytes/unicode.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I64")]
            pub start_index: i64,

            /// End of the attributed segment, exclusive.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I64")]
            pub end_index: i64,

            /// Citation sources for the attributed segment.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub sources: std::vec::Vec<crate::model::search_response::summary::CitationSource>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Citation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [start_index][crate::model::search_response::summary::Citation::start_index].
            pub fn set_start_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.start_index = v.into();
                self
            }

            /// Sets the value of [end_index][crate::model::search_response::summary::Citation::end_index].
            pub fn set_end_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.end_index = v.into();
                self
            }

            /// Sets the value of [sources][crate::model::search_response::summary::Citation::sources].
            pub fn set_sources<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::search_response::summary::CitationSource>,
            {
                use std::iter::Iterator;
                self.sources = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Citation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary.Citation"
            }
        }

        /// Citation source.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CitationSource {
            /// Document reference index from SummaryWithMetadata.references.
            /// It is 0-indexed and the value will be zero if the reference_index is
            /// not set explicitly.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I64")]
            pub reference_index: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CitationSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [reference_index][crate::model::search_response::summary::CitationSource::reference_index].
            pub fn set_reference_index<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.reference_index = v.into();
                self
            }
        }

        impl wkt::message::Message for CitationSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary.CitationSource"
            }
        }

        /// Document reference.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Reference {
            /// Title of the document.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub title: std::string::String,

            /// Required.
            /// [Document.name][google.cloud.discoveryengine.v1.Document.name] of the
            /// document. Full resource name of the referenced document, in the format
            /// `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
            ///
            /// [google.cloud.discoveryengine.v1.Document.name]: crate::model::Document::name
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub document: std::string::String,

            /// Cloud Storage or HTTP uri for the document.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub uri: std::string::String,

            /// List of cited chunk contents derived from document content.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub chunk_contents:
                std::vec::Vec<crate::model::search_response::summary::reference::ChunkContent>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Reference {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::search_response::summary::Reference::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [document][crate::model::search_response::summary::Reference::document].
            pub fn set_document<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.document = v.into();
                self
            }

            /// Sets the value of [uri][crate::model::search_response::summary::Reference::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }

            /// Sets the value of [chunk_contents][crate::model::search_response::summary::Reference::chunk_contents].
            pub fn set_chunk_contents<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::search_response::summary::reference::ChunkContent,
                    >,
            {
                use std::iter::Iterator;
                self.chunk_contents = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Reference {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary.Reference"
            }
        }

        /// Defines additional types related to [Reference].
        pub mod reference {
            #[allow(unused_imports)]
            use super::*;

            /// Chunk content.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ChunkContent {
                /// Chunk textual content.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub content: std::string::String,

                /// Page identifier.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub page_identifier: std::string::String,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ChunkContent {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [content][crate::model::search_response::summary::reference::ChunkContent::content].
                pub fn set_content<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.content = v.into();
                    self
                }

                /// Sets the value of [page_identifier][crate::model::search_response::summary::reference::ChunkContent::page_identifier].
                pub fn set_page_identifier<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.page_identifier = v.into();
                    self
                }
            }

            impl wkt::message::Message for ChunkContent {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary.Reference.ChunkContent"
                }
            }
        }

        /// Summary with metadata information.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct SummaryWithMetadata {
            /// Summary text with no citation information.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub summary: std::string::String,

            /// Citation metadata for given summary.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub citation_metadata:
                std::option::Option<crate::model::search_response::summary::CitationMetadata>,

            /// Document References.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub references: std::vec::Vec<crate::model::search_response::summary::Reference>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SummaryWithMetadata {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [summary][crate::model::search_response::summary::SummaryWithMetadata::summary].
            pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.summary = v.into();
                self
            }

            /// Sets the value of [citation_metadata][crate::model::search_response::summary::SummaryWithMetadata::citation_metadata].
            pub fn set_citation_metadata<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::search_response::summary::CitationMetadata>,
            {
                self.citation_metadata = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [citation_metadata][crate::model::search_response::summary::SummaryWithMetadata::citation_metadata].
            pub fn set_or_clear_citation_metadata<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::search_response::summary::CitationMetadata>,
            {
                self.citation_metadata = v.map(|x| x.into());
                self
            }

            /// Sets the value of [references][crate::model::search_response::summary::SummaryWithMetadata::references].
            pub fn set_references<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::search_response::summary::Reference>,
            {
                use std::iter::Iterator;
                self.references = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for SummaryWithMetadata {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.Summary.SummaryWithMetadata"
            }
        }

        /// An Enum for summary-skipped reasons.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SummarySkippedReason {
            /// Default value. The summary skipped reason is not specified.
            Unspecified,
            /// The adversarial query ignored case.
            ///
            /// Only used when
            /// [SummarySpec.ignore_adversarial_query][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_adversarial_query]
            /// is set to `true`.
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_adversarial_query]: crate::model::search_request::content_search_spec::SummarySpec::ignore_adversarial_query
            AdversarialQueryIgnored,
            /// The non-summary seeking query ignored case.
            ///
            /// Google skips the summary if the query is chit chat.
            /// Only used when
            /// [SummarySpec.ignore_non_summary_seeking_query][google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_summary_seeking_query]
            /// is set to `true`.
            ///
            /// [google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_summary_seeking_query]: crate::model::search_request::content_search_spec::SummarySpec::ignore_non_summary_seeking_query
            NonSummarySeekingQueryIgnored,
            /// The out-of-domain query ignored case.
            ///
            /// Google skips the summary if there are no high-relevance search results.
            /// For example, the data store contains facts about company A but the
            /// user query is asking questions about company B.
            OutOfDomainQueryIgnored,
            /// The potential policy violation case.
            ///
            /// Google skips the summary if there is a potential policy violation
            /// detected. This includes content that may be violent or toxic.
            PotentialPolicyViolation,
            /// The LLM addon not enabled case.
            ///
            /// Google skips the summary if the LLM addon is not enabled.
            LlmAddonNotEnabled,
            /// The no relevant content case.
            ///
            /// Google skips the summary if there is no relevant content in the
            /// retrieved search results.
            NoRelevantContent,
            /// The jail-breaking query ignored case.
            ///
            /// For example, "Reply in the tone of a competing company's CEO".
            /// Only used when
            /// [SearchRequest.ContentSearchSpec.SummarySpec.ignore_jail_breaking_query]
            /// is set to `true`.
            JailBreakingQueryIgnored,
            /// The customer policy violation case.
            ///
            /// Google skips the summary if there is a customer policy violation
            /// detected. The policy is defined by the customer.
            CustomerPolicyViolation,
            /// The non-answer seeking query ignored case.
            ///
            /// Google skips the summary if the query doesn't have clear intent.
            /// Only used when
            /// [SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_answer_seeking_query]
            /// is set to `true`.
            NonSummarySeekingQueryIgnoredV2,
            /// The time out case.
            ///
            /// Google skips the summary if the time out.
            TimeOut,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SummarySkippedReason::value] or
            /// [SummarySkippedReason::name].
            UnknownValue(summary_skipped_reason::UnknownValue),
        }

        #[doc(hidden)]
        pub mod summary_skipped_reason {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SummarySkippedReason {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::AdversarialQueryIgnored => std::option::Option::Some(1),
                    Self::NonSummarySeekingQueryIgnored => std::option::Option::Some(2),
                    Self::OutOfDomainQueryIgnored => std::option::Option::Some(3),
                    Self::PotentialPolicyViolation => std::option::Option::Some(4),
                    Self::LlmAddonNotEnabled => std::option::Option::Some(5),
                    Self::NoRelevantContent => std::option::Option::Some(6),
                    Self::JailBreakingQueryIgnored => std::option::Option::Some(7),
                    Self::CustomerPolicyViolation => std::option::Option::Some(8),
                    Self::NonSummarySeekingQueryIgnoredV2 => std::option::Option::Some(9),
                    Self::TimeOut => std::option::Option::Some(10),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SUMMARY_SKIPPED_REASON_UNSPECIFIED")
                    }
                    Self::AdversarialQueryIgnored => {
                        std::option::Option::Some("ADVERSARIAL_QUERY_IGNORED")
                    }
                    Self::NonSummarySeekingQueryIgnored => {
                        std::option::Option::Some("NON_SUMMARY_SEEKING_QUERY_IGNORED")
                    }
                    Self::OutOfDomainQueryIgnored => {
                        std::option::Option::Some("OUT_OF_DOMAIN_QUERY_IGNORED")
                    }
                    Self::PotentialPolicyViolation => {
                        std::option::Option::Some("POTENTIAL_POLICY_VIOLATION")
                    }
                    Self::LlmAddonNotEnabled => std::option::Option::Some("LLM_ADDON_NOT_ENABLED"),
                    Self::NoRelevantContent => std::option::Option::Some("NO_RELEVANT_CONTENT"),
                    Self::JailBreakingQueryIgnored => {
                        std::option::Option::Some("JAIL_BREAKING_QUERY_IGNORED")
                    }
                    Self::CustomerPolicyViolation => {
                        std::option::Option::Some("CUSTOMER_POLICY_VIOLATION")
                    }
                    Self::NonSummarySeekingQueryIgnoredV2 => {
                        std::option::Option::Some("NON_SUMMARY_SEEKING_QUERY_IGNORED_V2")
                    }
                    Self::TimeOut => std::option::Option::Some("TIME_OUT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SummarySkippedReason {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SummarySkippedReason {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SummarySkippedReason {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::AdversarialQueryIgnored,
                    2 => Self::NonSummarySeekingQueryIgnored,
                    3 => Self::OutOfDomainQueryIgnored,
                    4 => Self::PotentialPolicyViolation,
                    5 => Self::LlmAddonNotEnabled,
                    6 => Self::NoRelevantContent,
                    7 => Self::JailBreakingQueryIgnored,
                    8 => Self::CustomerPolicyViolation,
                    9 => Self::NonSummarySeekingQueryIgnoredV2,
                    10 => Self::TimeOut,
                    _ => Self::UnknownValue(summary_skipped_reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SummarySkippedReason {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SUMMARY_SKIPPED_REASON_UNSPECIFIED" => Self::Unspecified,
                    "ADVERSARIAL_QUERY_IGNORED" => Self::AdversarialQueryIgnored,
                    "NON_SUMMARY_SEEKING_QUERY_IGNORED" => Self::NonSummarySeekingQueryIgnored,
                    "OUT_OF_DOMAIN_QUERY_IGNORED" => Self::OutOfDomainQueryIgnored,
                    "POTENTIAL_POLICY_VIOLATION" => Self::PotentialPolicyViolation,
                    "LLM_ADDON_NOT_ENABLED" => Self::LlmAddonNotEnabled,
                    "NO_RELEVANT_CONTENT" => Self::NoRelevantContent,
                    "JAIL_BREAKING_QUERY_IGNORED" => Self::JailBreakingQueryIgnored,
                    "CUSTOMER_POLICY_VIOLATION" => Self::CustomerPolicyViolation,
                    "NON_SUMMARY_SEEKING_QUERY_IGNORED_V2" => Self::NonSummarySeekingQueryIgnoredV2,
                    "TIME_OUT" => Self::TimeOut,
                    _ => Self::UnknownValue(summary_skipped_reason::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SummarySkippedReason {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::AdversarialQueryIgnored => serializer.serialize_i32(1),
                    Self::NonSummarySeekingQueryIgnored => serializer.serialize_i32(2),
                    Self::OutOfDomainQueryIgnored => serializer.serialize_i32(3),
                    Self::PotentialPolicyViolation => serializer.serialize_i32(4),
                    Self::LlmAddonNotEnabled => serializer.serialize_i32(5),
                    Self::NoRelevantContent => serializer.serialize_i32(6),
                    Self::JailBreakingQueryIgnored => serializer.serialize_i32(7),
                    Self::CustomerPolicyViolation => serializer.serialize_i32(8),
                    Self::NonSummarySeekingQueryIgnoredV2 => serializer.serialize_i32(9),
                    Self::TimeOut => serializer.serialize_i32(10),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SummarySkippedReason {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SummarySkippedReason>::new(
                    ".google.cloud.discoveryengine.v1.SearchResponse.Summary.SummarySkippedReason"))
            }
        }
    }

    /// Information describing query expansion including whether expansion has
    /// occurred.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueryExpansionInfo {
        /// Bool describing whether query expansion has occurred.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub expanded_query: bool,

        /// Number of pinned results. This field will only be set when expansion
        /// happens and
        /// [SearchRequest.QueryExpansionSpec.pin_unexpanded_results][google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]
        /// is set to true.
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]: crate::model::search_request::QueryExpansionSpec::pin_unexpanded_results
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub pinned_result_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryExpansionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [expanded_query][crate::model::search_response::QueryExpansionInfo::expanded_query].
        pub fn set_expanded_query<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.expanded_query = v.into();
            self
        }

        /// Sets the value of [pinned_result_count][crate::model::search_response::QueryExpansionInfo::pinned_result_count].
        pub fn set_pinned_result_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.pinned_result_count = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryExpansionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.QueryExpansionInfo"
        }
    }

    /// Information about the session.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SessionInfo {
        /// Name of the session.
        /// If the auto-session mode is used (when
        /// [SearchRequest.session][google.cloud.discoveryengine.v1.SearchRequest.session]
        /// ends with "-"), this field holds the newly generated session name.
        ///
        /// [google.cloud.discoveryengine.v1.SearchRequest.session]: crate::model::SearchRequest::session
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Query ID that corresponds to this search API call.
        /// One session can have multiple turns, each with a unique query ID.
        ///
        /// By specifying the session name and this query ID in the Answer API call,
        /// the answer generation happens in the context of the search results from
        /// this search call.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub query_id: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::search_response::SessionInfo::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [query_id][crate::model::search_response::SessionInfo::query_id].
        pub fn set_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query_id = v.into();
            self
        }
    }

    impl wkt::message::Message for SessionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.SearchResponse.SessionInfo"
        }
    }
}

/// Request message for
/// [SearchTuningService.ListCustomModels][google.cloud.discoveryengine.v1.SearchTuningService.ListCustomModels]
/// method.
///
/// [google.cloud.discoveryengine.v1.SearchTuningService.ListCustomModels]: crate::client::SearchTuningService::list_custom_models
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomModelsRequest {
    /// Required. The resource name of the parent Data Store, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store`.
    /// This field is used to identify the data store where to fetch the models
    /// from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_store: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_store][crate::model::ListCustomModelsRequest::data_store].
    pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_store = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListCustomModelsRequest"
    }
}

/// Response message for
/// [SearchTuningService.ListCustomModels][google.cloud.discoveryengine.v1.SearchTuningService.ListCustomModels]
/// method.
///
/// [google.cloud.discoveryengine.v1.SearchTuningService.ListCustomModels]: crate::client::SearchTuningService::list_custom_models
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomModelsResponse {
    /// List of custom tuning models.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::CustomTuningModel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [models][crate::model::ListCustomModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomTuningModel>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListCustomModelsResponse"
    }
}

/// Request message for
/// [SearchTuningService.TrainCustomModel][google.cloud.discoveryengine.v1.SearchTuningService.TrainCustomModel]
/// method.
///
/// [google.cloud.discoveryengine.v1.SearchTuningService.TrainCustomModel]: crate::client::SearchTuningService::train_custom_model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrainCustomModelRequest {
    /// Required. The resource name of the Data Store, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store`.
    /// This field is used to identify the data store where to train the models.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_store: std::string::String,

    /// Model to be trained. Supported values are:
    ///
    /// * **search-tuning**: Fine tuning the search system based on data provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_type: std::string::String,

    /// The desired location of errors incurred during the data ingestion and
    /// training.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    /// If not provided, a UUID will be generated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// Model training input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub training_input:
        std::option::Option<crate::model::train_custom_model_request::TrainingInput>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrainCustomModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_store][crate::model::TrainCustomModelRequest::data_store].
    pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_store = v.into();
        self
    }

    /// Sets the value of [model_type][crate::model::TrainCustomModelRequest::model_type].
    pub fn set_model_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [error_config][crate::model::TrainCustomModelRequest::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::TrainCustomModelRequest::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_id][crate::model::TrainCustomModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [training_input][crate::model::TrainCustomModelRequest::training_input].
    ///
    /// Note that all the setters affecting `training_input` are mutually
    /// exclusive.
    pub fn set_training_input<
        T: std::convert::Into<
                std::option::Option<crate::model::train_custom_model_request::TrainingInput>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_input = v.into();
        self
    }

    /// The value of [training_input][crate::model::TrainCustomModelRequest::training_input]
    /// if it holds a `GcsTrainingInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_training_input(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::train_custom_model_request::GcsTrainingInput>,
    > {
        #[allow(unreachable_patterns)]
        self.training_input.as_ref().and_then(|v| match v {
            crate::model::train_custom_model_request::TrainingInput::GcsTrainingInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [training_input][crate::model::TrainCustomModelRequest::training_input]
    /// to hold a `GcsTrainingInput`.
    ///
    /// Note that all the setters affecting `training_input` are
    /// mutually exclusive.
    pub fn set_gcs_training_input<
        T: std::convert::Into<
                std::boxed::Box<crate::model::train_custom_model_request::GcsTrainingInput>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_input = std::option::Option::Some(
            crate::model::train_custom_model_request::TrainingInput::GcsTrainingInput(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TrainCustomModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.TrainCustomModelRequest"
    }
}

/// Defines additional types related to [TrainCustomModelRequest].
pub mod train_custom_model_request {
    #[allow(unused_imports)]
    use super::*;

    /// Cloud Storage training data input.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsTrainingInput {
        /// The Cloud Storage corpus data which could be associated in train data.
        /// The data path format is `gs://<bucket_to_data>/<jsonl_file_name>`.
        /// A newline delimited jsonl/ndjson file.
        ///
        /// For search-tuning model, each line should have the _id, title
        /// and text. Example:
        /// `{"_id": "doc1", title: "relevant doc", "text": "relevant text"}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub corpus_data_path: std::string::String,

        /// The gcs query data which could be associated in train data.
        /// The data path format is `gs://<bucket_to_data>/<jsonl_file_name>`.
        /// A newline delimited jsonl/ndjson file.
        ///
        /// For search-tuning model, each line should have the _id
        /// and text. Example: {"_id": "query1",  "text": "example query"}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub query_data_path: std::string::String,

        /// Cloud Storage training data path whose format should be
        /// `gs://<bucket_to_data>/<tsv_file_name>`. The file should be in tsv
        /// format. Each line should have the doc_id and query_id and score (number).
        ///
        /// For search-tuning model, it should have the query-id corpus-id
        /// score as tsv file header. The score should be a number in `[0, inf+)`.
        /// The larger the number is, the more relevant the pair is. Example:
        ///
        /// * `query-id\tcorpus-id\tscore`
        /// * `query1\tdoc1\t1`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub train_data_path: std::string::String,

        /// Cloud Storage test data. Same format as train_data_path. If not provided,
        /// a random 80/20 train/test split will be performed on train_data_path.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub test_data_path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsTrainingInput {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [corpus_data_path][crate::model::train_custom_model_request::GcsTrainingInput::corpus_data_path].
        pub fn set_corpus_data_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.corpus_data_path = v.into();
            self
        }

        /// Sets the value of [query_data_path][crate::model::train_custom_model_request::GcsTrainingInput::query_data_path].
        pub fn set_query_data_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.query_data_path = v.into();
            self
        }

        /// Sets the value of [train_data_path][crate::model::train_custom_model_request::GcsTrainingInput::train_data_path].
        pub fn set_train_data_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.train_data_path = v.into();
            self
        }

        /// Sets the value of [test_data_path][crate::model::train_custom_model_request::GcsTrainingInput::test_data_path].
        pub fn set_test_data_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.test_data_path = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsTrainingInput {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.TrainCustomModelRequest.GcsTrainingInput"
        }
    }

    /// Model training input.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TrainingInput {
        /// Cloud Storage training input.
        GcsTrainingInput(
            std::boxed::Box<crate::model::train_custom_model_request::GcsTrainingInput>,
        ),
    }
}

/// Response of the
/// [TrainCustomModelRequest][google.cloud.discoveryengine.v1.TrainCustomModelRequest].
/// This message is returned by the google.longrunning.Operations.response field.
///
/// [google.cloud.discoveryengine.v1.TrainCustomModelRequest]: crate::model::TrainCustomModelRequest
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrainCustomModelResponse {
    /// A sample of errors encountered while processing the data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// Echoes the destination for the complete errors in the request if set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_config: std::option::Option<crate::model::ImportErrorConfig>,

    /// The trained model status. Possible values are:
    ///
    /// * **bad-data**: The training data quality is bad.
    /// * **no-improvement**: Tuning didn't improve performance. Won't deploy.
    /// * **in-progress**: Model training job creation is in progress.
    /// * **training**: Model is actively training.
    /// * **evaluating**: The model is evaluating trained metrics.
    /// * **indexing**: The model trained metrics are indexing.
    /// * **ready**: The model is ready for serving.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_status: std::string::String,

    /// The metrics of the trained model.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, wkt::internal::F64>")]
    pub metrics: std::collections::HashMap<std::string::String, f64>,

    /// Fully qualified name of the CustomTuningModel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrainCustomModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::TrainCustomModelResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_config][crate::model::TrainCustomModelResponse::error_config].
    pub fn set_error_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_config][crate::model::TrainCustomModelResponse::error_config].
    pub fn set_or_clear_error_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorConfig>,
    {
        self.error_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_status][crate::model::TrainCustomModelResponse::model_status].
    pub fn set_model_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_status = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::TrainCustomModelResponse::metrics].
    pub fn set_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [model_name][crate::model::TrainCustomModelResponse::model_name].
    pub fn set_model_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_name = v.into();
        self
    }
}

impl wkt::message::Message for TrainCustomModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.TrainCustomModelResponse"
    }
}

/// Metadata related to the progress of the TrainCustomModel operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrainCustomModelMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrainCustomModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::TrainCustomModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TrainCustomModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::TrainCustomModelMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TrainCustomModelMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TrainCustomModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.TrainCustomModelMetadata"
    }
}

/// Configures metadata that is used to generate serving time results (e.g.
/// search results or recommendation predictions).
/// The ServingConfig is passed in the search and predict request and generates
/// results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServingConfig {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The human readable serving config display name. Used in Discovery
    /// UI.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Required. Immutable. Specifies the solution type that a serving config can
    /// be associated with.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub solution_type: crate::model::SolutionType,

    /// The id of the model to use at serving time.
    /// Currently only RecommendationModels are supported.
    /// Can be changed but only to a compatible model (e.g.
    /// others-you-may-like CTR to others-you-may-like CVR).
    ///
    /// Required when [SolutionType][google.cloud.discoveryengine.v1.SolutionType]
    /// is
    /// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// How much diversity to use in recommendation model results e.g.
    /// `medium-diversity` or `high-diversity`. Currently supported values:
    ///
    /// * `no-diversity`
    /// * `low-diversity`
    /// * `medium-diversity`
    /// * `high-diversity`
    /// * `auto-diversity`
    ///
    /// If not specified, we choose default based on recommendation model
    /// type. Default value: `no-diversity`.
    ///
    /// Can only be set if
    /// [SolutionType][google.cloud.discoveryengine.v1.SolutionType] is
    /// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub diversity_level: std::string::String,

    /// The ranking expression controls the customized ranking on retrieval
    /// documents. To leverage this, document embedding is required. The ranking
    /// expression setting in ServingConfig applies to all search requests served
    /// by the serving config. However, if `SearchRequest.ranking_expression` is
    /// specified, it overrides the ServingConfig ranking expression.
    ///
    /// The ranking expression is a single function or multiple functions that are
    /// joined by "+".
    ///
    /// * ranking_expression = function, { " + ", function };
    ///
    /// Supported functions:
    ///
    /// * double * relevance_score
    /// * double * dotProduct(embedding_field_path)
    ///
    /// Function variables:
    ///
    /// * `relevance_score`: pre-defined keywords, used for measure relevance
    ///   between query and document.
    /// * `embedding_field_path`: the document embedding field
    ///   used with query embedding vector.
    /// * `dotProduct`: embedding function between embedding_field_path and query
    ///   embedding vector.
    ///
    /// Example ranking expression:
    ///
    /// If document has an embedding field doc_embedding, the ranking expression
    /// could be `0.5 * relevance_score + 0.3 * dotProduct(doc_embedding)`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ranking_expression: std::string::String,

    /// Output only. ServingConfig created timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. ServingConfig updated timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Filter controls to use in serving path.
    /// All triggered filter controls will be applied.
    /// Filter controls must be in the same data store as the serving config.
    /// Maximum of 20 filter controls.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub filter_control_ids: std::vec::Vec<std::string::String>,

    /// Boost controls to use in serving path.
    /// All triggered boost controls will be applied.
    /// Boost controls must be in the same data store as the serving config.
    /// Maximum of 20 boost controls.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub boost_control_ids: std::vec::Vec<std::string::String>,

    /// IDs of the redirect controls. Only the first triggered redirect
    /// action is applied, even if multiple apply. Maximum number of
    /// specifications is 100.
    ///
    /// Can only be set if
    /// [SolutionType][google.cloud.discoveryengine.v1.SolutionType] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub redirect_control_ids: std::vec::Vec<std::string::String>,

    /// Condition synonyms specifications. If multiple synonyms conditions
    /// match, all matching synonyms controls in the list will execute.
    /// Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// [SolutionType][google.cloud.discoveryengine.v1.SolutionType] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub synonyms_control_ids: std::vec::Vec<std::string::String>,

    /// Condition oneway synonyms specifications. If multiple oneway synonyms
    /// conditions match, all matching oneway synonyms controls in the list
    /// will execute. Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// [SolutionType][google.cloud.discoveryengine.v1.SolutionType] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub oneway_synonyms_control_ids: std::vec::Vec<std::string::String>,

    /// Condition do not associate specifications. If multiple do not
    /// associate conditions match, all matching do not associate controls in
    /// the list will execute.
    /// Order does not matter.
    /// Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// [SolutionType][google.cloud.discoveryengine.v1.SolutionType] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dissociate_control_ids: std::vec::Vec<std::string::String>,

    /// Condition replacement specifications.
    /// Applied according to the order in the list.
    /// A previously replaced term can not be re-replaced.
    /// Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// [SolutionType][google.cloud.discoveryengine.v1.SolutionType] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replacement_control_ids: std::vec::Vec<std::string::String>,

    /// Condition ignore specifications. If multiple ignore
    /// conditions match, all matching ignore controls in the list will
    /// execute.
    /// Order does not matter.
    /// Maximum number of specifications is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ignore_control_ids: std::vec::Vec<std::string::String>,

    /// Condition promote specifications.
    ///
    /// Maximum number of specifications is 100.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub promote_control_ids: std::vec::Vec<std::string::String>,

    /// Industry vertical specific config.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub vertical_config: std::option::Option<crate::model::serving_config::VerticalConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ServingConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ServingConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [solution_type][crate::model::ServingConfig::solution_type].
    pub fn set_solution_type<T: std::convert::Into<crate::model::SolutionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.solution_type = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::ServingConfig::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [diversity_level][crate::model::ServingConfig::diversity_level].
    pub fn set_diversity_level<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.diversity_level = v.into();
        self
    }

    /// Sets the value of [ranking_expression][crate::model::ServingConfig::ranking_expression].
    pub fn set_ranking_expression<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ranking_expression = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ServingConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ServingConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ServingConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ServingConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter_control_ids][crate::model::ServingConfig::filter_control_ids].
    pub fn set_filter_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.filter_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [boost_control_ids][crate::model::ServingConfig::boost_control_ids].
    pub fn set_boost_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.boost_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [redirect_control_ids][crate::model::ServingConfig::redirect_control_ids].
    pub fn set_redirect_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.redirect_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [synonyms_control_ids][crate::model::ServingConfig::synonyms_control_ids].
    pub fn set_synonyms_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.synonyms_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [oneway_synonyms_control_ids][crate::model::ServingConfig::oneway_synonyms_control_ids].
    pub fn set_oneway_synonyms_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oneway_synonyms_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dissociate_control_ids][crate::model::ServingConfig::dissociate_control_ids].
    pub fn set_dissociate_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dissociate_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [replacement_control_ids][crate::model::ServingConfig::replacement_control_ids].
    pub fn set_replacement_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replacement_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignore_control_ids][crate::model::ServingConfig::ignore_control_ids].
    pub fn set_ignore_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ignore_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [promote_control_ids][crate::model::ServingConfig::promote_control_ids].
    pub fn set_promote_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.promote_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [vertical_config][crate::model::ServingConfig::vertical_config].
    ///
    /// Note that all the setters affecting `vertical_config` are mutually
    /// exclusive.
    pub fn set_vertical_config<
        T: std::convert::Into<std::option::Option<crate::model::serving_config::VerticalConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vertical_config = v.into();
        self
    }

    /// The value of [vertical_config][crate::model::ServingConfig::vertical_config]
    /// if it holds a `MediaConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn media_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::serving_config::MediaConfig>> {
        #[allow(unreachable_patterns)]
        self.vertical_config.as_ref().and_then(|v| match v {
            crate::model::serving_config::VerticalConfig::MediaConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vertical_config][crate::model::ServingConfig::vertical_config]
    /// to hold a `MediaConfig`.
    ///
    /// Note that all the setters affecting `vertical_config` are
    /// mutually exclusive.
    pub fn set_media_config<
        T: std::convert::Into<std::boxed::Box<crate::model::serving_config::MediaConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vertical_config = std::option::Option::Some(
            crate::model::serving_config::VerticalConfig::MediaConfig(v.into()),
        );
        self
    }

    /// The value of [vertical_config][crate::model::ServingConfig::vertical_config]
    /// if it holds a `GenericConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generic_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::serving_config::GenericConfig>> {
        #[allow(unreachable_patterns)]
        self.vertical_config.as_ref().and_then(|v| match v {
            crate::model::serving_config::VerticalConfig::GenericConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vertical_config][crate::model::ServingConfig::vertical_config]
    /// to hold a `GenericConfig`.
    ///
    /// Note that all the setters affecting `vertical_config` are
    /// mutually exclusive.
    pub fn set_generic_config<
        T: std::convert::Into<std::boxed::Box<crate::model::serving_config::GenericConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vertical_config = std::option::Option::Some(
            crate::model::serving_config::VerticalConfig::GenericConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ServingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ServingConfig"
    }
}

/// Defines additional types related to [ServingConfig].
pub mod serving_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the configurations needed for Media Discovery. Currently we
    /// support:
    ///
    /// * `demote_content_watched`: Threshold for watched content demotion.
    ///   Customers can specify if using watched content demotion or use viewed
    ///   detail page. Using the content watched demotion, customers need to specify
    ///   the watched minutes or percentage exceeds the threshold, the content will
    ///   be demoted in the recommendation result.
    /// * `promote_fresh_content`: cutoff days for fresh content promotion.
    ///   Customers can specify if using content freshness promotion. If the content
    ///   was published within the cutoff days, the content will be promoted in the
    ///   recommendation result.
    ///   Can only be set if
    ///   [SolutionType][google.cloud.discoveryengine.v1.SolutionType] is
    ///   [SOLUTION_TYPE_RECOMMENDATION][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
    ///
    /// [google.cloud.discoveryengine.v1.SolutionType]: crate::model::SolutionType
    /// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MediaConfig {
        /// Specifies the event type used for demoting recommendation result.
        /// Currently supported values:
        ///
        /// * `view-item`: Item viewed.
        /// * `media-play`: Start/resume watching a video, playing a song, etc.
        /// * `media-complete`: Finished or stopped midway through a video, song,
        ///   etc.
        ///
        /// If unset, watch history demotion will not be applied. Content freshness
        /// demotion will still be applied.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub demotion_event_type: std::string::String,

        /// Optional. Specifies the number of days to look back for demoting watched
        /// content. If set to zero or unset, defaults to the maximum of 365 days.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub demote_content_watched_past_days: i32,

        /// Specifies the content freshness used for recommendation result.
        /// Contents will be demoted if contents were published for more than content
        /// freshness cutoff days.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I32")]
        pub content_freshness_cutoff_days: i32,

        /// Specify the threshold for demoting watched content, the threshold can be
        /// either percentage or minutes value.
        /// This must be set for `media-complete` event type.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub demote_content_watched:
            std::option::Option<crate::model::serving_config::media_config::DemoteContentWatched>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MediaConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [demotion_event_type][crate::model::serving_config::MediaConfig::demotion_event_type].
        pub fn set_demotion_event_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.demotion_event_type = v.into();
            self
        }

        /// Sets the value of [demote_content_watched_past_days][crate::model::serving_config::MediaConfig::demote_content_watched_past_days].
        pub fn set_demote_content_watched_past_days<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.demote_content_watched_past_days = v.into();
            self
        }

        /// Sets the value of [content_freshness_cutoff_days][crate::model::serving_config::MediaConfig::content_freshness_cutoff_days].
        pub fn set_content_freshness_cutoff_days<T: std::convert::Into<i32>>(
            mut self,
            v: T,
        ) -> Self {
            self.content_freshness_cutoff_days = v.into();
            self
        }

        /// Sets the value of [demote_content_watched][crate::model::serving_config::MediaConfig::demote_content_watched].
        ///
        /// Note that all the setters affecting `demote_content_watched` are mutually
        /// exclusive.
        pub fn set_demote_content_watched<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::serving_config::media_config::DemoteContentWatched,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.demote_content_watched = v.into();
            self
        }

        /// The value of [demote_content_watched][crate::model::serving_config::MediaConfig::demote_content_watched]
        /// if it holds a `ContentWatchedPercentageThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn content_watched_percentage_threshold(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.demote_content_watched.as_ref().and_then(|v| match v {
                crate::model::serving_config::media_config::DemoteContentWatched::ContentWatchedPercentageThreshold(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [demote_content_watched][crate::model::serving_config::MediaConfig::demote_content_watched]
        /// to hold a `ContentWatchedPercentageThreshold`.
        ///
        /// Note that all the setters affecting `demote_content_watched` are
        /// mutually exclusive.
        pub fn set_content_watched_percentage_threshold<T: std::convert::Into<f32>>(
            mut self,
            v: T,
        ) -> Self {
            self.demote_content_watched = std::option::Option::Some(
                crate::model::serving_config::media_config::DemoteContentWatched::ContentWatchedPercentageThreshold(
                    v.into()
                )
            );
            self
        }

        /// The value of [demote_content_watched][crate::model::serving_config::MediaConfig::demote_content_watched]
        /// if it holds a `ContentWatchedSecondsThreshold`, `None` if the field is not set or
        /// holds a different branch.
        pub fn content_watched_seconds_threshold(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.demote_content_watched.as_ref().and_then(|v| match v {
                crate::model::serving_config::media_config::DemoteContentWatched::ContentWatchedSecondsThreshold(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [demote_content_watched][crate::model::serving_config::MediaConfig::demote_content_watched]
        /// to hold a `ContentWatchedSecondsThreshold`.
        ///
        /// Note that all the setters affecting `demote_content_watched` are
        /// mutually exclusive.
        pub fn set_content_watched_seconds_threshold<T: std::convert::Into<f32>>(
            mut self,
            v: T,
        ) -> Self {
            self.demote_content_watched = std::option::Option::Some(
                crate::model::serving_config::media_config::DemoteContentWatched::ContentWatchedSecondsThreshold(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for MediaConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.ServingConfig.MediaConfig"
        }
    }

    /// Defines additional types related to [MediaConfig].
    pub mod media_config {
        #[allow(unused_imports)]
        use super::*;

        /// Specify the threshold for demoting watched content, the threshold can be
        /// either percentage or minutes value.
        /// This must be set for `media-complete` event type.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DemoteContentWatched {
            /// Specifies the content watched percentage threshold for demotion.
            /// Threshold value must be between [0, 1.0] inclusive.
            ContentWatchedPercentageThreshold(#[serde_as(as = "wkt::internal::F32")] f32),
            /// Specifies the content watched minutes threshold for demotion.
            ContentWatchedSecondsThreshold(#[serde_as(as = "wkt::internal::F32")] f32),
        }
    }

    /// Specifies the configurations needed for Generic Discovery.Currently we
    /// support:
    ///
    /// * `content_search_spec`: configuration for generic content search.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GenericConfig {
        /// Specifies the expected behavior of content search.
        /// Only valid for content-search enabled data store.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub content_search_spec:
            std::option::Option<crate::model::search_request::ContentSearchSpec>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GenericConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [content_search_spec][crate::model::serving_config::GenericConfig::content_search_spec].
        pub fn set_content_search_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_request::ContentSearchSpec>,
        {
            self.content_search_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [content_search_spec][crate::model::serving_config::GenericConfig::content_search_spec].
        pub fn set_or_clear_content_search_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_request::ContentSearchSpec>,
        {
            self.content_search_spec = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for GenericConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.ServingConfig.GenericConfig"
        }
    }

    /// Industry vertical specific config.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VerticalConfig {
        /// The MediaConfig of the serving configuration.
        MediaConfig(std::boxed::Box<crate::model::serving_config::MediaConfig>),
        /// The GenericConfig of the serving configuration.
        GenericConfig(std::boxed::Box<crate::model::serving_config::GenericConfig>),
    }
}

/// Request for UpdateServingConfig method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateServingConfigRequest {
    /// Required. The ServingConfig to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub serving_config: std::option::Option<crate::model::ServingConfig>,

    /// Indicates which fields in the provided
    /// [ServingConfig][google.cloud.discoveryengine.v1.ServingConfig] to update.
    /// The following are NOT supported:
    ///
    /// * [ServingConfig.name][google.cloud.discoveryengine.v1.ServingConfig.name]
    ///
    /// If not set, all supported fields are updated.
    ///
    /// [google.cloud.discoveryengine.v1.ServingConfig]: crate::model::ServingConfig
    /// [google.cloud.discoveryengine.v1.ServingConfig.name]: crate::model::ServingConfig::name
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServingConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::UpdateServingConfigRequest::serving_config].
    pub fn set_serving_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServingConfig>,
    {
        self.serving_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serving_config][crate::model::UpdateServingConfigRequest::serving_config].
    pub fn set_or_clear_serving_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServingConfig>,
    {
        self.serving_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServingConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServingConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateServingConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateServingConfigRequest"
    }
}

/// External session proto definition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Session {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions/*`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The display name of the session.
    ///
    /// This field is used to identify the session in the UI.
    /// By default, the display name is the first turn query text in the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The state of the session.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::session::State,

    /// A unique identifier for tracking users.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_pseudo_id: std::string::String,

    /// Turns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub turns: std::vec::Vec<crate::model::session::Turn>,

    /// Output only. The time the session started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the session finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Whether the session is pinned, pinned session will be displayed
    /// on the top of the session list.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub is_pinned: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Session {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Session::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Session::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Session::state].
    pub fn set_state<T: std::convert::Into<crate::model::session::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [user_pseudo_id][crate::model::Session::user_pseudo_id].
    pub fn set_user_pseudo_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_pseudo_id = v.into();
        self
    }

    /// Sets the value of [turns][crate::model::Session::turns].
    pub fn set_turns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::session::Turn>,
    {
        use std::iter::Iterator;
        self.turns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::Session::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Session::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Session::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Session::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_pinned][crate::model::Session::is_pinned].
    pub fn set_is_pinned<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_pinned = v.into();
        self
    }
}

impl wkt::message::Message for Session {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Session"
    }
}

/// Defines additional types related to [Session].
pub mod session {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a turn, including a query from the user and a
    /// answer from service.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Turn {
        /// The user query.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub query: std::option::Option<crate::model::Query>,

        /// The resource name of the answer to the user query.
        ///
        /// Only set if the answer generation (/answer API call) happened in this
        /// turn.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub answer: std::string::String,

        /// Output only. In
        /// [ConversationalSearchService.GetSession][google.cloud.discoveryengine.v1.ConversationalSearchService.GetSession]
        /// API, if
        /// [GetSessionRequest.include_answer_details][google.cloud.discoveryengine.v1.GetSessionRequest.include_answer_details]
        /// is set to true, this field will be populated when getting answer query
        /// session.
        ///
        /// [google.cloud.discoveryengine.v1.ConversationalSearchService.GetSession]: crate::client::ConversationalSearchService::get_session
        /// [google.cloud.discoveryengine.v1.GetSessionRequest.include_answer_details]: crate::model::GetSessionRequest::include_answer_details
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub detailed_answer: std::option::Option<crate::model::Answer>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Turn {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query][crate::model::session::Turn::query].
        pub fn set_query<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Query>,
        {
            self.query = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query][crate::model::session::Turn::query].
        pub fn set_or_clear_query<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Query>,
        {
            self.query = v.map(|x| x.into());
            self
        }

        /// Sets the value of [answer][crate::model::session::Turn::answer].
        pub fn set_answer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.answer = v.into();
            self
        }

        /// Sets the value of [detailed_answer][crate::model::session::Turn::detailed_answer].
        pub fn set_detailed_answer<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Answer>,
        {
            self.detailed_answer = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [detailed_answer][crate::model::session::Turn::detailed_answer].
        pub fn set_or_clear_detailed_answer<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Answer>,
        {
            self.detailed_answer = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Turn {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.Session.Turn"
        }
    }

    /// Enumeration of the state of the session.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is unspecified.
        Unspecified,
        /// The session is currently open.
        InProgress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.discoveryengine.v1.Session.State",
            ))
        }
    }
}

/// Defines a user inputed query.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Query {
    /// Unique Id for the query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_id: std::string::String,

    /// Query content.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::query::Content>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Query {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_id][crate::model::Query::query_id].
    pub fn set_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_id = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Query::content].
    ///
    /// Note that all the setters affecting `content` are mutually
    /// exclusive.
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::query::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Query::content]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::query::Content::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Query::content]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::query::Content::Text(v.into()));
        self
    }
}

impl wkt::message::Message for Query {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Query"
    }
}

/// Defines additional types related to [Query].
pub mod query {
    #[allow(unused_imports)]
    use super::*;

    /// Query content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Content {
        /// Plain text.
        Text(std::string::String),
    }
}

/// SiteSearchEngine captures DataStore level site search persisting
/// configurations. It is a singleton value per data store.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SiteSearchEngine {
    /// The fully qualified resource name of the site search engine.
    /// Format: `projects/*/locations/*/dataStores/*/siteSearchEngine`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SiteSearchEngine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SiteSearchEngine::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SiteSearchEngine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SiteSearchEngine"
    }
}

/// A target site for the SiteSearchEngine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetSite {
    /// Output only. The fully qualified resource name of the target site.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`
    /// The `target_site_id` is system-generated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Input only. The user provided URI pattern from which the
    /// `generated_uri_pattern` is generated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub provided_uri_pattern: std::string::String,

    /// The type of the target site, e.g., whether the site is to be included or
    /// excluded.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::target_site::Type,

    /// Immutable. If set to false, a uri_pattern is generated to include all pages
    /// whose address contains the provided_uri_pattern. If set to true, an
    /// uri_pattern is generated to try to be an exact match of the
    /// provided_uri_pattern or just the specific page if the provided_uri_pattern
    /// is a specific one. provided_uri_pattern is always normalized to
    /// generate the URI pattern to be used by the search engine.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub exact_match: bool,

    /// Output only. This is system-generated based on the provided_uri_pattern.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub generated_uri_pattern: std::string::String,

    /// Output only. Root domain of the provided_uri_pattern.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_domain_uri: std::string::String,

    /// Output only. Site ownership and validity verification status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub site_verification_info: std::option::Option<crate::model::SiteVerificationInfo>,

    /// Output only. Indexing status.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub indexing_status: crate::model::target_site::IndexingStatus,

    /// Output only. The target site's last updated time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Failure reason.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failure_reason: std::option::Option<crate::model::target_site::FailureReason>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetSite {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TargetSite::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [provided_uri_pattern][crate::model::TargetSite::provided_uri_pattern].
    pub fn set_provided_uri_pattern<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.provided_uri_pattern = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::TargetSite::type].
    pub fn set_type<T: std::convert::Into<crate::model::target_site::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [exact_match][crate::model::TargetSite::exact_match].
    pub fn set_exact_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.exact_match = v.into();
        self
    }

    /// Sets the value of [generated_uri_pattern][crate::model::TargetSite::generated_uri_pattern].
    pub fn set_generated_uri_pattern<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.generated_uri_pattern = v.into();
        self
    }

    /// Sets the value of [root_domain_uri][crate::model::TargetSite::root_domain_uri].
    pub fn set_root_domain_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_domain_uri = v.into();
        self
    }

    /// Sets the value of [site_verification_info][crate::model::TargetSite::site_verification_info].
    pub fn set_site_verification_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SiteVerificationInfo>,
    {
        self.site_verification_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [site_verification_info][crate::model::TargetSite::site_verification_info].
    pub fn set_or_clear_site_verification_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SiteVerificationInfo>,
    {
        self.site_verification_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [indexing_status][crate::model::TargetSite::indexing_status].
    pub fn set_indexing_status<T: std::convert::Into<crate::model::target_site::IndexingStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.indexing_status = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::TargetSite::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TargetSite::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failure_reason][crate::model::TargetSite::failure_reason].
    pub fn set_failure_reason<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::target_site::FailureReason>,
    {
        self.failure_reason = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failure_reason][crate::model::TargetSite::failure_reason].
    pub fn set_or_clear_failure_reason<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::target_site::FailureReason>,
    {
        self.failure_reason = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TargetSite {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.TargetSite"
    }
}

/// Defines additional types related to [TargetSite].
pub mod target_site {
    #[allow(unused_imports)]
    use super::*;

    /// Site search indexing failure reasons.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FailureReason {
        /// Failure reason.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub failure: std::option::Option<crate::model::target_site::failure_reason::Failure>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailureReason {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [failure][crate::model::target_site::FailureReason::failure].
        ///
        /// Note that all the setters affecting `failure` are mutually
        /// exclusive.
        pub fn set_failure<
            T: std::convert::Into<
                    std::option::Option<crate::model::target_site::failure_reason::Failure>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.failure = v.into();
            self
        }

        /// The value of [failure][crate::model::target_site::FailureReason::failure]
        /// if it holds a `QuotaFailure`, `None` if the field is not set or
        /// holds a different branch.
        pub fn quota_failure(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::target_site::failure_reason::QuotaFailure>,
        > {
            #[allow(unreachable_patterns)]
            self.failure.as_ref().and_then(|v| match v {
                crate::model::target_site::failure_reason::Failure::QuotaFailure(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [failure][crate::model::target_site::FailureReason::failure]
        /// to hold a `QuotaFailure`.
        ///
        /// Note that all the setters affecting `failure` are
        /// mutually exclusive.
        pub fn set_quota_failure<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::target_site::failure_reason::QuotaFailure>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.failure = std::option::Option::Some(
                crate::model::target_site::failure_reason::Failure::QuotaFailure(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for FailureReason {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.TargetSite.FailureReason"
        }
    }

    /// Defines additional types related to [FailureReason].
    pub mod failure_reason {
        #[allow(unused_imports)]
        use super::*;

        /// Failed due to insufficient quota.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct QuotaFailure {
            /// This number is an estimation on how much total quota this project needs
            /// to successfully complete indexing.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::I64")]
            pub total_required_quota: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl QuotaFailure {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [total_required_quota][crate::model::target_site::failure_reason::QuotaFailure::total_required_quota].
            pub fn set_total_required_quota<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.total_required_quota = v.into();
                self
            }
        }

        impl wkt::message::Message for QuotaFailure {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.TargetSite.FailureReason.QuotaFailure"
            }
        }

        /// Failure reason.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Failure {
            /// Failed due to insufficient quota.
            QuotaFailure(std::boxed::Box<crate::model::target_site::failure_reason::QuotaFailure>),
        }
    }

    /// Possible target site types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// This value is unused. In this case, server behavior defaults to
        /// [Type.INCLUDE][google.cloud.discoveryengine.v1.TargetSite.Type.INCLUDE].
        ///
        /// [google.cloud.discoveryengine.v1.TargetSite.Type.INCLUDE]: crate::model::target_site::Type::Include
        Unspecified,
        /// Include the target site.
        Include,
        /// Exclude the target site.
        Exclude,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Include => std::option::Option::Some(1),
                Self::Exclude => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Include => std::option::Option::Some("INCLUDE"),
                Self::Exclude => std::option::Option::Some("EXCLUDE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Include,
                2 => Self::Exclude,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "INCLUDE" => Self::Include,
                "EXCLUDE" => Self::Exclude,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Include => serializer.serialize_i32(1),
                Self::Exclude => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.discoveryengine.v1.TargetSite.Type",
            ))
        }
    }

    /// Target site indexing status enumeration.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IndexingStatus {
        /// Defaults to SUCCEEDED.
        Unspecified,
        /// The target site is in the update queue and will be picked up by indexing
        /// pipeline.
        Pending,
        /// The target site fails to be indexed.
        Failed,
        /// The target site has been indexed.
        Succeeded,
        /// The previously indexed target site has been marked to be deleted. This is
        /// a transitioning state which will resulted in either:
        ///
        /// . target site deleted if unindexing is successful;
        /// . state reverts to SUCCEEDED if the unindexing fails.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IndexingStatus::value] or
        /// [IndexingStatus::name].
        UnknownValue(indexing_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod indexing_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IndexingStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INDEXING_STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IndexingStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IndexingStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IndexingStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Succeeded,
                4 => Self::Deleting,
                _ => Self::UnknownValue(indexing_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IndexingStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INDEXING_STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(indexing_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IndexingStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IndexingStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndexingStatus>::new(
                ".google.cloud.discoveryengine.v1.TargetSite.IndexingStatus",
            ))
        }
    }
}

/// Verification information for target sites in advanced site search.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SiteVerificationInfo {
    /// Site verification state indicating the ownership and validity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub site_verification_state: crate::model::site_verification_info::SiteVerificationState,

    /// Latest site verification time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub verify_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SiteVerificationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_verification_state][crate::model::SiteVerificationInfo::site_verification_state].
    pub fn set_site_verification_state<
        T: std::convert::Into<crate::model::site_verification_info::SiteVerificationState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.site_verification_state = v.into();
        self
    }

    /// Sets the value of [verify_time][crate::model::SiteVerificationInfo::verify_time].
    pub fn set_verify_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.verify_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verify_time][crate::model::SiteVerificationInfo::verify_time].
    pub fn set_or_clear_verify_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.verify_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SiteVerificationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SiteVerificationInfo"
    }
}

/// Defines additional types related to [SiteVerificationInfo].
pub mod site_verification_info {
    #[allow(unused_imports)]
    use super::*;

    /// Site verification state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SiteVerificationState {
        /// Defaults to VERIFIED.
        Unspecified,
        /// Site ownership verified.
        Verified,
        /// Site ownership pending verification or verification failed.
        Unverified,
        /// Site exempt from verification, e.g., a public website that opens to all.
        Exempted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SiteVerificationState::value] or
        /// [SiteVerificationState::name].
        UnknownValue(site_verification_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod site_verification_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SiteVerificationState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Verified => std::option::Option::Some(1),
                Self::Unverified => std::option::Option::Some(2),
                Self::Exempted => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SITE_VERIFICATION_STATE_UNSPECIFIED")
                }
                Self::Verified => std::option::Option::Some("VERIFIED"),
                Self::Unverified => std::option::Option::Some("UNVERIFIED"),
                Self::Exempted => std::option::Option::Some("EXEMPTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SiteVerificationState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SiteVerificationState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SiteVerificationState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Verified,
                2 => Self::Unverified,
                3 => Self::Exempted,
                _ => Self::UnknownValue(site_verification_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SiteVerificationState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SITE_VERIFICATION_STATE_UNSPECIFIED" => Self::Unspecified,
                "VERIFIED" => Self::Verified,
                "UNVERIFIED" => Self::Unverified,
                "EXEMPTED" => Self::Exempted,
                _ => Self::UnknownValue(site_verification_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SiteVerificationState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Verified => serializer.serialize_i32(1),
                Self::Unverified => serializer.serialize_i32(2),
                Self::Exempted => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SiteVerificationState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SiteVerificationState>::new(
                ".google.cloud.discoveryengine.v1.SiteVerificationInfo.SiteVerificationState",
            ))
        }
    }
}

/// A sitemap for the SiteSearchEngine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sitemap {
    /// Output only. The fully qualified resource name of the sitemap.
    /// `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine/sitemaps/*`
    /// The `sitemap_id` suffix is system-generated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The sitemap's creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Supported feed sources.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub feed: std::option::Option<crate::model::sitemap::Feed>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sitemap {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Sitemap::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Sitemap::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Sitemap::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [feed][crate::model::Sitemap::feed].
    ///
    /// Note that all the setters affecting `feed` are mutually
    /// exclusive.
    pub fn set_feed<T: std::convert::Into<std::option::Option<crate::model::sitemap::Feed>>>(
        mut self,
        v: T,
    ) -> Self {
        self.feed = v.into();
        self
    }

    /// The value of [feed][crate::model::Sitemap::feed]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.feed.as_ref().and_then(|v| match v {
            crate::model::sitemap::Feed::Uri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [feed][crate::model::Sitemap::feed]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `feed` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feed = std::option::Option::Some(crate::model::sitemap::Feed::Uri(v.into()));
        self
    }
}

impl wkt::message::Message for Sitemap {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.Sitemap"
    }
}

/// Defines additional types related to [Sitemap].
pub mod sitemap {
    #[allow(unused_imports)]
    use super::*;

    /// Supported feed sources.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Feed {
        /// Public URI for the sitemap, e.g. `www.example.com/sitemap.xml`.
        Uri(std::string::String),
    }
}

/// Request message for
/// [SiteSearchEngineService.GetSiteSearchEngine][google.cloud.discoveryengine.v1.SiteSearchEngineService.GetSiteSearchEngine]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.GetSiteSearchEngine]: crate::client::SiteSearchEngineService::get_site_search_engine
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSiteSearchEngineRequest {
    /// Required. Resource name of
    /// [SiteSearchEngine][google.cloud.discoveryengine.v1.SiteSearchEngine], such
    /// as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    ///
    /// If the caller does not have permission to access the [SiteSearchEngine],
    /// regardless of whether or not it exists, a PERMISSION_DENIED error is
    /// returned.
    ///
    /// [google.cloud.discoveryengine.v1.SiteSearchEngine]: crate::model::SiteSearchEngine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSiteSearchEngineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSiteSearchEngineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSiteSearchEngineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetSiteSearchEngineRequest"
    }
}

/// Request message for
/// [SiteSearchEngineService.CreateTargetSite][google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateTargetSite]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateTargetSite]: crate::client::SiteSearchEngineService::create_target_site
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTargetSiteRequest {
    /// Required. Parent resource name of
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    ///
    /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The [TargetSite][google.cloud.discoveryengine.v1.TargetSite] to
    /// create.
    ///
    /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_site: std::option::Option<crate::model::TargetSite>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTargetSiteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTargetSiteRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target_site][crate::model::CreateTargetSiteRequest::target_site].
    pub fn set_target_site<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetSite>,
    {
        self.target_site = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_site][crate::model::CreateTargetSiteRequest::target_site].
    pub fn set_or_clear_target_site<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetSite>,
    {
        self.target_site = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTargetSiteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateTargetSiteRequest"
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.CreateTargetSite][google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateTargetSite]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateTargetSite]: crate::client::SiteSearchEngineService::create_target_site
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTargetSiteMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTargetSiteMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateTargetSiteMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateTargetSiteMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CreateTargetSiteMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CreateTargetSiteMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTargetSiteMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateTargetSiteMetadata"
    }
}

/// Request message for
/// [SiteSearchEngineService.BatchCreateTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites]: crate::client::SiteSearchEngineService::batch_create_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTargetSitesRequest {
    /// Required. The parent resource shared by all TargetSites being created.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    /// The parent field in the CreateBookRequest messages must either be empty or
    /// match this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The request message specifying the resources to create.
    /// A maximum of 20 TargetSites can be created in a batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::CreateTargetSiteRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateTargetSitesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateTargetSitesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateTargetSitesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateTargetSiteRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateTargetSitesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchCreateTargetSitesRequest"
    }
}

/// Request message for
/// [SiteSearchEngineService.GetTargetSite][google.cloud.discoveryengine.v1.SiteSearchEngineService.GetTargetSite]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.GetTargetSite]: crate::client::SiteSearchEngineService::get_target_site
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTargetSiteRequest {
    /// Required. Full resource name of
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
    ///
    /// If the caller does not have permission to access the
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested [TargetSite][google.cloud.discoveryengine.v1.TargetSite]
    /// does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTargetSiteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTargetSiteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTargetSiteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.GetTargetSiteRequest"
    }
}

/// Request message for
/// [SiteSearchEngineService.UpdateTargetSite][google.cloud.discoveryengine.v1.SiteSearchEngineService.UpdateTargetSite]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.UpdateTargetSite]: crate::client::SiteSearchEngineService::update_target_site
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTargetSiteRequest {
    /// Required. The target site to update.
    /// If the caller does not have permission to update the
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [TargetSite][google.cloud.discoveryengine.v1.TargetSite] to update
    /// does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_site: std::option::Option<crate::model::TargetSite>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTargetSiteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_site][crate::model::UpdateTargetSiteRequest::target_site].
    pub fn set_target_site<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetSite>,
    {
        self.target_site = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_site][crate::model::UpdateTargetSiteRequest::target_site].
    pub fn set_or_clear_target_site<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetSite>,
    {
        self.target_site = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTargetSiteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateTargetSiteRequest"
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.UpdateTargetSite][google.cloud.discoveryengine.v1.SiteSearchEngineService.UpdateTargetSite]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.UpdateTargetSite]: crate::client::SiteSearchEngineService::update_target_site
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTargetSiteMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTargetSiteMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::UpdateTargetSiteMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UpdateTargetSiteMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::UpdateTargetSiteMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::UpdateTargetSiteMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTargetSiteMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UpdateTargetSiteMetadata"
    }
}

/// Request message for
/// [SiteSearchEngineService.DeleteTargetSite][google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteTargetSite]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteTargetSite]: crate::client::SiteSearchEngineService::delete_target_site
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTargetSiteRequest {
    /// Required. Full resource name of
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
    ///
    /// If the caller does not have permission to access the
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested [TargetSite][google.cloud.discoveryengine.v1.TargetSite]
    /// does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTargetSiteRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTargetSiteRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTargetSiteRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteTargetSiteRequest"
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.DeleteTargetSite][google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteTargetSite]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteTargetSite]: crate::client::SiteSearchEngineService::delete_target_site
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTargetSiteMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTargetSiteMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeleteTargetSiteMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteTargetSiteMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteTargetSiteMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeleteTargetSiteMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteTargetSiteMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteTargetSiteMetadata"
    }
}

/// Request message for
/// [SiteSearchEngineService.ListTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.ListTargetSites]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.ListTargetSites]: crate::client::SiteSearchEngineService::list_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTargetSitesRequest {
    /// Required. The parent site search engine resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    ///
    /// If the caller does not have permission to list
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite]s under this site
    /// search engine, regardless of whether or not this branch exists, a
    /// PERMISSION_DENIED error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested. If
    /// unspecified, server will pick an appropriate default. The maximum value is
    /// 1000; values above 1000 will be coerced to 1000.
    ///
    /// If this field is negative, an INVALID_ARGUMENT error is returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `ListTargetSites` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTargetSites`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetSitesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTargetSitesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTargetSitesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTargetSitesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTargetSitesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListTargetSitesRequest"
    }
}

/// Response message for
/// [SiteSearchEngineService.ListTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.ListTargetSites]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.ListTargetSites]: crate::client::SiteSearchEngineService::list_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTargetSitesResponse {
    /// List of TargetSites.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_sites: std::vec::Vec<crate::model::TargetSite>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of items matching the request.
    /// This will always be populated in the response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub total_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetSitesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_sites][crate::model::ListTargetSitesResponse::target_sites].
    pub fn set_target_sites<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetSite>,
    {
        use std::iter::Iterator;
        self.target_sites = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTargetSitesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListTargetSitesResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListTargetSitesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.ListTargetSitesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTargetSitesResponse {
    type PageItem = crate::model::TargetSite;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.target_sites
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.BatchCreateTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites]: crate::client::SiteSearchEngineService::batch_create_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTargetSiteMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateTargetSiteMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BatchCreateTargetSiteMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BatchCreateTargetSiteMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BatchCreateTargetSiteMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BatchCreateTargetSiteMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchCreateTargetSiteMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchCreateTargetSiteMetadata"
    }
}

/// Response message for
/// [SiteSearchEngineService.BatchCreateTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites]: crate::client::SiteSearchEngineService::batch_create_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateTargetSitesResponse {
    /// TargetSites created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_sites: std::vec::Vec<crate::model::TargetSite>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateTargetSitesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_sites][crate::model::BatchCreateTargetSitesResponse::target_sites].
    pub fn set_target_sites<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetSite>,
    {
        use std::iter::Iterator;
        self.target_sites = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateTargetSitesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchCreateTargetSitesResponse"
    }
}

/// Request message for
/// [SiteSearchEngineService.CreateSitemap][google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateSitemap]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateSitemap]: crate::client::SiteSearchEngineService::create_sitemap
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSitemapRequest {
    /// Required. Parent resource name of the
    /// [SiteSearchEngine][google.cloud.discoveryengine.v1.SiteSearchEngine], such
    /// as `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine`.
    ///
    /// [google.cloud.discoveryengine.v1.SiteSearchEngine]: crate::model::SiteSearchEngine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The [Sitemap][google.cloud.discoveryengine.v1.Sitemap] to create.
    ///
    /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sitemap: std::option::Option<crate::model::Sitemap>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSitemapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSitemapRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [sitemap][crate::model::CreateSitemapRequest::sitemap].
    pub fn set_sitemap<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sitemap>,
    {
        self.sitemap = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sitemap][crate::model::CreateSitemapRequest::sitemap].
    pub fn set_or_clear_sitemap<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sitemap>,
    {
        self.sitemap = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSitemapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateSitemapRequest"
    }
}

/// Request message for
/// [SiteSearchEngineService.DeleteSitemap][google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteSitemap]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteSitemap]: crate::client::SiteSearchEngineService::delete_sitemap
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSitemapRequest {
    /// Required. Full resource name of
    /// [Sitemap][google.cloud.discoveryengine.v1.Sitemap], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/sitemaps/{sitemap}`.
    ///
    /// If the caller does not have permission to access the
    /// [Sitemap][google.cloud.discoveryengine.v1.Sitemap], regardless of whether
    /// or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested [Sitemap][google.cloud.discoveryengine.v1.Sitemap] does
    /// not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSitemapRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSitemapRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSitemapRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteSitemapRequest"
    }
}

/// Request message for
/// [SiteSearchEngineService.FetchSitemaps][google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchSitemaps]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchSitemaps]: crate::client::SiteSearchEngineService::fetch_sitemaps
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchSitemapsRequest {
    /// Required. Parent resource name of the
    /// [SiteSearchEngine][google.cloud.discoveryengine.v1.SiteSearchEngine], such
    /// as `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine`.
    ///
    /// [google.cloud.discoveryengine.v1.SiteSearchEngine]: crate::model::SiteSearchEngine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. If specified, fetches the matching
    /// [Sitemap][google.cloud.discoveryengine.v1.Sitemap]s. If not specified,
    /// fetches all [Sitemap][google.cloud.discoveryengine.v1.Sitemap]s in the
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore].
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub matcher: std::option::Option<crate::model::fetch_sitemaps_request::Matcher>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchSitemapsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::FetchSitemapsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [matcher][crate::model::FetchSitemapsRequest::matcher].
    pub fn set_matcher<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::fetch_sitemaps_request::Matcher>,
    {
        self.matcher = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [matcher][crate::model::FetchSitemapsRequest::matcher].
    pub fn set_or_clear_matcher<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::fetch_sitemaps_request::Matcher>,
    {
        self.matcher = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FetchSitemapsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.FetchSitemapsRequest"
    }
}

/// Defines additional types related to [FetchSitemapsRequest].
pub mod fetch_sitemaps_request {
    #[allow(unused_imports)]
    use super::*;

    /// Matcher for the [Sitemap][google.cloud.discoveryengine.v1.Sitemap]s by
    /// their uris.
    ///
    /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UrisMatcher {
        /// The [Sitemap][google.cloud.discoveryengine.v1.Sitemap] uris.
        ///
        /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub uris: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UrisMatcher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uris][crate::model::fetch_sitemaps_request::UrisMatcher::uris].
        pub fn set_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for UrisMatcher {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.FetchSitemapsRequest.UrisMatcher"
        }
    }

    /// Matcher for the [Sitemap][google.cloud.discoveryengine.v1.Sitemap]s.
    /// Currently only supports uris matcher.
    ///
    /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Matcher {
        /// Matcher for the [Sitemap][google.cloud.discoveryengine.v1.Sitemap]s.
        ///
        /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub matcher: std::option::Option<crate::model::fetch_sitemaps_request::matcher::Matcher>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Matcher {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [matcher][crate::model::fetch_sitemaps_request::Matcher::matcher].
        ///
        /// Note that all the setters affecting `matcher` are mutually
        /// exclusive.
        pub fn set_matcher<
            T: std::convert::Into<
                    std::option::Option<crate::model::fetch_sitemaps_request::matcher::Matcher>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.matcher = v.into();
            self
        }

        /// The value of [matcher][crate::model::fetch_sitemaps_request::Matcher::matcher]
        /// if it holds a `UrisMatcher`, `None` if the field is not set or
        /// holds a different branch.
        pub fn uris_matcher(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::fetch_sitemaps_request::UrisMatcher>>
        {
            #[allow(unreachable_patterns)]
            self.matcher.as_ref().and_then(|v| match v {
                crate::model::fetch_sitemaps_request::matcher::Matcher::UrisMatcher(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [matcher][crate::model::fetch_sitemaps_request::Matcher::matcher]
        /// to hold a `UrisMatcher`.
        ///
        /// Note that all the setters affecting `matcher` are
        /// mutually exclusive.
        pub fn set_uris_matcher<
            T: std::convert::Into<std::boxed::Box<crate::model::fetch_sitemaps_request::UrisMatcher>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.matcher = std::option::Option::Some(
                crate::model::fetch_sitemaps_request::matcher::Matcher::UrisMatcher(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Matcher {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.FetchSitemapsRequest.Matcher"
        }
    }

    /// Defines additional types related to [Matcher].
    pub mod matcher {
        #[allow(unused_imports)]
        use super::*;

        /// Matcher for the [Sitemap][google.cloud.discoveryengine.v1.Sitemap]s.
        ///
        /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
        #[serde_with::serde_as]
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Matcher {
            /// Matcher by sitemap URIs.
            UrisMatcher(std::boxed::Box<crate::model::fetch_sitemaps_request::UrisMatcher>),
        }
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.CreateSitemap][google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateSitemap]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateSitemap]: crate::client::SiteSearchEngineService::create_sitemap
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSitemapMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSitemapMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CreateSitemapMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateSitemapMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CreateSitemapMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CreateSitemapMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSitemapMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CreateSitemapMetadata"
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.DeleteSitemap][google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteSitemap]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteSitemap]: crate::client::SiteSearchEngineService::delete_sitemap
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSitemapMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSitemapMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DeleteSitemapMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteSitemapMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteSitemapMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeleteSitemapMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteSitemapMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DeleteSitemapMetadata"
    }
}

/// Response message for
/// [SiteSearchEngineService.FetchSitemaps][google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchSitemaps]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchSitemaps]: crate::client::SiteSearchEngineService::fetch_sitemaps
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchSitemapsResponse {
    /// List of [Sitemap][google.cloud.discoveryengine.v1.Sitemap]s fetched.
    ///
    /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sitemaps_metadata: std::vec::Vec<crate::model::fetch_sitemaps_response::SitemapMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchSitemapsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sitemaps_metadata][crate::model::FetchSitemapsResponse::sitemaps_metadata].
    pub fn set_sitemaps_metadata<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::fetch_sitemaps_response::SitemapMetadata>,
    {
        use std::iter::Iterator;
        self.sitemaps_metadata = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchSitemapsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.FetchSitemapsResponse"
    }
}

/// Defines additional types related to [FetchSitemapsResponse].
pub mod fetch_sitemaps_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains a [Sitemap][google.cloud.discoveryengine.v1.Sitemap] and its
    /// metadata.
    ///
    /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SitemapMetadata {
        /// The [Sitemap][google.cloud.discoveryengine.v1.Sitemap].
        ///
        /// [google.cloud.discoveryengine.v1.Sitemap]: crate::model::Sitemap
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub sitemap: std::option::Option<crate::model::Sitemap>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SitemapMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sitemap][crate::model::fetch_sitemaps_response::SitemapMetadata::sitemap].
        pub fn set_sitemap<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Sitemap>,
        {
            self.sitemap = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sitemap][crate::model::fetch_sitemaps_response::SitemapMetadata::sitemap].
        pub fn set_or_clear_sitemap<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Sitemap>,
        {
            self.sitemap = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SitemapMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.FetchSitemapsResponse.SitemapMetadata"
        }
    }
}

/// Request message for
/// [SiteSearchEngineService.EnableAdvancedSiteSearch][google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch]: crate::client::SiteSearchEngineService::enable_advanced_site_search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableAdvancedSiteSearchRequest {
    /// Required. Full resource name of the
    /// [SiteSearchEngine][google.cloud.discoveryengine.v1.SiteSearchEngine], such
    /// as
    /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
    ///
    /// [google.cloud.discoveryengine.v1.SiteSearchEngine]: crate::model::SiteSearchEngine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site_search_engine: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableAdvancedSiteSearchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_search_engine][crate::model::EnableAdvancedSiteSearchRequest::site_search_engine].
    pub fn set_site_search_engine<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.site_search_engine = v.into();
        self
    }
}

impl wkt::message::Message for EnableAdvancedSiteSearchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.EnableAdvancedSiteSearchRequest"
    }
}

/// Response message for
/// [SiteSearchEngineService.EnableAdvancedSiteSearch][google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch]: crate::client::SiteSearchEngineService::enable_advanced_site_search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableAdvancedSiteSearchResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableAdvancedSiteSearchResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnableAdvancedSiteSearchResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.EnableAdvancedSiteSearchResponse"
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.EnableAdvancedSiteSearch][google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch]: crate::client::SiteSearchEngineService::enable_advanced_site_search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableAdvancedSiteSearchMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableAdvancedSiteSearchMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::EnableAdvancedSiteSearchMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::EnableAdvancedSiteSearchMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::EnableAdvancedSiteSearchMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::EnableAdvancedSiteSearchMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EnableAdvancedSiteSearchMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.EnableAdvancedSiteSearchMetadata"
    }
}

/// Request message for
/// [SiteSearchEngineService.DisableAdvancedSiteSearch][google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch]: crate::client::SiteSearchEngineService::disable_advanced_site_search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisableAdvancedSiteSearchRequest {
    /// Required. Full resource name of the
    /// [SiteSearchEngine][google.cloud.discoveryengine.v1.SiteSearchEngine], such
    /// as
    /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
    ///
    /// [google.cloud.discoveryengine.v1.SiteSearchEngine]: crate::model::SiteSearchEngine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site_search_engine: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableAdvancedSiteSearchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_search_engine][crate::model::DisableAdvancedSiteSearchRequest::site_search_engine].
    pub fn set_site_search_engine<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.site_search_engine = v.into();
        self
    }
}

impl wkt::message::Message for DisableAdvancedSiteSearchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DisableAdvancedSiteSearchRequest"
    }
}

/// Response message for
/// [SiteSearchEngineService.DisableAdvancedSiteSearch][google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch]: crate::client::SiteSearchEngineService::disable_advanced_site_search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisableAdvancedSiteSearchResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableAdvancedSiteSearchResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisableAdvancedSiteSearchResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DisableAdvancedSiteSearchResponse"
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.DisableAdvancedSiteSearch][google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch]: crate::client::SiteSearchEngineService::disable_advanced_site_search
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisableAdvancedSiteSearchMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableAdvancedSiteSearchMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DisableAdvancedSiteSearchMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DisableAdvancedSiteSearchMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DisableAdvancedSiteSearchMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DisableAdvancedSiteSearchMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DisableAdvancedSiteSearchMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DisableAdvancedSiteSearchMetadata"
    }
}

/// Request message for
/// [SiteSearchEngineService.RecrawlUris][google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris]: crate::client::SiteSearchEngineService::recrawl_uris
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecrawlUrisRequest {
    /// Required. Full resource name of the
    /// [SiteSearchEngine][google.cloud.discoveryengine.v1.SiteSearchEngine], such
    /// as `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine`.
    ///
    /// [google.cloud.discoveryengine.v1.SiteSearchEngine]: crate::model::SiteSearchEngine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site_search_engine: std::string::String,

    /// Required. List of URIs to crawl. At most 10K URIs are supported, otherwise
    /// an INVALID_ARGUMENT error is thrown. Each URI should match at least one
    /// [TargetSite][google.cloud.discoveryengine.v1.TargetSite] in
    /// `site_search_engine`.
    ///
    /// [google.cloud.discoveryengine.v1.TargetSite]: crate::model::TargetSite
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uris: std::vec::Vec<std::string::String>,

    /// Optional. Credential id to use for crawling.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site_credential: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecrawlUrisRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_search_engine][crate::model::RecrawlUrisRequest::site_search_engine].
    pub fn set_site_search_engine<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.site_search_engine = v.into();
        self
    }

    /// Sets the value of [uris][crate::model::RecrawlUrisRequest::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [site_credential][crate::model::RecrawlUrisRequest::site_credential].
    pub fn set_site_credential<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.site_credential = v.into();
        self
    }
}

impl wkt::message::Message for RecrawlUrisRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RecrawlUrisRequest"
    }
}

/// Response message for
/// [SiteSearchEngineService.RecrawlUris][google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris]: crate::client::SiteSearchEngineService::recrawl_uris
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecrawlUrisResponse {
    /// Details for a sample of up to 10 `failed_uris`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub failure_samples: std::vec::Vec<crate::model::recrawl_uris_response::FailureInfo>,

    /// URIs that were not crawled before the LRO terminated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub failed_uris: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecrawlUrisResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [failure_samples][crate::model::RecrawlUrisResponse::failure_samples].
    pub fn set_failure_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::recrawl_uris_response::FailureInfo>,
    {
        use std::iter::Iterator;
        self.failure_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [failed_uris][crate::model::RecrawlUrisResponse::failed_uris].
    pub fn set_failed_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RecrawlUrisResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RecrawlUrisResponse"
    }
}

/// Defines additional types related to [RecrawlUrisResponse].
pub mod recrawl_uris_response {
    #[allow(unused_imports)]
    use super::*;

    /// Details about why a particular URI failed to be crawled. Each FailureInfo
    /// contains one FailureReason per CorpusType.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FailureInfo {
        /// URI that failed to be crawled.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uri: std::string::String,

        /// List of failure reasons by corpus type (e.g. desktop, mobile).
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub failure_reasons:
            std::vec::Vec<crate::model::recrawl_uris_response::failure_info::FailureReason>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailureInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::recrawl_uris_response::FailureInfo::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [failure_reasons][crate::model::recrawl_uris_response::FailureInfo::failure_reasons].
        pub fn set_failure_reasons<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::recrawl_uris_response::failure_info::FailureReason>,
        {
            use std::iter::Iterator;
            self.failure_reasons = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FailureInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.discoveryengine.v1.RecrawlUrisResponse.FailureInfo"
        }
    }

    /// Defines additional types related to [FailureInfo].
    pub mod failure_info {
        #[allow(unused_imports)]
        use super::*;

        /// Details about why crawling failed for a particular CorpusType, e.g.,
        /// DESKTOP and MOBILE crawling may fail for different reasons.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct FailureReason {
            /// DESKTOP, MOBILE, or CORPUS_TYPE_UNSPECIFIED.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub corpus_type:
                crate::model::recrawl_uris_response::failure_info::failure_reason::CorpusType,

            /// Reason why the URI was not crawled.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub error_message: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FailureReason {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [corpus_type][crate::model::recrawl_uris_response::failure_info::FailureReason::corpus_type].
            pub fn set_corpus_type<T: std::convert::Into<crate::model::recrawl_uris_response::failure_info::failure_reason::CorpusType>>(mut self, v: T) -> Self{
                self.corpus_type = v.into();
                self
            }

            /// Sets the value of [error_message][crate::model::recrawl_uris_response::failure_info::FailureReason::error_message].
            pub fn set_error_message<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.error_message = v.into();
                self
            }
        }

        impl wkt::message::Message for FailureReason {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.discoveryengine.v1.RecrawlUrisResponse.FailureInfo.FailureReason"
            }
        }

        /// Defines additional types related to [FailureReason].
        pub mod failure_reason {
            #[allow(unused_imports)]
            use super::*;

            /// CorpusType for the failed crawling operation.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum CorpusType {
                /// Default value.
                Unspecified,
                /// Denotes a crawling attempt for the desktop version of a page.
                Desktop,
                /// Denotes a crawling attempt for the mobile version of a page.
                Mobile,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [CorpusType::value] or
                /// [CorpusType::name].
                UnknownValue(corpus_type::UnknownValue),
            }

            #[doc(hidden)]
            pub mod corpus_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl CorpusType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Desktop => std::option::Option::Some(1),
                        Self::Mobile => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("CORPUS_TYPE_UNSPECIFIED"),
                        Self::Desktop => std::option::Option::Some("DESKTOP"),
                        Self::Mobile => std::option::Option::Some("MOBILE"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for CorpusType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for CorpusType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for CorpusType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Desktop,
                        2 => Self::Mobile,
                        _ => Self::UnknownValue(corpus_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for CorpusType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "CORPUS_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "DESKTOP" => Self::Desktop,
                        "MOBILE" => Self::Mobile,
                        _ => Self::UnknownValue(corpus_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for CorpusType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Desktop => serializer.serialize_i32(1),
                        Self::Mobile => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for CorpusType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<CorpusType>::new(
                        ".google.cloud.discoveryengine.v1.RecrawlUrisResponse.FailureInfo.FailureReason.CorpusType"))
                }
            }
        }
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.RecrawlUris][google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris]: crate::client::SiteSearchEngineService::recrawl_uris
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecrawlUrisMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Unique URIs in the request that have invalid format. Sample limited to
    /// 1000.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub invalid_uris: std::vec::Vec<std::string::String>,

    /// Total number of unique URIs in the request that have invalid format.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub invalid_uris_count: i32,

    /// URIs that have no index meta tag. Sample limited to 1000.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub noindex_uris: std::vec::Vec<std::string::String>,

    /// Total number of URIs that have no index meta tag.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub noindex_uris_count: i32,

    /// Unique URIs in the request that don't match any TargetSite in the
    /// DataStore, only match TargetSites that haven't been fully indexed, or match
    /// a TargetSite with type EXCLUDE. Sample limited to 1000.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub uris_not_matching_target_sites: std::vec::Vec<std::string::String>,

    /// Total number of URIs that don't match any TargetSites.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub uris_not_matching_target_sites_count: i32,

    /// Total number of unique URIs in the request that are not in invalid_uris.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub valid_uris_count: i32,

    /// Total number of URIs that have been crawled so far.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub success_count: i32,

    /// Total number of URIs that have yet to be crawled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub pending_count: i32,

    /// Total number of URIs that were rejected due to insufficient indexing
    /// resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub quota_exceeded_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecrawlUrisMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::RecrawlUrisMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::RecrawlUrisMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::RecrawlUrisMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::RecrawlUrisMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [invalid_uris][crate::model::RecrawlUrisMetadata::invalid_uris].
    pub fn set_invalid_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.invalid_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [invalid_uris_count][crate::model::RecrawlUrisMetadata::invalid_uris_count].
    pub fn set_invalid_uris_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.invalid_uris_count = v.into();
        self
    }

    /// Sets the value of [noindex_uris][crate::model::RecrawlUrisMetadata::noindex_uris].
    pub fn set_noindex_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.noindex_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [noindex_uris_count][crate::model::RecrawlUrisMetadata::noindex_uris_count].
    pub fn set_noindex_uris_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.noindex_uris_count = v.into();
        self
    }

    /// Sets the value of [uris_not_matching_target_sites][crate::model::RecrawlUrisMetadata::uris_not_matching_target_sites].
    pub fn set_uris_not_matching_target_sites<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris_not_matching_target_sites = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uris_not_matching_target_sites_count][crate::model::RecrawlUrisMetadata::uris_not_matching_target_sites_count].
    pub fn set_uris_not_matching_target_sites_count<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.uris_not_matching_target_sites_count = v.into();
        self
    }

    /// Sets the value of [valid_uris_count][crate::model::RecrawlUrisMetadata::valid_uris_count].
    pub fn set_valid_uris_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.valid_uris_count = v.into();
        self
    }

    /// Sets the value of [success_count][crate::model::RecrawlUrisMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [pending_count][crate::model::RecrawlUrisMetadata::pending_count].
    pub fn set_pending_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pending_count = v.into();
        self
    }

    /// Sets the value of [quota_exceeded_count][crate::model::RecrawlUrisMetadata::quota_exceeded_count].
    pub fn set_quota_exceeded_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.quota_exceeded_count = v.into();
        self
    }
}

impl wkt::message::Message for RecrawlUrisMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.RecrawlUrisMetadata"
    }
}

/// Request message for
/// [SiteSearchEngineService.BatchVerifyTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites]: crate::client::SiteSearchEngineService::batch_verify_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchVerifyTargetSitesRequest {
    /// Required. The parent resource shared by all TargetSites being verified.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchVerifyTargetSitesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchVerifyTargetSitesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for BatchVerifyTargetSitesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchVerifyTargetSitesRequest"
    }
}

/// Response message for
/// [SiteSearchEngineService.BatchVerifyTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites]: crate::client::SiteSearchEngineService::batch_verify_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchVerifyTargetSitesResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchVerifyTargetSitesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for BatchVerifyTargetSitesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchVerifyTargetSitesResponse"
    }
}

/// Metadata related to the progress of the
/// [SiteSearchEngineService.BatchVerifyTargetSites][google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites]: crate::client::SiteSearchEngineService::batch_verify_target_sites
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchVerifyTargetSitesMetadata {
    /// Operation create time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchVerifyTargetSitesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::BatchVerifyTargetSitesMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BatchVerifyTargetSitesMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BatchVerifyTargetSitesMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BatchVerifyTargetSitesMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchVerifyTargetSitesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.BatchVerifyTargetSitesMetadata"
    }
}

/// Request message for
/// [SiteSearchEngineService.FetchDomainVerificationStatus][google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchDomainVerificationStatus]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchDomainVerificationStatus]: crate::client::SiteSearchEngineService::fetch_domain_verification_status
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchDomainVerificationStatusRequest {
    /// Required. The site search engine resource under which we fetch all the
    /// domain verification status.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub site_search_engine: std::string::String,

    /// Requested page size. Server may return fewer items than requested. If
    /// unspecified, server will pick an appropriate default. The maximum value is
    /// 1000; values above 1000 will be coerced to 1000.
    ///
    /// If this field is negative, an INVALID_ARGUMENT error is returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// A page token, received from a previous `FetchDomainVerificationStatus`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `FetchDomainVerificationStatus` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchDomainVerificationStatusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [site_search_engine][crate::model::FetchDomainVerificationStatusRequest::site_search_engine].
    pub fn set_site_search_engine<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.site_search_engine = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchDomainVerificationStatusRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchDomainVerificationStatusRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchDomainVerificationStatusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.FetchDomainVerificationStatusRequest"
    }
}

/// Response message for
/// [SiteSearchEngineService.FetchDomainVerificationStatus][google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchDomainVerificationStatus]
/// method.
///
/// [google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchDomainVerificationStatus]: crate::client::SiteSearchEngineService::fetch_domain_verification_status
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchDomainVerificationStatusResponse {
    /// List of TargetSites containing the site verification status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_sites: std::vec::Vec<crate::model::TargetSite>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// The total number of items matching the request.
    /// This will always be populated in the response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub total_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchDomainVerificationStatusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_sites][crate::model::FetchDomainVerificationStatusResponse::target_sites].
    pub fn set_target_sites<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetSite>,
    {
        use std::iter::Iterator;
        self.target_sites = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchDomainVerificationStatusResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::FetchDomainVerificationStatusResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for FetchDomainVerificationStatusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.FetchDomainVerificationStatusResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchDomainVerificationStatusResponse {
    type PageItem = crate::model::TargetSite;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.target_sites
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// UserEvent captures all metadata information Discovery Engine API needs to
/// know about how end users interact with your website.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserEvent {
    /// Required. User event type. Allowed values are:
    ///
    /// Generic values:
    ///
    /// * `search`: Search for Documents.
    /// * `view-item`: Detailed page view of a Document.
    /// * `view-item-list`: View of a panel or ordered list of Documents.
    /// * `view-home-page`: View of the home page.
    /// * `view-category-page`: View of a category page, e.g. Home > Men > Jeans
    /// * `add-feedback`: Add a user feedback.
    ///
    /// Retail-related values:
    ///
    /// * `add-to-cart`: Add an item(s) to cart, e.g. in Retail online shopping
    /// * `purchase`: Purchase an item(s)
    ///
    /// Media-related values:
    ///
    /// * `media-play`: Start/resume watching a video, playing a song, etc.
    /// * `media-complete`: Finished or stopped midway through a video, song, etc.
    ///
    /// Custom conversion value:
    ///
    /// * `conversion`: Customer defined conversion event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub event_type: std::string::String,

    /// Optional. Conversion type.
    ///
    /// Required if
    /// [UserEvent.event_type][google.cloud.discoveryengine.v1.UserEvent.event_type]
    /// is `conversion`. This is a customer-defined conversion name in lowercase
    /// letters or numbers separated by "-", such as "watch", "good-visit" etc.
    ///
    /// Do not set the field if
    /// [UserEvent.event_type][google.cloud.discoveryengine.v1.UserEvent.event_type]
    /// is not `conversion`. This mixes the custom conversion event with predefined
    /// events like `search`, `view-item` etc.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent.event_type]: crate::model::UserEvent::event_type
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_type: std::string::String,

    /// Required. A unique identifier for tracking visitors.
    ///
    /// For example, this could be implemented with an HTTP cookie, which should be
    /// able to uniquely identify a visitor on a single device. This unique
    /// identifier should not change if the visitor log in/out of the website.
    ///
    /// Do not set the field to the same fixed ID for different users. This mixes
    /// the event history of those users together, which results in degraded model
    /// quality.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// The field should not contain PII or user-data. We recommend to use Google
    /// Analytics [Client
    /// ID](https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#clientId)
    /// for this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_pseudo_id: std::string::String,

    /// The [Engine][google.cloud.discoveryengine.v1.Engine] resource name, in the
    /// form of
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    ///
    /// Optional. Only required for
    /// [Engine][google.cloud.discoveryengine.v1.Engine] produced user events. For
    /// example, user events from blended search.
    ///
    /// [google.cloud.discoveryengine.v1.Engine]: crate::model::Engine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine: std::string::String,

    /// The [DataStore][google.cloud.discoveryengine.v1.DataStore] resource full
    /// name, of the form
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// Optional. Only required for user events whose data store can't by
    /// determined by
    /// [UserEvent.engine][google.cloud.discoveryengine.v1.UserEvent.engine] or
    /// [UserEvent.documents][google.cloud.discoveryengine.v1.UserEvent.documents].
    /// If data store is set in the parent of write/import/collect user event
    /// requests, this field can be omitted.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    /// [google.cloud.discoveryengine.v1.UserEvent.documents]: crate::model::UserEvent::documents
    /// [google.cloud.discoveryengine.v1.UserEvent.engine]: crate::model::UserEvent::engine
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_store: std::string::String,

    /// Only required for
    /// [UserEventService.ImportUserEvents][google.cloud.discoveryengine.v1.UserEventService.ImportUserEvents]
    /// method. Timestamp of when the user event happened.
    ///
    /// [google.cloud.discoveryengine.v1.UserEventService.ImportUserEvents]: crate::client::UserEventService::import_user_events
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub event_time: std::option::Option<wkt::Timestamp>,

    /// Information about the end user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_info: std::option::Option<crate::model::UserInfo>,

    /// Should set to true if the request is made directly from the end user, in
    /// which case the
    /// [UserEvent.user_info.user_agent][google.cloud.discoveryengine.v1.UserInfo.user_agent]
    /// can be populated from the HTTP request.
    ///
    /// This flag should be set only if the API request is made directly from the
    /// end user such as a mobile app (and not if a gateway or a server is
    /// processing and pushing the user events).
    ///
    /// This should not be set when using the JavaScript tag in
    /// [UserEventService.CollectUserEvent][google.cloud.discoveryengine.v1.UserEventService.CollectUserEvent].
    ///
    /// [google.cloud.discoveryengine.v1.UserEventService.CollectUserEvent]: crate::client::UserEventService::collect_user_event
    /// [google.cloud.discoveryengine.v1.UserInfo.user_agent]: crate::model::UserInfo::user_agent
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub direct_user_request: bool,

    /// A unique identifier for tracking a visitor session with a length limit of
    /// 128 bytes. A session is an aggregation of an end user behavior in a time
    /// span.
    ///
    /// A general guideline to populate the session_id:
    ///
    /// . If user has no activity for 30 min, a new session_id should be assigned.
    /// . The session_id should be unique across users, suggest use uuid or add
    ///   [UserEvent.user_pseudo_id][google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]
    ///   as prefix.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id]: crate::model::UserEvent::user_pseudo_id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session_id: std::string::String,

    /// Page metadata such as categories and other critical information for certain
    /// event types such as `view-category-page`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub page_info: std::option::Option<crate::model::PageInfo>,

    /// Token to attribute an API response to user action(s) to trigger the event.
    ///
    /// Highly recommended for user events that are the result of
    /// [RecommendationService.Recommend][google.cloud.discoveryengine.v1.RecommendationService.Recommend].
    /// This field enables accurate attribution of recommendation model
    /// performance.
    ///
    /// The value must be one of:
    ///
    /// * [RecommendResponse.attribution_token][google.cloud.discoveryengine.v1.RecommendResponse.attribution_token] for events that are the result of
    ///   [RecommendationService.Recommend][google.cloud.discoveryengine.v1.RecommendationService.Recommend].
    /// * [SearchResponse.attribution_token][google.cloud.discoveryengine.v1.SearchResponse.attribution_token] for events that are the result of
    ///   [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search].
    ///
    /// This token enables us to accurately attribute page view or conversion
    /// completion back to the event and the particular predict response containing
    /// this clicked/purchased product. If user clicks on product K in the
    /// recommendation results, pass
    /// [RecommendResponse.attribution_token][google.cloud.discoveryengine.v1.RecommendResponse.attribution_token]
    /// as a URL parameter to product K's page. When recording events on product
    /// K's page, log the
    /// [RecommendResponse.attribution_token][google.cloud.discoveryengine.v1.RecommendResponse.attribution_token]
    /// to this field.
    ///
    /// [google.cloud.discoveryengine.v1.RecommendResponse.attribution_token]: crate::model::RecommendResponse::attribution_token
    /// [google.cloud.discoveryengine.v1.RecommendationService.Recommend]: crate::client::RecommendationService::recommend
    /// [google.cloud.discoveryengine.v1.SearchResponse.attribution_token]: crate::model::SearchResponse::attribution_token
    /// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub attribution_token: std::string::String,

    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the documents being filtered.
    ///
    /// One example is for `search` events, the associated
    /// [SearchRequest][google.cloud.discoveryengine.v1.SearchRequest] may contain
    /// a filter expression in
    /// [SearchRequest.filter][google.cloud.discoveryengine.v1.SearchRequest.filter]
    /// conforming to <https://google.aip.dev/160#filtering>.
    ///
    /// Similarly, for `view-item-list` events that are generated from a
    /// [RecommendRequest][google.cloud.discoveryengine.v1.RecommendRequest], this
    /// field may be populated directly from
    /// [RecommendRequest.filter][google.cloud.discoveryengine.v1.RecommendRequest.filter]
    /// conforming to <https://google.aip.dev/160#filtering>.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.RecommendRequest]: crate::model::RecommendRequest
    /// [google.cloud.discoveryengine.v1.RecommendRequest.filter]: crate::model::RecommendRequest::filter
    /// [google.cloud.discoveryengine.v1.SearchRequest]: crate::model::SearchRequest
    /// [google.cloud.discoveryengine.v1.SearchRequest.filter]: crate::model::SearchRequest::filter
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// List of [Document][google.cloud.discoveryengine.v1.Document]s associated
    /// with this user event.
    ///
    /// This field is optional except for the following event types:
    ///
    /// * `view-item`
    /// * `add-to-cart`
    /// * `purchase`
    /// * `media-play`
    /// * `media-complete`
    ///
    /// In a `search` event, this field represents the documents returned to the
    /// end user on the current page (the end user may have not finished browsing
    /// the whole page yet). When a new page is returned to the end user, after
    /// pagination/filtering/ordering even for the same query, a new `search` event
    /// with different
    /// [UserEvent.documents][google.cloud.discoveryengine.v1.UserEvent.documents]
    /// is desired.
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.UserEvent.documents]: crate::model::UserEvent::documents
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub documents: std::vec::Vec<crate::model::DocumentInfo>,

    /// Panel metadata associated with this user event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub panel: std::option::Option<crate::model::PanelInfo>,

    /// [SearchService.Search][google.cloud.discoveryengine.v1.SearchService.Search]
    /// details related to the event.
    ///
    /// This field should be set for `search` event.
    ///
    /// [google.cloud.discoveryengine.v1.SearchService.Search]: crate::client::SearchService::search
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub search_info: std::option::Option<crate::model::SearchInfo>,

    /// [CompletionService.CompleteQuery][google.cloud.discoveryengine.v1.CompletionService.CompleteQuery]
    /// details related to the event.
    ///
    /// This field should be set for `search` event when autocomplete function is
    /// enabled and the user clicks a suggestion for search.
    ///
    /// [google.cloud.discoveryengine.v1.CompletionService.CompleteQuery]: crate::client::CompletionService::complete_query
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completion_info: std::option::Option<crate::model::CompletionInfo>,

    /// The transaction metadata (if any) associated with this user event.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transaction_info: std::option::Option<crate::model::TransactionInfo>,

    /// A list of identifiers for the independent experiment groups this user event
    /// belongs to. This is used to distinguish between user events associated with
    /// different experiment setups.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tag_ids: std::vec::Vec<std::string::String>,

    /// The promotion IDs if this is an event associated with promotions.
    /// Currently, this field is restricted to at most one ID.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub promotion_ids: std::vec::Vec<std::string::String>,

    /// Extra user event features to include in the recommendation model.
    /// These attributes must NOT contain data that needs to be parsed or processed
    /// further, e.g. JSON or other encodings.
    ///
    /// If you provide custom attributes for ingested user events, also include
    /// them in the user events that you associate with prediction requests. Custom
    /// attribute formatting must be consistent between imported events and events
    /// provided with prediction requests. This lets the Discovery Engine API use
    /// those custom attributes when training models and serving predictions, which
    /// helps improve recommendation quality.
    ///
    /// This field needs to pass all below criteria, otherwise an
    /// `INVALID_ARGUMENT` error is returned:
    ///
    /// * The key must be a UTF-8 encoded string with a length limit of 5,000
    ///   characters.
    /// * For text attributes, at most 400 values are allowed. Empty values are not
    ///   allowed. Each value must be a UTF-8 encoded string with a length limit of
    ///   256 characters.
    /// * For number attributes, at most 400 values are allowed.
    ///
    /// For product recommendations, an example of extra user information is
    /// `traffic_channel`, which is how a user arrives at the site. Users can
    /// arrive
    /// at the site by coming to the site directly, coming through Google
    /// search, or in other ways.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub attributes: std::collections::HashMap<std::string::String, crate::model::CustomAttribute>,

    /// Media-specific info.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub media_info: std::option::Option<crate::model::MediaInfo>,

    /// Optional. List of panels associated with this event.
    /// Used for page-level impression data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub panels: std::vec::Vec<crate::model::PanelInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_type][crate::model::UserEvent::event_type].
    pub fn set_event_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [conversion_type][crate::model::UserEvent::conversion_type].
    pub fn set_conversion_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversion_type = v.into();
        self
    }

    /// Sets the value of [user_pseudo_id][crate::model::UserEvent::user_pseudo_id].
    pub fn set_user_pseudo_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_pseudo_id = v.into();
        self
    }

    /// Sets the value of [engine][crate::model::UserEvent::engine].
    pub fn set_engine<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }

    /// Sets the value of [data_store][crate::model::UserEvent::data_store].
    pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_store = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::UserEvent::event_time].
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::UserEvent::event_time].
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_info][crate::model::UserEvent::user_info].
    pub fn set_user_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_info][crate::model::UserEvent::user_info].
    pub fn set_or_clear_user_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [direct_user_request][crate::model::UserEvent::direct_user_request].
    pub fn set_direct_user_request<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.direct_user_request = v.into();
        self
    }

    /// Sets the value of [session_id][crate::model::UserEvent::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [page_info][crate::model::UserEvent::page_info].
    pub fn set_page_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PageInfo>,
    {
        self.page_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_info][crate::model::UserEvent::page_info].
    pub fn set_or_clear_page_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PageInfo>,
    {
        self.page_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attribution_token][crate::model::UserEvent::attribution_token].
    pub fn set_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribution_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::UserEvent::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [documents][crate::model::UserEvent::documents].
    pub fn set_documents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DocumentInfo>,
    {
        use std::iter::Iterator;
        self.documents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [panel][crate::model::UserEvent::panel].
    pub fn set_panel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PanelInfo>,
    {
        self.panel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [panel][crate::model::UserEvent::panel].
    pub fn set_or_clear_panel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PanelInfo>,
    {
        self.panel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [search_info][crate::model::UserEvent::search_info].
    pub fn set_search_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SearchInfo>,
    {
        self.search_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [search_info][crate::model::UserEvent::search_info].
    pub fn set_or_clear_search_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SearchInfo>,
    {
        self.search_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_info][crate::model::UserEvent::completion_info].
    pub fn set_completion_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompletionInfo>,
    {
        self.completion_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_info][crate::model::UserEvent::completion_info].
    pub fn set_or_clear_completion_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompletionInfo>,
    {
        self.completion_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transaction_info][crate::model::UserEvent::transaction_info].
    pub fn set_transaction_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransactionInfo>,
    {
        self.transaction_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transaction_info][crate::model::UserEvent::transaction_info].
    pub fn set_or_clear_transaction_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransactionInfo>,
    {
        self.transaction_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tag_ids][crate::model::UserEvent::tag_ids].
    pub fn set_tag_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tag_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [promotion_ids][crate::model::UserEvent::promotion_ids].
    pub fn set_promotion_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.promotion_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attributes][crate::model::UserEvent::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CustomAttribute>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [media_info][crate::model::UserEvent::media_info].
    pub fn set_media_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MediaInfo>,
    {
        self.media_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [media_info][crate::model::UserEvent::media_info].
    pub fn set_or_clear_media_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MediaInfo>,
    {
        self.media_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [panels][crate::model::UserEvent::panels].
    pub fn set_panels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PanelInfo>,
    {
        use std::iter::Iterator;
        self.panels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.UserEvent"
    }
}

/// Detailed page information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PageInfo {
    /// A unique ID of a web page view.
    ///
    /// This should be kept the same for all user events triggered from the same
    /// pageview. For example, an item detail page view could trigger multiple
    /// events as the user is browsing the page. The `pageview_id` property should
    /// be kept the same for all these events so that they can be grouped together
    /// properly.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pageview_id: std::string::String,

    /// The most specific category associated with a category page.
    ///
    /// To represent full path of category, use '>' sign to separate different
    /// hierarchies. If '>' is part of the category name, replace it with
    /// other character(s).
    ///
    /// Category pages include special pages such as sales or promotions. For
    /// instance, a special sale page may have the category hierarchy:
    /// `"pageCategory" : "Sales > 2017 Black Friday Deals"`.
    ///
    /// Required for `view-category-page` events. Other event types should not set
    /// this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_category: std::string::String,

    /// Complete URL (window.location.href) of the user's current page.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically. Maximum length 5,000
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The referrer URL of the current page.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically. However, some browser
    /// privacy restrictions may cause this field to be empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub referrer_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PageInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pageview_id][crate::model::PageInfo::pageview_id].
    pub fn set_pageview_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pageview_id = v.into();
        self
    }

    /// Sets the value of [page_category][crate::model::PageInfo::page_category].
    pub fn set_page_category<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_category = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::PageInfo::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [referrer_uri][crate::model::PageInfo::referrer_uri].
    pub fn set_referrer_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.referrer_uri = v.into();
        self
    }
}

impl wkt::message::Message for PageInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PageInfo"
    }
}

/// Detailed search information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchInfo {
    /// The user's search query.
    ///
    /// See
    /// [SearchRequest.query][google.cloud.discoveryengine.v1.SearchRequest.query]
    /// for definition.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 5,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// At least one of
    /// [search_query][google.cloud.discoveryengine.v1.SearchInfo.search_query] or
    /// [PageInfo.page_category][google.cloud.discoveryengine.v1.PageInfo.page_category]
    /// is required for `search` events. Other event types should not set this
    /// field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.PageInfo.page_category]: crate::model::PageInfo::page_category
    /// [google.cloud.discoveryengine.v1.SearchInfo.search_query]: crate::model::SearchInfo::search_query
    /// [google.cloud.discoveryengine.v1.SearchRequest.query]: crate::model::SearchRequest::query
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub search_query: std::string::String,

    /// The order in which products are returned, if applicable.
    ///
    /// See
    /// [SearchRequest.order_by][google.cloud.discoveryengine.v1.SearchRequest.order_by]
    /// for definition and syntax.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// This can only be set for `search` events. Other event types should not set
    /// this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.order_by]: crate::model::SearchRequest::order_by
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// An integer that specifies the current offset for pagination (the 0-indexed
    /// starting location, amongst the products deemed by the API as relevant).
    ///
    /// See
    /// [SearchRequest.offset][google.cloud.discoveryengine.v1.SearchRequest.offset]
    /// for definition.
    ///
    /// If this field is negative, an `INVALID_ARGUMENT` is returned.
    ///
    /// This can only be set for `search` events. Other event types should not set
    /// this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.offset]: crate::model::SearchRequest::offset
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
    pub offset: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_query][crate::model::SearchInfo::search_query].
    pub fn set_search_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.search_query = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchInfo::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [offset][crate::model::SearchInfo::offset].
    pub fn set_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [offset][crate::model::SearchInfo::offset].
    pub fn set_or_clear_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.offset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.SearchInfo"
    }
}

/// Detailed completion information including completion attribution token and
/// clicked completion info.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CompletionInfo {
    /// End user selected
    /// [CompleteQueryResponse.QuerySuggestion.suggestion][google.cloud.discoveryengine.v1.CompleteQueryResponse.QuerySuggestion.suggestion].
    ///
    /// [google.cloud.discoveryengine.v1.CompleteQueryResponse.QuerySuggestion.suggestion]: crate::model::complete_query_response::QuerySuggestion::suggestion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub selected_suggestion: std::string::String,

    /// End user selected
    /// [CompleteQueryResponse.QuerySuggestion.suggestion][google.cloud.discoveryengine.v1.CompleteQueryResponse.QuerySuggestion.suggestion]
    /// position, starting from 0.
    ///
    /// [google.cloud.discoveryengine.v1.CompleteQueryResponse.QuerySuggestion.suggestion]: crate::model::complete_query_response::QuerySuggestion::suggestion
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub selected_position: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompletionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [selected_suggestion][crate::model::CompletionInfo::selected_suggestion].
    pub fn set_selected_suggestion<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.selected_suggestion = v.into();
        self
    }

    /// Sets the value of [selected_position][crate::model::CompletionInfo::selected_position].
    pub fn set_selected_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.selected_position = v.into();
        self
    }
}

impl wkt::message::Message for CompletionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CompletionInfo"
    }
}

/// A transaction represents the entire purchase transaction.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TransactionInfo {
    /// Required. Total non-zero value associated with the transaction. This value
    /// may include shipping, tax, or other adjustments to the total value that you
    /// want to include.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub value: std::option::Option<f32>,

    /// Required. Currency code. Use three-character ISO-4217 code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub currency: std::string::String,

    /// The transaction ID with a length limit of 128 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub transaction_id: std::string::String,

    /// All the taxes associated with the transaction.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub tax: std::option::Option<f32>,

    /// All the costs associated with the products. These can be manufacturing
    /// costs, shipping expenses not borne by the end user, or any other costs,
    /// such that:
    ///
    /// * Profit = [value][google.cloud.discoveryengine.v1.TransactionInfo.value] -
    ///   [tax][google.cloud.discoveryengine.v1.TransactionInfo.tax] -
    ///   [cost][google.cloud.discoveryengine.v1.TransactionInfo.cost]
    ///
    /// [google.cloud.discoveryengine.v1.TransactionInfo.cost]: crate::model::TransactionInfo::cost
    /// [google.cloud.discoveryengine.v1.TransactionInfo.tax]: crate::model::TransactionInfo::tax
    /// [google.cloud.discoveryengine.v1.TransactionInfo.value]: crate::model::TransactionInfo::value
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub cost: std::option::Option<f32>,

    /// The total discount(s) value applied to this transaction.
    /// This figure should be excluded from
    /// [TransactionInfo.value][google.cloud.discoveryengine.v1.TransactionInfo.value]
    ///
    /// For example, if a user paid
    /// [TransactionInfo.value][google.cloud.discoveryengine.v1.TransactionInfo.value]
    /// amount, then nominal (pre-discount) value of the transaction is the sum of
    /// [TransactionInfo.value][google.cloud.discoveryengine.v1.TransactionInfo.value]
    /// and
    /// [TransactionInfo.discount_value][google.cloud.discoveryengine.v1.TransactionInfo.discount_value]
    ///
    /// This means that profit is calculated the same way, regardless of the
    /// discount value, and that
    /// [TransactionInfo.discount_value][google.cloud.discoveryengine.v1.TransactionInfo.discount_value]
    /// can be larger than
    /// [TransactionInfo.value][google.cloud.discoveryengine.v1.TransactionInfo.value]:
    ///
    /// * Profit = [value][google.cloud.discoveryengine.v1.TransactionInfo.value] -
    ///   [tax][google.cloud.discoveryengine.v1.TransactionInfo.tax] -
    ///   [cost][google.cloud.discoveryengine.v1.TransactionInfo.cost]
    ///
    /// [google.cloud.discoveryengine.v1.TransactionInfo.cost]: crate::model::TransactionInfo::cost
    /// [google.cloud.discoveryengine.v1.TransactionInfo.discount_value]: crate::model::TransactionInfo::discount_value
    /// [google.cloud.discoveryengine.v1.TransactionInfo.tax]: crate::model::TransactionInfo::tax
    /// [google.cloud.discoveryengine.v1.TransactionInfo.value]: crate::model::TransactionInfo::value
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub discount_value: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransactionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::TransactionInfo::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::TransactionInfo::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [currency][crate::model::TransactionInfo::currency].
    pub fn set_currency<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency = v.into();
        self
    }

    /// Sets the value of [transaction_id][crate::model::TransactionInfo::transaction_id].
    pub fn set_transaction_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transaction_id = v.into();
        self
    }

    /// Sets the value of [tax][crate::model::TransactionInfo::tax].
    pub fn set_tax<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.tax = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tax][crate::model::TransactionInfo::tax].
    pub fn set_or_clear_tax<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.tax = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cost][crate::model::TransactionInfo::cost].
    pub fn set_cost<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.cost = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost][crate::model::TransactionInfo::cost].
    pub fn set_or_clear_cost<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.cost = v.map(|x| x.into());
        self
    }

    /// Sets the value of [discount_value][crate::model::TransactionInfo::discount_value].
    pub fn set_discount_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.discount_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discount_value][crate::model::TransactionInfo::discount_value].
    pub fn set_or_clear_discount_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.discount_value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TransactionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.TransactionInfo"
    }
}

/// Detailed document information associated with a user event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DocumentInfo {
    /// Quantity of the Document associated with the user event. Defaults to 1.
    ///
    /// For example, this field is 2 if two quantities of the same Document
    /// are involved in a `add-to-cart` event.
    ///
    /// Required for events of the following event types:
    ///
    /// * `add-to-cart`
    /// * `purchase`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
    pub quantity: std::option::Option<i32>,

    /// The promotion IDs associated with this Document.
    /// Currently, this field is restricted to at most one ID.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub promotion_ids: std::vec::Vec<std::string::String>,

    /// Output only. Whether the referenced Document can be found in the data
    /// store.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub joined: bool,

    /// Optional. The conversion value associated with this Document.
    /// Must be set if
    /// [UserEvent.event_type][google.cloud.discoveryengine.v1.UserEvent.event_type]
    /// is "conversion".
    ///
    /// For example, a value of 1000 signifies that 1000 seconds were spent viewing
    /// a Document for the `watch` conversion type.
    ///
    /// [google.cloud.discoveryengine.v1.UserEvent.event_type]: crate::model::UserEvent::event_type
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub conversion_value: std::option::Option<f32>,

    /// A required descriptor of the associated
    /// [Document][google.cloud.discoveryengine.v1.Document].
    ///
    /// * If [id][google.cloud.discoveryengine.v1.DocumentInfo.id] is specified,
    ///   then the default values for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and `{branch_id}` are
    ///   used when annotating with the stored Document.
    ///
    /// * If [name][google.cloud.discoveryengine.v1.DocumentInfo.name] is
    ///   specified, then the provided values (default values allowed) for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and
    ///   `{branch_id}` are used when annotating with the stored Document.
    ///
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.DocumentInfo.id]: crate::model::DocumentInfo::document_descriptor
    /// [google.cloud.discoveryengine.v1.DocumentInfo.name]: crate::model::DocumentInfo::document_descriptor
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub document_descriptor: std::option::Option<crate::model::document_info::DocumentDescriptor>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quantity][crate::model::DocumentInfo::quantity].
    pub fn set_quantity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.quantity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quantity][crate::model::DocumentInfo::quantity].
    pub fn set_or_clear_quantity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.quantity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [promotion_ids][crate::model::DocumentInfo::promotion_ids].
    pub fn set_promotion_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.promotion_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [joined][crate::model::DocumentInfo::joined].
    pub fn set_joined<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.joined = v.into();
        self
    }

    /// Sets the value of [conversion_value][crate::model::DocumentInfo::conversion_value].
    pub fn set_conversion_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.conversion_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversion_value][crate::model::DocumentInfo::conversion_value].
    pub fn set_or_clear_conversion_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.conversion_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_descriptor][crate::model::DocumentInfo::document_descriptor].
    ///
    /// Note that all the setters affecting `document_descriptor` are mutually
    /// exclusive.
    pub fn set_document_descriptor<
        T: std::convert::Into<std::option::Option<crate::model::document_info::DocumentDescriptor>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_descriptor = v.into();
        self
    }

    /// The value of [document_descriptor][crate::model::DocumentInfo::document_descriptor]
    /// if it holds a `Id`, `None` if the field is not set or
    /// holds a different branch.
    pub fn id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.document_descriptor.as_ref().and_then(|v| match v {
            crate::model::document_info::DocumentDescriptor::Id(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [document_descriptor][crate::model::DocumentInfo::document_descriptor]
    /// to hold a `Id`.
    ///
    /// Note that all the setters affecting `document_descriptor` are
    /// mutually exclusive.
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.document_descriptor = std::option::Option::Some(
            crate::model::document_info::DocumentDescriptor::Id(v.into()),
        );
        self
    }

    /// The value of [document_descriptor][crate::model::DocumentInfo::document_descriptor]
    /// if it holds a `Name`, `None` if the field is not set or
    /// holds a different branch.
    pub fn name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.document_descriptor.as_ref().and_then(|v| match v {
            crate::model::document_info::DocumentDescriptor::Name(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [document_descriptor][crate::model::DocumentInfo::document_descriptor]
    /// to hold a `Name`.
    ///
    /// Note that all the setters affecting `document_descriptor` are
    /// mutually exclusive.
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.document_descriptor = std::option::Option::Some(
            crate::model::document_info::DocumentDescriptor::Name(v.into()),
        );
        self
    }

    /// The value of [document_descriptor][crate::model::DocumentInfo::document_descriptor]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.document_descriptor.as_ref().and_then(|v| match v {
            crate::model::document_info::DocumentDescriptor::Uri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [document_descriptor][crate::model::DocumentInfo::document_descriptor]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `document_descriptor` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.document_descriptor = std::option::Option::Some(
            crate::model::document_info::DocumentDescriptor::Uri(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DocumentInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.DocumentInfo"
    }
}

/// Defines additional types related to [DocumentInfo].
pub mod document_info {
    #[allow(unused_imports)]
    use super::*;

    /// A required descriptor of the associated
    /// [Document][google.cloud.discoveryengine.v1.Document].
    ///
    /// * If [id][google.cloud.discoveryengine.v1.DocumentInfo.id] is specified,
    ///   then the default values for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and `{branch_id}` are
    ///   used when annotating with the stored Document.
    ///
    /// * If [name][google.cloud.discoveryengine.v1.DocumentInfo.name] is
    ///   specified, then the provided values (default values allowed) for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and
    ///   `{branch_id}` are used when annotating with the stored Document.
    ///
    ///
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.discoveryengine.v1.DocumentInfo.id]: crate::model::DocumentInfo::document_descriptor
    /// [google.cloud.discoveryengine.v1.DocumentInfo.name]: crate::model::DocumentInfo::document_descriptor
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DocumentDescriptor {
        /// The [Document][google.cloud.discoveryengine.v1.Document] resource ID.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        Id(std::string::String),
        /// The [Document][google.cloud.discoveryengine.v1.Document] resource full
        /// name, of the form:
        /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/branches/{branch_id}/documents/{document_id}`
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        Name(std::string::String),
        /// The [Document][google.cloud.discoveryengine.v1.Document] URI - only
        /// allowed for website data stores.
        ///
        /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
        Uri(std::string::String),
    }
}

/// Detailed panel information associated with a user event.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PanelInfo {
    /// Required. The panel ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub panel_id: std::string::String,

    /// The display name of the panel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The ordered position of the panel, if shown to the user with other panels.
    /// If set, then
    /// [total_panels][google.cloud.discoveryengine.v1.PanelInfo.total_panels] must
    /// also be set.
    ///
    /// [google.cloud.discoveryengine.v1.PanelInfo.total_panels]: crate::model::PanelInfo::total_panels
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
    pub panel_position: std::option::Option<i32>,

    /// The total number of panels, including this one, shown to the user.
    /// Must be set if
    /// [panel_position][google.cloud.discoveryengine.v1.PanelInfo.panel_position]
    /// is set.
    ///
    /// [google.cloud.discoveryengine.v1.PanelInfo.panel_position]: crate::model::PanelInfo::panel_position
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I32>")]
    pub total_panels: std::option::Option<i32>,

    /// Optional. The document IDs associated with this panel.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub documents: std::vec::Vec<crate::model::DocumentInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PanelInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [panel_id][crate::model::PanelInfo::panel_id].
    pub fn set_panel_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.panel_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PanelInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [panel_position][crate::model::PanelInfo::panel_position].
    pub fn set_panel_position<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.panel_position = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [panel_position][crate::model::PanelInfo::panel_position].
    pub fn set_or_clear_panel_position<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.panel_position = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_panels][crate::model::PanelInfo::total_panels].
    pub fn set_total_panels<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.total_panels = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_panels][crate::model::PanelInfo::total_panels].
    pub fn set_or_clear_total_panels<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.total_panels = v.map(|x| x.into());
        self
    }

    /// Sets the value of [documents][crate::model::PanelInfo::documents].
    pub fn set_documents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DocumentInfo>,
    {
        use std::iter::Iterator;
        self.documents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PanelInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.PanelInfo"
    }
}

/// Media-specific user event information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MediaInfo {
    /// The media progress time in seconds, if applicable.
    /// For example, if the end user has finished 90 seconds of a playback video,
    /// then
    /// [MediaInfo.media_progress_duration.seconds][google.protobuf.Duration.seconds]
    /// should be set to 90.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub media_progress_duration: std::option::Option<wkt::Duration>,

    /// Media progress should be computed using only the
    /// [media_progress_duration][google.cloud.discoveryengine.v1.MediaInfo.media_progress_duration]
    /// relative to the media total length.
    ///
    /// This value must be between `[0, 1.0]` inclusive.
    ///
    /// If this is not a playback or the progress cannot be computed (e.g. ongoing
    /// livestream), this field should be unset.
    ///
    /// [google.cloud.discoveryengine.v1.MediaInfo.media_progress_duration]: crate::model::MediaInfo::media_progress_duration
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub media_progress_percentage: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MediaInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [media_progress_duration][crate::model::MediaInfo::media_progress_duration].
    pub fn set_media_progress_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.media_progress_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [media_progress_duration][crate::model::MediaInfo::media_progress_duration].
    pub fn set_or_clear_media_progress_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.media_progress_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [media_progress_percentage][crate::model::MediaInfo::media_progress_percentage].
    pub fn set_media_progress_percentage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.media_progress_percentage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [media_progress_percentage][crate::model::MediaInfo::media_progress_percentage].
    pub fn set_or_clear_media_progress_percentage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.media_progress_percentage = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MediaInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.MediaInfo"
    }
}

/// Request message for WriteUserEvent method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WriteUserEventRequest {
    /// Required. The parent resource name.
    /// If the write user event action is applied in
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore] level, the format
    /// is:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    /// If the write user event action is applied in
    /// [Location][google.cloud.location.Location] level, for example, the event
    /// with [Document][google.cloud.discoveryengine.v1.Document] across multiple
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], the format is:
    /// `projects/{project}/locations/{location}`.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.location.Location]: location::model::Location
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User event to write.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_event: std::option::Option<crate::model::UserEvent>,

    /// If set to true, the user event is written asynchronously after
    /// validation, and the API responds without waiting for the write.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub write_async: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteUserEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::WriteUserEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_event][crate::model::WriteUserEventRequest::user_event].
    pub fn set_user_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_event][crate::model::WriteUserEventRequest::user_event].
    pub fn set_or_clear_user_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = v.map(|x| x.into());
        self
    }

    /// Sets the value of [write_async][crate::model::WriteUserEventRequest::write_async].
    pub fn set_write_async<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.write_async = v.into();
        self
    }
}

impl wkt::message::Message for WriteUserEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.WriteUserEventRequest"
    }
}

/// Request message for CollectUserEvent method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CollectUserEventRequest {
    /// Required. The parent resource name.
    /// If the collect user event action is applied in
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore] level, the format
    /// is:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    /// If the collect user event action is applied in
    /// [Location][google.cloud.location.Location] level, for example, the event
    /// with [Document][google.cloud.discoveryengine.v1.Document] across multiple
    /// [DataStore][google.cloud.discoveryengine.v1.DataStore], the format is:
    /// `projects/{project}/locations/{location}`.
    ///
    /// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
    /// [google.cloud.discoveryengine.v1.Document]: crate::model::Document
    /// [google.cloud.location.Location]: location::model::Location
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. URL encoded UserEvent proto with a length limit of 2,000,000
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_event: std::string::String,

    /// The URL including cgi-parameters but excluding the hash fragment with a
    /// length limit of 5,000 characters. This is often more useful than the
    /// referer URL, because many browsers only send the domain for third-party
    /// requests.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub uri: std::option::Option<std::string::String>,

    /// The event timestamp in milliseconds. This prevents browser caching of
    /// otherwise identical get requests. The name is abbreviated to reduce the
    /// payload bytes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I64>")]
    pub ets: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CollectUserEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CollectUserEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_event][crate::model::CollectUserEventRequest::user_event].
    pub fn set_user_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_event = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CollectUserEventRequest::uri].
    pub fn set_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [uri][crate::model::CollectUserEventRequest::uri].
    pub fn set_or_clear_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ets][crate::model::CollectUserEventRequest::ets].
    pub fn set_ets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.ets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ets][crate::model::CollectUserEventRequest::ets].
    pub fn set_or_clear_ets<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.ets = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CollectUserEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.discoveryengine.v1.CollectUserEventRequest"
    }
}

/// The industry vertical associated with the
/// [DataStore][google.cloud.discoveryengine.v1.DataStore].
///
/// [google.cloud.discoveryengine.v1.DataStore]: crate::model::DataStore
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IndustryVertical {
    /// Value used when unset.
    Unspecified,
    /// The generic vertical for documents that are not specific to any industry
    /// vertical.
    Generic,
    /// The media industry vertical.
    Media,
    /// The healthcare FHIR vertical.
    HealthcareFhir,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IndustryVertical::value] or
    /// [IndustryVertical::name].
    UnknownValue(industry_vertical::UnknownValue),
}

#[doc(hidden)]
pub mod industry_vertical {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IndustryVertical {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Generic => std::option::Option::Some(1),
            Self::Media => std::option::Option::Some(2),
            Self::HealthcareFhir => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INDUSTRY_VERTICAL_UNSPECIFIED"),
            Self::Generic => std::option::Option::Some("GENERIC"),
            Self::Media => std::option::Option::Some("MEDIA"),
            Self::HealthcareFhir => std::option::Option::Some("HEALTHCARE_FHIR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IndustryVertical {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IndustryVertical {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IndustryVertical {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Generic,
            2 => Self::Media,
            7 => Self::HealthcareFhir,
            _ => Self::UnknownValue(industry_vertical::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IndustryVertical {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INDUSTRY_VERTICAL_UNSPECIFIED" => Self::Unspecified,
            "GENERIC" => Self::Generic,
            "MEDIA" => Self::Media,
            "HEALTHCARE_FHIR" => Self::HealthcareFhir,
            _ => Self::UnknownValue(industry_vertical::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IndustryVertical {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Generic => serializer.serialize_i32(1),
            Self::Media => serializer.serialize_i32(2),
            Self::HealthcareFhir => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IndustryVertical {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndustryVertical>::new(
            ".google.cloud.discoveryengine.v1.IndustryVertical",
        ))
    }
}

/// The type of solution.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SolutionType {
    /// Default value.
    Unspecified,
    /// Used for Recommendations AI.
    Recommendation,
    /// Used for Discovery Search.
    Search,
    /// Used for use cases related to the Generative AI agent.
    Chat,
    /// Used for use cases related to the Generative Chat agent.
    /// It's used for Generative chat engine only, the associated data stores
    /// must enrolled with `SOLUTION_TYPE_CHAT` solution.
    GenerativeChat,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SolutionType::value] or
    /// [SolutionType::name].
    UnknownValue(solution_type::UnknownValue),
}

#[doc(hidden)]
pub mod solution_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SolutionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Recommendation => std::option::Option::Some(1),
            Self::Search => std::option::Option::Some(2),
            Self::Chat => std::option::Option::Some(3),
            Self::GenerativeChat => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SOLUTION_TYPE_UNSPECIFIED"),
            Self::Recommendation => std::option::Option::Some("SOLUTION_TYPE_RECOMMENDATION"),
            Self::Search => std::option::Option::Some("SOLUTION_TYPE_SEARCH"),
            Self::Chat => std::option::Option::Some("SOLUTION_TYPE_CHAT"),
            Self::GenerativeChat => std::option::Option::Some("SOLUTION_TYPE_GENERATIVE_CHAT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SolutionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SolutionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SolutionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Recommendation,
            2 => Self::Search,
            3 => Self::Chat,
            4 => Self::GenerativeChat,
            _ => Self::UnknownValue(solution_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SolutionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SOLUTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SOLUTION_TYPE_RECOMMENDATION" => Self::Recommendation,
            "SOLUTION_TYPE_SEARCH" => Self::Search,
            "SOLUTION_TYPE_CHAT" => Self::Chat,
            "SOLUTION_TYPE_GENERATIVE_CHAT" => Self::GenerativeChat,
            _ => Self::UnknownValue(solution_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SolutionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Recommendation => serializer.serialize_i32(1),
            Self::Search => serializer.serialize_i32(2),
            Self::Chat => serializer.serialize_i32(3),
            Self::GenerativeChat => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SolutionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SolutionType>::new(
            ".google.cloud.discoveryengine.v1.SolutionType",
        ))
    }
}

/// Defines a further subdivision of `SolutionType`.
/// Specifically applies to
/// [SOLUTION_TYPE_SEARCH][google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH].
///
/// [google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SearchUseCase {
    /// Value used when unset. Will not occur in CSS.
    Unspecified,
    /// Search use case. Expects the traffic has a non-empty
    /// [query][google.cloud.discoveryengine.v1.SearchRequest.query].
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.query]: crate::model::SearchRequest::query
    Search,
    /// Browse use case. Expects the traffic has an empty
    /// [query][google.cloud.discoveryengine.v1.SearchRequest.query].
    ///
    /// [google.cloud.discoveryengine.v1.SearchRequest.query]: crate::model::SearchRequest::query
    Browse,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SearchUseCase::value] or
    /// [SearchUseCase::name].
    UnknownValue(search_use_case::UnknownValue),
}

#[doc(hidden)]
pub mod search_use_case {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SearchUseCase {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Search => std::option::Option::Some(1),
            Self::Browse => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEARCH_USE_CASE_UNSPECIFIED"),
            Self::Search => std::option::Option::Some("SEARCH_USE_CASE_SEARCH"),
            Self::Browse => std::option::Option::Some("SEARCH_USE_CASE_BROWSE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SearchUseCase {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SearchUseCase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SearchUseCase {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Search,
            2 => Self::Browse,
            _ => Self::UnknownValue(search_use_case::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SearchUseCase {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEARCH_USE_CASE_UNSPECIFIED" => Self::Unspecified,
            "SEARCH_USE_CASE_SEARCH" => Self::Search,
            "SEARCH_USE_CASE_BROWSE" => Self::Browse,
            _ => Self::UnknownValue(search_use_case::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SearchUseCase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Search => serializer.serialize_i32(1),
            Self::Browse => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SearchUseCase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchUseCase>::new(
            ".google.cloud.discoveryengine.v1.SearchUseCase",
        ))
    }
}

/// Tiers of search features. Different tiers might have different
/// pricing. To learn more, check the pricing documentation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SearchTier {
    /// Default value when the enum is unspecified. This is invalid to use.
    Unspecified,
    /// Standard tier.
    Standard,
    /// Enterprise tier.
    Enterprise,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SearchTier::value] or
    /// [SearchTier::name].
    UnknownValue(search_tier::UnknownValue),
}

#[doc(hidden)]
pub mod search_tier {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SearchTier {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Enterprise => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEARCH_TIER_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("SEARCH_TIER_STANDARD"),
            Self::Enterprise => std::option::Option::Some("SEARCH_TIER_ENTERPRISE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SearchTier {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SearchTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SearchTier {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Enterprise,
            _ => Self::UnknownValue(search_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SearchTier {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEARCH_TIER_UNSPECIFIED" => Self::Unspecified,
            "SEARCH_TIER_STANDARD" => Self::Standard,
            "SEARCH_TIER_ENTERPRISE" => Self::Enterprise,
            _ => Self::UnknownValue(search_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SearchTier {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Enterprise => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SearchTier {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchTier>::new(
            ".google.cloud.discoveryengine.v1.SearchTier",
        ))
    }
}

/// Add-on that provides additional functionality for search.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SearchAddOn {
    /// Default value when the enum is unspecified. This is invalid to use.
    Unspecified,
    /// Large language model add-on.
    Llm,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SearchAddOn::value] or
    /// [SearchAddOn::name].
    UnknownValue(search_add_on::UnknownValue),
}

#[doc(hidden)]
pub mod search_add_on {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SearchAddOn {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Llm => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEARCH_ADD_ON_UNSPECIFIED"),
            Self::Llm => std::option::Option::Some("SEARCH_ADD_ON_LLM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SearchAddOn {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SearchAddOn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SearchAddOn {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Llm,
            _ => Self::UnknownValue(search_add_on::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SearchAddOn {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEARCH_ADD_ON_UNSPECIFIED" => Self::Unspecified,
            "SEARCH_ADD_ON_LLM" => Self::Llm,
            _ => Self::UnknownValue(search_add_on::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SearchAddOn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Llm => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SearchAddOn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchAddOn>::new(
            ".google.cloud.discoveryengine.v1.SearchAddOn",
        ))
    }
}

/// Harm categories that will block the content.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum HarmCategory {
    /// The harm category is unspecified.
    Unspecified,
    /// The harm category is hate speech.
    HateSpeech,
    /// The harm category is dangerous content.
    DangerousContent,
    /// The harm category is harassment.
    Harassment,
    /// The harm category is sexually explicit content.
    SexuallyExplicit,
    /// The harm category is civic integrity.
    CivicIntegrity,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [HarmCategory::value] or
    /// [HarmCategory::name].
    UnknownValue(harm_category::UnknownValue),
}

#[doc(hidden)]
pub mod harm_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl HarmCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::HateSpeech => std::option::Option::Some(1),
            Self::DangerousContent => std::option::Option::Some(2),
            Self::Harassment => std::option::Option::Some(3),
            Self::SexuallyExplicit => std::option::Option::Some(4),
            Self::CivicIntegrity => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("HARM_CATEGORY_UNSPECIFIED"),
            Self::HateSpeech => std::option::Option::Some("HARM_CATEGORY_HATE_SPEECH"),
            Self::DangerousContent => std::option::Option::Some("HARM_CATEGORY_DANGEROUS_CONTENT"),
            Self::Harassment => std::option::Option::Some("HARM_CATEGORY_HARASSMENT"),
            Self::SexuallyExplicit => std::option::Option::Some("HARM_CATEGORY_SEXUALLY_EXPLICIT"),
            Self::CivicIntegrity => std::option::Option::Some("HARM_CATEGORY_CIVIC_INTEGRITY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for HarmCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for HarmCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for HarmCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::HateSpeech,
            2 => Self::DangerousContent,
            3 => Self::Harassment,
            4 => Self::SexuallyExplicit,
            5 => Self::CivicIntegrity,
            _ => Self::UnknownValue(harm_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for HarmCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "HARM_CATEGORY_UNSPECIFIED" => Self::Unspecified,
            "HARM_CATEGORY_HATE_SPEECH" => Self::HateSpeech,
            "HARM_CATEGORY_DANGEROUS_CONTENT" => Self::DangerousContent,
            "HARM_CATEGORY_HARASSMENT" => Self::Harassment,
            "HARM_CATEGORY_SEXUALLY_EXPLICIT" => Self::SexuallyExplicit,
            "HARM_CATEGORY_CIVIC_INTEGRITY" => Self::CivicIntegrity,
            _ => Self::UnknownValue(harm_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for HarmCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::HateSpeech => serializer.serialize_i32(1),
            Self::DangerousContent => serializer.serialize_i32(2),
            Self::Harassment => serializer.serialize_i32(3),
            Self::SexuallyExplicit => serializer.serialize_i32(4),
            Self::CivicIntegrity => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for HarmCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<HarmCategory>::new(
            ".google.cloud.discoveryengine.v1.HarmCategory",
        ))
    }
}
