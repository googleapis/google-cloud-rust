// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(feature = "assistant-service",feature = "cmek-config-service",feature = "completion-service",feature = "control-service",feature = "conversational-search-service",feature = "data-store-service",feature = "document-service",feature = "engine-service",feature = "grounded-generation-service",feature = "identity-mapping-store-service",feature = "project-service",feature = "rank-service",feature = "recommendation-service",feature = "schema-service",feature = "search-service",feature = "search-tuning-service",feature = "serving-config-service",feature = "session-service",feature = "site-search-engine-service",feature = "user-event-service",feature = "user-license-service",))]
use crate::Result;

/// Implements a [AssistantService](super::stub::AssistantService) decorator for logging and tracing.
#[cfg(feature = "assistant-service")]
#[derive(Clone, Debug)]
pub struct AssistantService<T>
where T: super::stub::AssistantService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "assistant-service")]
impl<T> AssistantService<T>
where T: super::stub::AssistantService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "assistant-service")]
impl<T> super::stub::AssistantService for AssistantService<T>
where T: super::stub::AssistantService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AssistantService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AssistantService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AssistantService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [CmekConfigService](super::stub::CmekConfigService) decorator for logging and tracing.
#[cfg(feature = "cmek-config-service")]
#[derive(Clone, Debug)]
pub struct CmekConfigService<T>
where T: super::stub::CmekConfigService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "cmek-config-service")]
impl<T> CmekConfigService<T>
where T: super::stub::CmekConfigService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "cmek-config-service")]
impl<T> super::stub::CmekConfigService for CmekConfigService<T>
where T: super::stub::CmekConfigService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_cmek_config(
        &self,
        req: crate::model::UpdateCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CmekConfigService",
            "::update_cmek_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_cmek_config",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_cmek_config(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_cmek_config(
        &self,
        req: crate::model::UpdateCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_cmek_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_cmek_config(
        &self,
        req: crate::model::GetCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CmekConfig>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CmekConfigService",
            "::get_cmek_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_cmek_config",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_cmek_config(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_cmek_config(
        &self,
        req: crate::model::GetCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CmekConfig>> {
        self.inner.get_cmek_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_cmek_configs(
        &self,
        req: crate::model::ListCmekConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCmekConfigsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CmekConfigService",
            "::list_cmek_configs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_cmek_configs",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_cmek_configs(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_cmek_configs(
        &self,
        req: crate::model::ListCmekConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCmekConfigsResponse>> {
        self.inner.list_cmek_configs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_cmek_config(
        &self,
        req: crate::model::DeleteCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CmekConfigService",
            "::delete_cmek_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_cmek_config",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_cmek_config(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_cmek_config(
        &self,
        req: crate::model::DeleteCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_cmek_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CmekConfigService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CmekConfigService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CmekConfigService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [CompletionService](super::stub::CompletionService) decorator for logging and tracing.
#[cfg(feature = "completion-service")]
#[derive(Clone, Debug)]
pub struct CompletionService<T>
where T: super::stub::CompletionService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "completion-service")]
impl<T> CompletionService<T>
where T: super::stub::CompletionService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "completion-service")]
impl<T> super::stub::CompletionService for CompletionService<T>
where T: super::stub::CompletionService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn complete_query(
        &self,
        req: crate::model::CompleteQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompleteQueryResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::complete_query"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "complete_query",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.complete_query(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn complete_query(
        &self,
        req: crate::model::CompleteQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompleteQueryResponse>> {
        self.inner.complete_query(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_suggestion_deny_list_entries(
        &self,
        req: crate::model::ImportSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::import_suggestion_deny_list_entries"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_suggestion_deny_list_entries",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.import_suggestion_deny_list_entries(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_suggestion_deny_list_entries(
        &self,
        req: crate::model::ImportSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_suggestion_deny_list_entries(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_suggestion_deny_list_entries(
        &self,
        req: crate::model::PurgeSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::purge_suggestion_deny_list_entries"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_suggestion_deny_list_entries",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.purge_suggestion_deny_list_entries(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_suggestion_deny_list_entries(
        &self,
        req: crate::model::PurgeSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_suggestion_deny_list_entries(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_completion_suggestions(
        &self,
        req: crate::model::ImportCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::import_completion_suggestions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_completion_suggestions",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.import_completion_suggestions(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_completion_suggestions(
        &self,
        req: crate::model::ImportCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_completion_suggestions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_completion_suggestions(
        &self,
        req: crate::model::PurgeCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::purge_completion_suggestions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_completion_suggestions",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.purge_completion_suggestions(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_completion_suggestions(
        &self,
        req: crate::model::PurgeCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_completion_suggestions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "CompletionService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ControlService](super::stub::ControlService) decorator for logging and tracing.
#[cfg(feature = "control-service")]
#[derive(Clone, Debug)]
pub struct ControlService<T>
where T: super::stub::ControlService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "control-service")]
impl<T> ControlService<T>
where T: super::stub::ControlService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "control-service")]
impl<T> super::stub::ControlService for ControlService<T>
where T: super::stub::ControlService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_control(
        &self,
        req: crate::model::CreateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::create_control"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_control",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_control(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_control(
        &self,
        req: crate::model::CreateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        self.inner.create_control(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_control(
        &self,
        req: crate::model::DeleteControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::delete_control"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_control",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_control(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_control(
        &self,
        req: crate::model::DeleteControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_control(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_control(
        &self,
        req: crate::model::UpdateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::update_control"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_control",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_control(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_control(
        &self,
        req: crate::model::UpdateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        self.inner.update_control(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_control(
        &self,
        req: crate::model::GetControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::get_control"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_control",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_control(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_control(
        &self,
        req: crate::model::GetControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        self.inner.get_control(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_controls(
        &self,
        req: crate::model::ListControlsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListControlsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::list_controls"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_controls",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_controls(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_controls(
        &self,
        req: crate::model::ListControlsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListControlsResponse>> {
        self.inner.list_controls(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ControlService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [ConversationalSearchService](super::stub::ConversationalSearchService) decorator for logging and tracing.
#[cfg(feature = "conversational-search-service")]
#[derive(Clone, Debug)]
pub struct ConversationalSearchService<T>
where T: super::stub::ConversationalSearchService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "conversational-search-service")]
impl<T> ConversationalSearchService<T>
where T: super::stub::ConversationalSearchService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "conversational-search-service")]
impl<T> super::stub::ConversationalSearchService for ConversationalSearchService<T>
where T: super::stub::ConversationalSearchService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn converse_conversation(
        &self,
        req: crate::model::ConverseConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConverseConversationResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::converse_conversation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "converse_conversation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.converse_conversation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn converse_conversation(
        &self,
        req: crate::model::ConverseConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConverseConversationResponse>> {
        self.inner.converse_conversation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_conversation(
        &self,
        req: crate::model::CreateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::create_conversation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_conversation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_conversation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_conversation(
        &self,
        req: crate::model::CreateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.create_conversation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_conversation(
        &self,
        req: crate::model::DeleteConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::delete_conversation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_conversation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_conversation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_conversation(
        &self,
        req: crate::model::DeleteConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_conversation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_conversation(
        &self,
        req: crate::model::UpdateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::update_conversation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_conversation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_conversation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_conversation(
        &self,
        req: crate::model::UpdateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.update_conversation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_conversation(
        &self,
        req: crate::model::GetConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::get_conversation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_conversation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_conversation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_conversation(
        &self,
        req: crate::model::GetConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.get_conversation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_conversations(
        &self,
        req: crate::model::ListConversationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::list_conversations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_conversations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_conversations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_conversations(
        &self,
        req: crate::model::ListConversationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationsResponse>> {
        self.inner.list_conversations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn answer_query(
        &self,
        req: crate::model::AnswerQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnswerQueryResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::answer_query"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "answer_query",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.answer_query(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn answer_query(
        &self,
        req: crate::model::AnswerQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnswerQueryResponse>> {
        self.inner.answer_query(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_answer(
        &self,
        req: crate::model::GetAnswerRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Answer>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::get_answer"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_answer",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_answer(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_answer(
        &self,
        req: crate::model::GetAnswerRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Answer>> {
        self.inner.get_answer(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::create_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.create_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::delete_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_session(
        &self,
        req: crate::model::UpdateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::update_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_session(
        &self,
        req: crate::model::UpdateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.update_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::get_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.get_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::list_sessions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_sessions",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_sessions(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        self.inner.list_sessions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ConversationalSearchService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [DataStoreService](super::stub::DataStoreService) decorator for logging and tracing.
#[cfg(feature = "data-store-service")]
#[derive(Clone, Debug)]
pub struct DataStoreService<T>
where T: super::stub::DataStoreService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "data-store-service")]
impl<T> DataStoreService<T>
where T: super::stub::DataStoreService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "data-store-service")]
impl<T> super::stub::DataStoreService for DataStoreService<T>
where T: super::stub::DataStoreService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_data_store(
        &self,
        req: crate::model::CreateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::create_data_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_data_store",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_data_store(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_data_store(
        &self,
        req: crate::model::CreateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_data_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_data_store(
        &self,
        req: crate::model::GetDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataStore>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::get_data_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_data_store",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_data_store(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_data_store(
        &self,
        req: crate::model::GetDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataStore>> {
        self.inner.get_data_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_data_stores(
        &self,
        req: crate::model::ListDataStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataStoresResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::list_data_stores"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_data_stores",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_data_stores(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_data_stores(
        &self,
        req: crate::model::ListDataStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataStoresResponse>> {
        self.inner.list_data_stores(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_data_store(
        &self,
        req: crate::model::DeleteDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::delete_data_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_data_store",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_data_store(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_data_store(
        &self,
        req: crate::model::DeleteDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_data_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_data_store(
        &self,
        req: crate::model::UpdateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataStore>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::update_data_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_data_store",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_data_store(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_data_store(
        &self,
        req: crate::model::UpdateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataStore>> {
        self.inner.update_data_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DataStoreService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [DocumentService](super::stub::DocumentService) decorator for logging and tracing.
#[cfg(feature = "document-service")]
#[derive(Clone, Debug)]
pub struct DocumentService<T>
where T: super::stub::DocumentService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "document-service")]
impl<T> DocumentService<T>
where T: super::stub::DocumentService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "document-service")]
impl<T> super::stub::DocumentService for DocumentService<T>
where T: super::stub::DocumentService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_document(
        &self,
        req: crate::model::GetDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::get_document"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_document",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_document(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_document(
        &self,
        req: crate::model::GetDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        self.inner.get_document(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_documents(
        &self,
        req: crate::model::ListDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDocumentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::list_documents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_documents",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_documents(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_documents(
        &self,
        req: crate::model::ListDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDocumentsResponse>> {
        self.inner.list_documents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_document(
        &self,
        req: crate::model::CreateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::create_document"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_document",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_document(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_document(
        &self,
        req: crate::model::CreateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        self.inner.create_document(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_document(
        &self,
        req: crate::model::UpdateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::update_document"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_document",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_document(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_document(
        &self,
        req: crate::model::UpdateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        self.inner.update_document(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_document(
        &self,
        req: crate::model::DeleteDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::delete_document"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_document",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_document(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_document(
        &self,
        req: crate::model::DeleteDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_document(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_documents(
        &self,
        req: crate::model::ImportDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::import_documents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_documents",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.import_documents(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_documents(
        &self,
        req: crate::model::ImportDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_documents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_documents(
        &self,
        req: crate::model::PurgeDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::purge_documents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_documents",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.purge_documents(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_documents(
        &self,
        req: crate::model::PurgeDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_documents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_get_documents_metadata(
        &self,
        req: crate::model::BatchGetDocumentsMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchGetDocumentsMetadataResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::batch_get_documents_metadata"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_get_documents_metadata",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.batch_get_documents_metadata(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_get_documents_metadata(
        &self,
        req: crate::model::BatchGetDocumentsMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchGetDocumentsMetadataResponse>> {
        self.inner.batch_get_documents_metadata(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "DocumentService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EngineService](super::stub::EngineService) decorator for logging and tracing.
#[cfg(feature = "engine-service")]
#[derive(Clone, Debug)]
pub struct EngineService<T>
where T: super::stub::EngineService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "engine-service")]
impl<T> EngineService<T>
where T: super::stub::EngineService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "engine-service")]
impl<T> super::stub::EngineService for EngineService<T>
where T: super::stub::EngineService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_engine(
        &self,
        req: crate::model::CreateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::create_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_engine",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_engine(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_engine(
        &self,
        req: crate::model::CreateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_engine(
        &self,
        req: crate::model::DeleteEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::delete_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_engine",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_engine(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_engine(
        &self,
        req: crate::model::DeleteEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_engine(
        &self,
        req: crate::model::UpdateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Engine>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::update_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_engine",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_engine(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_engine(
        &self,
        req: crate::model::UpdateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Engine>> {
        self.inner.update_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_engine(
        &self,
        req: crate::model::GetEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Engine>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::get_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_engine",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_engine(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_engine(
        &self,
        req: crate::model::GetEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Engine>> {
        self.inner.get_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_engines(
        &self,
        req: crate::model::ListEnginesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnginesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::list_engines"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_engines",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_engines(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_engines(
        &self,
        req: crate::model::ListEnginesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnginesResponse>> {
        self.inner.list_engines(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EngineService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GroundedGenerationService](super::stub::GroundedGenerationService) decorator for logging and tracing.
#[cfg(feature = "grounded-generation-service")]
#[derive(Clone, Debug)]
pub struct GroundedGenerationService<T>
where T: super::stub::GroundedGenerationService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "grounded-generation-service")]
impl<T> GroundedGenerationService<T>
where T: super::stub::GroundedGenerationService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "grounded-generation-service")]
impl<T> super::stub::GroundedGenerationService for GroundedGenerationService<T>
where T: super::stub::GroundedGenerationService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn generate_grounded_content(
        &self,
        req: crate::model::GenerateGroundedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateGroundedContentResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GroundedGenerationService",
            "::generate_grounded_content"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "generate_grounded_content",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.generate_grounded_content(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn generate_grounded_content(
        &self,
        req: crate::model::GenerateGroundedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateGroundedContentResponse>> {
        self.inner.generate_grounded_content(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn check_grounding(
        &self,
        req: crate::model::CheckGroundingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckGroundingResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GroundedGenerationService",
            "::check_grounding"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "check_grounding",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.check_grounding(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn check_grounding(
        &self,
        req: crate::model::CheckGroundingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckGroundingResponse>> {
        self.inner.check_grounding(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GroundedGenerationService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GroundedGenerationService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "GroundedGenerationService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [IdentityMappingStoreService](super::stub::IdentityMappingStoreService) decorator for logging and tracing.
#[cfg(feature = "identity-mapping-store-service")]
#[derive(Clone, Debug)]
pub struct IdentityMappingStoreService<T>
where T: super::stub::IdentityMappingStoreService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "identity-mapping-store-service")]
impl<T> IdentityMappingStoreService<T>
where T: super::stub::IdentityMappingStoreService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "identity-mapping-store-service")]
impl<T> super::stub::IdentityMappingStoreService for IdentityMappingStoreService<T>
where T: super::stub::IdentityMappingStoreService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_identity_mapping_store(
        &self,
        req: crate::model::CreateIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IdentityMappingStore>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::create_identity_mapping_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_identity_mapping_store",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_identity_mapping_store(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_identity_mapping_store(
        &self,
        req: crate::model::CreateIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IdentityMappingStore>> {
        self.inner.create_identity_mapping_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_identity_mapping_store(
        &self,
        req: crate::model::GetIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IdentityMappingStore>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::get_identity_mapping_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_identity_mapping_store",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_identity_mapping_store(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_identity_mapping_store(
        &self,
        req: crate::model::GetIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IdentityMappingStore>> {
        self.inner.get_identity_mapping_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_identity_mapping_store(
        &self,
        req: crate::model::DeleteIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::delete_identity_mapping_store"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_identity_mapping_store",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_identity_mapping_store(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_identity_mapping_store(
        &self,
        req: crate::model::DeleteIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_identity_mapping_store(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_identity_mappings(
        &self,
        req: crate::model::ImportIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::import_identity_mappings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_identity_mappings",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.import_identity_mappings(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_identity_mappings(
        &self,
        req: crate::model::ImportIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_identity_mappings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_identity_mappings(
        &self,
        req: crate::model::PurgeIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::purge_identity_mappings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_identity_mappings",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.purge_identity_mappings(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_identity_mappings(
        &self,
        req: crate::model::PurgeIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_identity_mappings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_identity_mappings(
        &self,
        req: crate::model::ListIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIdentityMappingsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::list_identity_mappings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_identity_mappings",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_identity_mappings(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_identity_mappings(
        &self,
        req: crate::model::ListIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIdentityMappingsResponse>> {
        self.inner.list_identity_mappings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_identity_mapping_stores(
        &self,
        req: crate::model::ListIdentityMappingStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIdentityMappingStoresResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::list_identity_mapping_stores"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_identity_mapping_stores",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_identity_mapping_stores(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_identity_mapping_stores(
        &self,
        req: crate::model::ListIdentityMappingStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIdentityMappingStoresResponse>> {
        self.inner.list_identity_mapping_stores(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "IdentityMappingStoreService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ProjectService](super::stub::ProjectService) decorator for logging and tracing.
#[cfg(feature = "project-service")]
#[derive(Clone, Debug)]
pub struct ProjectService<T>
where T: super::stub::ProjectService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "project-service")]
impl<T> ProjectService<T>
where T: super::stub::ProjectService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "project-service")]
impl<T> super::stub::ProjectService for ProjectService<T>
where T: super::stub::ProjectService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn provision_project(
        &self,
        req: crate::model::ProvisionProjectRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ProjectService",
            "::provision_project"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "provision_project",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.provision_project(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn provision_project(
        &self,
        req: crate::model::ProvisionProjectRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.provision_project(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ProjectService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ProjectService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ProjectService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RankService](super::stub::RankService) decorator for logging and tracing.
#[cfg(feature = "rank-service")]
#[derive(Clone, Debug)]
pub struct RankService<T>
where T: super::stub::RankService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "rank-service")]
impl<T> RankService<T>
where T: super::stub::RankService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "rank-service")]
impl<T> super::stub::RankService for RankService<T>
where T: super::stub::RankService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn rank(
        &self,
        req: crate::model::RankRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RankResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RankService",
            "::rank"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "rank",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.rank(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn rank(
        &self,
        req: crate::model::RankRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RankResponse>> {
        self.inner.rank(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RankService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RankService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RankService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [RecommendationService](super::stub::RecommendationService) decorator for logging and tracing.
#[cfg(feature = "recommendation-service")]
#[derive(Clone, Debug)]
pub struct RecommendationService<T>
where T: super::stub::RecommendationService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "recommendation-service")]
impl<T> RecommendationService<T>
where T: super::stub::RecommendationService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "recommendation-service")]
impl<T> super::stub::RecommendationService for RecommendationService<T>
where T: super::stub::RecommendationService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn recommend(
        &self,
        req: crate::model::RecommendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RecommendResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RecommendationService",
            "::recommend"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "recommend",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.recommend(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn recommend(
        &self,
        req: crate::model::RecommendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RecommendResponse>> {
        self.inner.recommend(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RecommendationService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RecommendationService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "RecommendationService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SchemaService](super::stub::SchemaService) decorator for logging and tracing.
#[cfg(feature = "schema-service")]
#[derive(Clone, Debug)]
pub struct SchemaService<T>
where T: super::stub::SchemaService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "schema-service")]
impl<T> SchemaService<T>
where T: super::stub::SchemaService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "schema-service")]
impl<T> super::stub::SchemaService for SchemaService<T>
where T: super::stub::SchemaService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_schema(
        &self,
        req: crate::model::GetSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schema>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::get_schema"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_schema",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_schema(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_schema(
        &self,
        req: crate::model::GetSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schema>> {
        self.inner.get_schema(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_schemas(
        &self,
        req: crate::model::ListSchemasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchemasResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::list_schemas"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_schemas",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_schemas(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_schemas(
        &self,
        req: crate::model::ListSchemasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchemasResponse>> {
        self.inner.list_schemas(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_schema(
        &self,
        req: crate::model::CreateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::create_schema"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_schema",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_schema(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_schema(
        &self,
        req: crate::model::CreateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_schema(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_schema(
        &self,
        req: crate::model::UpdateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::update_schema"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_schema",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_schema(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_schema(
        &self,
        req: crate::model::UpdateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_schema(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_schema(
        &self,
        req: crate::model::DeleteSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::delete_schema"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_schema",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_schema(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_schema(
        &self,
        req: crate::model::DeleteSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_schema(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SchemaService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SearchService](super::stub::SearchService) decorator for logging and tracing.
#[cfg(feature = "search-service")]
#[derive(Clone, Debug)]
pub struct SearchService<T>
where T: super::stub::SearchService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "search-service")]
impl<T> SearchService<T>
where T: super::stub::SearchService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "search-service")]
impl<T> super::stub::SearchService for SearchService<T>
where T: super::stub::SearchService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn search(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchService",
            "::search"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.search(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchResponse>> {
        self.inner.search(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn search_lite(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchService",
            "::search_lite"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "search_lite",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.search_lite(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn search_lite(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchResponse>> {
        self.inner.search_lite(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SearchTuningService](super::stub::SearchTuningService) decorator for logging and tracing.
#[cfg(feature = "search-tuning-service")]
#[derive(Clone, Debug)]
pub struct SearchTuningService<T>
where T: super::stub::SearchTuningService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "search-tuning-service")]
impl<T> SearchTuningService<T>
where T: super::stub::SearchTuningService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "search-tuning-service")]
impl<T> super::stub::SearchTuningService for SearchTuningService<T>
where T: super::stub::SearchTuningService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn train_custom_model(
        &self,
        req: crate::model::TrainCustomModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchTuningService",
            "::train_custom_model"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "train_custom_model",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.train_custom_model(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn train_custom_model(
        &self,
        req: crate::model::TrainCustomModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.train_custom_model(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_custom_models(
        &self,
        req: crate::model::ListCustomModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCustomModelsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchTuningService",
            "::list_custom_models"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_custom_models",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_custom_models(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_custom_models(
        &self,
        req: crate::model::ListCustomModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCustomModelsResponse>> {
        self.inner.list_custom_models(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchTuningService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchTuningService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SearchTuningService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ServingConfigService](super::stub::ServingConfigService) decorator for logging and tracing.
#[cfg(feature = "serving-config-service")]
#[derive(Clone, Debug)]
pub struct ServingConfigService<T>
where T: super::stub::ServingConfigService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "serving-config-service")]
impl<T> ServingConfigService<T>
where T: super::stub::ServingConfigService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "serving-config-service")]
impl<T> super::stub::ServingConfigService for ServingConfigService<T>
where T: super::stub::ServingConfigService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_serving_config(
        &self,
        req: crate::model::UpdateServingConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ServingConfigService",
            "::update_serving_config"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_serving_config",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_serving_config(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_serving_config(
        &self,
        req: crate::model::UpdateServingConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        self.inner.update_serving_config(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ServingConfigService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ServingConfigService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ServingConfigService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SessionService](super::stub::SessionService) decorator for logging and tracing.
#[cfg(feature = "session-service")]
#[derive(Clone, Debug)]
pub struct SessionService<T>
where T: super::stub::SessionService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "session-service")]
impl<T> SessionService<T>
where T: super::stub::SessionService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "session-service")]
impl<T> super::stub::SessionService for SessionService<T>
where T: super::stub::SessionService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::create_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.create_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::delete_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_session(
        &self,
        req: crate::model::UpdateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::update_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_session(
        &self,
        req: crate::model::UpdateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.update_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::get_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_session",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_session(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.get_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::list_sessions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_sessions",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_sessions(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        self.inner.list_sessions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SiteSearchEngineService](super::stub::SiteSearchEngineService) decorator for logging and tracing.
#[cfg(feature = "site-search-engine-service")]
#[derive(Clone, Debug)]
pub struct SiteSearchEngineService<T>
where T: super::stub::SiteSearchEngineService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "site-search-engine-service")]
impl<T> SiteSearchEngineService<T>
where T: super::stub::SiteSearchEngineService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "site-search-engine-service")]
impl<T> super::stub::SiteSearchEngineService for SiteSearchEngineService<T>
where T: super::stub::SiteSearchEngineService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_site_search_engine(
        &self,
        req: crate::model::GetSiteSearchEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SiteSearchEngine>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::get_site_search_engine"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_site_search_engine",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_site_search_engine(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_site_search_engine(
        &self,
        req: crate::model::GetSiteSearchEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SiteSearchEngine>> {
        self.inner.get_site_search_engine(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_target_site(
        &self,
        req: crate::model::CreateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::create_target_site"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_target_site",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_target_site(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_target_site(
        &self,
        req: crate::model::CreateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_target_site(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_create_target_sites(
        &self,
        req: crate::model::BatchCreateTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::batch_create_target_sites"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_create_target_sites",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.batch_create_target_sites(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_create_target_sites(
        &self,
        req: crate::model::BatchCreateTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_create_target_sites(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_target_site(
        &self,
        req: crate::model::GetTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetSite>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::get_target_site"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_target_site",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_target_site(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_target_site(
        &self,
        req: crate::model::GetTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetSite>> {
        self.inner.get_target_site(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_target_site(
        &self,
        req: crate::model::UpdateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::update_target_site"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_target_site",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.update_target_site(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_target_site(
        &self,
        req: crate::model::UpdateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_target_site(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_target_site(
        &self,
        req: crate::model::DeleteTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::delete_target_site"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_target_site",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_target_site(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_target_site(
        &self,
        req: crate::model::DeleteTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_target_site(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_target_sites(
        &self,
        req: crate::model::ListTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTargetSitesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::list_target_sites"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_target_sites",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_target_sites(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_target_sites(
        &self,
        req: crate::model::ListTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTargetSitesResponse>> {
        self.inner.list_target_sites(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_sitemap(
        &self,
        req: crate::model::CreateSitemapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::create_sitemap"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_sitemap",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.create_sitemap(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_sitemap(
        &self,
        req: crate::model::CreateSitemapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_sitemap(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_sitemap(
        &self,
        req: crate::model::DeleteSitemapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::delete_sitemap"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_sitemap",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.delete_sitemap(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_sitemap(
        &self,
        req: crate::model::DeleteSitemapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_sitemap(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn fetch_sitemaps(
        &self,
        req: crate::model::FetchSitemapsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchSitemapsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::fetch_sitemaps"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "fetch_sitemaps",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.fetch_sitemaps(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn fetch_sitemaps(
        &self,
        req: crate::model::FetchSitemapsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchSitemapsResponse>> {
        self.inner.fetch_sitemaps(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn enable_advanced_site_search(
        &self,
        req: crate::model::EnableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::enable_advanced_site_search"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "enable_advanced_site_search",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.enable_advanced_site_search(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn enable_advanced_site_search(
        &self,
        req: crate::model::EnableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.enable_advanced_site_search(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn disable_advanced_site_search(
        &self,
        req: crate::model::DisableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::disable_advanced_site_search"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "disable_advanced_site_search",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.disable_advanced_site_search(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn disable_advanced_site_search(
        &self,
        req: crate::model::DisableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.disable_advanced_site_search(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn recrawl_uris(
        &self,
        req: crate::model::RecrawlUrisRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::recrawl_uris"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "recrawl_uris",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.recrawl_uris(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn recrawl_uris(
        &self,
        req: crate::model::RecrawlUrisRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.recrawl_uris(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_verify_target_sites(
        &self,
        req: crate::model::BatchVerifyTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::batch_verify_target_sites"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_verify_target_sites",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.batch_verify_target_sites(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_verify_target_sites(
        &self,
        req: crate::model::BatchVerifyTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_verify_target_sites(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn fetch_domain_verification_status(
        &self,
        req: crate::model::FetchDomainVerificationStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchDomainVerificationStatusResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::fetch_domain_verification_status"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "fetch_domain_verification_status",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.fetch_domain_verification_status(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn fetch_domain_verification_status(
        &self,
        req: crate::model::FetchDomainVerificationStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchDomainVerificationStatusResponse>> {
        self.inner.fetch_domain_verification_status(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SiteSearchEngineService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [UserEventService](super::stub::UserEventService) decorator for logging and tracing.
#[cfg(feature = "user-event-service")]
#[derive(Clone, Debug)]
pub struct UserEventService<T>
where T: super::stub::UserEventService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "user-event-service")]
impl<T> UserEventService<T>
where T: super::stub::UserEventService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "user-event-service")]
impl<T> super::stub::UserEventService for UserEventService<T>
where T: super::stub::UserEventService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn write_user_event(
        &self,
        req: crate::model::WriteUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UserEvent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserEventService",
            "::write_user_event"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "write_user_event",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.write_user_event(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn write_user_event(
        &self,
        req: crate::model::WriteUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UserEvent>> {
        self.inner.write_user_event(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn collect_user_event(
        &self,
        req: crate::model::CollectUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::HttpBody>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserEventService",
            "::collect_user_event"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "collect_user_event",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.collect_user_event(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn collect_user_event(
        &self,
        req: crate::model::CollectUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::HttpBody>> {
        self.inner.collect_user_event(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn purge_user_events(
        &self,
        req: crate::model::PurgeUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserEventService",
            "::purge_user_events"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "purge_user_events",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.purge_user_events(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn purge_user_events(
        &self,
        req: crate::model::PurgeUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_user_events(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_user_events(
        &self,
        req: crate::model::ImportUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserEventService",
            "::import_user_events"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_user_events",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.import_user_events(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_user_events(
        &self,
        req: crate::model::ImportUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_user_events(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserEventService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserEventService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserEventService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [UserLicenseService](super::stub::UserLicenseService) decorator for logging and tracing.
#[cfg(feature = "user-license-service")]
#[derive(Clone, Debug)]
pub struct UserLicenseService<T>
where T: super::stub::UserLicenseService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "user-license-service")]
impl<T> UserLicenseService<T>
where T: super::stub::UserLicenseService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "user-license-service")]
impl<T> super::stub::UserLicenseService for UserLicenseService<T>
where T: super::stub::UserLicenseService + std::fmt::Debug + Send + Sync {
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_user_licenses(
        &self,
        req: crate::model::ListUserLicensesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUserLicensesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserLicenseService",
            "::list_user_licenses"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_user_licenses",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_user_licenses(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_user_licenses(
        &self,
        req: crate::model::ListUserLicensesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUserLicensesResponse>> {
        self.inner.list_user_licenses(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_update_user_licenses(
        &self,
        req: crate::model::BatchUpdateUserLicensesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserLicenseService",
            "::batch_update_user_licenses"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_update_user_licenses",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.batch_update_user_licenses(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_update_user_licenses(
        &self,
        req: crate::model::BatchUpdateUserLicensesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_update_user_licenses(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserLicenseService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.list_operations(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserLicenseService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.get_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "UserLicenseService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &super::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self.inner.cancel_operation(req, options)
            .instrument(client_request_span.clone()).await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

