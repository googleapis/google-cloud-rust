// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [CompletionService](crate::stubs::CompletionService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct CompletionService<T>
where
    T: crate::stubs::CompletionService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> CompletionService<T>
where
    T: crate::stubs::CompletionService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::CompletionService for CompletionService<T>
where
    T: crate::stubs::CompletionService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn complete_query(
        &self,
        req: crate::model::CompleteQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::CompleteQueryResponse> {
        self.inner.complete_query(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_suggestion_deny_list_entries(
        &self,
        req: crate::model::ImportSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner
            .import_suggestion_deny_list_entries(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn purge_suggestion_deny_list_entries(
        &self,
        req: crate::model::PurgeSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner
            .purge_suggestion_deny_list_entries(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn import_completion_suggestions(
        &self,
        req: crate::model::ImportCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.import_completion_suggestions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_completion_suggestions(
        &self,
        req: crate::model::PurgeCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.purge_completion_suggestions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ControlService](crate::stubs::ControlService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ControlService<T>
where
    T: crate::stubs::ControlService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ControlService<T>
where
    T: crate::stubs::ControlService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::ControlService for ControlService<T>
where
    T: crate::stubs::ControlService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_control(
        &self,
        req: crate::model::CreateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Control> {
        self.inner.create_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_control(
        &self,
        req: crate::model::DeleteControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_control(
        &self,
        req: crate::model::UpdateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Control> {
        self.inner.update_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_control(
        &self,
        req: crate::model::GetControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Control> {
        self.inner.get_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_controls(
        &self,
        req: crate::model::ListControlsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListControlsResponse> {
        self.inner.list_controls(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [ConversationalSearchService](crate::stubs::ConversationalSearchService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ConversationalSearchService<T>
where
    T: crate::stubs::ConversationalSearchService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ConversationalSearchService<T>
where
    T: crate::stubs::ConversationalSearchService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::ConversationalSearchService for ConversationalSearchService<T>
where
    T: crate::stubs::ConversationalSearchService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn converse_conversation(
        &self,
        req: crate::model::ConverseConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ConverseConversationResponse> {
        self.inner.converse_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_conversation(
        &self,
        req: crate::model::CreateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Conversation> {
        self.inner.create_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation(
        &self,
        req: crate::model::DeleteConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_conversation(
        &self,
        req: crate::model::UpdateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Conversation> {
        self.inner.update_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation(
        &self,
        req: crate::model::GetConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Conversation> {
        self.inner.get_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversations(
        &self,
        req: crate::model::ListConversationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListConversationsResponse> {
        self.inner.list_conversations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn answer_query(
        &self,
        req: crate::model::AnswerQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::AnswerQueryResponse> {
        self.inner.answer_query(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_answer(
        &self,
        req: crate::model::GetAnswerRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Answer> {
        self.inner.get_answer(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Session> {
        self.inner.create_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_session(
        &self,
        req: crate::model::UpdateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Session> {
        self.inner.update_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Session> {
        self.inner.get_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListSessionsResponse> {
        self.inner.list_sessions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [DataStoreService](crate::stubs::DataStoreService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct DataStoreService<T>
where
    T: crate::stubs::DataStoreService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> DataStoreService<T>
where
    T: crate::stubs::DataStoreService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::DataStoreService for DataStoreService<T>
where
    T: crate::stubs::DataStoreService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_data_store(
        &self,
        req: crate::model::CreateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_data_store(
        &self,
        req: crate::model::GetDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::DataStore> {
        self.inner.get_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_data_stores(
        &self,
        req: crate::model::ListDataStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListDataStoresResponse> {
        self.inner.list_data_stores(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_data_store(
        &self,
        req: crate::model::DeleteDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_data_store(
        &self,
        req: crate::model::UpdateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::DataStore> {
        self.inner.update_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [DocumentService](crate::stubs::DocumentService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct DocumentService<T>
where
    T: crate::stubs::DocumentService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> DocumentService<T>
where
    T: crate::stubs::DocumentService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::DocumentService for DocumentService<T>
where
    T: crate::stubs::DocumentService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_document(
        &self,
        req: crate::model::GetDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Document> {
        self.inner.get_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_documents(
        &self,
        req: crate::model::ListDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListDocumentsResponse> {
        self.inner.list_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_document(
        &self,
        req: crate::model::CreateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Document> {
        self.inner.create_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_document(
        &self,
        req: crate::model::UpdateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Document> {
        self.inner.update_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_document(
        &self,
        req: crate::model::DeleteDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_documents(
        &self,
        req: crate::model::ImportDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.import_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_documents(
        &self,
        req: crate::model::PurgeDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.purge_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_get_documents_metadata(
        &self,
        req: crate::model::BatchGetDocumentsMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::BatchGetDocumentsMetadataResponse> {
        self.inner.batch_get_documents_metadata(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EngineService](crate::stubs::EngineService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct EngineService<T>
where
    T: crate::stubs::EngineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> EngineService<T>
where
    T: crate::stubs::EngineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::EngineService for EngineService<T>
where
    T: crate::stubs::EngineService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_engine(
        &self,
        req: crate::model::CreateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_engine(
        &self,
        req: crate::model::DeleteEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_engine(
        &self,
        req: crate::model::UpdateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Engine> {
        self.inner.update_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_engine(
        &self,
        req: crate::model::GetEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Engine> {
        self.inner.get_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_engines(
        &self,
        req: crate::model::ListEnginesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListEnginesResponse> {
        self.inner.list_engines(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GroundedGenerationService](crate::stubs::GroundedGenerationService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct GroundedGenerationService<T>
where
    T: crate::stubs::GroundedGenerationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> GroundedGenerationService<T>
where
    T: crate::stubs::GroundedGenerationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::GroundedGenerationService for GroundedGenerationService<T>
where
    T: crate::stubs::GroundedGenerationService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn generate_grounded_content(
        &self,
        req: crate::model::GenerateGroundedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::GenerateGroundedContentResponse> {
        self.inner.generate_grounded_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn check_grounding(
        &self,
        req: crate::model::CheckGroundingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::CheckGroundingResponse> {
        self.inner.check_grounding(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [ProjectService](crate::stubs::ProjectService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ProjectService<T>
where
    T: crate::stubs::ProjectService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ProjectService<T>
where
    T: crate::stubs::ProjectService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::ProjectService for ProjectService<T>
where
    T: crate::stubs::ProjectService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn provision_project(
        &self,
        req: crate::model::ProvisionProjectRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.provision_project(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RankService](crate::stubs::RankService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct RankService<T>
where
    T: crate::stubs::RankService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> RankService<T>
where
    T: crate::stubs::RankService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::RankService for RankService<T>
where
    T: crate::stubs::RankService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn rank(
        &self,
        req: crate::model::RankRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::RankResponse> {
        self.inner.rank(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [RecommendationService](crate::stubs::RecommendationService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct RecommendationService<T>
where
    T: crate::stubs::RecommendationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> RecommendationService<T>
where
    T: crate::stubs::RecommendationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::RecommendationService for RecommendationService<T>
where
    T: crate::stubs::RecommendationService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn recommend(
        &self,
        req: crate::model::RecommendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::RecommendResponse> {
        self.inner.recommend(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SchemaService](crate::stubs::SchemaService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SchemaService<T>
where
    T: crate::stubs::SchemaService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SchemaService<T>
where
    T: crate::stubs::SchemaService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::SchemaService for SchemaService<T>
where
    T: crate::stubs::SchemaService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_schema(
        &self,
        req: crate::model::GetSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Schema> {
        self.inner.get_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_schemas(
        &self,
        req: crate::model::ListSchemasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListSchemasResponse> {
        self.inner.list_schemas(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_schema(
        &self,
        req: crate::model::CreateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_schema(
        &self,
        req: crate::model::UpdateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.update_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_schema(
        &self,
        req: crate::model::DeleteSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SearchService](crate::stubs::SearchService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SearchService<T>
where
    T: crate::stubs::SearchService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SearchService<T>
where
    T: crate::stubs::SearchService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::SearchService for SearchService<T>
where
    T: crate::stubs::SearchService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn search(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SearchResponse> {
        self.inner.search(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_lite(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SearchResponse> {
        self.inner.search_lite(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SearchTuningService](crate::stubs::SearchTuningService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SearchTuningService<T>
where
    T: crate::stubs::SearchTuningService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SearchTuningService<T>
where
    T: crate::stubs::SearchTuningService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::SearchTuningService for SearchTuningService<T>
where
    T: crate::stubs::SearchTuningService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn train_custom_model(
        &self,
        req: crate::model::TrainCustomModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.train_custom_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_custom_models(
        &self,
        req: crate::model::ListCustomModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListCustomModelsResponse> {
        self.inner.list_custom_models(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SiteSearchEngineService](crate::stubs::SiteSearchEngineService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SiteSearchEngineService<T>
where
    T: crate::stubs::SiteSearchEngineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SiteSearchEngineService<T>
where
    T: crate::stubs::SiteSearchEngineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::SiteSearchEngineService for SiteSearchEngineService<T>
where
    T: crate::stubs::SiteSearchEngineService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_site_search_engine(
        &self,
        req: crate::model::GetSiteSearchEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SiteSearchEngine> {
        self.inner.get_site_search_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_target_site(
        &self,
        req: crate::model::CreateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_target_sites(
        &self,
        req: crate::model::BatchCreateTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_create_target_sites(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_target_site(
        &self,
        req: crate::model::GetTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::TargetSite> {
        self.inner.get_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_target_site(
        &self,
        req: crate::model::UpdateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.update_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_target_site(
        &self,
        req: crate::model::DeleteTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_target_sites(
        &self,
        req: crate::model::ListTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListTargetSitesResponse> {
        self.inner.list_target_sites(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn enable_advanced_site_search(
        &self,
        req: crate::model::EnableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.enable_advanced_site_search(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn disable_advanced_site_search(
        &self,
        req: crate::model::DisableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.disable_advanced_site_search(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn recrawl_uris(
        &self,
        req: crate::model::RecrawlUrisRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.recrawl_uris(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_verify_target_sites(
        &self,
        req: crate::model::BatchVerifyTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_verify_target_sites(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn fetch_domain_verification_status(
        &self,
        req: crate::model::FetchDomainVerificationStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::FetchDomainVerificationStatusResponse> {
        self.inner
            .fetch_domain_verification_status(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [UserEventService](crate::stubs::UserEventService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct UserEventService<T>
where
    T: crate::stubs::UserEventService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> UserEventService<T>
where
    T: crate::stubs::UserEventService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::UserEventService for UserEventService<T>
where
    T: crate::stubs::UserEventService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn write_user_event(
        &self,
        req: crate::model::WriteUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::UserEvent> {
        self.inner.write_user_event(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn collect_user_event(
        &self,
        req: crate::model::CollectUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<api::model::HttpBody> {
        self.inner.collect_user_event(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_user_events(
        &self,
        req: crate::model::PurgeUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.purge_user_events(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_user_events(
        &self,
        req: crate::model::ImportUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.import_user_events(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
