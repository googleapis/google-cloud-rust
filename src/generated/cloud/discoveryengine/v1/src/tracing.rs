// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(
    feature = "assistant-service",
    feature = "cmek-config-service",
    feature = "completion-service",
    feature = "control-service",
    feature = "conversational-search-service",
    feature = "data-store-service",
    feature = "document-service",
    feature = "engine-service",
    feature = "grounded-generation-service",
    feature = "identity-mapping-store-service",
    feature = "project-service",
    feature = "rank-service",
    feature = "recommendation-service",
    feature = "schema-service",
    feature = "search-service",
    feature = "search-tuning-service",
    feature = "serving-config-service",
    feature = "session-service",
    feature = "site-search-engine-service",
    feature = "user-event-service",
    feature = "user-license-service",
))]
use crate::Result;

/// Implements a [AssistantService](super::stub::AssistantService) decorator for logging and tracing.
#[cfg(feature = "assistant-service")]
#[derive(Clone, Debug)]
pub struct AssistantService<T>
where
    T: super::stub::AssistantService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "assistant-service")]
impl<T> AssistantService<T>
where
    T: super::stub::AssistantService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "assistant-service")]
impl<T> super::stub::AssistantService for AssistantService<T>
where
    T: super::stub::AssistantService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [CmekConfigService](super::stub::CmekConfigService) decorator for logging and tracing.
#[cfg(feature = "cmek-config-service")]
#[derive(Clone, Debug)]
pub struct CmekConfigService<T>
where
    T: super::stub::CmekConfigService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "cmek-config-service")]
impl<T> CmekConfigService<T>
where
    T: super::stub::CmekConfigService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "cmek-config-service")]
impl<T> super::stub::CmekConfigService for CmekConfigService<T>
where
    T: super::stub::CmekConfigService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn update_cmek_config(
        &self,
        req: crate::model::UpdateCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_cmek_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_cmek_config(
        &self,
        req: crate::model::GetCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CmekConfig>> {
        self.inner.get_cmek_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_cmek_configs(
        &self,
        req: crate::model::ListCmekConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCmekConfigsResponse>> {
        self.inner.list_cmek_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_cmek_config(
        &self,
        req: crate::model::DeleteCmekConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_cmek_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [CompletionService](super::stub::CompletionService) decorator for logging and tracing.
#[cfg(feature = "completion-service")]
#[derive(Clone, Debug)]
pub struct CompletionService<T>
where
    T: super::stub::CompletionService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "completion-service")]
impl<T> CompletionService<T>
where
    T: super::stub::CompletionService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "completion-service")]
impl<T> super::stub::CompletionService for CompletionService<T>
where
    T: super::stub::CompletionService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn complete_query(
        &self,
        req: crate::model::CompleteQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompleteQueryResponse>> {
        self.inner.complete_query(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_suggestion_deny_list_entries(
        &self,
        req: crate::model::ImportSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .import_suggestion_deny_list_entries(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn purge_suggestion_deny_list_entries(
        &self,
        req: crate::model::PurgeSuggestionDenyListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .purge_suggestion_deny_list_entries(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn import_completion_suggestions(
        &self,
        req: crate::model::ImportCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_completion_suggestions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_completion_suggestions(
        &self,
        req: crate::model::PurgeCompletionSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_completion_suggestions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ControlService](super::stub::ControlService) decorator for logging and tracing.
#[cfg(feature = "control-service")]
#[derive(Clone, Debug)]
pub struct ControlService<T>
where
    T: super::stub::ControlService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "control-service")]
impl<T> ControlService<T>
where
    T: super::stub::ControlService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "control-service")]
impl<T> super::stub::ControlService for ControlService<T>
where
    T: super::stub::ControlService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_control(
        &self,
        req: crate::model::CreateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        self.inner.create_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_control(
        &self,
        req: crate::model::DeleteControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_control(
        &self,
        req: crate::model::UpdateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        self.inner.update_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_control(
        &self,
        req: crate::model::GetControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        self.inner.get_control(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_controls(
        &self,
        req: crate::model::ListControlsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListControlsResponse>> {
        self.inner.list_controls(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [ConversationalSearchService](super::stub::ConversationalSearchService) decorator for logging and tracing.
#[cfg(feature = "conversational-search-service")]
#[derive(Clone, Debug)]
pub struct ConversationalSearchService<T>
where
    T: super::stub::ConversationalSearchService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "conversational-search-service")]
impl<T> ConversationalSearchService<T>
where
    T: super::stub::ConversationalSearchService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "conversational-search-service")]
impl<T> super::stub::ConversationalSearchService for ConversationalSearchService<T>
where
    T: super::stub::ConversationalSearchService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn converse_conversation(
        &self,
        req: crate::model::ConverseConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConverseConversationResponse>> {
        self.inner.converse_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_conversation(
        &self,
        req: crate::model::CreateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.create_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation(
        &self,
        req: crate::model::DeleteConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_conversation(
        &self,
        req: crate::model::UpdateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.update_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation(
        &self,
        req: crate::model::GetConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.get_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversations(
        &self,
        req: crate::model::ListConversationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationsResponse>> {
        self.inner.list_conversations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn answer_query(
        &self,
        req: crate::model::AnswerQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnswerQueryResponse>> {
        self.inner.answer_query(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_answer(
        &self,
        req: crate::model::GetAnswerRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Answer>> {
        self.inner.get_answer(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.create_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_session(
        &self,
        req: crate::model::UpdateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.update_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.get_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        self.inner.list_sessions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [DataStoreService](super::stub::DataStoreService) decorator for logging and tracing.
#[cfg(feature = "data-store-service")]
#[derive(Clone, Debug)]
pub struct DataStoreService<T>
where
    T: super::stub::DataStoreService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "data-store-service")]
impl<T> DataStoreService<T>
where
    T: super::stub::DataStoreService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "data-store-service")]
impl<T> super::stub::DataStoreService for DataStoreService<T>
where
    T: super::stub::DataStoreService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_data_store(
        &self,
        req: crate::model::CreateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_data_store(
        &self,
        req: crate::model::GetDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataStore>> {
        self.inner.get_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_data_stores(
        &self,
        req: crate::model::ListDataStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataStoresResponse>> {
        self.inner.list_data_stores(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_data_store(
        &self,
        req: crate::model::DeleteDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_data_store(
        &self,
        req: crate::model::UpdateDataStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataStore>> {
        self.inner.update_data_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [DocumentService](super::stub::DocumentService) decorator for logging and tracing.
#[cfg(feature = "document-service")]
#[derive(Clone, Debug)]
pub struct DocumentService<T>
where
    T: super::stub::DocumentService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "document-service")]
impl<T> DocumentService<T>
where
    T: super::stub::DocumentService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "document-service")]
impl<T> super::stub::DocumentService for DocumentService<T>
where
    T: super::stub::DocumentService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_document(
        &self,
        req: crate::model::GetDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        self.inner.get_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_documents(
        &self,
        req: crate::model::ListDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDocumentsResponse>> {
        self.inner.list_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_document(
        &self,
        req: crate::model::CreateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        self.inner.create_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_document(
        &self,
        req: crate::model::UpdateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        self.inner.update_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_document(
        &self,
        req: crate::model::DeleteDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_documents(
        &self,
        req: crate::model::ImportDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_documents(
        &self,
        req: crate::model::PurgeDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_get_documents_metadata(
        &self,
        req: crate::model::BatchGetDocumentsMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchGetDocumentsMetadataResponse>> {
        self.inner.batch_get_documents_metadata(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EngineService](super::stub::EngineService) decorator for logging and tracing.
#[cfg(feature = "engine-service")]
#[derive(Clone, Debug)]
pub struct EngineService<T>
where
    T: super::stub::EngineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "engine-service")]
impl<T> EngineService<T>
where
    T: super::stub::EngineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "engine-service")]
impl<T> super::stub::EngineService for EngineService<T>
where
    T: super::stub::EngineService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_engine(
        &self,
        req: crate::model::CreateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_engine(
        &self,
        req: crate::model::DeleteEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_engine(
        &self,
        req: crate::model::UpdateEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Engine>> {
        self.inner.update_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_engine(
        &self,
        req: crate::model::GetEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Engine>> {
        self.inner.get_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_engines(
        &self,
        req: crate::model::ListEnginesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnginesResponse>> {
        self.inner.list_engines(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GroundedGenerationService](super::stub::GroundedGenerationService) decorator for logging and tracing.
#[cfg(feature = "grounded-generation-service")]
#[derive(Clone, Debug)]
pub struct GroundedGenerationService<T>
where
    T: super::stub::GroundedGenerationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "grounded-generation-service")]
impl<T> GroundedGenerationService<T>
where
    T: super::stub::GroundedGenerationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "grounded-generation-service")]
impl<T> super::stub::GroundedGenerationService for GroundedGenerationService<T>
where
    T: super::stub::GroundedGenerationService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn generate_grounded_content(
        &self,
        req: crate::model::GenerateGroundedContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateGroundedContentResponse>> {
        self.inner.generate_grounded_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn check_grounding(
        &self,
        req: crate::model::CheckGroundingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckGroundingResponse>> {
        self.inner.check_grounding(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [IdentityMappingStoreService](super::stub::IdentityMappingStoreService) decorator for logging and tracing.
#[cfg(feature = "identity-mapping-store-service")]
#[derive(Clone, Debug)]
pub struct IdentityMappingStoreService<T>
where
    T: super::stub::IdentityMappingStoreService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "identity-mapping-store-service")]
impl<T> IdentityMappingStoreService<T>
where
    T: super::stub::IdentityMappingStoreService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "identity-mapping-store-service")]
impl<T> super::stub::IdentityMappingStoreService for IdentityMappingStoreService<T>
where
    T: super::stub::IdentityMappingStoreService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_identity_mapping_store(
        &self,
        req: crate::model::CreateIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IdentityMappingStore>> {
        self.inner.create_identity_mapping_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_identity_mapping_store(
        &self,
        req: crate::model::GetIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IdentityMappingStore>> {
        self.inner.get_identity_mapping_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_identity_mapping_store(
        &self,
        req: crate::model::DeleteIdentityMappingStoreRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_identity_mapping_store(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_identity_mappings(
        &self,
        req: crate::model::ImportIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_identity_mappings(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_identity_mappings(
        &self,
        req: crate::model::PurgeIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_identity_mappings(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_identity_mappings(
        &self,
        req: crate::model::ListIdentityMappingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIdentityMappingsResponse>> {
        self.inner.list_identity_mappings(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_identity_mapping_stores(
        &self,
        req: crate::model::ListIdentityMappingStoresRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIdentityMappingStoresResponse>> {
        self.inner.list_identity_mapping_stores(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ProjectService](super::stub::ProjectService) decorator for logging and tracing.
#[cfg(feature = "project-service")]
#[derive(Clone, Debug)]
pub struct ProjectService<T>
where
    T: super::stub::ProjectService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "project-service")]
impl<T> ProjectService<T>
where
    T: super::stub::ProjectService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "project-service")]
impl<T> super::stub::ProjectService for ProjectService<T>
where
    T: super::stub::ProjectService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn provision_project(
        &self,
        req: crate::model::ProvisionProjectRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.provision_project(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RankService](super::stub::RankService) decorator for logging and tracing.
#[cfg(feature = "rank-service")]
#[derive(Clone, Debug)]
pub struct RankService<T>
where
    T: super::stub::RankService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "rank-service")]
impl<T> RankService<T>
where
    T: super::stub::RankService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "rank-service")]
impl<T> super::stub::RankService for RankService<T>
where
    T: super::stub::RankService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn rank(
        &self,
        req: crate::model::RankRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RankResponse>> {
        self.inner.rank(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [RecommendationService](super::stub::RecommendationService) decorator for logging and tracing.
#[cfg(feature = "recommendation-service")]
#[derive(Clone, Debug)]
pub struct RecommendationService<T>
where
    T: super::stub::RecommendationService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "recommendation-service")]
impl<T> RecommendationService<T>
where
    T: super::stub::RecommendationService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "recommendation-service")]
impl<T> super::stub::RecommendationService for RecommendationService<T>
where
    T: super::stub::RecommendationService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn recommend(
        &self,
        req: crate::model::RecommendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RecommendResponse>> {
        self.inner.recommend(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SchemaService](super::stub::SchemaService) decorator for logging and tracing.
#[cfg(feature = "schema-service")]
#[derive(Clone, Debug)]
pub struct SchemaService<T>
where
    T: super::stub::SchemaService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "schema-service")]
impl<T> SchemaService<T>
where
    T: super::stub::SchemaService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "schema-service")]
impl<T> super::stub::SchemaService for SchemaService<T>
where
    T: super::stub::SchemaService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_schema(
        &self,
        req: crate::model::GetSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Schema>> {
        self.inner.get_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_schemas(
        &self,
        req: crate::model::ListSchemasRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchemasResponse>> {
        self.inner.list_schemas(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_schema(
        &self,
        req: crate::model::CreateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_schema(
        &self,
        req: crate::model::UpdateSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_schema(
        &self,
        req: crate::model::DeleteSchemaRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_schema(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SearchService](super::stub::SearchService) decorator for logging and tracing.
#[cfg(feature = "search-service")]
#[derive(Clone, Debug)]
pub struct SearchService<T>
where
    T: super::stub::SearchService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "search-service")]
impl<T> SearchService<T>
where
    T: super::stub::SearchService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "search-service")]
impl<T> super::stub::SearchService for SearchService<T>
where
    T: super::stub::SearchService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn search(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchResponse>> {
        self.inner.search(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_lite(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchResponse>> {
        self.inner.search_lite(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SearchTuningService](super::stub::SearchTuningService) decorator for logging and tracing.
#[cfg(feature = "search-tuning-service")]
#[derive(Clone, Debug)]
pub struct SearchTuningService<T>
where
    T: super::stub::SearchTuningService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "search-tuning-service")]
impl<T> SearchTuningService<T>
where
    T: super::stub::SearchTuningService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "search-tuning-service")]
impl<T> super::stub::SearchTuningService for SearchTuningService<T>
where
    T: super::stub::SearchTuningService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn train_custom_model(
        &self,
        req: crate::model::TrainCustomModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.train_custom_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_custom_models(
        &self,
        req: crate::model::ListCustomModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCustomModelsResponse>> {
        self.inner.list_custom_models(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ServingConfigService](super::stub::ServingConfigService) decorator for logging and tracing.
#[cfg(feature = "serving-config-service")]
#[derive(Clone, Debug)]
pub struct ServingConfigService<T>
where
    T: super::stub::ServingConfigService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "serving-config-service")]
impl<T> ServingConfigService<T>
where
    T: super::stub::ServingConfigService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "serving-config-service")]
impl<T> super::stub::ServingConfigService for ServingConfigService<T>
where
    T: super::stub::ServingConfigService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn update_serving_config(
        &self,
        req: crate::model::UpdateServingConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        self.inner.update_serving_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SessionService](super::stub::SessionService) decorator for logging and tracing.
#[cfg(feature = "session-service")]
#[derive(Clone, Debug)]
pub struct SessionService<T>
where
    T: super::stub::SessionService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "session-service")]
impl<T> SessionService<T>
where
    T: super::stub::SessionService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "session-service")]
impl<T> super::stub::SessionService for SessionService<T>
where
    T: super::stub::SessionService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.create_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_session(
        &self,
        req: crate::model::UpdateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.update_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.get_session(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        self.inner.list_sessions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SiteSearchEngineService](super::stub::SiteSearchEngineService) decorator for logging and tracing.
#[cfg(feature = "site-search-engine-service")]
#[derive(Clone, Debug)]
pub struct SiteSearchEngineService<T>
where
    T: super::stub::SiteSearchEngineService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "site-search-engine-service")]
impl<T> SiteSearchEngineService<T>
where
    T: super::stub::SiteSearchEngineService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "site-search-engine-service")]
impl<T> super::stub::SiteSearchEngineService for SiteSearchEngineService<T>
where
    T: super::stub::SiteSearchEngineService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_site_search_engine(
        &self,
        req: crate::model::GetSiteSearchEngineRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SiteSearchEngine>> {
        self.inner.get_site_search_engine(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_target_site(
        &self,
        req: crate::model::CreateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_target_sites(
        &self,
        req: crate::model::BatchCreateTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_create_target_sites(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_target_site(
        &self,
        req: crate::model::GetTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetSite>> {
        self.inner.get_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_target_site(
        &self,
        req: crate::model::UpdateTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_target_site(
        &self,
        req: crate::model::DeleteTargetSiteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_target_site(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_target_sites(
        &self,
        req: crate::model::ListTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTargetSitesResponse>> {
        self.inner.list_target_sites(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_sitemap(
        &self,
        req: crate::model::CreateSitemapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_sitemap(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_sitemap(
        &self,
        req: crate::model::DeleteSitemapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_sitemap(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn fetch_sitemaps(
        &self,
        req: crate::model::FetchSitemapsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchSitemapsResponse>> {
        self.inner.fetch_sitemaps(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn enable_advanced_site_search(
        &self,
        req: crate::model::EnableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.enable_advanced_site_search(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn disable_advanced_site_search(
        &self,
        req: crate::model::DisableAdvancedSiteSearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.disable_advanced_site_search(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn recrawl_uris(
        &self,
        req: crate::model::RecrawlUrisRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.recrawl_uris(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_verify_target_sites(
        &self,
        req: crate::model::BatchVerifyTargetSitesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_verify_target_sites(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn fetch_domain_verification_status(
        &self,
        req: crate::model::FetchDomainVerificationStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FetchDomainVerificationStatusResponse>> {
        self.inner
            .fetch_domain_verification_status(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [UserEventService](super::stub::UserEventService) decorator for logging and tracing.
#[cfg(feature = "user-event-service")]
#[derive(Clone, Debug)]
pub struct UserEventService<T>
where
    T: super::stub::UserEventService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "user-event-service")]
impl<T> UserEventService<T>
where
    T: super::stub::UserEventService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "user-event-service")]
impl<T> super::stub::UserEventService for UserEventService<T>
where
    T: super::stub::UserEventService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn write_user_event(
        &self,
        req: crate::model::WriteUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UserEvent>> {
        self.inner.write_user_event(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn collect_user_event(
        &self,
        req: crate::model::CollectUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::HttpBody>> {
        self.inner.collect_user_event(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn purge_user_events(
        &self,
        req: crate::model::PurgeUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.purge_user_events(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_user_events(
        &self,
        req: crate::model::ImportUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_user_events(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [UserLicenseService](super::stub::UserLicenseService) decorator for logging and tracing.
#[cfg(feature = "user-license-service")]
#[derive(Clone, Debug)]
pub struct UserLicenseService<T>
where
    T: super::stub::UserLicenseService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "user-license-service")]
impl<T> UserLicenseService<T>
where
    T: super::stub::UserLicenseService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "user-license-service")]
impl<T> super::stub::UserLicenseService for UserLicenseService<T>
where
    T: super::stub::UserLicenseService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_user_licenses(
        &self,
        req: crate::model::ListUserLicensesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUserLicensesResponse>> {
        self.inner.list_user_licenses(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_update_user_licenses(
        &self,
        req: crate::model::BatchUpdateUserLicensesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_update_user_licenses(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
