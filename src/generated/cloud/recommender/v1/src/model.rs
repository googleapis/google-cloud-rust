// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An insight along with the information used to derive the insight. The insight
/// may have associated recommendations as well.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Insight {
    /// Name of the insight.
    pub name: std::string::String,

    /// Free-form human readable summary in English. The maximum length is 500
    /// characters.
    pub description: std::string::String,

    /// Fully qualified resource names that this insight is targeting.
    pub target_resources: std::vec::Vec<std::string::String>,

    /// Insight subtype. Insight content schema will be stable for a given subtype.
    pub insight_subtype: std::string::String,

    /// A struct of custom fields to explain the insight.
    /// Example: "grantedPermissionsCount": "1000"
    pub content: std::option::Option<wkt::Struct>,

    /// Timestamp of the latest data used to generate the insight.
    pub last_refresh_time: std::option::Option<wkt::Timestamp>,

    /// Observation period that led to the insight. The source data used to
    /// generate the insight ends at last_refresh_time and begins at
    /// (last_refresh_time - observation_period).
    pub observation_period: std::option::Option<wkt::Duration>,

    /// Information state and metadata.
    pub state_info: std::option::Option<crate::model::InsightStateInfo>,

    /// Category being targeted by the insight.
    pub category: crate::model::insight::Category,

    /// Insight's severity.
    pub severity: crate::model::insight::Severity,

    /// Fingerprint of the Insight. Provides optimistic locking when updating
    /// states.
    pub etag: std::string::String,

    /// Recommendations derived from this insight.
    pub associated_recommendations: std::vec::Vec<crate::model::insight::RecommendationReference>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Insight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Insight::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Insight::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [target_resources][crate::model::Insight::target_resources].
    pub fn set_target_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [insight_subtype][crate::model::Insight::insight_subtype].
    pub fn set_insight_subtype<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.insight_subtype = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Insight::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::Insight::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_refresh_time][crate::model::Insight::last_refresh_time].
    pub fn set_last_refresh_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_refresh_time][crate::model::Insight::last_refresh_time].
    pub fn set_or_clear_last_refresh_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [observation_period][crate::model::Insight::observation_period].
    pub fn set_observation_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.observation_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [observation_period][crate::model::Insight::observation_period].
    pub fn set_or_clear_observation_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.observation_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state_info][crate::model::Insight::state_info].
    pub fn set_state_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightStateInfo>,
    {
        self.state_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_info][crate::model::Insight::state_info].
    pub fn set_or_clear_state_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightStateInfo>,
    {
        self.state_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [category][crate::model::Insight::category].
    pub fn set_category<T: std::convert::Into<crate::model::insight::Category>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Insight::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::insight::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Insight::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [associated_recommendations][crate::model::Insight::associated_recommendations].
    pub fn set_associated_recommendations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::insight::RecommendationReference>,
    {
        use std::iter::Iterator;
        self.associated_recommendations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Insight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Insight"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Insight {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __target_resources,
            __insight_subtype,
            __content,
            __last_refresh_time,
            __observation_period,
            __state_info,
            __category,
            __severity,
            __etag,
            __associated_recommendations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Insight")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "targetResources" => Ok(__FieldTag::__target_resources),
                            "target_resources" => Ok(__FieldTag::__target_resources),
                            "insightSubtype" => Ok(__FieldTag::__insight_subtype),
                            "insight_subtype" => Ok(__FieldTag::__insight_subtype),
                            "content" => Ok(__FieldTag::__content),
                            "lastRefreshTime" => Ok(__FieldTag::__last_refresh_time),
                            "last_refresh_time" => Ok(__FieldTag::__last_refresh_time),
                            "observationPeriod" => Ok(__FieldTag::__observation_period),
                            "observation_period" => Ok(__FieldTag::__observation_period),
                            "stateInfo" => Ok(__FieldTag::__state_info),
                            "state_info" => Ok(__FieldTag::__state_info),
                            "category" => Ok(__FieldTag::__category),
                            "severity" => Ok(__FieldTag::__severity),
                            "etag" => Ok(__FieldTag::__etag),
                            "associatedRecommendations" => {
                                Ok(__FieldTag::__associated_recommendations)
                            }
                            "associated_recommendations" => {
                                Ok(__FieldTag::__associated_recommendations)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Insight;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Insight")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_resources => {
                            if !fields.insert(__FieldTag::__target_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_resources",
                                ));
                            }
                            result.target_resources = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__insight_subtype => {
                            if !fields.insert(__FieldTag::__insight_subtype) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insight_subtype",
                                ));
                            }
                            result.insight_subtype = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__last_refresh_time => {
                            if !fields.insert(__FieldTag::__last_refresh_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_refresh_time",
                                ));
                            }
                            result.last_refresh_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__observation_period => {
                            if !fields.insert(__FieldTag::__observation_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observation_period",
                                ));
                            }
                            result.observation_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__state_info => {
                            if !fields.insert(__FieldTag::__state_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_info",
                                ));
                            }
                            result.state_info = map
                                .next_value::<std::option::Option<crate::model::InsightStateInfo>>(
                                )?;
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<crate::model::insight::Category>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::insight::Severity>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__associated_recommendations => {
                            if !fields.insert(__FieldTag::__associated_recommendations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for associated_recommendations",
                                ));
                            }
                            result.associated_recommendations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::insight::RecommendationReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Insight {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.target_resources.is_empty() {
            state.serialize_entry("targetResources", &self.target_resources)?;
        }
        if !self.insight_subtype.is_empty() {
            state.serialize_entry("insightSubtype", &self.insight_subtype)?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.last_refresh_time.is_some() {
            state.serialize_entry("lastRefreshTime", &self.last_refresh_time)?;
        }
        if self.observation_period.is_some() {
            state.serialize_entry("observationPeriod", &self.observation_period)?;
        }
        if self.state_info.is_some() {
            state.serialize_entry("stateInfo", &self.state_info)?;
        }
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.associated_recommendations.is_empty() {
            state.serialize_entry(
                "associatedRecommendations",
                &self.associated_recommendations,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Insight {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Insight");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("target_resources", &self.target_resources);
        debug_struct.field("insight_subtype", &self.insight_subtype);
        debug_struct.field("content", &self.content);
        debug_struct.field("last_refresh_time", &self.last_refresh_time);
        debug_struct.field("observation_period", &self.observation_period);
        debug_struct.field("state_info", &self.state_info);
        debug_struct.field("category", &self.category);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("etag", &self.etag);
        debug_struct.field(
            "associated_recommendations",
            &self.associated_recommendations,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Insight].
pub mod insight {
    #[allow(unused_imports)]
    use super::*;

    /// Reference to an associated recommendation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RecommendationReference {
        /// Recommendation resource name, e.g.
        /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/recommendations/[RECOMMENDATION_ID]
        pub recommendation: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RecommendationReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [recommendation][crate::model::insight::RecommendationReference::recommendation].
        pub fn set_recommendation<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.recommendation = v.into();
            self
        }
    }

    impl wkt::message::Message for RecommendationReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recommender.v1.Insight.RecommendationReference"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RecommendationReference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __recommendation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RecommendationReference")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "recommendation" => Ok(__FieldTag::__recommendation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RecommendationReference;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RecommendationReference")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__recommendation => {
                                if !fields.insert(__FieldTag::__recommendation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recommendation",
                                    ));
                                }
                                result.recommendation = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RecommendationReference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.recommendation.is_empty() {
                state.serialize_entry("recommendation", &self.recommendation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RecommendationReference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RecommendationReference");
            debug_struct.field("recommendation", &self.recommendation);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Insight category.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Category {
        /// Unspecified category.
        Unspecified,
        /// The insight is related to cost.
        Cost,
        /// The insight is related to security.
        Security,
        /// The insight is related to performance.
        Performance,
        /// This insight is related to manageability.
        Manageability,
        /// The insight is related to sustainability.
        Sustainability,
        /// This insight is related to reliability.
        Reliability,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Category::value] or
        /// [Category::name].
        UnknownValue(category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Category {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cost => std::option::Option::Some(1),
                Self::Security => std::option::Option::Some(2),
                Self::Performance => std::option::Option::Some(3),
                Self::Manageability => std::option::Option::Some(4),
                Self::Sustainability => std::option::Option::Some(5),
                Self::Reliability => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CATEGORY_UNSPECIFIED"),
                Self::Cost => std::option::Option::Some("COST"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::Performance => std::option::Option::Some("PERFORMANCE"),
                Self::Manageability => std::option::Option::Some("MANAGEABILITY"),
                Self::Sustainability => std::option::Option::Some("SUSTAINABILITY"),
                Self::Reliability => std::option::Option::Some("RELIABILITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Category {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Category {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Category {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cost,
                2 => Self::Security,
                3 => Self::Performance,
                4 => Self::Manageability,
                5 => Self::Sustainability,
                6 => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Category {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "COST" => Self::Cost,
                "SECURITY" => Self::Security,
                "PERFORMANCE" => Self::Performance,
                "MANAGEABILITY" => Self::Manageability,
                "SUSTAINABILITY" => Self::Sustainability,
                "RELIABILITY" => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Category {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cost => serializer.serialize_i32(1),
                Self::Security => serializer.serialize_i32(2),
                Self::Performance => serializer.serialize_i32(3),
                Self::Manageability => serializer.serialize_i32(4),
                Self::Sustainability => serializer.serialize_i32(5),
                Self::Reliability => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Category {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Category>::new(
                ".google.cloud.recommender.v1.Insight.Category",
            ))
        }
    }

    /// Insight severity levels.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Insight has unspecified severity.
        Unspecified,
        /// Insight has low severity.
        Low,
        /// Insight has medium severity.
        Medium,
        /// Insight has high severity.
        High,
        /// Insight has critical severity.
        Critical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::Critical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::Medium,
                3 => Self::High,
                4 => Self::Critical,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "LOW" => Self::Low,
                "MEDIUM" => Self::Medium,
                "HIGH" => Self::High,
                "CRITICAL" => Self::Critical,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::Critical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.recommender.v1.Insight.Severity",
            ))
        }
    }
}

/// Information related to insight state.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InsightStateInfo {
    /// Insight state.
    pub state: crate::model::insight_state_info::State,

    /// A map of metadata for the state, provided by user or automations systems.
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightStateInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::InsightStateInfo::state].
    pub fn set_state<T: std::convert::Into<crate::model::insight_state_info::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::InsightStateInfo::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InsightStateInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.InsightStateInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsightStateInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __state_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsightStateInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "stateMetadata" => Ok(__FieldTag::__state_metadata),
                            "state_metadata" => Ok(__FieldTag::__state_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsightStateInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsightStateInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::insight_state_info::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_metadata => {
                            if !fields.insert(__FieldTag::__state_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_metadata",
                                ));
                            }
                            result.state_metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsightStateInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_metadata.is_empty() {
            state.serialize_entry("stateMetadata", &self.state_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InsightStateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsightStateInfo");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_metadata", &self.state_metadata);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [InsightStateInfo].
pub mod insight_state_info {
    #[allow(unused_imports)]
    use super::*;

    /// Represents insight state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Insight is active. Content for ACTIVE insights can be updated by Google.
        /// ACTIVE insights can be marked DISMISSED OR ACCEPTED.
        Active,
        /// Some action has been taken based on this insight. Insights become
        /// accepted when a recommendation derived from the insight has been marked
        /// CLAIMED, SUCCEEDED, or FAILED. ACTIVE insights can also be marked
        /// ACCEPTED explicitly. Content for ACCEPTED insights is immutable. ACCEPTED
        /// insights can only be marked ACCEPTED (which may update state metadata).
        Accepted,
        /// Insight is dismissed. Content for DISMISSED insights can be updated by
        /// Google. DISMISSED insights can be marked as ACTIVE.
        Dismissed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Accepted => std::option::Option::Some(2),
                Self::Dismissed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Accepted => std::option::Option::Some("ACCEPTED"),
                Self::Dismissed => std::option::Option::Some("DISMISSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Accepted,
                3 => Self::Dismissed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "ACCEPTED" => Self::Accepted,
                "DISMISSED" => Self::Dismissed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Accepted => serializer.serialize_i32(2),
                Self::Dismissed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.recommender.v1.InsightStateInfo.State",
            ))
        }
    }
}

/// Configuration for an InsightType.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InsightTypeConfig {
    /// Name of insight type config.
    /// Eg,
    /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config
    pub name: std::string::String,

    /// InsightTypeGenerationConfig which configures the generation of
    /// insights for this insight type.
    pub insight_type_generation_config:
        std::option::Option<crate::model::InsightTypeGenerationConfig>,

    /// Fingerprint of the InsightTypeConfig. Provides optimistic locking when
    /// updating.
    pub etag: std::string::String,

    /// Last time when the config was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Immutable. The revision ID of the config.
    /// A new revision is committed whenever the config is changed in any way.
    /// The format is an 8-character hexadecimal string.
    pub revision_id: std::string::String,

    /// Allows clients to store small amounts of arbitrary data. Annotations must
    /// follow the Kubernetes syntax.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// A user-settable field to provide a human-readable name to be used in user
    /// interfaces.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InsightTypeConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [insight_type_generation_config][crate::model::InsightTypeConfig::insight_type_generation_config].
    pub fn set_insight_type_generation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeGenerationConfig>,
    {
        self.insight_type_generation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insight_type_generation_config][crate::model::InsightTypeConfig::insight_type_generation_config].
    pub fn set_or_clear_insight_type_generation_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeGenerationConfig>,
    {
        self.insight_type_generation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::InsightTypeConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::InsightTypeConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::InsightTypeConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision_id][crate::model::InsightTypeConfig::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::InsightTypeConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::InsightTypeConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for InsightTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.InsightTypeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsightTypeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __insight_type_generation_config,
            __etag,
            __update_time,
            __revision_id,
            __annotations,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsightTypeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "insightTypeGenerationConfig" => {
                                Ok(__FieldTag::__insight_type_generation_config)
                            }
                            "insight_type_generation_config" => {
                                Ok(__FieldTag::__insight_type_generation_config)
                            }
                            "etag" => Ok(__FieldTag::__etag),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsightTypeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsightTypeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insight_type_generation_config => {
                            if !fields.insert(__FieldTag::__insight_type_generation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insight_type_generation_config",
                                ));
                            }
                            result.insight_type_generation_config = map.next_value::<std::option::Option<crate::model::InsightTypeGenerationConfig>>()?
                                ;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsightTypeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.insight_type_generation_config.is_some() {
            state.serialize_entry(
                "insightTypeGenerationConfig",
                &self.insight_type_generation_config,
            )?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InsightTypeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsightTypeConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field(
            "insight_type_generation_config",
            &self.insight_type_generation_config,
        );
        debug_struct.field("etag", &self.etag);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("display_name", &self.display_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A configuration to customize the generation of insights.
/// Eg, customizing the lookback period considered when generating a
/// insight.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InsightTypeGenerationConfig {
    /// Parameters for this InsightTypeGenerationConfig. These configs can be used
    /// by or are applied to all subtypes.
    pub params: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightTypeGenerationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [params][crate::model::InsightTypeGenerationConfig::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::InsightTypeGenerationConfig::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InsightTypeGenerationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.InsightTypeGenerationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InsightTypeGenerationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InsightTypeGenerationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "params" => Ok(__FieldTag::__params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InsightTypeGenerationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InsightTypeGenerationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__params => {
                            if !fields.insert(__FieldTag::__params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for params",
                                ));
                            }
                            result.params = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InsightTypeGenerationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InsightTypeGenerationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsightTypeGenerationConfig");
        debug_struct.field("params", &self.params);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A recommendation along with a suggested action. E.g., a rightsizing
/// recommendation for an underutilized VM, IAM role recommendations, etc
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Recommendation {
    /// Name of recommendation.
    pub name: std::string::String,

    /// Free-form human readable summary in English. The maximum length is 500
    /// characters.
    pub description: std::string::String,

    /// Contains an identifier for a subtype of recommendations produced for the
    /// same recommender. Subtype is a function of content and impact, meaning a
    /// new subtype might be added when significant changes to `content` or
    /// `primary_impact.category` are introduced. See the Recommenders section
    /// to see a list of subtypes for a given Recommender.
    ///
    /// Examples:
    /// For recommender = "google.iam.policy.Recommender",
    /// recommender_subtype can be one of "REMOVE_ROLE"/"REPLACE_ROLE"
    pub recommender_subtype: std::string::String,

    /// Last time this recommendation was refreshed by the system that created it
    /// in the first place.
    pub last_refresh_time: std::option::Option<wkt::Timestamp>,

    /// The primary impact that this recommendation can have while trying to
    /// optimize for one category.
    pub primary_impact: std::option::Option<crate::model::Impact>,

    /// Optional set of additional impact that this recommendation may have when
    /// trying to optimize for the primary category. These may be positive
    /// or negative.
    pub additional_impact: std::vec::Vec<crate::model::Impact>,

    /// Recommendation's priority.
    pub priority: crate::model::recommendation::Priority,

    /// Content of the recommendation describing recommended changes to resources.
    pub content: std::option::Option<crate::model::RecommendationContent>,

    /// Information for state. Contains state and metadata.
    pub state_info: std::option::Option<crate::model::RecommendationStateInfo>,

    /// Fingerprint of the Recommendation. Provides optimistic locking when
    /// updating states.
    pub etag: std::string::String,

    /// Insights that led to this recommendation.
    pub associated_insights: std::vec::Vec<crate::model::recommendation::InsightReference>,

    /// Corresponds to a mutually exclusive group ID within a recommender.
    /// A non-empty ID indicates that the recommendation belongs to a mutually
    /// exclusive group. This means that only one recommendation within the group
    /// is suggested to be applied.
    pub xor_group_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Recommendation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Recommendation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Recommendation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [recommender_subtype][crate::model::Recommendation::recommender_subtype].
    pub fn set_recommender_subtype<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.recommender_subtype = v.into();
        self
    }

    /// Sets the value of [last_refresh_time][crate::model::Recommendation::last_refresh_time].
    pub fn set_last_refresh_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_refresh_time][crate::model::Recommendation::last_refresh_time].
    pub fn set_or_clear_last_refresh_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [primary_impact][crate::model::Recommendation::primary_impact].
    pub fn set_primary_impact<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Impact>,
    {
        self.primary_impact = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_impact][crate::model::Recommendation::primary_impact].
    pub fn set_or_clear_primary_impact<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Impact>,
    {
        self.primary_impact = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_impact][crate::model::Recommendation::additional_impact].
    pub fn set_additional_impact<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Impact>,
    {
        use std::iter::Iterator;
        self.additional_impact = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [priority][crate::model::Recommendation::priority].
    pub fn set_priority<T: std::convert::Into<crate::model::recommendation::Priority>>(
        mut self,
        v: T,
    ) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Recommendation::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationContent>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::Recommendation::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationContent>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state_info][crate::model::Recommendation::state_info].
    pub fn set_state_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationStateInfo>,
    {
        self.state_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_info][crate::model::Recommendation::state_info].
    pub fn set_or_clear_state_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationStateInfo>,
    {
        self.state_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Recommendation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [associated_insights][crate::model::Recommendation::associated_insights].
    pub fn set_associated_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::recommendation::InsightReference>,
    {
        use std::iter::Iterator;
        self.associated_insights = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [xor_group_id][crate::model::Recommendation::xor_group_id].
    pub fn set_xor_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.xor_group_id = v.into();
        self
    }
}

impl wkt::message::Message for Recommendation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Recommendation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Recommendation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __recommender_subtype,
            __last_refresh_time,
            __primary_impact,
            __additional_impact,
            __priority,
            __content,
            __state_info,
            __etag,
            __associated_insights,
            __xor_group_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Recommendation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "recommenderSubtype" => Ok(__FieldTag::__recommender_subtype),
                            "recommender_subtype" => Ok(__FieldTag::__recommender_subtype),
                            "lastRefreshTime" => Ok(__FieldTag::__last_refresh_time),
                            "last_refresh_time" => Ok(__FieldTag::__last_refresh_time),
                            "primaryImpact" => Ok(__FieldTag::__primary_impact),
                            "primary_impact" => Ok(__FieldTag::__primary_impact),
                            "additionalImpact" => Ok(__FieldTag::__additional_impact),
                            "additional_impact" => Ok(__FieldTag::__additional_impact),
                            "priority" => Ok(__FieldTag::__priority),
                            "content" => Ok(__FieldTag::__content),
                            "stateInfo" => Ok(__FieldTag::__state_info),
                            "state_info" => Ok(__FieldTag::__state_info),
                            "etag" => Ok(__FieldTag::__etag),
                            "associatedInsights" => Ok(__FieldTag::__associated_insights),
                            "associated_insights" => Ok(__FieldTag::__associated_insights),
                            "xorGroupId" => Ok(__FieldTag::__xor_group_id),
                            "xor_group_id" => Ok(__FieldTag::__xor_group_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Recommendation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Recommendation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recommender_subtype => {
                            if !fields.insert(__FieldTag::__recommender_subtype) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recommender_subtype",
                                ));
                            }
                            result.recommender_subtype = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_refresh_time => {
                            if !fields.insert(__FieldTag::__last_refresh_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_refresh_time",
                                ));
                            }
                            result.last_refresh_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__primary_impact => {
                            if !fields.insert(__FieldTag::__primary_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_impact",
                                ));
                            }
                            result.primary_impact =
                                map.next_value::<std::option::Option<crate::model::Impact>>()?;
                        }
                        __FieldTag::__additional_impact => {
                            if !fields.insert(__FieldTag::__additional_impact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_impact",
                                ));
                            }
                            result.additional_impact = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Impact>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            result.priority = map.next_value::<std::option::Option<crate::model::recommendation::Priority>>()?.unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map.next_value::<std::option::Option<crate::model::RecommendationContent>>()?
                                ;
                        }
                        __FieldTag::__state_info => {
                            if !fields.insert(__FieldTag::__state_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_info",
                                ));
                            }
                            result.state_info = map.next_value::<std::option::Option<crate::model::RecommendationStateInfo>>()?
                                ;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__associated_insights => {
                            if !fields.insert(__FieldTag::__associated_insights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for associated_insights",
                                ));
                            }
                            result.associated_insights = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::recommendation::InsightReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__xor_group_id => {
                            if !fields.insert(__FieldTag::__xor_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for xor_group_id",
                                ));
                            }
                            result.xor_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Recommendation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.recommender_subtype.is_empty() {
            state.serialize_entry("recommenderSubtype", &self.recommender_subtype)?;
        }
        if self.last_refresh_time.is_some() {
            state.serialize_entry("lastRefreshTime", &self.last_refresh_time)?;
        }
        if self.primary_impact.is_some() {
            state.serialize_entry("primaryImpact", &self.primary_impact)?;
        }
        if !self.additional_impact.is_empty() {
            state.serialize_entry("additionalImpact", &self.additional_impact)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            state.serialize_entry("priority", &self.priority)?;
        }
        if self.content.is_some() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.state_info.is_some() {
            state.serialize_entry("stateInfo", &self.state_info)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.associated_insights.is_empty() {
            state.serialize_entry("associatedInsights", &self.associated_insights)?;
        }
        if !self.xor_group_id.is_empty() {
            state.serialize_entry("xorGroupId", &self.xor_group_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Recommendation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Recommendation");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("recommender_subtype", &self.recommender_subtype);
        debug_struct.field("last_refresh_time", &self.last_refresh_time);
        debug_struct.field("primary_impact", &self.primary_impact);
        debug_struct.field("additional_impact", &self.additional_impact);
        debug_struct.field("priority", &self.priority);
        debug_struct.field("content", &self.content);
        debug_struct.field("state_info", &self.state_info);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("associated_insights", &self.associated_insights);
        debug_struct.field("xor_group_id", &self.xor_group_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Recommendation].
pub mod recommendation {
    #[allow(unused_imports)]
    use super::*;

    /// Reference to an associated insight.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsightReference {
        /// Insight resource name, e.g.
        /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/insights/[INSIGHT_ID]
        pub insight: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InsightReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [insight][crate::model::recommendation::InsightReference::insight].
        pub fn set_insight<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.insight = v.into();
            self
        }
    }

    impl wkt::message::Message for InsightReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recommender.v1.Recommendation.InsightReference"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InsightReference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __insight,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InsightReference")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "insight" => Ok(__FieldTag::__insight),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InsightReference;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InsightReference")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__insight => {
                                if !fields.insert(__FieldTag::__insight) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for insight",
                                    ));
                                }
                                result.insight = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InsightReference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.insight.is_empty() {
                state.serialize_entry("insight", &self.insight)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for InsightReference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("InsightReference");
            debug_struct.field("insight", &self.insight);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Recommendation priority levels.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Priority {
        /// Recommendation has unspecified priority.
        Unspecified,
        /// Recommendation has P4 priority (lowest priority).
        P4,
        /// Recommendation has P3 priority (second lowest priority).
        P3,
        /// Recommendation has P2 priority (second highest priority).
        P2,
        /// Recommendation has P1 priority (highest priority).
        P1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Priority::value] or
        /// [Priority::name].
        UnknownValue(priority::UnknownValue),
    }

    #[doc(hidden)]
    pub mod priority {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Priority {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::P4 => std::option::Option::Some(1),
                Self::P3 => std::option::Option::Some(2),
                Self::P2 => std::option::Option::Some(3),
                Self::P1 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIORITY_UNSPECIFIED"),
                Self::P4 => std::option::Option::Some("P4"),
                Self::P3 => std::option::Option::Some("P3"),
                Self::P2 => std::option::Option::Some("P2"),
                Self::P1 => std::option::Option::Some("P1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Priority {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Priority {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Priority {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::P4,
                2 => Self::P3,
                3 => Self::P2,
                4 => Self::P1,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Priority {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIORITY_UNSPECIFIED" => Self::Unspecified,
                "P4" => Self::P4,
                "P3" => Self::P3,
                "P2" => Self::P2,
                "P1" => Self::P1,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Priority {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::P4 => serializer.serialize_i32(1),
                Self::P3 => serializer.serialize_i32(2),
                Self::P2 => serializer.serialize_i32(3),
                Self::P1 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Priority {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Priority>::new(
                ".google.cloud.recommender.v1.Recommendation.Priority",
            ))
        }
    }
}

/// Contains what resources are changing and how they are changing.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecommendationContent {
    /// Operations to one or more Google Cloud resources grouped in such a way
    /// that, all operations within one group are expected to be performed
    /// atomically and in an order.
    pub operation_groups: std::vec::Vec<crate::model::OperationGroup>,

    /// Condensed overview information about the recommendation.
    pub overview: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommendationContent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_groups][crate::model::RecommendationContent::operation_groups].
    pub fn set_operation_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OperationGroup>,
    {
        use std::iter::Iterator;
        self.operation_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [overview][crate::model::RecommendationContent::overview].
    pub fn set_overview<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [overview][crate::model::RecommendationContent::overview].
    pub fn set_or_clear_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.overview = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecommendationContent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommendationContent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecommendationContent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_groups,
            __overview,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecommendationContent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationGroups" => Ok(__FieldTag::__operation_groups),
                            "operation_groups" => Ok(__FieldTag::__operation_groups),
                            "overview" => Ok(__FieldTag::__overview),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecommendationContent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecommendationContent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_groups => {
                            if !fields.insert(__FieldTag::__operation_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_groups",
                                ));
                            }
                            result.operation_groups =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OperationGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__overview => {
                            if !fields.insert(__FieldTag::__overview) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for overview",
                                ));
                            }
                            result.overview =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecommendationContent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_groups.is_empty() {
            state.serialize_entry("operationGroups", &self.operation_groups)?;
        }
        if self.overview.is_some() {
            state.serialize_entry("overview", &self.overview)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecommendationContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecommendationContent");
        debug_struct.field("operation_groups", &self.operation_groups);
        debug_struct.field("overview", &self.overview);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Group of operations that need to be performed atomically.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationGroup {
    /// List of operations across one or more resources that belong to this group.
    /// Loosely based on RFC6902 and should be performed in the order they appear.
    pub operations: std::vec::Vec<crate::model::Operation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::OperationGroup::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.OperationGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operations" => Ok(__FieldTag::__operations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Operation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationGroup");
        debug_struct.field("operations", &self.operations);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains an operation for a resource loosely based on the JSON-PATCH format
/// with support for:
///
/// * Custom filters for describing partial array patch.
/// * Extended path values for describing nested arrays.
/// * Custom fields for describing the resource for which the operation is being
///   described.
/// * Allows extension to custom operations not natively supported by RFC6902.
///   See <https://tools.ietf.org/html/rfc6902> for details on the original RFC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Operation {
    /// Type of this operation. Contains one of 'add', 'remove', 'replace', 'move',
    /// 'copy', 'test' and custom operations. This field is case-insensitive and
    /// always populated.
    pub action: std::string::String,

    /// Type of GCP resource being modified/tested. This field is always populated.
    /// Example: cloudresourcemanager.googleapis.com/Project,
    /// compute.googleapis.com/Instance
    pub resource_type: std::string::String,

    /// Contains the fully qualified resource name. This field is always populated.
    /// ex: //cloudresourcemanager.googleapis.com/projects/foo.
    pub resource: std::string::String,

    /// Path to the target field being operated on. If the operation is at the
    /// resource level, then path should be "/". This field is always populated.
    pub path: std::string::String,

    /// Can be set with action 'copy' to copy resource configuration across
    /// different resources of the same type. Example: A resource clone can be
    /// done via action = 'copy', path = "/", from = "/",
    /// source_resource = \<source\> and resource_name = \<target\>.
    /// This field is empty for all other values of `action`.
    pub source_resource: std::string::String,

    /// Can be set with action 'copy' or 'move' to indicate the source field within
    /// resource or source_resource, ignored if provided for other operation types.
    pub source_path: std::string::String,

    /// Set of filters to apply if `path` refers to array elements or nested array
    /// elements in order to narrow down to a single unique element that is being
    /// tested/modified.
    /// This is intended to be an exact match per filter. To perform advanced
    /// matching, use path_value_matchers.
    ///
    /// * Example:
    ///
    /// ```norust
    /// {
    ///   "/versions/*/name" : "it-123"
    ///   "/versions/*/targetSize/percent": 20
    /// }
    /// ```
    ///
    /// * Example:
    ///
    /// ```norust
    /// {
    ///   "/bindings/*/role": "roles/owner"
    ///   "/bindings/*/condition" : null
    /// }
    /// ```
    ///
    /// * Example:
    ///
    /// ```norust
    /// {
    ///   "/bindings/*/role": "roles/owner"
    ///   "/bindings/*/members/*" : ["x@example.com", "y@example.com"]
    /// }
    /// ```
    ///
    /// When both path_filters and path_value_matchers are set, an implicit AND
    /// must be performed.
    pub path_filters: std::collections::HashMap<std::string::String, wkt::Value>,

    /// Similar to path_filters, this contains set of filters to apply if `path`
    /// field refers to array elements. This is meant to support value matching
    /// beyond exact match. To perform exact match, use path_filters.
    /// When both path_filters and path_value_matchers are set, an implicit AND
    /// must be performed.
    pub path_value_matchers:
        std::collections::HashMap<std::string::String, crate::model::ValueMatcher>,

    /// One of the fields in the following block will be set and intend to
    /// describe a value for 'path' field.
    pub path_value: std::option::Option<crate::model::operation::PathValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::Operation::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::Operation::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::Operation::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Operation::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [source_resource][crate::model::Operation::source_resource].
    pub fn set_source_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_resource = v.into();
        self
    }

    /// Sets the value of [source_path][crate::model::Operation::source_path].
    pub fn set_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_path = v.into();
        self
    }

    /// Sets the value of [path_filters][crate::model::Operation::path_filters].
    pub fn set_path_filters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.path_filters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [path_value_matchers][crate::model::Operation::path_value_matchers].
    pub fn set_path_value_matchers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ValueMatcher>,
    {
        use std::iter::Iterator;
        self.path_value_matchers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [path_value][crate::model::Operation::path_value].
    ///
    /// Note that all the setters affecting `path_value` are mutually
    /// exclusive.
    pub fn set_path_value<
        T: std::convert::Into<std::option::Option<crate::model::operation::PathValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.path_value = v.into();
        self
    }

    /// The value of [path_value][crate::model::Operation::path_value]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value(&self) -> std::option::Option<&std::boxed::Box<wkt::Value>> {
        #[allow(unreachable_patterns)]
        self.path_value.as_ref().and_then(|v| match v {
            crate::model::operation::PathValue::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [path_value][crate::model::Operation::path_value]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `path_value` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<std::boxed::Box<wkt::Value>>>(mut self, v: T) -> Self {
        self.path_value =
            std::option::Option::Some(crate::model::operation::PathValue::Value(v.into()));
        self
    }

    /// The value of [path_value][crate::model::Operation::path_value]
    /// if it holds a `ValueMatcher`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value_matcher(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ValueMatcher>> {
        #[allow(unreachable_patterns)]
        self.path_value.as_ref().and_then(|v| match v {
            crate::model::operation::PathValue::ValueMatcher(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [path_value][crate::model::Operation::path_value]
    /// to hold a `ValueMatcher`.
    ///
    /// Note that all the setters affecting `path_value` are
    /// mutually exclusive.
    pub fn set_value_matcher<T: std::convert::Into<std::boxed::Box<crate::model::ValueMatcher>>>(
        mut self,
        v: T,
    ) -> Self {
        self.path_value =
            std::option::Option::Some(crate::model::operation::PathValue::ValueMatcher(v.into()));
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Operation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Operation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action,
            __resource_type,
            __resource,
            __path,
            __source_resource,
            __source_path,
            __value,
            __value_matcher,
            __path_filters,
            __path_value_matchers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Operation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "action" => Ok(__FieldTag::__action),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "resource" => Ok(__FieldTag::__resource),
                            "path" => Ok(__FieldTag::__path),
                            "sourceResource" => Ok(__FieldTag::__source_resource),
                            "source_resource" => Ok(__FieldTag::__source_resource),
                            "sourcePath" => Ok(__FieldTag::__source_path),
                            "source_path" => Ok(__FieldTag::__source_path),
                            "value" => Ok(__FieldTag::__value),
                            "valueMatcher" => Ok(__FieldTag::__value_matcher),
                            "value_matcher" => Ok(__FieldTag::__value_matcher),
                            "pathFilters" => Ok(__FieldTag::__path_filters),
                            "path_filters" => Ok(__FieldTag::__path_filters),
                            "pathValueMatchers" => Ok(__FieldTag::__path_value_matchers),
                            "path_value_matchers" => Ok(__FieldTag::__path_value_matchers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Operation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Operation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_resource => {
                            if !fields.insert(__FieldTag::__source_resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_resource",
                                ));
                            }
                            result.source_resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_path => {
                            if !fields.insert(__FieldTag::__source_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_path",
                                ));
                            }
                            result.source_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            if result.path_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `path_value`, a oneof with full ID .google.cloud.recommender.v1.Operation.value, latest field was value",
                                ));
                            }
                            result.path_value = std::option::Option::Some(
                                crate::model::operation::PathValue::Value(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Value>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__value_matcher => {
                            if !fields.insert(__FieldTag::__value_matcher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_matcher",
                                ));
                            }
                            if result.path_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `path_value`, a oneof with full ID .google.cloud.recommender.v1.Operation.value_matcher, latest field was valueMatcher",
                                ));
                            }
                            result.path_value = std::option::Option::Some(
                                crate::model::operation::PathValue::ValueMatcher(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ValueMatcher>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__path_filters => {
                            if !fields.insert(__FieldTag::__path_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path_filters",
                                ));
                            }
                            result.path_filters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path_value_matchers => {
                            if !fields.insert(__FieldTag::__path_value_matchers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path_value_matchers",
                                ));
                            }
                            result.path_value_matchers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ValueMatcher,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.source_resource.is_empty() {
            state.serialize_entry("sourceResource", &self.source_resource)?;
        }
        if !self.source_path.is_empty() {
            state.serialize_entry("sourcePath", &self.source_path)?;
        }
        if let Some(value) = self.value() {
            state.serialize_entry("value", value)?;
        }
        if let Some(value) = self.value_matcher() {
            state.serialize_entry("valueMatcher", value)?;
        }
        if !self.path_filters.is_empty() {
            state.serialize_entry("pathFilters", &self.path_filters)?;
        }
        if !self.path_value_matchers.is_empty() {
            state.serialize_entry("pathValueMatchers", &self.path_value_matchers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Operation");
        debug_struct.field("action", &self.action);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("path", &self.path);
        debug_struct.field("source_resource", &self.source_resource);
        debug_struct.field("source_path", &self.source_path);
        debug_struct.field("path_filters", &self.path_filters);
        debug_struct.field("path_value_matchers", &self.path_value_matchers);
        debug_struct.field("path_value", &self.path_value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// One of the fields in the following block will be set and intend to
    /// describe a value for 'path' field.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PathValue {
        /// Value for the `path` field. Will be set for actions:'add'/'replace'.
        /// Maybe set for action: 'test'. Either this or `value_matcher` will be set
        /// for 'test' operation. An exact match must be performed.
        Value(std::boxed::Box<wkt::Value>),
        /// Can be set for action 'test' for advanced matching for the value of
        /// 'path' field. Either this or `value` will be set for 'test' operation.
        ValueMatcher(std::boxed::Box<crate::model::ValueMatcher>),
    }
}

/// Contains various matching options for values for a GCP resource field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValueMatcher {
    pub match_variant: std::option::Option<crate::model::value_matcher::MatchVariant>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [match_variant][crate::model::ValueMatcher::match_variant].
    ///
    /// Note that all the setters affecting `match_variant` are mutually
    /// exclusive.
    pub fn set_match_variant<
        T: std::convert::Into<std::option::Option<crate::model::value_matcher::MatchVariant>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.match_variant = v.into();
        self
    }

    /// The value of [match_variant][crate::model::ValueMatcher::match_variant]
    /// if it holds a `MatchesPattern`, `None` if the field is not set or
    /// holds a different branch.
    pub fn matches_pattern(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.match_variant.as_ref().and_then(|v| match v {
            crate::model::value_matcher::MatchVariant::MatchesPattern(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [match_variant][crate::model::ValueMatcher::match_variant]
    /// to hold a `MatchesPattern`.
    ///
    /// Note that all the setters affecting `match_variant` are
    /// mutually exclusive.
    pub fn set_matches_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.match_variant = std::option::Option::Some(
            crate::model::value_matcher::MatchVariant::MatchesPattern(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ValueMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ValueMatcher"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValueMatcher {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __matches_pattern,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValueMatcher")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "matchesPattern" => Ok(__FieldTag::__matches_pattern),
                            "matches_pattern" => Ok(__FieldTag::__matches_pattern),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValueMatcher;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValueMatcher")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__matches_pattern => {
                            if !fields.insert(__FieldTag::__matches_pattern) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matches_pattern",
                                ));
                            }
                            if result.match_variant.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `match_variant`, a oneof with full ID .google.cloud.recommender.v1.ValueMatcher.matches_pattern, latest field was matchesPattern",
                                ));
                            }
                            result.match_variant = std::option::Option::Some(
                                crate::model::value_matcher::MatchVariant::MatchesPattern(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValueMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.matches_pattern() {
            state.serialize_entry("matchesPattern", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValueMatcher {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValueMatcher");
        debug_struct.field("match_variant", &self.match_variant);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ValueMatcher].
pub mod value_matcher {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MatchVariant {
        /// To be used for full regex matching. The regular expression is using the
        /// Google RE2 syntax (<https://github.com/google/re2/wiki/Syntax>), so to be
        /// used with RE2::FullMatch
        MatchesPattern(std::string::String),
    }
}

/// Contains metadata about how much money a recommendation can save or incur.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CostProjection {
    /// An approximate projection on amount saved or amount incurred. Negative cost
    /// units indicate cost savings and positive cost units indicate increase.
    /// See google.type.Money documentation for positive/negative units.
    ///
    /// A user's permissions may affect whether the cost is computed using list
    /// prices or custom contract prices.
    pub cost: std::option::Option<gtype::model::Money>,

    /// Duration for which this cost applies.
    pub duration: std::option::Option<wkt::Duration>,

    /// The approximate cost savings in the billing account's local currency.
    pub cost_in_local_currency: std::option::Option<gtype::model::Money>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CostProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cost][crate::model::CostProjection::cost].
    pub fn set_cost<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost][crate::model::CostProjection::cost].
    pub fn set_or_clear_cost<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost = v.map(|x| x.into());
        self
    }

    /// Sets the value of [duration][crate::model::CostProjection::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::CostProjection::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cost_in_local_currency][crate::model::CostProjection::cost_in_local_currency].
    pub fn set_cost_in_local_currency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost_in_local_currency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost_in_local_currency][crate::model::CostProjection::cost_in_local_currency].
    pub fn set_or_clear_cost_in_local_currency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost_in_local_currency = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CostProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.CostProjection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CostProjection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cost,
            __duration,
            __cost_in_local_currency,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CostProjection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cost" => Ok(__FieldTag::__cost),
                            "duration" => Ok(__FieldTag::__duration),
                            "costInLocalCurrency" => Ok(__FieldTag::__cost_in_local_currency),
                            "cost_in_local_currency" => Ok(__FieldTag::__cost_in_local_currency),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CostProjection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CostProjection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cost => {
                            if !fields.insert(__FieldTag::__cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost",
                                ));
                            }
                            result.cost =
                                map.next_value::<std::option::Option<gtype::model::Money>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__cost_in_local_currency => {
                            if !fields.insert(__FieldTag::__cost_in_local_currency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_in_local_currency",
                                ));
                            }
                            result.cost_in_local_currency =
                                map.next_value::<std::option::Option<gtype::model::Money>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CostProjection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cost.is_some() {
            state.serialize_entry("cost", &self.cost)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.cost_in_local_currency.is_some() {
            state.serialize_entry("costInLocalCurrency", &self.cost_in_local_currency)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CostProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CostProjection");
        debug_struct.field("cost", &self.cost);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("cost_in_local_currency", &self.cost_in_local_currency);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains various ways of describing the impact on Security.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityProjection {
    /// Additional security impact details that is provided by the recommender.
    pub details: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::SecurityProjection::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::SecurityProjection::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SecurityProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.SecurityProjection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityProjection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityProjection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityProjection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityProjection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityProjection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecurityProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityProjection");
        debug_struct.field("details", &self.details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains metadata about how much sustainability a recommendation can save or
/// incur.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SustainabilityProjection {
    /// Carbon Footprint generated in kg of CO2 equivalent.
    /// Chose kg_c_o2e so that the name renders correctly in camelCase (kgCO2e).
    pub kg_c_o2e: f64,

    /// Duration for which this sustainability applies.
    pub duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SustainabilityProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kg_c_o2e][crate::model::SustainabilityProjection::kg_c_o2e].
    pub fn set_kg_c_o2e<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.kg_c_o2e = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::SustainabilityProjection::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::SustainabilityProjection::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SustainabilityProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.SustainabilityProjection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SustainabilityProjection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kg_c_o2e,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SustainabilityProjection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kgCO2e" => Ok(__FieldTag::__kg_c_o2e),
                            "kg_c_o2e" => Ok(__FieldTag::__kg_c_o2e),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SustainabilityProjection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SustainabilityProjection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kg_c_o2e => {
                            if !fields.insert(__FieldTag::__kg_c_o2e) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kg_c_o2e",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.kg_c_o2e = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SustainabilityProjection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.kg_c_o2e) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("kgCO2e", &__With(&self.kg_c_o2e))?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SustainabilityProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SustainabilityProjection");
        debug_struct.field("kg_c_o2e", &self.kg_c_o2e);
        debug_struct.field("duration", &self.duration);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information on the impact of a reliability recommendation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReliabilityProjection {
    /// Reliability risks mitigated by this recommendation.
    pub risks: std::vec::Vec<crate::model::reliability_projection::RiskType>,

    /// Per-recommender projection.
    pub details: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReliabilityProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [risks][crate::model::ReliabilityProjection::risks].
    pub fn set_risks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::reliability_projection::RiskType>,
    {
        use std::iter::Iterator;
        self.risks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [details][crate::model::ReliabilityProjection::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::ReliabilityProjection::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReliabilityProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ReliabilityProjection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReliabilityProjection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __risks,
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReliabilityProjection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "risks" => Ok(__FieldTag::__risks),
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReliabilityProjection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReliabilityProjection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__risks => {
                            if !fields.insert(__FieldTag::__risks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for risks",
                                ));
                            }
                            result.risks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::reliability_projection::RiskType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReliabilityProjection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.risks.is_empty() {
            state.serialize_entry("risks", &self.risks)?;
        }
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReliabilityProjection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReliabilityProjection");
        debug_struct.field("risks", &self.risks);
        debug_struct.field("details", &self.details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReliabilityProjection].
pub mod reliability_projection {
    #[allow(unused_imports)]
    use super::*;

    /// The risk associated with the reliability issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RiskType {
        /// Default unspecified risk. Don't use directly.
        Unspecified,
        /// Potential service downtime.
        ServiceDisruption,
        /// Potential data loss.
        DataLoss,
        /// Potential access denial. The service is still up but some or all clients
        /// can't access it.
        AccessDeny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RiskType::value] or
        /// [RiskType::name].
        UnknownValue(risk_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod risk_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RiskType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServiceDisruption => std::option::Option::Some(1),
                Self::DataLoss => std::option::Option::Some(2),
                Self::AccessDeny => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RISK_TYPE_UNSPECIFIED"),
                Self::ServiceDisruption => std::option::Option::Some("SERVICE_DISRUPTION"),
                Self::DataLoss => std::option::Option::Some("DATA_LOSS"),
                Self::AccessDeny => std::option::Option::Some("ACCESS_DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RiskType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RiskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RiskType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServiceDisruption,
                2 => Self::DataLoss,
                3 => Self::AccessDeny,
                _ => Self::UnknownValue(risk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RiskType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RISK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVICE_DISRUPTION" => Self::ServiceDisruption,
                "DATA_LOSS" => Self::DataLoss,
                "ACCESS_DENY" => Self::AccessDeny,
                _ => Self::UnknownValue(risk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RiskType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServiceDisruption => serializer.serialize_i32(1),
                Self::DataLoss => serializer.serialize_i32(2),
                Self::AccessDeny => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RiskType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RiskType>::new(
                ".google.cloud.recommender.v1.ReliabilityProjection.RiskType",
            ))
        }
    }
}

/// Contains the impact a recommendation can have for a given category.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Impact {
    /// Category that is being targeted.
    pub category: crate::model::impact::Category,

    /// Contains projections (if any) for this category.
    pub projection: std::option::Option<crate::model::impact::Projection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Impact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::Impact::category].
    pub fn set_category<T: std::convert::Into<crate::model::impact::Category>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [projection][crate::model::Impact::projection].
    ///
    /// Note that all the setters affecting `projection` are mutually
    /// exclusive.
    pub fn set_projection<
        T: std::convert::Into<std::option::Option<crate::model::impact::Projection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = v.into();
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `CostProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cost_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CostProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::CostProjection(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `CostProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_cost_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::CostProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection =
            std::option::Option::Some(crate::model::impact::Projection::CostProjection(v.into()));
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `SecurityProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn security_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecurityProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::SecurityProjection(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `SecurityProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_security_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::SecurityProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = std::option::Option::Some(
            crate::model::impact::Projection::SecurityProjection(v.into()),
        );
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `SustainabilityProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sustainability_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SustainabilityProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::SustainabilityProjection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `SustainabilityProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_sustainability_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::SustainabilityProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = std::option::Option::Some(
            crate::model::impact::Projection::SustainabilityProjection(v.into()),
        );
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `ReliabilityProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn reliability_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReliabilityProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::ReliabilityProjection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `ReliabilityProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_reliability_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::ReliabilityProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = std::option::Option::Some(
            crate::model::impact::Projection::ReliabilityProjection(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Impact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Impact"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Impact {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __category,
            __cost_projection,
            __security_projection,
            __sustainability_projection,
            __reliability_projection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Impact")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "category" => Ok(__FieldTag::__category),
                            "costProjection" => Ok(__FieldTag::__cost_projection),
                            "cost_projection" => Ok(__FieldTag::__cost_projection),
                            "securityProjection" => Ok(__FieldTag::__security_projection),
                            "security_projection" => Ok(__FieldTag::__security_projection),
                            "sustainabilityProjection" => {
                                Ok(__FieldTag::__sustainability_projection)
                            }
                            "sustainability_projection" => {
                                Ok(__FieldTag::__sustainability_projection)
                            }
                            "reliabilityProjection" => Ok(__FieldTag::__reliability_projection),
                            "reliability_projection" => Ok(__FieldTag::__reliability_projection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Impact;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Impact")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category = map
                                .next_value::<std::option::Option<crate::model::impact::Category>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cost_projection => {
                            if !fields.insert(__FieldTag::__cost_projection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_projection",
                                ));
                            }
                            if result.projection.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `projection`, a oneof with full ID .google.cloud.recommender.v1.Impact.cost_projection, latest field was costProjection",
                                ));
                            }
                            result.projection = std::option::Option::Some(
                                crate::model::impact::Projection::CostProjection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CostProjection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__security_projection => {
                            if !fields.insert(__FieldTag::__security_projection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_projection",
                                ));
                            }
                            if result.projection.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `projection`, a oneof with full ID .google.cloud.recommender.v1.Impact.security_projection, latest field was securityProjection",
                                ));
                            }
                            result.projection = std::option::Option::Some(
                                crate::model::impact::Projection::SecurityProjection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SecurityProjection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sustainability_projection => {
                            if !fields.insert(__FieldTag::__sustainability_projection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sustainability_projection",
                                ));
                            }
                            if result.projection.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `projection`, a oneof with full ID .google.cloud.recommender.v1.Impact.sustainability_projection, latest field was sustainabilityProjection",
                                ));
                            }
                            result.projection = std::option::Option::Some(
                                crate::model::impact::Projection::SustainabilityProjection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SustainabilityProjection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__reliability_projection => {
                            if !fields.insert(__FieldTag::__reliability_projection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reliability_projection",
                                ));
                            }
                            if result.projection.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `projection`, a oneof with full ID .google.cloud.recommender.v1.Impact.reliability_projection, latest field was reliabilityProjection",
                                ));
                            }
                            result.projection = std::option::Option::Some(
                                crate::model::impact::Projection::ReliabilityProjection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReliabilityProjection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Impact {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.category) {
            state.serialize_entry("category", &self.category)?;
        }
        if let Some(value) = self.cost_projection() {
            state.serialize_entry("costProjection", value)?;
        }
        if let Some(value) = self.security_projection() {
            state.serialize_entry("securityProjection", value)?;
        }
        if let Some(value) = self.sustainability_projection() {
            state.serialize_entry("sustainabilityProjection", value)?;
        }
        if let Some(value) = self.reliability_projection() {
            state.serialize_entry("reliabilityProjection", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Impact {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Impact");
        debug_struct.field("category", &self.category);
        debug_struct.field("projection", &self.projection);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Impact].
pub mod impact {
    #[allow(unused_imports)]
    use super::*;

    /// The category of the impact.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Category {
        /// Default unspecified category. Don't use directly.
        Unspecified,
        /// Indicates a potential increase or decrease in cost.
        Cost,
        /// Indicates a potential increase or decrease in security.
        Security,
        /// Indicates a potential increase or decrease in performance.
        Performance,
        /// Indicates a potential increase or decrease in manageability.
        Manageability,
        /// Indicates a potential increase or decrease in sustainability.
        Sustainability,
        /// Indicates a potential increase or decrease in reliability.
        Reliability,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Category::value] or
        /// [Category::name].
        UnknownValue(category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Category {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cost => std::option::Option::Some(1),
                Self::Security => std::option::Option::Some(2),
                Self::Performance => std::option::Option::Some(3),
                Self::Manageability => std::option::Option::Some(4),
                Self::Sustainability => std::option::Option::Some(5),
                Self::Reliability => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CATEGORY_UNSPECIFIED"),
                Self::Cost => std::option::Option::Some("COST"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::Performance => std::option::Option::Some("PERFORMANCE"),
                Self::Manageability => std::option::Option::Some("MANAGEABILITY"),
                Self::Sustainability => std::option::Option::Some("SUSTAINABILITY"),
                Self::Reliability => std::option::Option::Some("RELIABILITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Category {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Category {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Category {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cost,
                2 => Self::Security,
                3 => Self::Performance,
                4 => Self::Manageability,
                5 => Self::Sustainability,
                6 => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Category {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "COST" => Self::Cost,
                "SECURITY" => Self::Security,
                "PERFORMANCE" => Self::Performance,
                "MANAGEABILITY" => Self::Manageability,
                "SUSTAINABILITY" => Self::Sustainability,
                "RELIABILITY" => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Category {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cost => serializer.serialize_i32(1),
                Self::Security => serializer.serialize_i32(2),
                Self::Performance => serializer.serialize_i32(3),
                Self::Manageability => serializer.serialize_i32(4),
                Self::Sustainability => serializer.serialize_i32(5),
                Self::Reliability => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Category {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Category>::new(
                ".google.cloud.recommender.v1.Impact.Category",
            ))
        }
    }

    /// Contains projections (if any) for this category.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Projection {
        /// Use with CategoryType.COST
        CostProjection(std::boxed::Box<crate::model::CostProjection>),
        /// Use with CategoryType.SECURITY
        SecurityProjection(std::boxed::Box<crate::model::SecurityProjection>),
        /// Use with CategoryType.SUSTAINABILITY
        SustainabilityProjection(std::boxed::Box<crate::model::SustainabilityProjection>),
        /// Use with CategoryType.RELIABILITY
        ReliabilityProjection(std::boxed::Box<crate::model::ReliabilityProjection>),
    }
}

/// Information for state. Contains state and metadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecommendationStateInfo {
    /// The state of the recommendation, Eg ACTIVE, SUCCEEDED, FAILED.
    pub state: crate::model::recommendation_state_info::State,

    /// A map of metadata for the state, provided by user or automations systems.
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommendationStateInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::RecommendationStateInfo::state].
    pub fn set_state<T: std::convert::Into<crate::model::recommendation_state_info::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::RecommendationStateInfo::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RecommendationStateInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommendationStateInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecommendationStateInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __state_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecommendationStateInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "stateMetadata" => Ok(__FieldTag::__state_metadata),
                            "state_metadata" => Ok(__FieldTag::__state_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecommendationStateInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecommendationStateInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::recommendation_state_info::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_metadata => {
                            if !fields.insert(__FieldTag::__state_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_metadata",
                                ));
                            }
                            result.state_metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecommendationStateInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_metadata.is_empty() {
            state.serialize_entry("stateMetadata", &self.state_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecommendationStateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecommendationStateInfo");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_metadata", &self.state_metadata);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RecommendationStateInfo].
pub mod recommendation_state_info {
    #[allow(unused_imports)]
    use super::*;

    /// Represents Recommendation State.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default state. Don't use directly.
        Unspecified,
        /// Recommendation is active and can be applied. Recommendations content can
        /// be updated by Google.
        ///
        /// ACTIVE recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
        Active,
        /// Recommendation is in claimed state. Recommendations content is
        /// immutable and cannot be updated by Google.
        ///
        /// CLAIMED recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
        Claimed,
        /// Recommendation is in succeeded state. Recommendations content is
        /// immutable and cannot be updated by Google.
        ///
        /// SUCCEEDED recommendations can be marked as SUCCEEDED, or FAILED.
        Succeeded,
        /// Recommendation is in failed state. Recommendations content is immutable
        /// and cannot be updated by Google.
        ///
        /// FAILED recommendations can be marked as SUCCEEDED, or FAILED.
        Failed,
        /// Recommendation is in dismissed state. Recommendation content can be
        /// updated by Google.
        ///
        /// DISMISSED recommendations can be marked as ACTIVE.
        Dismissed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Claimed => std::option::Option::Some(6),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Dismissed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Claimed => std::option::Option::Some("CLAIMED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Dismissed => std::option::Option::Some("DISMISSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Dismissed,
                6 => Self::Claimed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CLAIMED" => Self::Claimed,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "DISMISSED" => Self::Dismissed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Claimed => serializer.serialize_i32(6),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Dismissed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.recommender.v1.RecommendationStateInfo.State",
            ))
        }
    }
}

/// Configuration for a Recommender.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecommenderConfig {
    /// Name of recommender config.
    /// Eg,
    /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config
    pub name: std::string::String,

    /// RecommenderGenerationConfig which configures the Generation of
    /// recommendations for this recommender.
    pub recommender_generation_config:
        std::option::Option<crate::model::RecommenderGenerationConfig>,

    /// Fingerprint of the RecommenderConfig. Provides optimistic locking when
    /// updating.
    pub etag: std::string::String,

    /// Last time when the config was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Immutable. The revision ID of the config.
    /// A new revision is committed whenever the config is changed in any way.
    /// The format is an 8-character hexadecimal string.
    pub revision_id: std::string::String,

    /// Allows clients to store small amounts of arbitrary data. Annotations must
    /// follow the Kubernetes syntax.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// A user-settable field to provide a human-readable name to be used in user
    /// interfaces.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommenderConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RecommenderConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [recommender_generation_config][crate::model::RecommenderConfig::recommender_generation_config].
    pub fn set_recommender_generation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderGenerationConfig>,
    {
        self.recommender_generation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recommender_generation_config][crate::model::RecommenderConfig::recommender_generation_config].
    pub fn set_or_clear_recommender_generation_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderGenerationConfig>,
    {
        self.recommender_generation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::RecommenderConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::RecommenderConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::RecommenderConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision_id][crate::model::RecommenderConfig::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::RecommenderConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::RecommenderConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for RecommenderConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommenderConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecommenderConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __recommender_generation_config,
            __etag,
            __update_time,
            __revision_id,
            __annotations,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecommenderConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "recommenderGenerationConfig" => {
                                Ok(__FieldTag::__recommender_generation_config)
                            }
                            "recommender_generation_config" => {
                                Ok(__FieldTag::__recommender_generation_config)
                            }
                            "etag" => Ok(__FieldTag::__etag),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecommenderConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecommenderConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recommender_generation_config => {
                            if !fields.insert(__FieldTag::__recommender_generation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recommender_generation_config",
                                ));
                            }
                            result.recommender_generation_config = map.next_value::<std::option::Option<crate::model::RecommenderGenerationConfig>>()?
                                ;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecommenderConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.recommender_generation_config.is_some() {
            state.serialize_entry(
                "recommenderGenerationConfig",
                &self.recommender_generation_config,
            )?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecommenderConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecommenderConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field(
            "recommender_generation_config",
            &self.recommender_generation_config,
        );
        debug_struct.field("etag", &self.etag);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("display_name", &self.display_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Configuration to customize the generation of recommendations.
/// Eg, customizing the lookback period considered when generating a
/// recommendation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecommenderGenerationConfig {
    /// Parameters for this RecommenderGenerationConfig. These configs can be used
    /// by or are applied to all subtypes.
    pub params: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommenderGenerationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [params][crate::model::RecommenderGenerationConfig::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::RecommenderGenerationConfig::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecommenderGenerationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommenderGenerationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecommenderGenerationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecommenderGenerationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "params" => Ok(__FieldTag::__params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecommenderGenerationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecommenderGenerationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__params => {
                            if !fields.insert(__FieldTag::__params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for params",
                                ));
                            }
                            result.params = map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecommenderGenerationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecommenderGenerationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecommenderGenerationConfig");
        debug_struct.field("params", &self.params);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListInsights` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInsightsRequest {
    /// Required. The container resource on which to execute the request.
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `folders/[FOLDER_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    ///
    /// LOCATION here refers to GCP Locations:
    /// <https://cloud.google.com/about/locations/>
    /// INSIGHT_TYPE_ID refers to supported insight types:
    /// <https://cloud.google.com/recommender/docs/insights/insight-types>.
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. If not specified, the server will
    /// determine the number of results to return.
    pub page_size: i32,

    /// Optional. If present, retrieves the next batch of results from the
    /// preceding call to this method. `page_token` must be the value of
    /// `next_page_token` from the previous response. The values of other method
    /// parameters must be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Optional. Filter expression to restrict the insights returned. Supported
    /// filter fields:
    ///
    /// * `stateInfo.state`
    ///
    /// * `insightSubtype`
    ///
    /// * `severity`
    ///
    /// * `targetResources`
    ///
    ///
    /// Examples:
    ///
    /// * `stateInfo.state = ACTIVE OR stateInfo.state = DISMISSED`
    ///
    /// * `insightSubtype = PERMISSIONS_USAGE`
    ///
    /// * `severity = CRITICAL OR severity = HIGH`
    ///
    /// * `targetResources :
    ///   //compute.googleapis.com/projects/1234/zones/us-central1-a/instances/instance-1`
    ///
    /// * `stateInfo.state = ACTIVE AND (severity = CRITICAL OR severity = HIGH)`
    ///
    ///
    /// The max allowed filter length is 500 characters.
    ///
    /// (These expressions are based on the filter language described at
    /// <https://google.aip.dev/160>)
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInsightsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInsightsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInsightsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInsightsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInsightsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInsightsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListInsightsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInsightsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInsightsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInsightsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInsightsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInsightsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInsightsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInsightsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to the `ListInsights` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInsightsResponse {
    /// The set of insights for the `parent` resource.
    pub insights: std::vec::Vec<crate::model::Insight>,

    /// A token that can be used to request the next page of results. This field is
    /// empty if there are no additional results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInsightsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insights][crate::model::ListInsightsResponse::insights].
    pub fn set_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Insight>,
    {
        use std::iter::Iterator;
        self.insights = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInsightsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInsightsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListInsightsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInsightsResponse {
    type PageItem = crate::model::Insight;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.insights
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInsightsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __insights,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInsightsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insights" => Ok(__FieldTag::__insights),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInsightsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInsightsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__insights => {
                            if !fields.insert(__FieldTag::__insights) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights",
                                ));
                            }
                            result.insights = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Insight>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInsightsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.insights.is_empty() {
            state.serialize_entry("insights", &self.insights)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListInsightsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInsightsResponse");
        debug_struct.field("insights", &self.insights);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to the `GetInsight` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInsightRequest {
    /// Required. Name of the insight.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInsightRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInsightRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInsightRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetInsightRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInsightRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInsightRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInsightRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInsightRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInsightRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetInsightRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInsightRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `MarkInsightAccepted` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MarkInsightAcceptedRequest {
    /// Required. Name of the insight.
    pub name: std::string::String,

    /// Optional. State properties user wish to include with this state.  Full
    /// replace of the current state_metadata.
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Insight. Provides optimistic locking.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkInsightAcceptedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkInsightAcceptedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkInsightAcceptedRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkInsightAcceptedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkInsightAcceptedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkInsightAcceptedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MarkInsightAcceptedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state_metadata,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MarkInsightAcceptedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "stateMetadata" => Ok(__FieldTag::__state_metadata),
                            "state_metadata" => Ok(__FieldTag::__state_metadata),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MarkInsightAcceptedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MarkInsightAcceptedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_metadata => {
                            if !fields.insert(__FieldTag::__state_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_metadata",
                                ));
                            }
                            result.state_metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MarkInsightAcceptedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.state_metadata.is_empty() {
            state.serialize_entry("stateMetadata", &self.state_metadata)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MarkInsightAcceptedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MarkInsightAcceptedRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("state_metadata", &self.state_metadata);
        debug_struct.field("etag", &self.etag);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `ListRecommendations` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRecommendationsRequest {
    /// Required. The container resource on which to execute the request.
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `folders/[FOLDER_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    ///
    /// LOCATION here refers to GCP Locations:
    /// <https://cloud.google.com/about/locations/>
    /// RECOMMENDER_ID refers to supported recommenders:
    /// <https://cloud.google.com/recommender/docs/recommenders>.
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. If not specified, the server will
    /// determine the number of results to return.
    pub page_size: i32,

    /// Optional. If present, retrieves the next batch of results from the
    /// preceding call to this method. `page_token` must be the value of
    /// `next_page_token` from the previous response. The values of other method
    /// parameters must be identical to those in the previous call.
    pub page_token: std::string::String,

    /// Filter expression to restrict the recommendations returned. Supported
    /// filter fields:
    ///
    /// * `state_info.state`
    ///
    /// * `recommenderSubtype`
    ///
    /// * `priority`
    ///
    /// * `targetResources`
    ///
    ///
    /// Examples:
    ///
    /// * `stateInfo.state = ACTIVE OR stateInfo.state = DISMISSED`
    ///
    /// * `recommenderSubtype = REMOVE_ROLE OR recommenderSubtype = REPLACE_ROLE`
    ///
    /// * `priority = P1 OR priority = P2`
    ///
    /// * `targetResources :
    ///   //compute.googleapis.com/projects/1234/zones/us-central1-a/instances/instance-1`
    ///
    /// * `stateInfo.state = ACTIVE AND (priority = P1 OR priority = P2)`
    ///
    ///
    /// The max allowed filter length is 500 characters.
    ///
    /// (These expressions are based on the filter language described at
    /// <https://google.aip.dev/160>)
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecommendationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRecommendationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRecommendationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRecommendationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRecommendationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRecommendationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListRecommendationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRecommendationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRecommendationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRecommendationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRecommendationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRecommendationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRecommendationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRecommendationsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to the `ListRecommendations` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRecommendationsResponse {
    /// The set of recommendations for the `parent` resource.
    pub recommendations: std::vec::Vec<crate::model::Recommendation>,

    /// A token that can be used to request the next page of results. This field is
    /// empty if there are no additional results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecommendationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recommendations][crate::model::ListRecommendationsResponse::recommendations].
    pub fn set_recommendations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Recommendation>,
    {
        use std::iter::Iterator;
        self.recommendations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRecommendationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRecommendationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListRecommendationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRecommendationsResponse {
    type PageItem = crate::model::Recommendation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.recommendations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRecommendationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recommendations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRecommendationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recommendations" => Ok(__FieldTag::__recommendations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRecommendationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRecommendationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recommendations => {
                            if !fields.insert(__FieldTag::__recommendations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recommendations",
                                ));
                            }
                            result.recommendations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::Recommendation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRecommendationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.recommendations.is_empty() {
            state.serialize_entry("recommendations", &self.recommendations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListRecommendationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRecommendationsResponse");
        debug_struct.field("recommendations", &self.recommendations);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to the `GetRecommendation` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRecommendationRequest {
    /// Required. Name of the recommendation.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRecommendationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRecommendationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRecommendationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetRecommendationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRecommendationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRecommendationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRecommendationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRecommendationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRecommendationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetRecommendationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRecommendationRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `MarkRecommendationDismissed` Method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MarkRecommendationDismissedRequest {
    /// Required. Name of the recommendation.
    pub name: std::string::String,

    /// Fingerprint of the Recommendation. Provides optimistic locking.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationDismissedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationDismissedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationDismissedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationDismissedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationDismissedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MarkRecommendationDismissedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MarkRecommendationDismissedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MarkRecommendationDismissedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MarkRecommendationDismissedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MarkRecommendationDismissedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MarkRecommendationDismissedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MarkRecommendationDismissedRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("etag", &self.etag);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `MarkRecommendationClaimed` Method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MarkRecommendationClaimedRequest {
    /// Required. Name of the recommendation.
    pub name: std::string::String,

    /// State properties to include with this state. Overwrites any existing
    /// `state_metadata`.
    /// Keys must match the regex `/^[a-z0-9][a-z0-9_.-]{0,62}$/`.
    /// Values must match the regex `/^[a-zA-Z0-9_./-]{0,255}$/`.
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Recommendation. Provides optimistic locking.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationClaimedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationClaimedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkRecommendationClaimedRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationClaimedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationClaimedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationClaimedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MarkRecommendationClaimedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state_metadata,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MarkRecommendationClaimedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "stateMetadata" => Ok(__FieldTag::__state_metadata),
                            "state_metadata" => Ok(__FieldTag::__state_metadata),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MarkRecommendationClaimedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MarkRecommendationClaimedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_metadata => {
                            if !fields.insert(__FieldTag::__state_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_metadata",
                                ));
                            }
                            result.state_metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MarkRecommendationClaimedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.state_metadata.is_empty() {
            state.serialize_entry("stateMetadata", &self.state_metadata)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MarkRecommendationClaimedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MarkRecommendationClaimedRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("state_metadata", &self.state_metadata);
        debug_struct.field("etag", &self.etag);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `MarkRecommendationSucceeded` Method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MarkRecommendationSucceededRequest {
    /// Required. Name of the recommendation.
    pub name: std::string::String,

    /// State properties to include with this state. Overwrites any existing
    /// `state_metadata`.
    /// Keys must match the regex `/^[a-z0-9][a-z0-9_.-]{0,62}$/`.
    /// Values must match the regex `/^[a-zA-Z0-9_./-]{0,255}$/`.
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Recommendation. Provides optimistic locking.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationSucceededRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationSucceededRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkRecommendationSucceededRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationSucceededRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationSucceededRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationSucceededRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MarkRecommendationSucceededRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state_metadata,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MarkRecommendationSucceededRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "stateMetadata" => Ok(__FieldTag::__state_metadata),
                            "state_metadata" => Ok(__FieldTag::__state_metadata),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MarkRecommendationSucceededRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MarkRecommendationSucceededRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_metadata => {
                            if !fields.insert(__FieldTag::__state_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_metadata",
                                ));
                            }
                            result.state_metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MarkRecommendationSucceededRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.state_metadata.is_empty() {
            state.serialize_entry("stateMetadata", &self.state_metadata)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MarkRecommendationSucceededRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MarkRecommendationSucceededRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("state_metadata", &self.state_metadata);
        debug_struct.field("etag", &self.etag);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `MarkRecommendationFailed` Method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MarkRecommendationFailedRequest {
    /// Required. Name of the recommendation.
    pub name: std::string::String,

    /// State properties to include with this state. Overwrites any existing
    /// `state_metadata`.
    /// Keys must match the regex `/^[a-z0-9][a-z0-9_.-]{0,62}$/`.
    /// Values must match the regex `/^[a-zA-Z0-9_./-]{0,255}$/`.
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Recommendation. Provides optimistic locking.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationFailedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationFailedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkRecommendationFailedRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationFailedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationFailedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationFailedRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MarkRecommendationFailedRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state_metadata,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MarkRecommendationFailedRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "stateMetadata" => Ok(__FieldTag::__state_metadata),
                            "state_metadata" => Ok(__FieldTag::__state_metadata),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MarkRecommendationFailedRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MarkRecommendationFailedRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_metadata => {
                            if !fields.insert(__FieldTag::__state_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_metadata",
                                ));
                            }
                            result.state_metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MarkRecommendationFailedRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.state_metadata.is_empty() {
            state.serialize_entry("stateMetadata", &self.state_metadata)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MarkRecommendationFailedRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MarkRecommendationFailedRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("state_metadata", &self.state_metadata);
        debug_struct.field("etag", &self.etag);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the GetRecommenderConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRecommenderConfigRequest {
    /// Required. Name of the Recommendation Config to get.
    ///
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRecommenderConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRecommenderConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRecommenderConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetRecommenderConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRecommenderConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRecommenderConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRecommenderConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRecommenderConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRecommenderConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetRecommenderConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRecommenderConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `UpdateRecommenderConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRecommenderConfigRequest {
    /// Required. The RecommenderConfig to update.
    pub recommender_config: std::option::Option<crate::model::RecommenderConfig>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If true, validate the request and preview the change, but do not actually
    /// update it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRecommenderConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recommender_config][crate::model::UpdateRecommenderConfigRequest::recommender_config].
    pub fn set_recommender_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderConfig>,
    {
        self.recommender_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recommender_config][crate::model::UpdateRecommenderConfigRequest::recommender_config].
    pub fn set_or_clear_recommender_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderConfig>,
    {
        self.recommender_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRecommenderConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRecommenderConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateRecommenderConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRecommenderConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.UpdateRecommenderConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRecommenderConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recommender_config,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRecommenderConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recommenderConfig" => Ok(__FieldTag::__recommender_config),
                            "recommender_config" => Ok(__FieldTag::__recommender_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRecommenderConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRecommenderConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recommender_config => {
                            if !fields.insert(__FieldTag::__recommender_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recommender_config",
                                ));
                            }
                            result.recommender_config = map
                                .next_value::<std::option::Option<crate::model::RecommenderConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRecommenderConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.recommender_config.is_some() {
            state.serialize_entry("recommenderConfig", &self.recommender_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateRecommenderConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateRecommenderConfigRequest");
        debug_struct.field("recommender_config", &self.recommender_config);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the GetInsightTypeConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInsightTypeConfigRequest {
    /// Required. Name of the InsightTypeConfig to get.
    ///
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInsightTypeConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInsightTypeConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInsightTypeConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetInsightTypeConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInsightTypeConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInsightTypeConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInsightTypeConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInsightTypeConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInsightTypeConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetInsightTypeConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInsightTypeConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for the `UpdateInsightTypeConfig` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInsightTypeConfigRequest {
    /// Required. The InsightTypeConfig to update.
    pub insight_type_config: std::option::Option<crate::model::InsightTypeConfig>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If true, validate the request and preview the change, but do not actually
    /// update it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInsightTypeConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insight_type_config][crate::model::UpdateInsightTypeConfigRequest::insight_type_config].
    pub fn set_insight_type_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeConfig>,
    {
        self.insight_type_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insight_type_config][crate::model::UpdateInsightTypeConfigRequest::insight_type_config].
    pub fn set_or_clear_insight_type_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeConfig>,
    {
        self.insight_type_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInsightTypeConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInsightTypeConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInsightTypeConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInsightTypeConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.UpdateInsightTypeConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInsightTypeConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __insight_type_config,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInsightTypeConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "insightTypeConfig" => Ok(__FieldTag::__insight_type_config),
                            "insight_type_config" => Ok(__FieldTag::__insight_type_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInsightTypeConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInsightTypeConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__insight_type_config => {
                            if !fields.insert(__FieldTag::__insight_type_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insight_type_config",
                                ));
                            }
                            result.insight_type_config = map
                                .next_value::<std::option::Option<crate::model::InsightTypeConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInsightTypeConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.insight_type_config.is_some() {
            state.serialize_entry("insightTypeConfig", &self.insight_type_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateInsightTypeConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInsightTypeConfigRequest");
        debug_struct.field("insight_type_config", &self.insight_type_config);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
