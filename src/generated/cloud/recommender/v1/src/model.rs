// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An insight along with the information used to derive the insight. The insight
/// may have associated recommendations as well.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Insight {
    /// Name of the insight.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Free-form human readable summary in English. The maximum length is 500
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Fully qualified resource names that this insight is targeting.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub target_resources: std::vec::Vec<std::string::String>,

    /// Insight subtype. Insight content schema will be stable for a given subtype.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub insight_subtype: std::string::String,

    /// A struct of custom fields to explain the insight.
    /// Example: "grantedPermissionsCount": "1000"
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<wkt::Struct>,

    /// Timestamp of the latest data used to generate the insight.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_refresh_time: std::option::Option<wkt::Timestamp>,

    /// Observation period that led to the insight. The source data used to
    /// generate the insight ends at last_refresh_time and begins at
    /// (last_refresh_time - observation_period).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub observation_period: std::option::Option<wkt::Duration>,

    /// Information state and metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_info: std::option::Option<crate::model::InsightStateInfo>,

    /// Category being targeted by the insight.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub category: crate::model::insight::Category,

    /// Insight's severity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub severity: crate::model::insight::Severity,

    /// Fingerprint of the Insight. Provides optimistic locking when updating
    /// states.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Recommendations derived from this insight.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub associated_recommendations: std::vec::Vec<crate::model::insight::RecommendationReference>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Insight {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Insight::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Insight::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [target_resources][crate::model::Insight::target_resources].
    pub fn set_target_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [insight_subtype][crate::model::Insight::insight_subtype].
    pub fn set_insight_subtype<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.insight_subtype = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Insight::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::Insight::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_refresh_time][crate::model::Insight::last_refresh_time].
    pub fn set_last_refresh_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_refresh_time][crate::model::Insight::last_refresh_time].
    pub fn set_or_clear_last_refresh_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [observation_period][crate::model::Insight::observation_period].
    pub fn set_observation_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.observation_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [observation_period][crate::model::Insight::observation_period].
    pub fn set_or_clear_observation_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.observation_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state_info][crate::model::Insight::state_info].
    pub fn set_state_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightStateInfo>,
    {
        self.state_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_info][crate::model::Insight::state_info].
    pub fn set_or_clear_state_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightStateInfo>,
    {
        self.state_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [category][crate::model::Insight::category].
    pub fn set_category<T: std::convert::Into<crate::model::insight::Category>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Insight::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::insight::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Insight::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [associated_recommendations][crate::model::Insight::associated_recommendations].
    pub fn set_associated_recommendations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::insight::RecommendationReference>,
    {
        use std::iter::Iterator;
        self.associated_recommendations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Insight {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Insight"
    }
}

/// Defines additional types related to [Insight].
pub mod insight {
    #[allow(unused_imports)]
    use super::*;

    /// Reference to an associated recommendation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RecommendationReference {
        /// Recommendation resource name, e.g.
        /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/recommendations/[RECOMMENDATION_ID]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub recommendation: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RecommendationReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [recommendation][crate::model::insight::RecommendationReference::recommendation].
        pub fn set_recommendation<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.recommendation = v.into();
            self
        }
    }

    impl wkt::message::Message for RecommendationReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recommender.v1.Insight.RecommendationReference"
        }
    }

    /// Insight category.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Category {
        /// Unspecified category.
        Unspecified,
        /// The insight is related to cost.
        Cost,
        /// The insight is related to security.
        Security,
        /// The insight is related to performance.
        Performance,
        /// This insight is related to manageability.
        Manageability,
        /// The insight is related to sustainability.
        Sustainability,
        /// This insight is related to reliability.
        Reliability,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Category::value] or
        /// [Category::name].
        UnknownValue(category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Category {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cost => std::option::Option::Some(1),
                Self::Security => std::option::Option::Some(2),
                Self::Performance => std::option::Option::Some(3),
                Self::Manageability => std::option::Option::Some(4),
                Self::Sustainability => std::option::Option::Some(5),
                Self::Reliability => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CATEGORY_UNSPECIFIED"),
                Self::Cost => std::option::Option::Some("COST"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::Performance => std::option::Option::Some("PERFORMANCE"),
                Self::Manageability => std::option::Option::Some("MANAGEABILITY"),
                Self::Sustainability => std::option::Option::Some("SUSTAINABILITY"),
                Self::Reliability => std::option::Option::Some("RELIABILITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Category {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Category {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Category {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cost,
                2 => Self::Security,
                3 => Self::Performance,
                4 => Self::Manageability,
                5 => Self::Sustainability,
                6 => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Category {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "COST" => Self::Cost,
                "SECURITY" => Self::Security,
                "PERFORMANCE" => Self::Performance,
                "MANAGEABILITY" => Self::Manageability,
                "SUSTAINABILITY" => Self::Sustainability,
                "RELIABILITY" => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Category {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cost => serializer.serialize_i32(1),
                Self::Security => serializer.serialize_i32(2),
                Self::Performance => serializer.serialize_i32(3),
                Self::Manageability => serializer.serialize_i32(4),
                Self::Sustainability => serializer.serialize_i32(5),
                Self::Reliability => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Category {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Category>::new(
                ".google.cloud.recommender.v1.Insight.Category",
            ))
        }
    }

    /// Insight severity levels.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Insight has unspecified severity.
        Unspecified,
        /// Insight has low severity.
        Low,
        /// Insight has medium severity.
        Medium,
        /// Insight has high severity.
        High,
        /// Insight has critical severity.
        Critical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::Critical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::Medium,
                3 => Self::High,
                4 => Self::Critical,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "LOW" => Self::Low,
                "MEDIUM" => Self::Medium,
                "HIGH" => Self::High,
                "CRITICAL" => Self::Critical,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::Critical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.recommender.v1.Insight.Severity",
            ))
        }
    }
}

/// Information related to insight state.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsightStateInfo {
    /// Insight state.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::insight_state_info::State,

    /// A map of metadata for the state, provided by user or automations systems.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightStateInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::InsightStateInfo::state].
    pub fn set_state<T: std::convert::Into<crate::model::insight_state_info::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::InsightStateInfo::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InsightStateInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.InsightStateInfo"
    }
}

/// Defines additional types related to [InsightStateInfo].
pub mod insight_state_info {
    #[allow(unused_imports)]
    use super::*;

    /// Represents insight state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.
        Unspecified,
        /// Insight is active. Content for ACTIVE insights can be updated by Google.
        /// ACTIVE insights can be marked DISMISSED OR ACCEPTED.
        Active,
        /// Some action has been taken based on this insight. Insights become
        /// accepted when a recommendation derived from the insight has been marked
        /// CLAIMED, SUCCEEDED, or FAILED. ACTIVE insights can also be marked
        /// ACCEPTED explicitly. Content for ACCEPTED insights is immutable. ACCEPTED
        /// insights can only be marked ACCEPTED (which may update state metadata).
        Accepted,
        /// Insight is dismissed. Content for DISMISSED insights can be updated by
        /// Google. DISMISSED insights can be marked as ACTIVE.
        Dismissed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Accepted => std::option::Option::Some(2),
                Self::Dismissed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Accepted => std::option::Option::Some("ACCEPTED"),
                Self::Dismissed => std::option::Option::Some("DISMISSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Accepted,
                3 => Self::Dismissed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "ACCEPTED" => Self::Accepted,
                "DISMISSED" => Self::Dismissed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Accepted => serializer.serialize_i32(2),
                Self::Dismissed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.recommender.v1.InsightStateInfo.State",
            ))
        }
    }
}

/// Configuration for an InsightType.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsightTypeConfig {
    /// Name of insight type config.
    /// Eg,
    /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// InsightTypeGenerationConfig which configures the generation of
    /// insights for this insight type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insight_type_generation_config:
        std::option::Option<crate::model::InsightTypeGenerationConfig>,

    /// Fingerprint of the InsightTypeConfig. Provides optimistic locking when
    /// updating.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Last time when the config was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Immutable. The revision ID of the config.
    /// A new revision is committed whenever the config is changed in any way.
    /// The format is an 8-character hexadecimal string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub revision_id: std::string::String,

    /// Allows clients to store small amounts of arbitrary data. Annotations must
    /// follow the Kubernetes syntax.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// A user-settable field to provide a human-readable name to be used in user
    /// interfaces.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightTypeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InsightTypeConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [insight_type_generation_config][crate::model::InsightTypeConfig::insight_type_generation_config].
    pub fn set_insight_type_generation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeGenerationConfig>,
    {
        self.insight_type_generation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insight_type_generation_config][crate::model::InsightTypeConfig::insight_type_generation_config].
    pub fn set_or_clear_insight_type_generation_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeGenerationConfig>,
    {
        self.insight_type_generation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::InsightTypeConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::InsightTypeConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::InsightTypeConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision_id][crate::model::InsightTypeConfig::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::InsightTypeConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::InsightTypeConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for InsightTypeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.InsightTypeConfig"
    }
}

/// A configuration to customize the generation of insights.
/// Eg, customizing the lookback period considered when generating a
/// insight.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InsightTypeGenerationConfig {
    /// Parameters for this InsightTypeGenerationConfig. These configs can be used
    /// by or are applied to all subtypes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub params: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InsightTypeGenerationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [params][crate::model::InsightTypeGenerationConfig::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::InsightTypeGenerationConfig::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InsightTypeGenerationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.InsightTypeGenerationConfig"
    }
}

/// A recommendation along with a suggested action. E.g., a rightsizing
/// recommendation for an underutilized VM, IAM role recommendations, etc
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Recommendation {
    /// Name of recommendation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Free-form human readable summary in English. The maximum length is 500
    /// characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// Contains an identifier for a subtype of recommendations produced for the
    /// same recommender. Subtype is a function of content and impact, meaning a
    /// new subtype might be added when significant changes to `content` or
    /// `primary_impact.category` are introduced. See the Recommenders section
    /// to see a list of subtypes for a given Recommender.
    ///
    /// Examples:
    /// For recommender = "google.iam.policy.Recommender",
    /// recommender_subtype can be one of "REMOVE_ROLE"/"REPLACE_ROLE"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub recommender_subtype: std::string::String,

    /// Last time this recommendation was refreshed by the system that created it
    /// in the first place.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_refresh_time: std::option::Option<wkt::Timestamp>,

    /// The primary impact that this recommendation can have while trying to
    /// optimize for one category.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_impact: std::option::Option<crate::model::Impact>,

    /// Optional set of additional impact that this recommendation may have when
    /// trying to optimize for the primary category. These may be positive
    /// or negative.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub additional_impact: std::vec::Vec<crate::model::Impact>,

    /// Recommendation's priority.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub priority: crate::model::recommendation::Priority,

    /// Content of the recommendation describing recommended changes to resources.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::RecommendationContent>,

    /// Information for state. Contains state and metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_info: std::option::Option<crate::model::RecommendationStateInfo>,

    /// Fingerprint of the Recommendation. Provides optimistic locking when
    /// updating states.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Insights that led to this recommendation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub associated_insights: std::vec::Vec<crate::model::recommendation::InsightReference>,

    /// Corresponds to a mutually exclusive group ID within a recommender.
    /// A non-empty ID indicates that the recommendation belongs to a mutually
    /// exclusive group. This means that only one recommendation within the group
    /// is suggested to be applied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub xor_group_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Recommendation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Recommendation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Recommendation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [recommender_subtype][crate::model::Recommendation::recommender_subtype].
    pub fn set_recommender_subtype<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.recommender_subtype = v.into();
        self
    }

    /// Sets the value of [last_refresh_time][crate::model::Recommendation::last_refresh_time].
    pub fn set_last_refresh_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_refresh_time][crate::model::Recommendation::last_refresh_time].
    pub fn set_or_clear_last_refresh_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_refresh_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [primary_impact][crate::model::Recommendation::primary_impact].
    pub fn set_primary_impact<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Impact>,
    {
        self.primary_impact = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_impact][crate::model::Recommendation::primary_impact].
    pub fn set_or_clear_primary_impact<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Impact>,
    {
        self.primary_impact = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_impact][crate::model::Recommendation::additional_impact].
    pub fn set_additional_impact<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Impact>,
    {
        use std::iter::Iterator;
        self.additional_impact = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [priority][crate::model::Recommendation::priority].
    pub fn set_priority<T: std::convert::Into<crate::model::recommendation::Priority>>(
        mut self,
        v: T,
    ) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Recommendation::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationContent>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::Recommendation::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationContent>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state_info][crate::model::Recommendation::state_info].
    pub fn set_state_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationStateInfo>,
    {
        self.state_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_info][crate::model::Recommendation::state_info].
    pub fn set_or_clear_state_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecommendationStateInfo>,
    {
        self.state_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Recommendation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [associated_insights][crate::model::Recommendation::associated_insights].
    pub fn set_associated_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::recommendation::InsightReference>,
    {
        use std::iter::Iterator;
        self.associated_insights = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [xor_group_id][crate::model::Recommendation::xor_group_id].
    pub fn set_xor_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.xor_group_id = v.into();
        self
    }
}

impl wkt::message::Message for Recommendation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Recommendation"
    }
}

/// Defines additional types related to [Recommendation].
pub mod recommendation {
    #[allow(unused_imports)]
    use super::*;

    /// Reference to an associated insight.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InsightReference {
        /// Insight resource name, e.g.
        /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/insights/[INSIGHT_ID]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        #[serde_as(as = "serde_with::DefaultOnNull<_>")]
        pub insight: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InsightReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [insight][crate::model::recommendation::InsightReference::insight].
        pub fn set_insight<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.insight = v.into();
            self
        }
    }

    impl wkt::message::Message for InsightReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.recommender.v1.Recommendation.InsightReference"
        }
    }

    /// Recommendation priority levels.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Priority {
        /// Recommendation has unspecified priority.
        Unspecified,
        /// Recommendation has P4 priority (lowest priority).
        P4,
        /// Recommendation has P3 priority (second lowest priority).
        P3,
        /// Recommendation has P2 priority (second highest priority).
        P2,
        /// Recommendation has P1 priority (highest priority).
        P1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Priority::value] or
        /// [Priority::name].
        UnknownValue(priority::UnknownValue),
    }

    #[doc(hidden)]
    pub mod priority {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Priority {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::P4 => std::option::Option::Some(1),
                Self::P3 => std::option::Option::Some(2),
                Self::P2 => std::option::Option::Some(3),
                Self::P1 => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIORITY_UNSPECIFIED"),
                Self::P4 => std::option::Option::Some("P4"),
                Self::P3 => std::option::Option::Some("P3"),
                Self::P2 => std::option::Option::Some("P2"),
                Self::P1 => std::option::Option::Some("P1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Priority {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Priority {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Priority {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::P4,
                2 => Self::P3,
                3 => Self::P2,
                4 => Self::P1,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Priority {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIORITY_UNSPECIFIED" => Self::Unspecified,
                "P4" => Self::P4,
                "P3" => Self::P3,
                "P2" => Self::P2,
                "P1" => Self::P1,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Priority {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::P4 => serializer.serialize_i32(1),
                Self::P3 => serializer.serialize_i32(2),
                Self::P2 => serializer.serialize_i32(3),
                Self::P1 => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Priority {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Priority>::new(
                ".google.cloud.recommender.v1.Recommendation.Priority",
            ))
        }
    }
}

/// Contains what resources are changing and how they are changing.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecommendationContent {
    /// Operations to one or more Google Cloud resources grouped in such a way
    /// that, all operations within one group are expected to be performed
    /// atomically and in an order.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub operation_groups: std::vec::Vec<crate::model::OperationGroup>,

    /// Condensed overview information about the recommendation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub overview: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommendationContent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_groups][crate::model::RecommendationContent::operation_groups].
    pub fn set_operation_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OperationGroup>,
    {
        use std::iter::Iterator;
        self.operation_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [overview][crate::model::RecommendationContent::overview].
    pub fn set_overview<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.overview = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [overview][crate::model::RecommendationContent::overview].
    pub fn set_or_clear_overview<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.overview = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecommendationContent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommendationContent"
    }
}

/// Group of operations that need to be performed atomically.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationGroup {
    /// List of operations across one or more resources that belong to this group.
    /// Loosely based on RFC6902 and should be performed in the order they appear.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub operations: std::vec::Vec<crate::model::Operation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::OperationGroup::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.OperationGroup"
    }
}

/// Contains an operation for a resource loosely based on the JSON-PATCH format
/// with support for:
///
/// * Custom filters for describing partial array patch.
/// * Extended path values for describing nested arrays.
/// * Custom fields for describing the resource for which the operation is being
///   described.
/// * Allows extension to custom operations not natively supported by RFC6902.
///   See <https://tools.ietf.org/html/rfc6902> for details on the original RFC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Operation {
    /// Type of this operation. Contains one of 'add', 'remove', 'replace', 'move',
    /// 'copy', 'test' and custom operations. This field is case-insensitive and
    /// always populated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub action: std::string::String,

    /// Type of GCP resource being modified/tested. This field is always populated.
    /// Example: cloudresourcemanager.googleapis.com/Project,
    /// compute.googleapis.com/Instance
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub resource_type: std::string::String,

    /// Contains the fully qualified resource name. This field is always populated.
    /// ex: //cloudresourcemanager.googleapis.com/projects/foo.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub resource: std::string::String,

    /// Path to the target field being operated on. If the operation is at the
    /// resource level, then path should be "/". This field is always populated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub path: std::string::String,

    /// Can be set with action 'copy' to copy resource configuration across
    /// different resources of the same type. Example: A resource clone can be
    /// done via action = 'copy', path = "/", from = "/",
    /// source_resource = \<source\> and resource_name = \<target\>.
    /// This field is empty for all other values of `action`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub source_resource: std::string::String,

    /// Can be set with action 'copy' or 'move' to indicate the source field within
    /// resource or source_resource, ignored if provided for other operation types.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub source_path: std::string::String,

    /// Set of filters to apply if `path` refers to array elements or nested array
    /// elements in order to narrow down to a single unique element that is being
    /// tested/modified.
    /// This is intended to be an exact match per filter. To perform advanced
    /// matching, use path_value_matchers.
    ///
    /// * Example:
    ///
    /// ```norust
    /// {
    ///   "/versions/*/name" : "it-123"
    ///   "/versions/*/targetSize/percent": 20
    /// }
    /// ```
    ///
    /// * Example:
    ///
    /// ```norust
    /// {
    ///   "/bindings/*/role": "roles/owner"
    ///   "/bindings/*/condition" : null
    /// }
    /// ```
    ///
    /// * Example:
    ///
    /// ```norust
    /// {
    ///   "/bindings/*/role": "roles/owner"
    ///   "/bindings/*/members/*" : ["x@example.com", "y@example.com"]
    /// }
    /// ```
    ///
    /// When both path_filters and path_value_matchers are set, an implicit AND
    /// must be performed.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub path_filters: std::collections::HashMap<std::string::String, wkt::Value>,

    /// Similar to path_filters, this contains set of filters to apply if `path`
    /// field refers to array elements. This is meant to support value matching
    /// beyond exact match. To perform exact match, use path_filters.
    /// When both path_filters and path_value_matchers are set, an implicit AND
    /// must be performed.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub path_value_matchers:
        std::collections::HashMap<std::string::String, crate::model::ValueMatcher>,

    /// One of the fields in the following block will be set and intend to
    /// describe a value for 'path' field.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub path_value: std::option::Option<crate::model::operation::PathValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::Operation::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::Operation::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::Operation::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Operation::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [source_resource][crate::model::Operation::source_resource].
    pub fn set_source_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_resource = v.into();
        self
    }

    /// Sets the value of [source_path][crate::model::Operation::source_path].
    pub fn set_source_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_path = v.into();
        self
    }

    /// Sets the value of [path_filters][crate::model::Operation::path_filters].
    pub fn set_path_filters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.path_filters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [path_value_matchers][crate::model::Operation::path_value_matchers].
    pub fn set_path_value_matchers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ValueMatcher>,
    {
        use std::iter::Iterator;
        self.path_value_matchers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [path_value][crate::model::Operation::path_value].
    ///
    /// Note that all the setters affecting `path_value` are mutually
    /// exclusive.
    pub fn set_path_value<
        T: std::convert::Into<std::option::Option<crate::model::operation::PathValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.path_value = v.into();
        self
    }

    /// The value of [path_value][crate::model::Operation::path_value]
    /// if it holds a `Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value(&self) -> std::option::Option<&std::boxed::Box<wkt::Value>> {
        #[allow(unreachable_patterns)]
        self.path_value.as_ref().and_then(|v| match v {
            crate::model::operation::PathValue::Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [path_value][crate::model::Operation::path_value]
    /// to hold a `Value`.
    ///
    /// Note that all the setters affecting `path_value` are
    /// mutually exclusive.
    pub fn set_value<T: std::convert::Into<std::boxed::Box<wkt::Value>>>(mut self, v: T) -> Self {
        self.path_value =
            std::option::Option::Some(crate::model::operation::PathValue::Value(v.into()));
        self
    }

    /// The value of [path_value][crate::model::Operation::path_value]
    /// if it holds a `ValueMatcher`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value_matcher(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ValueMatcher>> {
        #[allow(unreachable_patterns)]
        self.path_value.as_ref().and_then(|v| match v {
            crate::model::operation::PathValue::ValueMatcher(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [path_value][crate::model::Operation::path_value]
    /// to hold a `ValueMatcher`.
    ///
    /// Note that all the setters affecting `path_value` are
    /// mutually exclusive.
    pub fn set_value_matcher<T: std::convert::Into<std::boxed::Box<crate::model::ValueMatcher>>>(
        mut self,
        v: T,
    ) -> Self {
        self.path_value =
            std::option::Option::Some(crate::model::operation::PathValue::ValueMatcher(v.into()));
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Operation"
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// One of the fields in the following block will be set and intend to
    /// describe a value for 'path' field.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum PathValue {
        /// Value for the `path` field. Will be set for actions:'add'/'replace'.
        /// Maybe set for action: 'test'. Either this or `value_matcher` will be set
        /// for 'test' operation. An exact match must be performed.
        Value(std::boxed::Box<wkt::Value>),
        /// Can be set for action 'test' for advanced matching for the value of
        /// 'path' field. Either this or `value` will be set for 'test' operation.
        ValueMatcher(std::boxed::Box<crate::model::ValueMatcher>),
    }
}

/// Contains various matching options for values for a GCP resource field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueMatcher {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub match_variant: std::option::Option<crate::model::value_matcher::MatchVariant>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [match_variant][crate::model::ValueMatcher::match_variant].
    ///
    /// Note that all the setters affecting `match_variant` are mutually
    /// exclusive.
    pub fn set_match_variant<
        T: std::convert::Into<std::option::Option<crate::model::value_matcher::MatchVariant>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.match_variant = v.into();
        self
    }

    /// The value of [match_variant][crate::model::ValueMatcher::match_variant]
    /// if it holds a `MatchesPattern`, `None` if the field is not set or
    /// holds a different branch.
    pub fn matches_pattern(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.match_variant.as_ref().and_then(|v| match v {
            crate::model::value_matcher::MatchVariant::MatchesPattern(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [match_variant][crate::model::ValueMatcher::match_variant]
    /// to hold a `MatchesPattern`.
    ///
    /// Note that all the setters affecting `match_variant` are
    /// mutually exclusive.
    pub fn set_matches_pattern<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.match_variant = std::option::Option::Some(
            crate::model::value_matcher::MatchVariant::MatchesPattern(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ValueMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ValueMatcher"
    }
}

/// Defines additional types related to [ValueMatcher].
pub mod value_matcher {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum MatchVariant {
        /// To be used for full regex matching. The regular expression is using the
        /// Google RE2 syntax (<https://github.com/google/re2/wiki/Syntax>), so to be
        /// used with RE2::FullMatch
        MatchesPattern(#[serde_as(as = "serde_with::DefaultOnNull<_>")] std::string::String),
    }
}

/// Contains metadata about how much money a recommendation can save or incur.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CostProjection {
    /// An approximate projection on amount saved or amount incurred. Negative cost
    /// units indicate cost savings and positive cost units indicate increase.
    /// See google.type.Money documentation for positive/negative units.
    ///
    /// A user's permissions may affect whether the cost is computed using list
    /// prices or custom contract prices.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cost: std::option::Option<gtype::model::Money>,

    /// Duration for which this cost applies.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// The approximate cost savings in the billing account's local currency.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cost_in_local_currency: std::option::Option<gtype::model::Money>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CostProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cost][crate::model::CostProjection::cost].
    pub fn set_cost<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost][crate::model::CostProjection::cost].
    pub fn set_or_clear_cost<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost = v.map(|x| x.into());
        self
    }

    /// Sets the value of [duration][crate::model::CostProjection::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::CostProjection::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cost_in_local_currency][crate::model::CostProjection::cost_in_local_currency].
    pub fn set_cost_in_local_currency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost_in_local_currency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost_in_local_currency][crate::model::CostProjection::cost_in_local_currency].
    pub fn set_or_clear_cost_in_local_currency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Money>,
    {
        self.cost_in_local_currency = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CostProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.CostProjection"
    }
}

/// Contains various ways of describing the impact on Security.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecurityProjection {
    /// Additional security impact details that is provided by the recommender.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::SecurityProjection::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::SecurityProjection::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SecurityProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.SecurityProjection"
    }
}

/// Contains metadata about how much sustainability a recommendation can save or
/// incur.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SustainabilityProjection {
    /// Carbon Footprint generated in kg of CO2 equivalent.
    /// Chose kg_c_o2e so that the name renders correctly in camelCase (kgCO2e).
    #[serde(rename = "kgCO2e")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::F64>")]
    pub kg_c_o2e: f64,

    /// Duration for which this sustainability applies.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SustainabilityProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kg_c_o2e][crate::model::SustainabilityProjection::kg_c_o2e].
    pub fn set_kg_c_o2e<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.kg_c_o2e = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::SustainabilityProjection::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::SustainabilityProjection::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SustainabilityProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.SustainabilityProjection"
    }
}

/// Contains information on the impact of a reliability recommendation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReliabilityProjection {
    /// Reliability risks mitigated by this recommendation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub risks: std::vec::Vec<crate::model::reliability_projection::RiskType>,

    /// Per-recommender projection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReliabilityProjection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [risks][crate::model::ReliabilityProjection::risks].
    pub fn set_risks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::reliability_projection::RiskType>,
    {
        use std::iter::Iterator;
        self.risks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [details][crate::model::ReliabilityProjection::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::ReliabilityProjection::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReliabilityProjection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ReliabilityProjection"
    }
}

/// Defines additional types related to [ReliabilityProjection].
pub mod reliability_projection {
    #[allow(unused_imports)]
    use super::*;

    /// The risk associated with the reliability issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RiskType {
        /// Default unspecified risk. Don't use directly.
        Unspecified,
        /// Potential service downtime.
        ServiceDisruption,
        /// Potential data loss.
        DataLoss,
        /// Potential access denial. The service is still up but some or all clients
        /// can't access it.
        AccessDeny,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RiskType::value] or
        /// [RiskType::name].
        UnknownValue(risk_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod risk_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RiskType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServiceDisruption => std::option::Option::Some(1),
                Self::DataLoss => std::option::Option::Some(2),
                Self::AccessDeny => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RISK_TYPE_UNSPECIFIED"),
                Self::ServiceDisruption => std::option::Option::Some("SERVICE_DISRUPTION"),
                Self::DataLoss => std::option::Option::Some("DATA_LOSS"),
                Self::AccessDeny => std::option::Option::Some("ACCESS_DENY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RiskType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RiskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RiskType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServiceDisruption,
                2 => Self::DataLoss,
                3 => Self::AccessDeny,
                _ => Self::UnknownValue(risk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RiskType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RISK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVICE_DISRUPTION" => Self::ServiceDisruption,
                "DATA_LOSS" => Self::DataLoss,
                "ACCESS_DENY" => Self::AccessDeny,
                _ => Self::UnknownValue(risk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RiskType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServiceDisruption => serializer.serialize_i32(1),
                Self::DataLoss => serializer.serialize_i32(2),
                Self::AccessDeny => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RiskType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RiskType>::new(
                ".google.cloud.recommender.v1.ReliabilityProjection.RiskType",
            ))
        }
    }
}

/// Contains the impact a recommendation can have for a given category.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Impact {
    /// Category that is being targeted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub category: crate::model::impact::Category,

    /// Contains projections (if any) for this category.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub projection: std::option::Option<crate::model::impact::Projection>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Impact {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::Impact::category].
    pub fn set_category<T: std::convert::Into<crate::model::impact::Category>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [projection][crate::model::Impact::projection].
    ///
    /// Note that all the setters affecting `projection` are mutually
    /// exclusive.
    pub fn set_projection<
        T: std::convert::Into<std::option::Option<crate::model::impact::Projection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = v.into();
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `CostProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cost_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CostProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::CostProjection(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `CostProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_cost_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::CostProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection =
            std::option::Option::Some(crate::model::impact::Projection::CostProjection(v.into()));
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `SecurityProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn security_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SecurityProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::SecurityProjection(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `SecurityProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_security_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::SecurityProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = std::option::Option::Some(
            crate::model::impact::Projection::SecurityProjection(v.into()),
        );
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `SustainabilityProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sustainability_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SustainabilityProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::SustainabilityProjection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `SustainabilityProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_sustainability_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::SustainabilityProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = std::option::Option::Some(
            crate::model::impact::Projection::SustainabilityProjection(v.into()),
        );
        self
    }

    /// The value of [projection][crate::model::Impact::projection]
    /// if it holds a `ReliabilityProjection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn reliability_projection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReliabilityProjection>> {
        #[allow(unreachable_patterns)]
        self.projection.as_ref().and_then(|v| match v {
            crate::model::impact::Projection::ReliabilityProjection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [projection][crate::model::Impact::projection]
    /// to hold a `ReliabilityProjection`.
    ///
    /// Note that all the setters affecting `projection` are
    /// mutually exclusive.
    pub fn set_reliability_projection<
        T: std::convert::Into<std::boxed::Box<crate::model::ReliabilityProjection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.projection = std::option::Option::Some(
            crate::model::impact::Projection::ReliabilityProjection(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Impact {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.Impact"
    }
}

/// Defines additional types related to [Impact].
pub mod impact {
    #[allow(unused_imports)]
    use super::*;

    /// The category of the impact.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Category {
        /// Default unspecified category. Don't use directly.
        Unspecified,
        /// Indicates a potential increase or decrease in cost.
        Cost,
        /// Indicates a potential increase or decrease in security.
        Security,
        /// Indicates a potential increase or decrease in performance.
        Performance,
        /// Indicates a potential increase or decrease in manageability.
        Manageability,
        /// Indicates a potential increase or decrease in sustainability.
        Sustainability,
        /// Indicates a potential increase or decrease in reliability.
        Reliability,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Category::value] or
        /// [Category::name].
        UnknownValue(category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Category {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Cost => std::option::Option::Some(1),
                Self::Security => std::option::Option::Some(2),
                Self::Performance => std::option::Option::Some(3),
                Self::Manageability => std::option::Option::Some(4),
                Self::Sustainability => std::option::Option::Some(5),
                Self::Reliability => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CATEGORY_UNSPECIFIED"),
                Self::Cost => std::option::Option::Some("COST"),
                Self::Security => std::option::Option::Some("SECURITY"),
                Self::Performance => std::option::Option::Some("PERFORMANCE"),
                Self::Manageability => std::option::Option::Some("MANAGEABILITY"),
                Self::Sustainability => std::option::Option::Some("SUSTAINABILITY"),
                Self::Reliability => std::option::Option::Some("RELIABILITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Category {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Category {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Category {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Cost,
                2 => Self::Security,
                3 => Self::Performance,
                4 => Self::Manageability,
                5 => Self::Sustainability,
                6 => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Category {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "COST" => Self::Cost,
                "SECURITY" => Self::Security,
                "PERFORMANCE" => Self::Performance,
                "MANAGEABILITY" => Self::Manageability,
                "SUSTAINABILITY" => Self::Sustainability,
                "RELIABILITY" => Self::Reliability,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Category {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Cost => serializer.serialize_i32(1),
                Self::Security => serializer.serialize_i32(2),
                Self::Performance => serializer.serialize_i32(3),
                Self::Manageability => serializer.serialize_i32(4),
                Self::Sustainability => serializer.serialize_i32(5),
                Self::Reliability => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Category {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Category>::new(
                ".google.cloud.recommender.v1.Impact.Category",
            ))
        }
    }

    /// Contains projections (if any) for this category.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Projection {
        /// Use with CategoryType.COST
        CostProjection(std::boxed::Box<crate::model::CostProjection>),
        /// Use with CategoryType.SECURITY
        SecurityProjection(std::boxed::Box<crate::model::SecurityProjection>),
        /// Use with CategoryType.SUSTAINABILITY
        SustainabilityProjection(std::boxed::Box<crate::model::SustainabilityProjection>),
        /// Use with CategoryType.RELIABILITY
        ReliabilityProjection(std::boxed::Box<crate::model::ReliabilityProjection>),
    }
}

/// Information for state. Contains state and metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecommendationStateInfo {
    /// The state of the recommendation, Eg ACTIVE, SUCCEEDED, FAILED.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::recommendation_state_info::State,

    /// A map of metadata for the state, provided by user or automations systems.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommendationStateInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::RecommendationStateInfo::state].
    pub fn set_state<T: std::convert::Into<crate::model::recommendation_state_info::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::RecommendationStateInfo::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RecommendationStateInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommendationStateInfo"
    }
}

/// Defines additional types related to [RecommendationStateInfo].
pub mod recommendation_state_info {
    #[allow(unused_imports)]
    use super::*;

    /// Represents Recommendation State.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default state. Don't use directly.
        Unspecified,
        /// Recommendation is active and can be applied. Recommendations content can
        /// be updated by Google.
        ///
        /// ACTIVE recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
        Active,
        /// Recommendation is in claimed state. Recommendations content is
        /// immutable and cannot be updated by Google.
        ///
        /// CLAIMED recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
        Claimed,
        /// Recommendation is in succeeded state. Recommendations content is
        /// immutable and cannot be updated by Google.
        ///
        /// SUCCEEDED recommendations can be marked as SUCCEEDED, or FAILED.
        Succeeded,
        /// Recommendation is in failed state. Recommendations content is immutable
        /// and cannot be updated by Google.
        ///
        /// FAILED recommendations can be marked as SUCCEEDED, or FAILED.
        Failed,
        /// Recommendation is in dismissed state. Recommendation content can be
        /// updated by Google.
        ///
        /// DISMISSED recommendations can be marked as ACTIVE.
        Dismissed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Claimed => std::option::Option::Some(6),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Dismissed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Claimed => std::option::Option::Some("CLAIMED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Dismissed => std::option::Option::Some("DISMISSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Dismissed,
                6 => Self::Claimed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "CLAIMED" => Self::Claimed,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "DISMISSED" => Self::Dismissed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Claimed => serializer.serialize_i32(6),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Dismissed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.recommender.v1.RecommendationStateInfo.State",
            ))
        }
    }
}

/// Configuration for a Recommender.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecommenderConfig {
    /// Name of recommender config.
    /// Eg,
    /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// RecommenderGenerationConfig which configures the Generation of
    /// recommendations for this recommender.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recommender_generation_config:
        std::option::Option<crate::model::RecommenderGenerationConfig>,

    /// Fingerprint of the RecommenderConfig. Provides optimistic locking when
    /// updating.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Last time when the config was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Immutable. The revision ID of the config.
    /// A new revision is committed whenever the config is changed in any way.
    /// The format is an 8-character hexadecimal string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub revision_id: std::string::String,

    /// Allows clients to store small amounts of arbitrary data. Annotations must
    /// follow the Kubernetes syntax.
    /// The total size of all keys and values combined is limited to 256k.
    /// Key can have 2 segments: prefix (optional) and name (required),
    /// separated by a slash (/).
    /// Prefix must be a DNS subdomain.
    /// Name must be 63 characters or less, begin and end with alphanumerics,
    /// with dashes (-), underscores (_), dots (.), and alphanumerics between.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// A user-settable field to provide a human-readable name to be used in user
    /// interfaces.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommenderConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RecommenderConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [recommender_generation_config][crate::model::RecommenderConfig::recommender_generation_config].
    pub fn set_recommender_generation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderGenerationConfig>,
    {
        self.recommender_generation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recommender_generation_config][crate::model::RecommenderConfig::recommender_generation_config].
    pub fn set_or_clear_recommender_generation_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderGenerationConfig>,
    {
        self.recommender_generation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::RecommenderConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::RecommenderConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::RecommenderConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision_id][crate::model::RecommenderConfig::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::RecommenderConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::RecommenderConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for RecommenderConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommenderConfig"
    }
}

/// A Configuration to customize the generation of recommendations.
/// Eg, customizing the lookback period considered when generating a
/// recommendation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecommenderGenerationConfig {
    /// Parameters for this RecommenderGenerationConfig. These configs can be used
    /// by or are applied to all subtypes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub params: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecommenderGenerationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [params][crate::model::RecommenderGenerationConfig::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::RecommenderGenerationConfig::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecommenderGenerationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.RecommenderGenerationConfig"
    }
}

/// Request for the `ListInsights` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInsightsRequest {
    /// Required. The container resource on which to execute the request.
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `folders/[FOLDER_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]`
    ///
    ///
    /// LOCATION here refers to GCP Locations:
    /// <https://cloud.google.com/about/locations/>
    /// INSIGHT_TYPE_ID refers to supported insight types:
    /// <https://cloud.google.com/recommender/docs/insights/insight-types>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. If not specified, the server will
    /// determine the number of results to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. If present, retrieves the next batch of results from the
    /// preceding call to this method. `page_token` must be the value of
    /// `next_page_token` from the previous response. The values of other method
    /// parameters must be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter expression to restrict the insights returned. Supported
    /// filter fields:
    ///
    /// * `stateInfo.state`
    ///
    /// * `insightSubtype`
    ///
    /// * `severity`
    ///
    /// * `targetResources`
    ///
    ///
    /// Examples:
    ///
    /// * `stateInfo.state = ACTIVE OR stateInfo.state = DISMISSED`
    ///
    /// * `insightSubtype = PERMISSIONS_USAGE`
    ///
    /// * `severity = CRITICAL OR severity = HIGH`
    ///
    /// * `targetResources :
    ///   //compute.googleapis.com/projects/1234/zones/us-central1-a/instances/instance-1`
    ///
    /// * `stateInfo.state = ACTIVE AND (severity = CRITICAL OR severity = HIGH)`
    ///
    ///
    /// The max allowed filter length is 500 characters.
    ///
    /// (These expressions are based on the filter language described at
    /// <https://google.aip.dev/160>)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInsightsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInsightsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInsightsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInsightsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInsightsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInsightsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListInsightsRequest"
    }
}

/// Response to the `ListInsights` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInsightsResponse {
    /// The set of insights for the `parent` resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub insights: std::vec::Vec<crate::model::Insight>,

    /// A token that can be used to request the next page of results. This field is
    /// empty if there are no additional results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInsightsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insights][crate::model::ListInsightsResponse::insights].
    pub fn set_insights<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Insight>,
    {
        use std::iter::Iterator;
        self.insights = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInsightsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInsightsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListInsightsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInsightsResponse {
    type PageItem = crate::model::Insight;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.insights
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to the `GetInsight` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInsightRequest {
    /// Required. Name of the insight.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInsightRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInsightRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInsightRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetInsightRequest"
    }
}

/// Request for the `MarkInsightAccepted` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MarkInsightAcceptedRequest {
    /// Required. Name of the insight.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Optional. State properties user wish to include with this state.  Full
    /// replace of the current state_metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Insight. Provides optimistic locking.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkInsightAcceptedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkInsightAcceptedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkInsightAcceptedRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkInsightAcceptedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkInsightAcceptedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkInsightAcceptedRequest"
    }
}

/// Request for the `ListRecommendations` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRecommendationsRequest {
    /// Required. The container resource on which to execute the request.
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `folders/[FOLDER_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]`
    ///
    ///
    /// LOCATION here refers to GCP Locations:
    /// <https://cloud.google.com/about/locations/>
    /// RECOMMENDER_ID refers to supported recommenders:
    /// <https://cloud.google.com/recommender/docs/recommenders>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored. If not specified, the server will
    /// determine the number of results to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. If present, retrieves the next batch of results from the
    /// preceding call to this method. `page_token` must be the value of
    /// `next_page_token` from the previous response. The values of other method
    /// parameters must be identical to those in the previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Filter expression to restrict the recommendations returned. Supported
    /// filter fields:
    ///
    /// * `state_info.state`
    ///
    /// * `recommenderSubtype`
    ///
    /// * `priority`
    ///
    /// * `targetResources`
    ///
    ///
    /// Examples:
    ///
    /// * `stateInfo.state = ACTIVE OR stateInfo.state = DISMISSED`
    ///
    /// * `recommenderSubtype = REMOVE_ROLE OR recommenderSubtype = REPLACE_ROLE`
    ///
    /// * `priority = P1 OR priority = P2`
    ///
    /// * `targetResources :
    ///   //compute.googleapis.com/projects/1234/zones/us-central1-a/instances/instance-1`
    ///
    /// * `stateInfo.state = ACTIVE AND (priority = P1 OR priority = P2)`
    ///
    ///
    /// The max allowed filter length is 500 characters.
    ///
    /// (These expressions are based on the filter language described at
    /// <https://google.aip.dev/160>)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecommendationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRecommendationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRecommendationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRecommendationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRecommendationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRecommendationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListRecommendationsRequest"
    }
}

/// Response to the `ListRecommendations` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRecommendationsResponse {
    /// The set of recommendations for the `parent` resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub recommendations: std::vec::Vec<crate::model::Recommendation>,

    /// A token that can be used to request the next page of results. This field is
    /// empty if there are no additional results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecommendationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recommendations][crate::model::ListRecommendationsResponse::recommendations].
    pub fn set_recommendations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Recommendation>,
    {
        use std::iter::Iterator;
        self.recommendations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRecommendationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRecommendationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.ListRecommendationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRecommendationsResponse {
    type PageItem = crate::model::Recommendation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.recommendations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request to the `GetRecommendation` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRecommendationRequest {
    /// Required. Name of the recommendation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRecommendationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRecommendationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRecommendationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetRecommendationRequest"
    }
}

/// Request for the `MarkRecommendationDismissed` Method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MarkRecommendationDismissedRequest {
    /// Required. Name of the recommendation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Fingerprint of the Recommendation. Provides optimistic locking.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationDismissedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationDismissedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationDismissedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationDismissedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationDismissedRequest"
    }
}

/// Request for the `MarkRecommendationClaimed` Method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MarkRecommendationClaimedRequest {
    /// Required. Name of the recommendation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// State properties to include with this state. Overwrites any existing
    /// `state_metadata`.
    /// Keys must match the regex `/^[a-z0-9][a-z0-9_.-]{0,62}$/`.
    /// Values must match the regex `/^[a-zA-Z0-9_./-]{0,255}$/`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Recommendation. Provides optimistic locking.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationClaimedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationClaimedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkRecommendationClaimedRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationClaimedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationClaimedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationClaimedRequest"
    }
}

/// Request for the `MarkRecommendationSucceeded` Method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MarkRecommendationSucceededRequest {
    /// Required. Name of the recommendation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// State properties to include with this state. Overwrites any existing
    /// `state_metadata`.
    /// Keys must match the regex `/^[a-z0-9][a-z0-9_.-]{0,62}$/`.
    /// Values must match the regex `/^[a-zA-Z0-9_./-]{0,255}$/`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Recommendation. Provides optimistic locking.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationSucceededRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationSucceededRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkRecommendationSucceededRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationSucceededRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationSucceededRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationSucceededRequest"
    }
}

/// Request for the `MarkRecommendationFailed` Method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MarkRecommendationFailedRequest {
    /// Required. Name of the recommendation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// State properties to include with this state. Overwrites any existing
    /// `state_metadata`.
    /// Keys must match the regex `/^[a-z0-9][a-z0-9_.-]{0,62}$/`.
    /// Values must match the regex `/^[a-zA-Z0-9_./-]{0,255}$/`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub state_metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fingerprint of the Recommendation. Provides optimistic locking.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MarkRecommendationFailedRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MarkRecommendationFailedRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state_metadata][crate::model::MarkRecommendationFailedRequest::state_metadata].
    pub fn set_state_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.state_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::MarkRecommendationFailedRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for MarkRecommendationFailedRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.MarkRecommendationFailedRequest"
    }
}

/// Request for the GetRecommenderConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRecommenderConfigRequest {
    /// Required. Name of the Recommendation Config to get.
    ///
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/recommenders/[RECOMMENDER_ID]/config`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRecommenderConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRecommenderConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRecommenderConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetRecommenderConfigRequest"
    }
}

/// Request for the `UpdateRecommenderConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRecommenderConfigRequest {
    /// Required. The RecommenderConfig to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recommender_config: std::option::Option<crate::model::RecommenderConfig>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If true, validate the request and preview the change, but do not actually
    /// update it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRecommenderConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recommender_config][crate::model::UpdateRecommenderConfigRequest::recommender_config].
    pub fn set_recommender_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderConfig>,
    {
        self.recommender_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recommender_config][crate::model::UpdateRecommenderConfigRequest::recommender_config].
    pub fn set_or_clear_recommender_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecommenderConfig>,
    {
        self.recommender_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRecommenderConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRecommenderConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateRecommenderConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRecommenderConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.UpdateRecommenderConfigRequest"
    }
}

/// Request for the GetInsightTypeConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInsightTypeConfigRequest {
    /// Required. Name of the InsightTypeConfig to get.
    ///
    /// Acceptable formats:
    ///
    /// * `projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    /// * `projects/[PROJECT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    /// * `organizations/[ORGANIZATION_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    /// * `billingAccounts/[BILLING_ACCOUNT_ID]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/config`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInsightTypeConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInsightTypeConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInsightTypeConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.GetInsightTypeConfigRequest"
    }
}

/// Request for the `UpdateInsightTypeConfig` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInsightTypeConfigRequest {
    /// Required. The InsightTypeConfig to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub insight_type_config: std::option::Option<crate::model::InsightTypeConfig>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If true, validate the request and preview the change, but do not actually
    /// update it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInsightTypeConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [insight_type_config][crate::model::UpdateInsightTypeConfigRequest::insight_type_config].
    pub fn set_insight_type_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeConfig>,
    {
        self.insight_type_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insight_type_config][crate::model::UpdateInsightTypeConfigRequest::insight_type_config].
    pub fn set_or_clear_insight_type_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InsightTypeConfig>,
    {
        self.insight_type_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInsightTypeConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInsightTypeConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInsightTypeConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInsightTypeConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.recommender.v1.UpdateInsightTypeConfigRequest"
    }
}
