// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A billing account in the
/// [Google Cloud Console](https://console.cloud.google.com/). You can assign a
/// billing account to one or more projects.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BillingAccount {
    /// Output only. The resource name of the billing account. The resource name
    /// has the form `billingAccounts/{billing_account_id}`. For example,
    /// `billingAccounts/012345-567890-ABCDEF` would be the resource name for
    /// billing account `012345-567890-ABCDEF`.
    pub name: std::string::String,

    /// Output only. True if the billing account is open, and will therefore be
    /// charged for any usage on associated projects. False if the billing account
    /// is closed, and therefore projects associated with it are unable to use paid
    /// services.
    pub open: bool,

    /// The display name given to the billing account, such as `My Billing
    /// Account`. This name is displayed in the Google Cloud Console.
    pub display_name: std::string::String,

    /// If this account is a
    /// [subaccount](https://cloud.google.com/billing/docs/concepts), then this
    /// will be the resource name of the parent billing account that it is being
    /// resold through.
    /// Otherwise this will be empty.
    pub master_billing_account: std::string::String,

    /// Output only. The billing account's parent resource identifier.
    /// Use the `MoveBillingAccount` method to update the account's parent resource
    /// if it is a organization.
    /// Format:
    ///
    /// - `organizations/{organization_id}`, for example,
    ///   `organizations/12345678`
    /// - `billingAccounts/{billing_account_id}`, for example,
    ///   `billingAccounts/012345-567890-ABCDEF`
    pub parent: std::string::String,

    /// Optional. The currency in which the billing account is billed and charged,
    /// represented as an ISO 4217 code such as `USD`.
    ///
    /// Billing account currency is determined at the time of billing account
    /// creation and cannot be updated subsequently, so this field should not be
    /// set on update requests. In addition, a subaccount always matches the
    /// currency of its parent billing account, so this field should not be set on
    /// subaccount creation requests. Clients can read this field to determine the
    /// currency of an existing billing account.
    pub currency_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BillingAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BillingAccount::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [open][crate::model::BillingAccount::open].
    pub fn set_open<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.open = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::BillingAccount::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [master_billing_account][crate::model::BillingAccount::master_billing_account].
    pub fn set_master_billing_account<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_billing_account = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::BillingAccount::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [currency_code][crate::model::BillingAccount::currency_code].
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }
}

impl wkt::message::Message for BillingAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.BillingAccount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BillingAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __open,
            __display_name,
            __master_billing_account,
            __parent,
            __currency_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BillingAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "open" => Ok(__FieldTag::__open),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "masterBillingAccount" => Ok(__FieldTag::__master_billing_account),
                            "master_billing_account" => Ok(__FieldTag::__master_billing_account),
                            "parent" => Ok(__FieldTag::__parent),
                            "currencyCode" => Ok(__FieldTag::__currency_code),
                            "currency_code" => Ok(__FieldTag::__currency_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BillingAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BillingAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__open => {
                            if !fields.insert(__FieldTag::__open) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for open",
                                ));
                            }
                            result.open = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_billing_account => {
                            if !fields.insert(__FieldTag::__master_billing_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_billing_account",
                                ));
                            }
                            result.master_billing_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__currency_code => {
                            if !fields.insert(__FieldTag::__currency_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for currency_code",
                                ));
                            }
                            result.currency_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BillingAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.open) {
            state.serialize_entry("open", &self.open)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.master_billing_account.is_empty() {
            state.serialize_entry("masterBillingAccount", &self.master_billing_account)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.currency_code.is_empty() {
            state.serialize_entry("currencyCode", &self.currency_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Encapsulation of billing information for a Google Cloud Console project. A
/// project has at most one associated billing account at a time (but a billing
/// account can be assigned to multiple projects).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ProjectBillingInfo {
    /// Output only. The resource name for the `ProjectBillingInfo`; has the form
    /// `projects/{project_id}/billingInfo`. For example, the resource name for the
    /// billing information for project `tokyo-rain-123` would be
    /// `projects/tokyo-rain-123/billingInfo`.
    pub name: std::string::String,

    /// Output only. The ID of the project that this `ProjectBillingInfo`
    /// represents, such as `tokyo-rain-123`. This is a convenience field so that
    /// you don't need to parse the `name` field to obtain a project ID.
    pub project_id: std::string::String,

    /// The resource name of the billing account associated with the project, if
    /// any. For example, `billingAccounts/012345-567890-ABCDEF`.
    pub billing_account_name: std::string::String,

    /// Output only. True if the project is associated with an open billing
    /// account, to which usage on the project is charged. False if the project is
    /// associated with a closed billing account, or no billing account at all, and
    /// therefore cannot use paid services.
    pub billing_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProjectBillingInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProjectBillingInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::ProjectBillingInfo::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [billing_account_name][crate::model::ProjectBillingInfo::billing_account_name].
    pub fn set_billing_account_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.billing_account_name = v.into();
        self
    }

    /// Sets the value of [billing_enabled][crate::model::ProjectBillingInfo::billing_enabled].
    pub fn set_billing_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.billing_enabled = v.into();
        self
    }
}

impl wkt::message::Message for ProjectBillingInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ProjectBillingInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProjectBillingInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_id,
            __billing_account_name,
            __billing_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProjectBillingInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "billingAccountName" => Ok(__FieldTag::__billing_account_name),
                            "billing_account_name" => Ok(__FieldTag::__billing_account_name),
                            "billingEnabled" => Ok(__FieldTag::__billing_enabled),
                            "billing_enabled" => Ok(__FieldTag::__billing_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProjectBillingInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProjectBillingInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__billing_account_name => {
                            if !fields.insert(__FieldTag::__billing_account_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_account_name",
                                ));
                            }
                            result.billing_account_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__billing_enabled => {
                            if !fields.insert(__FieldTag::__billing_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_enabled",
                                ));
                            }
                            result.billing_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProjectBillingInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.billing_account_name.is_empty() {
            state.serialize_entry("billingAccountName", &self.billing_account_name)?;
        }
        if !wkt::internal::is_default(&self.billing_enabled) {
            state.serialize_entry("billingEnabled", &self.billing_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `GetBillingAccount`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBillingAccountRequest {
    /// Required. The resource name of the billing account to retrieve. For
    /// example, `billingAccounts/012345-567890-ABCDEF`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBillingAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBillingAccountRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBillingAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.GetBillingAccountRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBillingAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBillingAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBillingAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBillingAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBillingAccountRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `ListBillingAccounts`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBillingAccountsRequest {
    /// Requested page size. The maximum page size is 100; this is also the
    /// default.
    pub page_size: i32,

    /// A token identifying a page of results to return. This should be a
    /// `next_page_token` value returned from a previous `ListBillingAccounts`
    /// call. If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    /// Options for how to filter the returned billing accounts.
    /// This only supports filtering for
    /// [subaccounts](https://cloud.google.com/billing/docs/concepts) under a
    /// single provided parent billing account.
    /// (for example,
    /// `master_billing_account=billingAccounts/012345-678901-ABCDEF`).
    /// Boolean algebra and other fields are not currently supported.
    pub filter: std::string::String,

    /// Optional. The parent resource to list billing accounts from.
    /// Format:
    ///
    /// - `organizations/{organization_id}`, for example,
    ///   `organizations/12345678`
    /// - `billingAccounts/{billing_account_id}`, for example,
    ///   `billingAccounts/012345-567890-ABCDEF`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBillingAccountsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListBillingAccountsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBillingAccountsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBillingAccountsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::ListBillingAccountsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListBillingAccountsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListBillingAccountsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBillingAccountsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            __filter,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBillingAccountsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBillingAccountsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBillingAccountsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBillingAccountsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `ListBillingAccounts`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBillingAccountsResponse {
    /// A list of billing accounts.
    pub billing_accounts: std::vec::Vec<crate::model::BillingAccount>,

    /// A token to retrieve the next page of results. To retrieve the next page,
    /// call `ListBillingAccounts` again with the `page_token` field set to this
    /// value. This field is empty if there are no more results to retrieve.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBillingAccountsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [billing_accounts][crate::model::ListBillingAccountsResponse::billing_accounts].
    pub fn set_billing_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BillingAccount>,
    {
        use std::iter::Iterator;
        self.billing_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBillingAccountsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBillingAccountsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListBillingAccountsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBillingAccountsResponse {
    type PageItem = crate::model::BillingAccount;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.billing_accounts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBillingAccountsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __billing_accounts,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBillingAccountsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "billingAccounts" => Ok(__FieldTag::__billing_accounts),
                            "billing_accounts" => Ok(__FieldTag::__billing_accounts),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBillingAccountsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBillingAccountsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__billing_accounts => {
                            if !fields.insert(__FieldTag::__billing_accounts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_accounts",
                                ));
                            }
                            result.billing_accounts =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BillingAccount>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBillingAccountsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.billing_accounts.is_empty() {
            state.serialize_entry("billingAccounts", &self.billing_accounts)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `CreateBillingAccount`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBillingAccountRequest {
    /// Required. The billing account resource to create.
    /// Currently CreateBillingAccount only supports subaccount creation, so
    /// any created billing accounts must be under a provided parent billing
    /// account.
    pub billing_account: std::option::Option<crate::model::BillingAccount>,

    /// Optional. The parent to create a billing account from.
    /// Format:
    ///
    /// - `billingAccounts/{billing_account_id}`, for example,
    ///   `billingAccounts/012345-567890-ABCDEF`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBillingAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [billing_account][crate::model::CreateBillingAccountRequest::billing_account].
    pub fn set_billing_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BillingAccount>,
    {
        self.billing_account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [billing_account][crate::model::CreateBillingAccountRequest::billing_account].
    pub fn set_or_clear_billing_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BillingAccount>,
    {
        self.billing_account = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent][crate::model::CreateBillingAccountRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateBillingAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.CreateBillingAccountRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBillingAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __billing_account,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBillingAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "billingAccount" => Ok(__FieldTag::__billing_account),
                            "billing_account" => Ok(__FieldTag::__billing_account),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBillingAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBillingAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__billing_account => {
                            if !fields.insert(__FieldTag::__billing_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for billing_account",
                                ));
                            }
                            result.billing_account = map
                                .next_value::<std::option::Option<crate::model::BillingAccount>>(
                                )?;
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBillingAccountRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.billing_account.is_some() {
            state.serialize_entry("billingAccount", &self.billing_account)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `UpdateBillingAccount`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBillingAccountRequest {
    /// Required. The name of the billing account resource to be updated.
    pub name: std::string::String,

    /// Required. The billing account resource to replace the resource on the
    /// server.
    pub account: std::option::Option<crate::model::BillingAccount>,

    /// The update mask applied to the resource.
    /// Only "display_name" is currently supported.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBillingAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateBillingAccountRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [account][crate::model::UpdateBillingAccountRequest::account].
    pub fn set_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BillingAccount>,
    {
        self.account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [account][crate::model::UpdateBillingAccountRequest::account].
    pub fn set_or_clear_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BillingAccount>,
    {
        self.account = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBillingAccountRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBillingAccountRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBillingAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.UpdateBillingAccountRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBillingAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __account,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBillingAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "account" => Ok(__FieldTag::__account),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBillingAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBillingAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__account => {
                            if !fields.insert(__FieldTag::__account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for account",
                                ));
                            }
                            result.account = map
                                .next_value::<std::option::Option<crate::model::BillingAccount>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBillingAccountRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.account.is_some() {
            state.serialize_entry("account", &self.account)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `ListProjectBillingInfo`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProjectBillingInfoRequest {
    /// Required. The resource name of the billing account associated with the
    /// projects that you want to list. For example,
    /// `billingAccounts/012345-567890-ABCDEF`.
    pub name: std::string::String,

    /// Requested page size. The maximum page size is 100; this is also the
    /// default.
    pub page_size: i32,

    /// A token identifying a page of results to be returned. This should be a
    /// `next_page_token` value returned from a previous `ListProjectBillingInfo`
    /// call. If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProjectBillingInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListProjectBillingInfoRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProjectBillingInfoRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProjectBillingInfoRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProjectBillingInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListProjectBillingInfoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProjectBillingInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProjectBillingInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProjectBillingInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProjectBillingInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProjectBillingInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `ListProjectBillingInfoResponse`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProjectBillingInfoResponse {
    /// A list of `ProjectBillingInfo` resources representing the projects
    /// associated with the billing account.
    pub project_billing_info: std::vec::Vec<crate::model::ProjectBillingInfo>,

    /// A token to retrieve the next page of results. To retrieve the next page,
    /// call `ListProjectBillingInfo` again with the `page_token` field set to this
    /// value. This field is empty if there are no more results to retrieve.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProjectBillingInfoResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_billing_info][crate::model::ListProjectBillingInfoResponse::project_billing_info].
    pub fn set_project_billing_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProjectBillingInfo>,
    {
        use std::iter::Iterator;
        self.project_billing_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProjectBillingInfoResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProjectBillingInfoResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListProjectBillingInfoResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProjectBillingInfoResponse {
    type PageItem = crate::model::ProjectBillingInfo;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.project_billing_info
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProjectBillingInfoResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_billing_info,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProjectBillingInfoResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectBillingInfo" => Ok(__FieldTag::__project_billing_info),
                            "project_billing_info" => Ok(__FieldTag::__project_billing_info),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProjectBillingInfoResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProjectBillingInfoResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_billing_info => {
                            if !fields.insert(__FieldTag::__project_billing_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_billing_info",
                                ));
                            }
                            result.project_billing_info = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ProjectBillingInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProjectBillingInfoResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_billing_info.is_empty() {
            state.serialize_entry("projectBillingInfo", &self.project_billing_info)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `GetProjectBillingInfo`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProjectBillingInfoRequest {
    /// Required. The resource name of the project for which billing information is
    /// retrieved. For example, `projects/tokyo-rain-123`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProjectBillingInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProjectBillingInfoRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProjectBillingInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.GetProjectBillingInfoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProjectBillingInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProjectBillingInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProjectBillingInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProjectBillingInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProjectBillingInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `UpdateProjectBillingInfo`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateProjectBillingInfoRequest {
    /// Required. The resource name of the project associated with the billing
    /// information that you want to update. For example,
    /// `projects/tokyo-rain-123`.
    pub name: std::string::String,

    /// The new billing information for the project. Output-only fields are
    /// ignored; thus, you can leave empty all fields except
    /// `billing_account_name`.
    pub project_billing_info: std::option::Option<crate::model::ProjectBillingInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProjectBillingInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateProjectBillingInfoRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project_billing_info][crate::model::UpdateProjectBillingInfoRequest::project_billing_info].
    pub fn set_project_billing_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProjectBillingInfo>,
    {
        self.project_billing_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [project_billing_info][crate::model::UpdateProjectBillingInfoRequest::project_billing_info].
    pub fn set_or_clear_project_billing_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProjectBillingInfo>,
    {
        self.project_billing_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateProjectBillingInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.UpdateProjectBillingInfoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateProjectBillingInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project_billing_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateProjectBillingInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "projectBillingInfo" => Ok(__FieldTag::__project_billing_info),
                            "project_billing_info" => Ok(__FieldTag::__project_billing_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateProjectBillingInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateProjectBillingInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_billing_info => {
                            if !fields.insert(__FieldTag::__project_billing_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_billing_info",
                                ));
                            }
                            result.project_billing_info = map.next_value::<std::option::Option<crate::model::ProjectBillingInfo>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateProjectBillingInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.project_billing_info.is_some() {
            state.serialize_entry("projectBillingInfo", &self.project_billing_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `MoveBillingAccount` RPC.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveBillingAccountRequest {
    /// Required. The resource name of the billing account to move.
    /// Must be of the form `billingAccounts/{billing_account_id}`.
    /// The specified billing account cannot be a subaccount, since a subaccount
    /// always belongs to the same organization as its parent account.
    pub name: std::string::String,

    /// Required. The resource name of the Organization to move
    /// the billing account under.
    /// Must be of the form `organizations/{organization_id}`.
    pub destination_parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveBillingAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MoveBillingAccountRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination_parent][crate::model::MoveBillingAccountRequest::destination_parent].
    pub fn set_destination_parent<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_parent = v.into();
        self
    }
}

impl wkt::message::Message for MoveBillingAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.MoveBillingAccountRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveBillingAccountRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __destination_parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveBillingAccountRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "destinationParent" => Ok(__FieldTag::__destination_parent),
                            "destination_parent" => Ok(__FieldTag::__destination_parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveBillingAccountRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveBillingAccountRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_parent => {
                            if !fields.insert(__FieldTag::__destination_parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_parent",
                                ));
                            }
                            result.destination_parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveBillingAccountRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.destination_parent.is_empty() {
            state.serialize_entry("destinationParent", &self.destination_parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Encapsulates a single service in Google Cloud Platform.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Service {
    /// The resource name for the service.
    /// Example: "services/6F81-5844-456A"
    pub name: std::string::String,

    /// The identifier for the service.
    /// Example: "6F81-5844-456A"
    pub service_id: std::string::String,

    /// A human readable display name for this service.
    pub display_name: std::string::String,

    /// The business under which the service is offered.
    /// Ex. "businessEntities/GCP", "businessEntities/Maps"
    pub business_entity_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [service_id][crate::model::Service::service_id].
    pub fn set_service_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Service::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [business_entity_name][crate::model::Service::business_entity_name].
    pub fn set_business_entity_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.business_entity_name = v.into();
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.Service"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Service {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __service_id,
            __display_name,
            __business_entity_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Service")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "serviceId" => Ok(__FieldTag::__service_id),
                            "service_id" => Ok(__FieldTag::__service_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "businessEntityName" => Ok(__FieldTag::__business_entity_name),
                            "business_entity_name" => Ok(__FieldTag::__business_entity_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Service;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Service")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_id => {
                            if !fields.insert(__FieldTag::__service_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_id",
                                ));
                            }
                            result.service_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__business_entity_name => {
                            if !fields.insert(__FieldTag::__business_entity_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for business_entity_name",
                                ));
                            }
                            result.business_entity_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Service {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.service_id.is_empty() {
            state.serialize_entry("serviceId", &self.service_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.business_entity_name.is_empty() {
            state.serialize_entry("businessEntityName", &self.business_entity_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Encapsulates a single SKU in Google Cloud
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Sku {
    /// The resource name for the SKU.
    /// Example: "services/6F81-5844-456A/skus/D041-B8A1-6E0B"
    pub name: std::string::String,

    /// The identifier for the SKU.
    /// Example: "D041-B8A1-6E0B"
    pub sku_id: std::string::String,

    /// A human readable description of the SKU, has a maximum length of 256
    /// characters.
    pub description: std::string::String,

    /// The category hierarchy of this SKU, purely for organizational purpose.
    pub category: std::option::Option<crate::model::Category>,

    /// List of service regions this SKU is offered at.
    /// Example: "asia-east1"
    /// Service regions can be found at <https://cloud.google.com/about/locations/>
    pub service_regions: std::vec::Vec<std::string::String>,

    /// A timeline of pricing info for this SKU in chronological order.
    pub pricing_info: std::vec::Vec<crate::model::PricingInfo>,

    /// Identifies the service provider.
    /// This is 'Google' for first party services in Google Cloud Platform.
    pub service_provider_name: std::string::String,

    /// The geographic taxonomy for this sku.
    pub geo_taxonomy: std::option::Option<crate::model::GeoTaxonomy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sku {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Sku::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [sku_id][crate::model::Sku::sku_id].
    pub fn set_sku_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sku_id = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Sku::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [category][crate::model::Sku::category].
    pub fn set_category<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Category>,
    {
        self.category = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [category][crate::model::Sku::category].
    pub fn set_or_clear_category<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Category>,
    {
        self.category = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_regions][crate::model::Sku::service_regions].
    pub fn set_service_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_regions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pricing_info][crate::model::Sku::pricing_info].
    pub fn set_pricing_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PricingInfo>,
    {
        use std::iter::Iterator;
        self.pricing_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_provider_name][crate::model::Sku::service_provider_name].
    pub fn set_service_provider_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_provider_name = v.into();
        self
    }

    /// Sets the value of [geo_taxonomy][crate::model::Sku::geo_taxonomy].
    pub fn set_geo_taxonomy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GeoTaxonomy>,
    {
        self.geo_taxonomy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [geo_taxonomy][crate::model::Sku::geo_taxonomy].
    pub fn set_or_clear_geo_taxonomy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GeoTaxonomy>,
    {
        self.geo_taxonomy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Sku {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.Sku"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Sku {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __sku_id,
            __description,
            __category,
            __service_regions,
            __pricing_info,
            __service_provider_name,
            __geo_taxonomy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sku")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "skuId" => Ok(__FieldTag::__sku_id),
                            "sku_id" => Ok(__FieldTag::__sku_id),
                            "description" => Ok(__FieldTag::__description),
                            "category" => Ok(__FieldTag::__category),
                            "serviceRegions" => Ok(__FieldTag::__service_regions),
                            "service_regions" => Ok(__FieldTag::__service_regions),
                            "pricingInfo" => Ok(__FieldTag::__pricing_info),
                            "pricing_info" => Ok(__FieldTag::__pricing_info),
                            "serviceProviderName" => Ok(__FieldTag::__service_provider_name),
                            "service_provider_name" => Ok(__FieldTag::__service_provider_name),
                            "geoTaxonomy" => Ok(__FieldTag::__geo_taxonomy),
                            "geo_taxonomy" => Ok(__FieldTag::__geo_taxonomy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Sku;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sku")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sku_id => {
                            if !fields.insert(__FieldTag::__sku_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sku_id",
                                ));
                            }
                            result.sku_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__category => {
                            if !fields.insert(__FieldTag::__category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for category",
                                ));
                            }
                            result.category =
                                map.next_value::<std::option::Option<crate::model::Category>>()?;
                        }
                        __FieldTag::__service_regions => {
                            if !fields.insert(__FieldTag::__service_regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_regions",
                                ));
                            }
                            result.service_regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pricing_info => {
                            if !fields.insert(__FieldTag::__pricing_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pricing_info",
                                ));
                            }
                            result.pricing_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PricingInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_provider_name => {
                            if !fields.insert(__FieldTag::__service_provider_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_provider_name",
                                ));
                            }
                            result.service_provider_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__geo_taxonomy => {
                            if !fields.insert(__FieldTag::__geo_taxonomy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for geo_taxonomy",
                                ));
                            }
                            result.geo_taxonomy =
                                map.next_value::<std::option::Option<crate::model::GeoTaxonomy>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Sku {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.sku_id.is_empty() {
            state.serialize_entry("skuId", &self.sku_id)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.category.is_some() {
            state.serialize_entry("category", &self.category)?;
        }
        if !self.service_regions.is_empty() {
            state.serialize_entry("serviceRegions", &self.service_regions)?;
        }
        if !self.pricing_info.is_empty() {
            state.serialize_entry("pricingInfo", &self.pricing_info)?;
        }
        if !self.service_provider_name.is_empty() {
            state.serialize_entry("serviceProviderName", &self.service_provider_name)?;
        }
        if self.geo_taxonomy.is_some() {
            state.serialize_entry("geoTaxonomy", &self.geo_taxonomy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the category hierarchy of a SKU.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Category {
    /// The display name of the service this SKU belongs to.
    pub service_display_name: std::string::String,

    /// The type of product the SKU refers to.
    /// Example: "Compute", "Storage", "Network", "ApplicationServices" etc.
    pub resource_family: std::string::String,

    /// A group classification for related SKUs.
    /// Example: "RAM", "GPU", "Prediction", "Ops", "GoogleEgress" etc.
    pub resource_group: std::string::String,

    /// Represents how the SKU is consumed.
    /// Example: "OnDemand", "Preemptible", "Commit1Mo", "Commit1Yr" etc.
    pub usage_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Category {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_display_name][crate::model::Category::service_display_name].
    pub fn set_service_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_display_name = v.into();
        self
    }

    /// Sets the value of [resource_family][crate::model::Category::resource_family].
    pub fn set_resource_family<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_family = v.into();
        self
    }

    /// Sets the value of [resource_group][crate::model::Category::resource_group].
    pub fn set_resource_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_group = v.into();
        self
    }

    /// Sets the value of [usage_type][crate::model::Category::usage_type].
    pub fn set_usage_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.usage_type = v.into();
        self
    }
}

impl wkt::message::Message for Category {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.Category"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Category {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_display_name,
            __resource_family,
            __resource_group,
            __usage_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Category")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceDisplayName" => Ok(__FieldTag::__service_display_name),
                            "service_display_name" => Ok(__FieldTag::__service_display_name),
                            "resourceFamily" => Ok(__FieldTag::__resource_family),
                            "resource_family" => Ok(__FieldTag::__resource_family),
                            "resourceGroup" => Ok(__FieldTag::__resource_group),
                            "resource_group" => Ok(__FieldTag::__resource_group),
                            "usageType" => Ok(__FieldTag::__usage_type),
                            "usage_type" => Ok(__FieldTag::__usage_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Category;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Category")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_display_name => {
                            if !fields.insert(__FieldTag::__service_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_display_name",
                                ));
                            }
                            result.service_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_family => {
                            if !fields.insert(__FieldTag::__resource_family) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_family",
                                ));
                            }
                            result.resource_family = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_group => {
                            if !fields.insert(__FieldTag::__resource_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_group",
                                ));
                            }
                            result.resource_group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__usage_type => {
                            if !fields.insert(__FieldTag::__usage_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage_type",
                                ));
                            }
                            result.usage_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Category {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_display_name.is_empty() {
            state.serialize_entry("serviceDisplayName", &self.service_display_name)?;
        }
        if !self.resource_family.is_empty() {
            state.serialize_entry("resourceFamily", &self.resource_family)?;
        }
        if !self.resource_group.is_empty() {
            state.serialize_entry("resourceGroup", &self.resource_group)?;
        }
        if !self.usage_type.is_empty() {
            state.serialize_entry("usageType", &self.usage_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the pricing information for a SKU at a single point of time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PricingInfo {
    /// The timestamp from which this pricing was effective within the requested
    /// time range. This is guaranteed to be greater than or equal to the
    /// start_time field in the request and less than the end_time field in the
    /// request. If a time range was not specified in the request this field will
    /// be equivalent to a time within the last 12 hours, indicating the latest
    /// pricing info.
    pub effective_time: std::option::Option<wkt::Timestamp>,

    /// An optional human readable summary of the pricing information, has a
    /// maximum length of 256 characters.
    pub summary: std::string::String,

    /// Expresses the pricing formula. See `PricingExpression` for an example.
    pub pricing_expression: std::option::Option<crate::model::PricingExpression>,

    /// Aggregation Info. This can be left unspecified if the pricing expression
    /// doesn't require aggregation.
    pub aggregation_info: std::option::Option<crate::model::AggregationInfo>,

    /// Conversion rate used for currency conversion, from USD to the currency
    /// specified in the request. This includes any surcharge collected for billing
    /// in non USD currency. If a currency is not specified in the request this
    /// defaults to 1.0.
    /// Example: USD * currency_conversion_rate = JPY
    pub currency_conversion_rate: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PricingInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [effective_time][crate::model::PricingInfo::effective_time].
    pub fn set_effective_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.effective_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [effective_time][crate::model::PricingInfo::effective_time].
    pub fn set_or_clear_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.effective_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [summary][crate::model::PricingInfo::summary].
    pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.summary = v.into();
        self
    }

    /// Sets the value of [pricing_expression][crate::model::PricingInfo::pricing_expression].
    pub fn set_pricing_expression<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PricingExpression>,
    {
        self.pricing_expression = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pricing_expression][crate::model::PricingInfo::pricing_expression].
    pub fn set_or_clear_pricing_expression<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PricingExpression>,
    {
        self.pricing_expression = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aggregation_info][crate::model::PricingInfo::aggregation_info].
    pub fn set_aggregation_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AggregationInfo>,
    {
        self.aggregation_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aggregation_info][crate::model::PricingInfo::aggregation_info].
    pub fn set_or_clear_aggregation_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AggregationInfo>,
    {
        self.aggregation_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [currency_conversion_rate][crate::model::PricingInfo::currency_conversion_rate].
    pub fn set_currency_conversion_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.currency_conversion_rate = v.into();
        self
    }
}

impl wkt::message::Message for PricingInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.PricingInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PricingInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __effective_time,
            __summary,
            __pricing_expression,
            __aggregation_info,
            __currency_conversion_rate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PricingInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "effectiveTime" => Ok(__FieldTag::__effective_time),
                            "effective_time" => Ok(__FieldTag::__effective_time),
                            "summary" => Ok(__FieldTag::__summary),
                            "pricingExpression" => Ok(__FieldTag::__pricing_expression),
                            "pricing_expression" => Ok(__FieldTag::__pricing_expression),
                            "aggregationInfo" => Ok(__FieldTag::__aggregation_info),
                            "aggregation_info" => Ok(__FieldTag::__aggregation_info),
                            "currencyConversionRate" => Ok(__FieldTag::__currency_conversion_rate),
                            "currency_conversion_rate" => {
                                Ok(__FieldTag::__currency_conversion_rate)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PricingInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PricingInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__effective_time => {
                            if !fields.insert(__FieldTag::__effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_time",
                                ));
                            }
                            result.effective_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pricing_expression => {
                            if !fields.insert(__FieldTag::__pricing_expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pricing_expression",
                                ));
                            }
                            result.pricing_expression = map
                                .next_value::<std::option::Option<crate::model::PricingExpression>>(
                                )?;
                        }
                        __FieldTag::__aggregation_info => {
                            if !fields.insert(__FieldTag::__aggregation_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_info",
                                ));
                            }
                            result.aggregation_info = map
                                .next_value::<std::option::Option<crate::model::AggregationInfo>>(
                                )?;
                        }
                        __FieldTag::__currency_conversion_rate => {
                            if !fields.insert(__FieldTag::__currency_conversion_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for currency_conversion_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.currency_conversion_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PricingInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.effective_time.is_some() {
            state.serialize_entry("effectiveTime", &self.effective_time)?;
        }
        if !self.summary.is_empty() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if self.pricing_expression.is_some() {
            state.serialize_entry("pricingExpression", &self.pricing_expression)?;
        }
        if self.aggregation_info.is_some() {
            state.serialize_entry("aggregationInfo", &self.aggregation_info)?;
        }
        if !wkt::internal::is_default(&self.currency_conversion_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "currencyConversionRate",
                &__With(&self.currency_conversion_rate),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Expresses a mathematical pricing formula. For Example:-
///
/// `usage_unit: GBy`
/// `tiered_rates:`
/// `[start_usage_amount: 20, unit_price: $10]`
/// `[start_usage_amount: 100, unit_price: $5]`
///
/// The above expresses a pricing formula where the first 20GB is free, the
/// next 80GB is priced at $10 per GB followed by $5 per GB for additional
/// usage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PricingExpression {
    /// The short hand for unit of usage this pricing is specified in.
    /// Example: usage_unit of "GiBy" means that usage is specified in "Gibi Byte".
    pub usage_unit: std::string::String,

    /// The recommended quantity of units for displaying pricing info. When
    /// displaying pricing info it is recommended to display:
    /// (unit_price * display_quantity) per display_quantity usage_unit.
    /// This field does not affect the pricing formula and is for display purposes
    /// only.
    /// Example: If the unit_price is "0.0001 USD", the usage_unit is "GB" and
    /// the display_quantity is "1000" then the recommended way of displaying the
    /// pricing info is "0.10 USD per 1000 GB"
    pub display_quantity: f64,

    /// The list of tiered rates for this pricing. The total cost is computed by
    /// applying each of the tiered rates on usage. This repeated list is sorted
    /// by ascending order of start_usage_amount.
    pub tiered_rates: std::vec::Vec<crate::model::pricing_expression::TierRate>,

    /// The unit of usage in human readable form.
    /// Example: "gibi byte".
    pub usage_unit_description: std::string::String,

    /// The base unit for the SKU which is the unit used in usage exports.
    /// Example: "By"
    pub base_unit: std::string::String,

    /// The base unit in human readable form.
    /// Example: "byte".
    pub base_unit_description: std::string::String,

    /// Conversion factor for converting from price per usage_unit to price per
    /// base_unit, and start_usage_amount to start_usage_amount in base_unit.
    /// unit_price / base_unit_conversion_factor = price per base_unit.
    /// start_usage_amount * base_unit_conversion_factor = start_usage_amount in
    /// base_unit.
    pub base_unit_conversion_factor: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PricingExpression {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [usage_unit][crate::model::PricingExpression::usage_unit].
    pub fn set_usage_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.usage_unit = v.into();
        self
    }

    /// Sets the value of [display_quantity][crate::model::PricingExpression::display_quantity].
    pub fn set_display_quantity<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.display_quantity = v.into();
        self
    }

    /// Sets the value of [tiered_rates][crate::model::PricingExpression::tiered_rates].
    pub fn set_tiered_rates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::pricing_expression::TierRate>,
    {
        use std::iter::Iterator;
        self.tiered_rates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [usage_unit_description][crate::model::PricingExpression::usage_unit_description].
    pub fn set_usage_unit_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.usage_unit_description = v.into();
        self
    }

    /// Sets the value of [base_unit][crate::model::PricingExpression::base_unit].
    pub fn set_base_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_unit = v.into();
        self
    }

    /// Sets the value of [base_unit_description][crate::model::PricingExpression::base_unit_description].
    pub fn set_base_unit_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.base_unit_description = v.into();
        self
    }

    /// Sets the value of [base_unit_conversion_factor][crate::model::PricingExpression::base_unit_conversion_factor].
    pub fn set_base_unit_conversion_factor<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.base_unit_conversion_factor = v.into();
        self
    }
}

impl wkt::message::Message for PricingExpression {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.PricingExpression"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PricingExpression {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __usage_unit,
            __display_quantity,
            __tiered_rates,
            __usage_unit_description,
            __base_unit,
            __base_unit_description,
            __base_unit_conversion_factor,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PricingExpression")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "usageUnit" => Ok(__FieldTag::__usage_unit),
                            "usage_unit" => Ok(__FieldTag::__usage_unit),
                            "displayQuantity" => Ok(__FieldTag::__display_quantity),
                            "display_quantity" => Ok(__FieldTag::__display_quantity),
                            "tieredRates" => Ok(__FieldTag::__tiered_rates),
                            "tiered_rates" => Ok(__FieldTag::__tiered_rates),
                            "usageUnitDescription" => Ok(__FieldTag::__usage_unit_description),
                            "usage_unit_description" => Ok(__FieldTag::__usage_unit_description),
                            "baseUnit" => Ok(__FieldTag::__base_unit),
                            "base_unit" => Ok(__FieldTag::__base_unit),
                            "baseUnitDescription" => Ok(__FieldTag::__base_unit_description),
                            "base_unit_description" => Ok(__FieldTag::__base_unit_description),
                            "baseUnitConversionFactor" => {
                                Ok(__FieldTag::__base_unit_conversion_factor)
                            }
                            "base_unit_conversion_factor" => {
                                Ok(__FieldTag::__base_unit_conversion_factor)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PricingExpression;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PricingExpression")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__usage_unit => {
                            if !fields.insert(__FieldTag::__usage_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage_unit",
                                ));
                            }
                            result.usage_unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_quantity => {
                            if !fields.insert(__FieldTag::__display_quantity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_quantity",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.display_quantity =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tiered_rates => {
                            if !fields.insert(__FieldTag::__tiered_rates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tiered_rates",
                                ));
                            }
                            result.tiered_rates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::pricing_expression::TierRate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__usage_unit_description => {
                            if !fields.insert(__FieldTag::__usage_unit_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage_unit_description",
                                ));
                            }
                            result.usage_unit_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_unit => {
                            if !fields.insert(__FieldTag::__base_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_unit",
                                ));
                            }
                            result.base_unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_unit_description => {
                            if !fields.insert(__FieldTag::__base_unit_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_unit_description",
                                ));
                            }
                            result.base_unit_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__base_unit_conversion_factor => {
                            if !fields.insert(__FieldTag::__base_unit_conversion_factor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_unit_conversion_factor",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.base_unit_conversion_factor =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PricingExpression {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.usage_unit.is_empty() {
            state.serialize_entry("usageUnit", &self.usage_unit)?;
        }
        if !wkt::internal::is_default(&self.display_quantity) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("displayQuantity", &__With(&self.display_quantity))?;
        }
        if !self.tiered_rates.is_empty() {
            state.serialize_entry("tieredRates", &self.tiered_rates)?;
        }
        if !self.usage_unit_description.is_empty() {
            state.serialize_entry("usageUnitDescription", &self.usage_unit_description)?;
        }
        if !self.base_unit.is_empty() {
            state.serialize_entry("baseUnit", &self.base_unit)?;
        }
        if !self.base_unit_description.is_empty() {
            state.serialize_entry("baseUnitDescription", &self.base_unit_description)?;
        }
        if !wkt::internal::is_default(&self.base_unit_conversion_factor) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "baseUnitConversionFactor",
                &__With(&self.base_unit_conversion_factor),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PricingExpression].
pub mod pricing_expression {
    #[allow(unused_imports)]
    use super::*;

    /// The price rate indicating starting usage and its corresponding price.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TierRate {
        /// Usage is priced at this rate only after this amount.
        /// Example: start_usage_amount of 10 indicates that the usage will be priced
        /// at the unit_price after the first 10 usage_units.
        pub start_usage_amount: f64,

        /// The price per unit of usage.
        /// Example: unit_price of amount $10 indicates that each unit will cost $10.
        pub unit_price: std::option::Option<gtype::model::Money>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TierRate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_usage_amount][crate::model::pricing_expression::TierRate::start_usage_amount].
        pub fn set_start_usage_amount<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.start_usage_amount = v.into();
            self
        }

        /// Sets the value of [unit_price][crate::model::pricing_expression::TierRate::unit_price].
        pub fn set_unit_price<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.unit_price = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [unit_price][crate::model::pricing_expression::TierRate::unit_price].
        pub fn set_or_clear_unit_price<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.unit_price = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TierRate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.billing.v1.PricingExpression.TierRate"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TierRate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_usage_amount,
                __unit_price,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TierRate")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startUsageAmount" => Ok(__FieldTag::__start_usage_amount),
                                "start_usage_amount" => Ok(__FieldTag::__start_usage_amount),
                                "unitPrice" => Ok(__FieldTag::__unit_price),
                                "unit_price" => Ok(__FieldTag::__unit_price),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TierRate;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TierRate")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_usage_amount => {
                                if !fields.insert(__FieldTag::__start_usage_amount) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_usage_amount",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.start_usage_amount =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__unit_price => {
                                if !fields.insert(__FieldTag::__unit_price) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for unit_price",
                                    ));
                                }
                                result.unit_price =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TierRate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.start_usage_amount) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("startUsageAmount", &__With(&self.start_usage_amount))?;
            }
            if self.unit_price.is_some() {
                state.serialize_entry("unitPrice", &self.unit_price)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Represents the aggregation level and interval for pricing of a single SKU.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AggregationInfo {
    pub aggregation_level: crate::model::aggregation_info::AggregationLevel,

    pub aggregation_interval: crate::model::aggregation_info::AggregationInterval,

    /// The number of intervals to aggregate over.
    /// Example: If aggregation_level is "DAILY" and aggregation_count is 14,
    /// aggregation will be over 14 days.
    pub aggregation_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AggregationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aggregation_level][crate::model::AggregationInfo::aggregation_level].
    pub fn set_aggregation_level<
        T: std::convert::Into<crate::model::aggregation_info::AggregationLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_level = v.into();
        self
    }

    /// Sets the value of [aggregation_interval][crate::model::AggregationInfo::aggregation_interval].
    pub fn set_aggregation_interval<
        T: std::convert::Into<crate::model::aggregation_info::AggregationInterval>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aggregation_interval = v.into();
        self
    }

    /// Sets the value of [aggregation_count][crate::model::AggregationInfo::aggregation_count].
    pub fn set_aggregation_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.aggregation_count = v.into();
        self
    }
}

impl wkt::message::Message for AggregationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.AggregationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AggregationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aggregation_level,
            __aggregation_interval,
            __aggregation_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AggregationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aggregationLevel" => Ok(__FieldTag::__aggregation_level),
                            "aggregation_level" => Ok(__FieldTag::__aggregation_level),
                            "aggregationInterval" => Ok(__FieldTag::__aggregation_interval),
                            "aggregation_interval" => Ok(__FieldTag::__aggregation_interval),
                            "aggregationCount" => Ok(__FieldTag::__aggregation_count),
                            "aggregation_count" => Ok(__FieldTag::__aggregation_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AggregationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AggregationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aggregation_level => {
                            if !fields.insert(__FieldTag::__aggregation_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_level",
                                ));
                            }
                            result.aggregation_level = map
                                .next_value::<std::option::Option<
                                    crate::model::aggregation_info::AggregationLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aggregation_interval => {
                            if !fields.insert(__FieldTag::__aggregation_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_interval",
                                ));
                            }
                            result.aggregation_interval = map
                                .next_value::<std::option::Option<
                                    crate::model::aggregation_info::AggregationInterval,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__aggregation_count => {
                            if !fields.insert(__FieldTag::__aggregation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.aggregation_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AggregationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.aggregation_level) {
            state.serialize_entry("aggregationLevel", &self.aggregation_level)?;
        }
        if !wkt::internal::is_default(&self.aggregation_interval) {
            state.serialize_entry("aggregationInterval", &self.aggregation_interval)?;
        }
        if !wkt::internal::is_default(&self.aggregation_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("aggregationCount", &__With(&self.aggregation_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AggregationInfo].
pub mod aggregation_info {
    #[allow(unused_imports)]
    use super::*;

    /// The level at which usage is aggregated to compute cost.
    /// Example: "ACCOUNT" aggregation level indicates that usage for tiered
    /// pricing is aggregated across all projects in a single account.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AggregationLevel {
        Unspecified,
        Account,
        Project,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AggregationLevel::value] or
        /// [AggregationLevel::name].
        UnknownValue(aggregation_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aggregation_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AggregationLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Account => std::option::Option::Some(1),
                Self::Project => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AGGREGATION_LEVEL_UNSPECIFIED"),
                Self::Account => std::option::Option::Some("ACCOUNT"),
                Self::Project => std::option::Option::Some("PROJECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AggregationLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AggregationLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AggregationLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Account,
                2 => Self::Project,
                _ => Self::UnknownValue(aggregation_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AggregationLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AGGREGATION_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "ACCOUNT" => Self::Account,
                "PROJECT" => Self::Project,
                _ => Self::UnknownValue(aggregation_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AggregationLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Account => serializer.serialize_i32(1),
                Self::Project => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AggregationLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AggregationLevel>::new(
                ".google.cloud.billing.v1.AggregationInfo.AggregationLevel",
            ))
        }
    }

    /// The interval at which usage is aggregated to compute cost.
    /// Example: "MONTHLY" aggregation interval indicates that usage for tiered
    /// pricing is aggregated every month.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AggregationInterval {
        Unspecified,
        Daily,
        Monthly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AggregationInterval::value] or
        /// [AggregationInterval::name].
        UnknownValue(aggregation_interval::UnknownValue),
    }

    #[doc(hidden)]
    pub mod aggregation_interval {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AggregationInterval {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Daily => std::option::Option::Some(1),
                Self::Monthly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AGGREGATION_INTERVAL_UNSPECIFIED"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AggregationInterval {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AggregationInterval {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AggregationInterval {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Daily,
                2 => Self::Monthly,
                _ => Self::UnknownValue(aggregation_interval::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AggregationInterval {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AGGREGATION_INTERVAL_UNSPECIFIED" => Self::Unspecified,
                "DAILY" => Self::Daily,
                "MONTHLY" => Self::Monthly,
                _ => Self::UnknownValue(aggregation_interval::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AggregationInterval {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Daily => serializer.serialize_i32(1),
                Self::Monthly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AggregationInterval {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AggregationInterval>::new(
                ".google.cloud.billing.v1.AggregationInfo.AggregationInterval",
            ))
        }
    }
}

/// Encapsulates the geographic taxonomy data for a sku.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GeoTaxonomy {
    /// The type of Geo Taxonomy: GLOBAL, REGIONAL, or MULTI_REGIONAL.
    pub r#type: crate::model::geo_taxonomy::Type,

    /// The list of regions associated with a sku. Empty for Global skus, which are
    /// associated with all Google Cloud regions.
    pub regions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GeoTaxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::GeoTaxonomy::type].
    pub fn set_type<T: std::convert::Into<crate::model::geo_taxonomy::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [regions][crate::model::GeoTaxonomy::regions].
    pub fn set_regions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.regions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GeoTaxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.GeoTaxonomy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GeoTaxonomy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __regions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeoTaxonomy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "regions" => Ok(__FieldTag::__regions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GeoTaxonomy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeoTaxonomy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::geo_taxonomy::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__regions => {
                            if !fields.insert(__FieldTag::__regions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regions",
                                ));
                            }
                            result.regions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GeoTaxonomy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.regions.is_empty() {
            state.serialize_entry("regions", &self.regions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GeoTaxonomy].
pub mod geo_taxonomy {
    #[allow(unused_imports)]
    use super::*;

    /// The type of Geo Taxonomy: GLOBAL, REGIONAL, or MULTI_REGIONAL.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The type is not specified.
        Unspecified,
        /// The sku is global in nature, e.g. a license sku. Global skus are
        /// available in all regions, and so have an empty region list.
        Global,
        /// The sku is available in a specific region, e.g. "us-west2".
        Regional,
        /// The sku is associated with multiple regions, e.g. "us-west2" and
        /// "us-east1".
        MultiRegional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Global => std::option::Option::Some(1),
                Self::Regional => std::option::Option::Some(2),
                Self::MultiRegional => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Global => std::option::Option::Some("GLOBAL"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::MultiRegional => std::option::Option::Some("MULTI_REGIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Global,
                2 => Self::Regional,
                3 => Self::MultiRegional,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GLOBAL" => Self::Global,
                "REGIONAL" => Self::Regional,
                "MULTI_REGIONAL" => Self::MultiRegional,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Global => serializer.serialize_i32(1),
                Self::Regional => serializer.serialize_i32(2),
                Self::MultiRegional => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.billing.v1.GeoTaxonomy.Type",
            ))
        }
    }
}

/// Request message for `ListServices`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Requested page size. Defaults to 5000.
    pub page_size: i32,

    /// A token identifying a page of results to return. This should be a
    /// `next_page_token` value returned from a previous `ListServices`
    /// call. If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `ListServices`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// A list of services.
    pub services: std::vec::Vec<crate::model::Service>,

    /// A token to retrieve the next page of results. To retrieve the next page,
    /// call `ListServices` again with the `page_token` field set to this
    /// value. This field is empty if there are no more results to retrieve.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for `ListSkus`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSkusRequest {
    /// Required. The name of the service.
    /// Example: "services/6F81-5844-456A"
    pub parent: std::string::String,

    /// Optional inclusive start time of the time range for which the pricing
    /// versions will be returned. Timestamps in the future are not allowed.
    /// The time range has to be within a single calendar month in
    /// America/Los_Angeles timezone. Time range as a whole is optional. If not
    /// specified, the latest pricing will be returned (up to 12 hours old at
    /// most).
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Optional exclusive end time of the time range for which the pricing
    /// versions will be returned. Timestamps in the future are not allowed.
    /// The time range has to be within a single calendar month in
    /// America/Los_Angeles timezone. Time range as a whole is optional. If not
    /// specified, the latest pricing will be returned (up to 12 hours old at
    /// most).
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The ISO 4217 currency code for the pricing info in the response proto.
    /// Will use the conversion rate as of start_time.
    /// Optional. If not specified USD will be used.
    pub currency_code: std::string::String,

    /// Requested page size. Defaults to 5000.
    pub page_size: i32,

    /// A token identifying a page of results to return. This should be a
    /// `next_page_token` value returned from a previous `ListSkus`
    /// call. If unspecified, the first page of results is returned.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSkusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSkusRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ListSkusRequest::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ListSkusRequest::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ListSkusRequest::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ListSkusRequest::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [currency_code][crate::model::ListSkusRequest::currency_code].
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSkusRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSkusRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSkusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListSkusRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSkusRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __start_time,
            __end_time,
            __currency_code,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSkusRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "currencyCode" => Ok(__FieldTag::__currency_code),
                            "currency_code" => Ok(__FieldTag::__currency_code),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSkusRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSkusRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__currency_code => {
                            if !fields.insert(__FieldTag::__currency_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for currency_code",
                                ));
                            }
                            result.currency_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSkusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.currency_code.is_empty() {
            state.serialize_entry("currencyCode", &self.currency_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for `ListSkus`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSkusResponse {
    /// The list of public SKUs of the given service.
    pub skus: std::vec::Vec<crate::model::Sku>,

    /// A token to retrieve the next page of results. To retrieve the next page,
    /// call `ListSkus` again with the `page_token` field set to this
    /// value. This field is empty if there are no more results to retrieve.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSkusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [skus][crate::model::ListSkusResponse::skus].
    pub fn set_skus<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Sku>,
    {
        use std::iter::Iterator;
        self.skus = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSkusResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSkusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.billing.v1.ListSkusResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSkusResponse {
    type PageItem = crate::model::Sku;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.skus
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSkusResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __skus,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSkusResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "skus" => Ok(__FieldTag::__skus),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSkusResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSkusResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__skus => {
                            if !fields.insert(__FieldTag::__skus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skus",
                                ));
                            }
                            result.skus = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Sku>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSkusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.skus.is_empty() {
            state.serialize_entry("skus", &self.skus)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
