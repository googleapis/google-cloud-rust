// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Assignment protocol for a license pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignmentProtocol {
    /// The type of assignment protocol.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub assignment_type: std::option::Option<crate::model::assignment_protocol::AssignmentType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignmentProtocol {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assignment_type][crate::model::AssignmentProtocol::assignment_type].
    ///
    /// Note that all the setters affecting `assignment_type` are mutually
    /// exclusive.
    pub fn set_assignment_type<
        T: std::convert::Into<std::option::Option<crate::model::assignment_protocol::AssignmentType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment_type = v.into();
        self
    }

    /// The value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// if it holds a `ManualAssignmentType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn manual_assignment_type(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::assignment_protocol::ManualAssignmentType>,
    > {
        #[allow(unreachable_patterns)]
        self.assignment_type.as_ref().and_then(|v| match v {
            crate::model::assignment_protocol::AssignmentType::ManualAssignmentType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// to hold a `ManualAssignmentType`.
    ///
    /// Note that all the setters affecting `assignment_type` are
    /// mutually exclusive.
    pub fn set_manual_assignment_type<
        T: std::convert::Into<
                std::boxed::Box<crate::model::assignment_protocol::ManualAssignmentType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment_type = std::option::Option::Some(
            crate::model::assignment_protocol::AssignmentType::ManualAssignmentType(v.into()),
        );
        self
    }

    /// The value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// if it holds a `AutoAssignmentType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_assignment_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::assignment_protocol::AutoAssignmentType>>
    {
        #[allow(unreachable_patterns)]
        self.assignment_type.as_ref().and_then(|v| match v {
            crate::model::assignment_protocol::AssignmentType::AutoAssignmentType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// to hold a `AutoAssignmentType`.
    ///
    /// Note that all the setters affecting `assignment_type` are
    /// mutually exclusive.
    pub fn set_auto_assignment_type<
        T: std::convert::Into<std::boxed::Box<crate::model::assignment_protocol::AutoAssignmentType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment_type = std::option::Option::Some(
            crate::model::assignment_protocol::AssignmentType::AutoAssignmentType(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AssignmentProtocol {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol"
    }
}

/// Defines additional types related to [AssignmentProtocol].
pub mod assignment_protocol {
    #[allow(unused_imports)]
    use super::*;

    /// Allow manual assignments triggered by administrative operations only.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManualAssignmentType {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManualAssignmentType {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ManualAssignmentType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol.ManualAssignmentType"
        }
    }

    /// Configuration for automatic assignments handled by data plane operations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutoAssignmentType {
        /// Optional. The time to live for an inactive license. After this time has
        /// passed, the license will be automatically unassigned from the user. Must
        /// be at least 7 days, if set. If unset, the license will never expire.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub inactive_license_ttl: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoAssignmentType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [inactive_license_ttl][crate::model::assignment_protocol::AutoAssignmentType::inactive_license_ttl].
        pub fn set_inactive_license_ttl<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.inactive_license_ttl = v.into();
            self
        }
    }

    impl wkt::message::Message for AutoAssignmentType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol.AutoAssignmentType"
        }
    }

    /// The type of assignment protocol.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AssignmentType {
        /// Allow manual assignments triggered by administrative operations only.
        ManualAssignmentType(
            std::boxed::Box<crate::model::assignment_protocol::ManualAssignmentType>,
        ),
        /// Allow automatic assignments triggered by data plane operations.
        AutoAssignmentType(std::boxed::Box<crate::model::assignment_protocol::AutoAssignmentType>),
    }
}

/// A license pool represents a pool of licenses that can be assigned to users.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LicensePool {
    /// Identifier. Format:
    /// `billingAccounts/{billing_account}/orders/{order}/licensePool`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Assignment protocol for the license pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub license_assignment_protocol: std::option::Option<crate::model::AssignmentProtocol>,

    /// Output only. Licenses count that are available to be assigned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub available_license_count: i32,

    /// Output only. Total number of licenses in the pool.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_license_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LicensePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LicensePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [license_assignment_protocol][crate::model::LicensePool::license_assignment_protocol].
    pub fn set_license_assignment_protocol<
        T: std::convert::Into<std::option::Option<crate::model::AssignmentProtocol>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_assignment_protocol = v.into();
        self
    }

    /// Sets the value of [available_license_count][crate::model::LicensePool::available_license_count].
    pub fn set_available_license_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_license_count = v.into();
        self
    }

    /// Sets the value of [total_license_count][crate::model::LicensePool::total_license_count].
    pub fn set_total_license_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_license_count = v.into();
        self
    }
}

impl wkt::message::Message for LicensePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LicensePool"
    }
}

/// Request message for getting a license pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLicensePoolRequest {
    /// Required. The name of the license pool to get.
    /// Format: `billingAccounts/{billing_account}/orders/{order}/licensePool`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLicensePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLicensePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLicensePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.GetLicensePoolRequest"
    }
}

/// Request message for updating a license pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateLicensePoolRequest {
    /// Required. The license pool to update.
    ///
    /// The license pool's name field is used to identify the license pool to
    /// update. Format:
    /// `billingAccounts/{billing_account}/orders/{order}/licensePool`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub license_pool: std::option::Option<crate::model::LicensePool>,

    /// Required. The list of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLicensePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [license_pool][crate::model::UpdateLicensePoolRequest::license_pool].
    pub fn set_license_pool<
        T: std::convert::Into<std::option::Option<crate::model::LicensePool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.license_pool = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateLicensePoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateLicensePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.UpdateLicensePoolRequest"
    }
}

/// Request message for
/// [LicenseManagementService.Assign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign]: crate::client::LicenseManagementService::assign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignRequest {
    /// Required. License pool name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Username.
    /// Format: `name@domain.com`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub usernames: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AssignRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [usernames][crate::model::AssignRequest::usernames].
    pub fn set_usernames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.usernames = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignRequest"
    }
}

/// Response message for
/// [LicenseManagementService.Assign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign]: crate::client::LicenseManagementService::assign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AssignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignResponse"
    }
}

/// Request message for
/// [LicenseManagementService.Unassign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign]: crate::client::LicenseManagementService::unassign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnassignRequest {
    /// Required. License pool name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Username.
    /// Format: `name@domain.com`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub usernames: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnassignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UnassignRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [usernames][crate::model::UnassignRequest::usernames].
    pub fn set_usernames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.usernames = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UnassignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.UnassignRequest"
    }
}

/// Response message for
/// [LicenseManagementService.Unassign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign]: crate::client::LicenseManagementService::unassign
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UnassignResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnassignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UnassignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.UnassignResponse"
    }
}

/// Request message for
/// [LicenseManagementService.EnumerateLicensedUsers][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers]: crate::client::LicenseManagementService::enumerate_licensed_users
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnumerateLicensedUsersRequest {
    /// Required. License pool name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of users to return. The service may return
    /// fewer than this value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token, received from a previous `EnumerateLicensedUsers`
    /// call. Provide this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumerateLicensedUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::EnumerateLicensedUsersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::EnumerateLicensedUsersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::EnumerateLicensedUsersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for EnumerateLicensedUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.EnumerateLicensedUsersRequest"
    }
}

/// A licensed user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LicensedUser {
    /// Username.
    /// Format: `name@domain.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Output only. Timestamp when the license was assigned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub assign_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when the license was recently used. This may not be
    /// the most recent usage time, and will be updated regularly (within 24
    /// hours).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recent_usage_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LicensedUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::LicensedUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [assign_time][crate::model::LicensedUser::assign_time].
    pub fn set_assign_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.assign_time = v.into();
        self
    }

    /// Sets the value of [recent_usage_time][crate::model::LicensedUser::recent_usage_time].
    pub fn set_recent_usage_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.recent_usage_time = v.into();
        self
    }
}

impl wkt::message::Message for LicensedUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LicensedUser"
    }
}

/// Response message for
/// [LicenseManagementService.EnumerateLicensedUsers][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers]: crate::client::LicenseManagementService::enumerate_licensed_users
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnumerateLicensedUsersResponse {
    /// The list of licensed users.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub licensed_users: std::vec::Vec<crate::model::LicensedUser>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumerateLicensedUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [licensed_users][crate::model::EnumerateLicensedUsersResponse::licensed_users].
    pub fn set_licensed_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LicensedUser>,
    {
        use std::iter::Iterator;
        self.licensed_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::EnumerateLicensedUsersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for EnumerateLicensedUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.EnumerateLicensedUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for EnumerateLicensedUsersResponse {
    type PageItem = crate::model::LicensedUser;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.licensed_users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Represents a purchase made by a customer on Cloud Marketplace.
/// Creating an order makes sure that both the Google backend systems
/// as well as external service provider's systems (if needed) allow use of
/// purchased products and ensures the appropriate billing events occur.
///
/// An Order can be made against one Product with multiple add-ons (optional) or
/// one Quote which might reference multiple products.
///
/// Customers typically choose a price plan for each Product purchased when
/// they create an order and can change their plan later, if the product allows.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Order {
    /// Output only. The resource name of the order.
    /// Has the form
    /// `billingAccounts/{billing_account}/orders/{order}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The user-specified name of the order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The items being purchased.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub line_items: std::vec::Vec<crate::model::LineItem>,

    /// Output only. Line items that were cancelled.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cancelled_line_items: std::vec::Vec<crate::model::LineItem>,

    /// Output only. The creation timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The weak etag of the order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Order {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Order::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Order::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [line_items][crate::model::Order::line_items].
    pub fn set_line_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItem>,
    {
        use std::iter::Iterator;
        self.line_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cancelled_line_items][crate::model::Order::cancelled_line_items].
    pub fn set_cancelled_line_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItem>,
    {
        use std::iter::Iterator;
        self.cancelled_line_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Order::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Order::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Order::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Order {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Order"
    }
}

/// A single item within an order.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LineItem {
    /// Output only. Line item ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub line_item_id: std::string::String,

    /// Output only. Current state and information of this item. It tells what,
    /// e.g. which offer, is currently effective.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub line_item_info: std::option::Option<crate::model::LineItemInfo>,

    /// Output only. A change made on the item which is pending and not yet
    /// effective. Absence of this field indicates the line item is not undergoing
    /// a change.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pending_change: std::option::Option<crate::model::LineItemChange>,

    /// Output only. Changes made on the item that are not pending anymore which
    /// might be because they already took effect, were reverted by the customer,
    /// or were rejected by the partner. No more operations are allowed on these
    /// changes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub change_history: std::vec::Vec<crate::model::LineItemChange>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LineItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [line_item_id][crate::model::LineItem::line_item_id].
    pub fn set_line_item_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.line_item_id = v.into();
        self
    }

    /// Sets the value of [line_item_info][crate::model::LineItem::line_item_info].
    pub fn set_line_item_info<
        T: std::convert::Into<std::option::Option<crate::model::LineItemInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.line_item_info = v.into();
        self
    }

    /// Sets the value of [pending_change][crate::model::LineItem::pending_change].
    pub fn set_pending_change<
        T: std::convert::Into<std::option::Option<crate::model::LineItemChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pending_change = v.into();
        self
    }

    /// Sets the value of [change_history][crate::model::LineItem::change_history].
    pub fn set_change_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItemChange>,
    {
        use std::iter::Iterator;
        self.change_history = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LineItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LineItem"
    }
}

/// A change made on a line item.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LineItemChange {
    /// Output only. Change ID.
    /// All changes made within one order update operation have the same change_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub change_id: std::string::String,

    /// Required. Type of the change to make.
    pub change_type: crate::model::LineItemChangeType,

    /// Output only. Line item info before the change.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub old_line_item_info: std::option::Option<crate::model::LineItemInfo>,

    /// Line item info after the change.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub new_line_item_info: std::option::Option<crate::model::LineItemInfo>,

    /// Output only. State of the change.
    pub change_state: crate::model::LineItemChangeState,

    /// Output only. Provider-supplied message explaining the LineItemChange's
    /// state. Mainly used to communicate progress and ETA for provisioning in the
    /// case of `PENDING_APPROVAL`, and to explain why the change request was
    /// denied or canceled in the case of `REJECTED` and `CANCELED` states.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_reason: std::string::String,

    /// Output only. Predefined enum types for why this line item change is in
    /// current state. For example, a line item change's state could be
    /// `LINE_ITEM_CHANGE_STATE_COMPLETED` because of end-of-term expiration,
    /// immediate cancellation initiated by the user, or system-initiated
    /// cancellation.
    pub change_state_reason_type: crate::model::LineItemChangeStateReasonType,

    /// Output only. A time at which the change became or will become (in case of
    /// pending change) effective.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub change_effective_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when change was initiated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when change was updated, e.g. approved/rejected by
    /// partners or cancelled by the user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LineItemChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [change_id][crate::model::LineItemChange::change_id].
    pub fn set_change_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.change_id = v.into();
        self
    }

    /// Sets the value of [change_type][crate::model::LineItemChange::change_type].
    pub fn set_change_type<T: std::convert::Into<crate::model::LineItemChangeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.change_type = v.into();
        self
    }

    /// Sets the value of [old_line_item_info][crate::model::LineItemChange::old_line_item_info].
    pub fn set_old_line_item_info<
        T: std::convert::Into<std::option::Option<crate::model::LineItemInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.old_line_item_info = v.into();
        self
    }

    /// Sets the value of [new_line_item_info][crate::model::LineItemChange::new_line_item_info].
    pub fn set_new_line_item_info<
        T: std::convert::Into<std::option::Option<crate::model::LineItemInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.new_line_item_info = v.into();
        self
    }

    /// Sets the value of [change_state][crate::model::LineItemChange::change_state].
    pub fn set_change_state<T: std::convert::Into<crate::model::LineItemChangeState>>(
        mut self,
        v: T,
    ) -> Self {
        self.change_state = v.into();
        self
    }

    /// Sets the value of [state_reason][crate::model::LineItemChange::state_reason].
    pub fn set_state_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_reason = v.into();
        self
    }

    /// Sets the value of [change_state_reason_type][crate::model::LineItemChange::change_state_reason_type].
    pub fn set_change_state_reason_type<
        T: std::convert::Into<crate::model::LineItemChangeStateReasonType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.change_state_reason_type = v.into();
        self
    }

    /// Sets the value of [change_effective_time][crate::model::LineItemChange::change_effective_time].
    pub fn set_change_effective_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.change_effective_time = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::LineItemChange::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::LineItemChange::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for LineItemChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LineItemChange"
    }
}

/// Line item information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LineItemInfo {
    /// Optional. The name of the offer can have either of these formats:
    /// 'billingAccounts/{billing_account}/offers/{offer}',
    /// or 'services/{service}/standardOffers/{offer}'.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub offer: std::string::String,

    /// Optional. User-provided parameters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::Parameter>,

    /// Output only. Information about the subscription created, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub subscription: std::option::Option<crate::model::Subscription>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LineItemInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [offer][crate::model::LineItemInfo::offer].
    pub fn set_offer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.offer = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::LineItemInfo::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subscription][crate::model::LineItemInfo::subscription].
    pub fn set_subscription<
        T: std::convert::Into<std::option::Option<crate::model::Subscription>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.subscription = v.into();
        self
    }
}

impl wkt::message::Message for LineItemInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LineItemInfo"
    }
}

/// User-provided Parameters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Parameter {
    /// Name of the parameter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Value of parameter.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::parameter::Value>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Parameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Parameter::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Parameter::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<crate::model::parameter::Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for Parameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Parameter"
    }
}

/// Defines additional types related to [Parameter].
pub mod parameter {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Value {
        /// The kind of value.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub kind: std::option::Option<crate::model::parameter::value::Kind>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Value {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::parameter::value::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::parameter::Value::kind]
        /// if it holds a `Int64Value`, `None` if the field is not set or
        /// holds a different branch.
        pub fn int64_value(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::parameter::value::Kind::Int64Value(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind]
        /// to hold a `Int64Value`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::parameter::value::Kind::Int64Value(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::parameter::Value::kind]
        /// if it holds a `StringValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn string_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::parameter::value::Kind::StringValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind]
        /// to hold a `StringValue`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_string_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::parameter::value::Kind::StringValue(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::parameter::Value::kind]
        /// if it holds a `DoubleValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn double_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::parameter::value::Kind::DoubleValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind]
        /// to hold a `DoubleValue`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::parameter::value::Kind::DoubleValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Value {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Parameter.Value"
        }
    }

    /// Defines additional types related to [Value].
    pub mod value {
        #[allow(unused_imports)]
        use super::*;

        /// The kind of value.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Kind {
            /// Represents an int64 value.
            Int64Value(i64),
            /// Represents a string value.
            StringValue(std::string::String),
            /// Represents a double value.
            DoubleValue(f64),
        }
    }
}

/// Subscription information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Subscription {
    /// The timestamp when the subscription begins, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The timestamp when the subscription ends, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Whether auto renewal is enabled by user choice on current subscription.
    /// This field indicates order/subscription status after pending plan change is
    /// cancelled or rejected.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_renewal_enabled: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subscription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::Subscription::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Subscription::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [auto_renewal_enabled][crate::model::Subscription::auto_renewal_enabled].
    pub fn set_auto_renewal_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_renewal_enabled = v.into();
        self
    }
}

impl wkt::message::Message for Subscription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Subscription"
    }
}

/// Request message for
/// [ConsumerProcurementService.PlaceOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder]: crate::client::ConsumerProcurementService::place_order
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PlaceOrderRequest {
    /// Required. The resource name of the parent resource.
    /// This field has the form  `billingAccounts/{billing-account-id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The user-specified name of the order being placed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. Places order for offer. Required when an offer-based order is
    /// being placed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub line_item_info: std::vec::Vec<crate::model::LineItemInfo>,

    /// Optional. A unique identifier for this request.
    /// The server will ignore subsequent requests that provide a duplicate request
    /// ID for at least 24 hours after the first request.
    ///
    /// The request ID must be a valid
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlaceOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PlaceOrderRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PlaceOrderRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [line_item_info][crate::model::PlaceOrderRequest::line_item_info].
    pub fn set_line_item_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItemInfo>,
    {
        use std::iter::Iterator;
        self.line_item_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [request_id][crate::model::PlaceOrderRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for PlaceOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.PlaceOrderRequest"
    }
}

/// Message stored in the metadata field of the Operation returned by
/// [ConsumerProcurementService.PlaceOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder]: crate::client::ConsumerProcurementService::place_order
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PlaceOrderMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlaceOrderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PlaceOrderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.PlaceOrderMetadata"
    }
}

/// Request message for
/// [ConsumerProcurementService.GetOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.GetOrder]
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.GetOrder]: crate::client::ConsumerProcurementService::get_order
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetOrderRequest {
    /// Required. The name of the order to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOrderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.GetOrderRequest"
    }
}

/// Request message for
/// [ConsumerProcurementService.ListOrders][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders]: crate::client::ConsumerProcurementService::list_orders
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrdersRequest {
    /// Required. The parent resource to query for orders.
    /// This field has the form `billingAccounts/{billing-account-id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of entries requested.
    /// The default page size is 25 and the maximum page size is 200.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The token for fetching the next page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filter that you can use to limit the list request.
    ///
    /// A query string that can match a selected set of attributes
    /// with string values. For example, `display_name=abc`.
    /// Supported query attributes are
    ///
    /// * `display_name`
    ///
    /// If the query contains special characters other than letters,
    /// underscore, or digits, the phrase must be quoted with double quotes. For
    /// example, `display_name="foo:bar"`, where the display name needs to be
    /// quoted because it contains special character colon.
    ///
    /// Queries can be combined with `OR`, and `NOT` to form more complex queries.
    /// You can also group them to force a desired evaluation order.
    /// For example, `display_name=abc OR display_name=def`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrdersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOrdersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOrdersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOrdersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOrdersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListOrdersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ListOrdersRequest"
    }
}

/// Response message for
/// [ConsumerProcurementService.ListOrders][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders]: crate::client::ConsumerProcurementService::list_orders
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListOrdersResponse {
    /// The list of orders in this response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub orders: std::vec::Vec<crate::model::Order>,

    /// The token for fetching the next page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrdersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [orders][crate::model::ListOrdersResponse::orders].
    pub fn set_orders<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Order>,
    {
        use std::iter::Iterator;
        self.orders = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOrdersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOrdersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ListOrdersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOrdersResponse {
    type PageItem = crate::model::Order;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.orders
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for
/// [ConsumerProcurementService.ModifyOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder]: crate::client::ConsumerProcurementService::modify_order
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModifyOrderRequest {
    /// Required. Name of the order to update.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Modifications for an existing Order created by an Offer.
    /// Required when Offer based Order is being modified, except for when going
    /// from an offer to a public plan.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub modifications: std::vec::Vec<crate::model::modify_order_request::Modification>,

    /// Optional. Updated display name of the order, leave as empty if you do not
    /// want to update current display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The weak etag, which can be optionally populated, of the order
    /// that this modify request is based on. Validation checking will only happen
    /// if the invoker supplies this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyOrderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [modifications][crate::model::ModifyOrderRequest::modifications].
    pub fn set_modifications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::modify_order_request::Modification>,
    {
        use std::iter::Iterator;
        self.modifications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::ModifyOrderRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::ModifyOrderRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for ModifyOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ModifyOrderRequest"
    }
}

/// Defines additional types related to [ModifyOrderRequest].
pub mod modify_order_request {
    #[allow(unused_imports)]
    use super::*;

    /// Modifications to make on the order.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Modification {
        /// Required. ID of the existing line item to make change to.
        /// Required when change type is
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE] or
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CANCEL].
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub line_item_id: std::string::String,

        /// Required. Type of change to make.
        pub change_type: crate::model::LineItemChangeType,

        /// Optional. The line item to update to.
        /// Required when change_type is
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CREATE] or
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE].
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub new_line_item_info: std::option::Option<crate::model::LineItemInfo>,

        /// Optional. Auto renewal behavior of the subscription for the update.
        /// Applied when change_type is
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE]. Follows plan default
        /// config when this field is not specified.
        pub auto_renewal_behavior: crate::model::AutoRenewalBehavior,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Modification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line_item_id][crate::model::modify_order_request::Modification::line_item_id].
        pub fn set_line_item_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.line_item_id = v.into();
            self
        }

        /// Sets the value of [change_type][crate::model::modify_order_request::Modification::change_type].
        pub fn set_change_type<T: std::convert::Into<crate::model::LineItemChangeType>>(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }

        /// Sets the value of [new_line_item_info][crate::model::modify_order_request::Modification::new_line_item_info].
        pub fn set_new_line_item_info<
            T: std::convert::Into<std::option::Option<crate::model::LineItemInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.new_line_item_info = v.into();
            self
        }

        /// Sets the value of [auto_renewal_behavior][crate::model::modify_order_request::Modification::auto_renewal_behavior].
        pub fn set_auto_renewal_behavior<
            T: std::convert::Into<crate::model::AutoRenewalBehavior>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auto_renewal_behavior = v.into();
            self
        }
    }

    impl wkt::message::Message for Modification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ModifyOrderRequest.Modification"
        }
    }
}

/// Message stored in the metadata field of the Operation returned by
/// [ConsumerProcurementService.ModifyOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder]: crate::client::ConsumerProcurementService::modify_order
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModifyOrderMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyOrderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ModifyOrderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ModifyOrderMetadata"
    }
}

/// Request message for
/// [ConsumerProcurementService.CancelOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder]: crate::client::ConsumerProcurementService::cancel_order
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelOrderRequest {
    /// Required. The resource name of the order.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The weak etag, which can be optionally populated, of the order
    /// that this cancel request is based on. Validation checking will only happen
    /// if the invoker supplies this field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Cancellation policy of this request.
    pub cancellation_policy: crate::model::cancel_order_request::CancellationPolicy,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelOrderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::CancelOrderRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [cancellation_policy][crate::model::CancelOrderRequest::cancellation_policy].
    pub fn set_cancellation_policy<
        T: std::convert::Into<crate::model::cancel_order_request::CancellationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cancellation_policy = v.into();
        self
    }
}

impl wkt::message::Message for CancelOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.CancelOrderRequest"
    }
}

/// Defines additional types related to [CancelOrderRequest].
pub mod cancel_order_request {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the cancellation policy the customer uses to cancel the order.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CancellationPolicy {
        /// If unspecified, cancellation will try to cancel the order, if order
        /// cannot be immediately cancelled, auto renewal will be turned off.
        /// However, caller should avoid using the value as it will yield a
        /// non-deterministic result. This is still supported mainly to maintain
        /// existing integrated usages and ensure backwards compatibility.
        Unspecified,
        /// Request will cancel the whole order immediately, if order cannot be
        /// immediately cancelled, the request will fail.
        CancelImmediately,
        /// Request will cancel the auto renewal, if order is not subscription based,
        /// the request will fail.
        CancelAtTermEnd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CancellationPolicy::value] or
        /// [CancellationPolicy::name].
        UnknownValue(cancellation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cancellation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CancellationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CancelImmediately => std::option::Option::Some(1),
                Self::CancelAtTermEnd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CANCELLATION_POLICY_UNSPECIFIED"),
                Self::CancelImmediately => {
                    std::option::Option::Some("CANCELLATION_POLICY_CANCEL_IMMEDIATELY")
                }
                Self::CancelAtTermEnd => {
                    std::option::Option::Some("CANCELLATION_POLICY_CANCEL_AT_TERM_END")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CancellationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CancellationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CancellationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CancelImmediately,
                2 => Self::CancelAtTermEnd,
                _ => Self::UnknownValue(cancellation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CancellationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CANCELLATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "CANCELLATION_POLICY_CANCEL_IMMEDIATELY" => Self::CancelImmediately,
                "CANCELLATION_POLICY_CANCEL_AT_TERM_END" => Self::CancelAtTermEnd,
                _ => Self::UnknownValue(cancellation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CancellationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CancelImmediately => serializer.serialize_i32(1),
                Self::CancelAtTermEnd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CancellationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CancellationPolicy>::new(
                ".google.cloud.commerce.consumer.procurement.v1.CancelOrderRequest.CancellationPolicy"))
        }
    }
}

/// Message stored in the metadata field of the Operation returned by
/// [ConsumerProcurementService.CancelOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder]: crate::client::ConsumerProcurementService::cancel_order
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelOrderMetadata {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelOrderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelOrderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.CancelOrderMetadata"
    }
}

/// Type of a line item change.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LineItemChangeType {
    /// Sentinel value. Do not use.
    Unspecified,
    /// The change is to create a new line item.
    Create,
    /// The change is to update an existing line item.
    Update,
    /// The change is to cancel an existing line item.
    Cancel,
    /// The change is to revert a cancellation.
    RevertCancellation,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LineItemChangeType::value] or
    /// [LineItemChangeType::name].
    UnknownValue(line_item_change_type::UnknownValue),
}

#[doc(hidden)]
pub mod line_item_change_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LineItemChangeType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Create => std::option::Option::Some(1),
            Self::Update => std::option::Option::Some(2),
            Self::Cancel => std::option::Option::Some(3),
            Self::RevertCancellation => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_UNSPECIFIED"),
            Self::Create => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_CREATE"),
            Self::Update => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_UPDATE"),
            Self::Cancel => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_CANCEL"),
            Self::RevertCancellation => {
                std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LineItemChangeType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LineItemChangeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LineItemChangeType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Create,
            2 => Self::Update,
            3 => Self::Cancel,
            4 => Self::RevertCancellation,
            _ => Self::UnknownValue(line_item_change_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LineItemChangeType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINE_ITEM_CHANGE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "LINE_ITEM_CHANGE_TYPE_CREATE" => Self::Create,
            "LINE_ITEM_CHANGE_TYPE_UPDATE" => Self::Update,
            "LINE_ITEM_CHANGE_TYPE_CANCEL" => Self::Cancel,
            "LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION" => Self::RevertCancellation,
            _ => Self::UnknownValue(line_item_change_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LineItemChangeType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Create => serializer.serialize_i32(1),
            Self::Update => serializer.serialize_i32(2),
            Self::Cancel => serializer.serialize_i32(3),
            Self::RevertCancellation => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LineItemChangeType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LineItemChangeType>::new(
            ".google.cloud.commerce.consumer.procurement.v1.LineItemChangeType",
        ))
    }
}

/// State of a change.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LineItemChangeState {
    /// Sentinel value. Do not use.
    Unspecified,
    /// Change is in this state when a change is initiated and waiting for partner
    /// approval. This state is only applicable for pending change.
    PendingApproval,
    /// Change is in this state after it's approved by the partner or auto-approved
    /// but before it takes effect. The change can be overwritten or cancelled
    /// depending on the new line item info property (pending Private Offer change
    /// cannot be cancelled and can only be overwritten by another Private Offer).
    /// This state is only applicable for pending change.
    Approved,
    /// Change is in this state after it's been activated. This state is only
    /// applicable for change in history.
    Completed,
    /// Change is in this state if it was rejected by the partner. This state is
    /// only applicable for change in history.
    Rejected,
    /// Change is in this state if it was abandoned by the user. This state is only
    /// applicable for change in history.
    Abandoned,
    /// Change is in this state if it's currently being provisioned downstream. The
    /// change can't be overwritten or cancelled when it's in this state. This
    /// state is only applicable for pending change.
    Activating,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LineItemChangeState::value] or
    /// [LineItemChangeState::name].
    UnknownValue(line_item_change_state::UnknownValue),
}

#[doc(hidden)]
pub mod line_item_change_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LineItemChangeState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PendingApproval => std::option::Option::Some(1),
            Self::Approved => std::option::Option::Some(2),
            Self::Completed => std::option::Option::Some(3),
            Self::Rejected => std::option::Option::Some(4),
            Self::Abandoned => std::option::Option::Some(5),
            Self::Activating => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_UNSPECIFIED"),
            Self::PendingApproval => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL")
            }
            Self::Approved => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_APPROVED"),
            Self::Completed => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_COMPLETED"),
            Self::Rejected => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REJECTED"),
            Self::Abandoned => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_ABANDONED"),
            Self::Activating => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_ACTIVATING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LineItemChangeState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LineItemChangeState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LineItemChangeState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PendingApproval,
            2 => Self::Approved,
            3 => Self::Completed,
            4 => Self::Rejected,
            5 => Self::Abandoned,
            6 => Self::Activating,
            _ => Self::UnknownValue(line_item_change_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LineItemChangeState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINE_ITEM_CHANGE_STATE_UNSPECIFIED" => Self::Unspecified,
            "LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL" => Self::PendingApproval,
            "LINE_ITEM_CHANGE_STATE_APPROVED" => Self::Approved,
            "LINE_ITEM_CHANGE_STATE_COMPLETED" => Self::Completed,
            "LINE_ITEM_CHANGE_STATE_REJECTED" => Self::Rejected,
            "LINE_ITEM_CHANGE_STATE_ABANDONED" => Self::Abandoned,
            "LINE_ITEM_CHANGE_STATE_ACTIVATING" => Self::Activating,
            _ => Self::UnknownValue(line_item_change_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LineItemChangeState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PendingApproval => serializer.serialize_i32(1),
            Self::Approved => serializer.serialize_i32(2),
            Self::Completed => serializer.serialize_i32(3),
            Self::Rejected => serializer.serialize_i32(4),
            Self::Abandoned => serializer.serialize_i32(5),
            Self::Activating => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LineItemChangeState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LineItemChangeState>::new(
            ".google.cloud.commerce.consumer.procurement.v1.LineItemChangeState",
        ))
    }
}

/// Predefined types for line item change state reason.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LineItemChangeStateReasonType {
    /// Default value, indicating there's no predefined type for change state
    /// reason.
    Unspecified,
    /// Change is in current state due to term expiration.
    Expired,
    /// Change is in current state due to user-initiated cancellation.
    UserCancelled,
    /// Change is in current state due to system-initiated cancellation.
    SystemCancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LineItemChangeStateReasonType::value] or
    /// [LineItemChangeStateReasonType::name].
    UnknownValue(line_item_change_state_reason_type::UnknownValue),
}

#[doc(hidden)]
pub mod line_item_change_state_reason_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LineItemChangeStateReasonType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Expired => std::option::Option::Some(1),
            Self::UserCancelled => std::option::Option::Some(2),
            Self::SystemCancelled => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED")
            }
            Self::Expired => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED")
            }
            Self::UserCancelled => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED")
            }
            Self::SystemCancelled => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LineItemChangeStateReasonType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LineItemChangeStateReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LineItemChangeStateReasonType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Expired,
            2 => Self::UserCancelled,
            3 => Self::SystemCancelled,
            _ => Self::UnknownValue(line_item_change_state_reason_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LineItemChangeStateReasonType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED" => Self::Unspecified,
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED" => Self::Expired,
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED" => Self::UserCancelled,
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED" => Self::SystemCancelled,
            _ => Self::UnknownValue(line_item_change_state_reason_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LineItemChangeStateReasonType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Expired => serializer.serialize_i32(1),
            Self::UserCancelled => serializer.serialize_i32(2),
            Self::SystemCancelled => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LineItemChangeStateReasonType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<LineItemChangeStateReasonType>::new(
                ".google.cloud.commerce.consumer.procurement.v1.LineItemChangeStateReasonType",
            ),
        )
    }
}

/// Indicates the auto renewal behavior customer specifies on subscription.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AutoRenewalBehavior {
    /// If unspecified, the auto renewal behavior will follow the default config.
    Unspecified,
    /// Auto Renewal will be enabled on subscription.
    Enable,
    /// Auto Renewal will be disabled on subscription.
    Disable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AutoRenewalBehavior::value] or
    /// [AutoRenewalBehavior::name].
    UnknownValue(auto_renewal_behavior::UnknownValue),
}

#[doc(hidden)]
pub mod auto_renewal_behavior {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AutoRenewalBehavior {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enable => std::option::Option::Some(1),
            Self::Disable => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUTO_RENEWAL_BEHAVIOR_UNSPECIFIED"),
            Self::Enable => std::option::Option::Some("AUTO_RENEWAL_BEHAVIOR_ENABLE"),
            Self::Disable => std::option::Option::Some("AUTO_RENEWAL_BEHAVIOR_DISABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AutoRenewalBehavior {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AutoRenewalBehavior {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AutoRenewalBehavior {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enable,
            2 => Self::Disable,
            _ => Self::UnknownValue(auto_renewal_behavior::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AutoRenewalBehavior {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTO_RENEWAL_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
            "AUTO_RENEWAL_BEHAVIOR_ENABLE" => Self::Enable,
            "AUTO_RENEWAL_BEHAVIOR_DISABLE" => Self::Disable,
            _ => Self::UnknownValue(auto_renewal_behavior::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AutoRenewalBehavior {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enable => serializer.serialize_i32(1),
            Self::Disable => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AutoRenewalBehavior {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoRenewalBehavior>::new(
            ".google.cloud.commerce.consumer.procurement.v1.AutoRenewalBehavior",
        ))
    }
}
