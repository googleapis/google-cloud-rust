// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Assignment protocol for a license pool.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AssignmentProtocol {
    /// The type of assignment protocol.
    pub assignment_type: std::option::Option<crate::model::assignment_protocol::AssignmentType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignmentProtocol {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assignment_type][crate::model::AssignmentProtocol::assignment_type].
    ///
    /// Note that all the setters affecting `assignment_type` are mutually
    /// exclusive.
    pub fn set_assignment_type<
        T: std::convert::Into<std::option::Option<crate::model::assignment_protocol::AssignmentType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment_type = v.into();
        self
    }

    /// The value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// if it holds a `ManualAssignmentType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn manual_assignment_type(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::assignment_protocol::ManualAssignmentType>,
    > {
        #[allow(unreachable_patterns)]
        self.assignment_type.as_ref().and_then(|v| match v {
            crate::model::assignment_protocol::AssignmentType::ManualAssignmentType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// to hold a `ManualAssignmentType`.
    ///
    /// Note that all the setters affecting `assignment_type` are
    /// mutually exclusive.
    pub fn set_manual_assignment_type<
        T: std::convert::Into<
                std::boxed::Box<crate::model::assignment_protocol::ManualAssignmentType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment_type = std::option::Option::Some(
            crate::model::assignment_protocol::AssignmentType::ManualAssignmentType(v.into()),
        );
        self
    }

    /// The value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// if it holds a `AutoAssignmentType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_assignment_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::assignment_protocol::AutoAssignmentType>>
    {
        #[allow(unreachable_patterns)]
        self.assignment_type.as_ref().and_then(|v| match v {
            crate::model::assignment_protocol::AssignmentType::AutoAssignmentType(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [assignment_type][crate::model::AssignmentProtocol::assignment_type]
    /// to hold a `AutoAssignmentType`.
    ///
    /// Note that all the setters affecting `assignment_type` are
    /// mutually exclusive.
    pub fn set_auto_assignment_type<
        T: std::convert::Into<std::boxed::Box<crate::model::assignment_protocol::AutoAssignmentType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.assignment_type = std::option::Option::Some(
            crate::model::assignment_protocol::AssignmentType::AutoAssignmentType(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AssignmentProtocol {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssignmentProtocol {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __manual_assignment_type,
            __auto_assignment_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssignmentProtocol")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "manualAssignmentType" => Ok(__FieldTag::__manual_assignment_type),
                            "manual_assignment_type" => Ok(__FieldTag::__manual_assignment_type),
                            "autoAssignmentType" => Ok(__FieldTag::__auto_assignment_type),
                            "auto_assignment_type" => Ok(__FieldTag::__auto_assignment_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssignmentProtocol;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssignmentProtocol")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__manual_assignment_type => {
                            if !fields.insert(__FieldTag::__manual_assignment_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_assignment_type",
                                ));
                            }
                            if result.assignment_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `assignment_type`, a oneof with full ID .google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol.manual_assignment_type, latest field was manualAssignmentType",
                                ));
                            }
                            result.assignment_type = std::option::Option::Some(
                                crate::model::assignment_protocol::AssignmentType::ManualAssignmentType(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::assignment_protocol::ManualAssignmentType>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__auto_assignment_type => {
                            if !fields.insert(__FieldTag::__auto_assignment_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_assignment_type",
                                ));
                            }
                            if result.assignment_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `assignment_type`, a oneof with full ID .google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol.auto_assignment_type, latest field was autoAssignmentType",
                                ));
                            }
                            result.assignment_type = std::option::Option::Some(
                                crate::model::assignment_protocol::AssignmentType::AutoAssignmentType(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::assignment_protocol::AutoAssignmentType>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssignmentProtocol {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.manual_assignment_type() {
            state.serialize_entry("manualAssignmentType", value)?;
        }
        if let Some(value) = self.auto_assignment_type() {
            state.serialize_entry("autoAssignmentType", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AssignmentProtocol].
pub mod assignment_protocol {
    #[allow(unused_imports)]
    use super::*;

    /// Allow manual assignments triggered by administrative operations only.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ManualAssignmentType {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManualAssignmentType {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for ManualAssignmentType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol.ManualAssignmentType"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ManualAssignmentType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ManualAssignmentType")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ManualAssignmentType;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ManualAssignmentType")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ManualAssignmentType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for automatic assignments handled by data plane operations.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutoAssignmentType {
        /// Optional. The time to live for an inactive license. After this time has
        /// passed, the license will be automatically unassigned from the user. Must
        /// be at least 7 days, if set. If unset, the license will never expire.
        pub inactive_license_ttl: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutoAssignmentType {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [inactive_license_ttl][crate::model::assignment_protocol::AutoAssignmentType::inactive_license_ttl].
        pub fn set_inactive_license_ttl<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.inactive_license_ttl = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [inactive_license_ttl][crate::model::assignment_protocol::AutoAssignmentType::inactive_license_ttl].
        pub fn set_or_clear_inactive_license_ttl<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.inactive_license_ttl = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AutoAssignmentType {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignmentProtocol.AutoAssignmentType"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AutoAssignmentType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __inactive_license_ttl,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AutoAssignmentType")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inactiveLicenseTtl" => Ok(__FieldTag::__inactive_license_ttl),
                                "inactive_license_ttl" => Ok(__FieldTag::__inactive_license_ttl),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AutoAssignmentType;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AutoAssignmentType")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__inactive_license_ttl => {
                                if !fields.insert(__FieldTag::__inactive_license_ttl) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for inactive_license_ttl",
                                    ));
                                }
                                result.inactive_license_ttl =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AutoAssignmentType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.inactive_license_ttl.is_some() {
                state.serialize_entry("inactiveLicenseTtl", &self.inactive_license_ttl)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The type of assignment protocol.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AssignmentType {
        /// Allow manual assignments triggered by administrative operations only.
        ManualAssignmentType(
            std::boxed::Box<crate::model::assignment_protocol::ManualAssignmentType>,
        ),
        /// Allow automatic assignments triggered by data plane operations.
        AutoAssignmentType(std::boxed::Box<crate::model::assignment_protocol::AutoAssignmentType>),
    }
}

/// A license pool represents a pool of licenses that can be assigned to users.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LicensePool {
    /// Identifier. Format:
    /// `billingAccounts/{billing_account}/orders/{order}/licensePool`
    pub name: std::string::String,

    /// Required. Assignment protocol for the license pool.
    pub license_assignment_protocol: std::option::Option<crate::model::AssignmentProtocol>,

    /// Output only. Licenses count that are available to be assigned.
    pub available_license_count: i32,

    /// Output only. Total number of licenses in the pool.
    pub total_license_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LicensePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LicensePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [license_assignment_protocol][crate::model::LicensePool::license_assignment_protocol].
    pub fn set_license_assignment_protocol<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssignmentProtocol>,
    {
        self.license_assignment_protocol = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license_assignment_protocol][crate::model::LicensePool::license_assignment_protocol].
    pub fn set_or_clear_license_assignment_protocol<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssignmentProtocol>,
    {
        self.license_assignment_protocol = v.map(|x| x.into());
        self
    }

    /// Sets the value of [available_license_count][crate::model::LicensePool::available_license_count].
    pub fn set_available_license_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.available_license_count = v.into();
        self
    }

    /// Sets the value of [total_license_count][crate::model::LicensePool::total_license_count].
    pub fn set_total_license_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_license_count = v.into();
        self
    }
}

impl wkt::message::Message for LicensePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LicensePool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LicensePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __license_assignment_protocol,
            __available_license_count,
            __total_license_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LicensePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "licenseAssignmentProtocol" => {
                                Ok(__FieldTag::__license_assignment_protocol)
                            }
                            "license_assignment_protocol" => {
                                Ok(__FieldTag::__license_assignment_protocol)
                            }
                            "availableLicenseCount" => Ok(__FieldTag::__available_license_count),
                            "available_license_count" => Ok(__FieldTag::__available_license_count),
                            "totalLicenseCount" => Ok(__FieldTag::__total_license_count),
                            "total_license_count" => Ok(__FieldTag::__total_license_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LicensePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LicensePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_assignment_protocol => {
                            if !fields.insert(__FieldTag::__license_assignment_protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_assignment_protocol",
                                ));
                            }
                            result.license_assignment_protocol = map.next_value::<std::option::Option<crate::model::AssignmentProtocol>>()?
                                ;
                        }
                        __FieldTag::__available_license_count => {
                            if !fields.insert(__FieldTag::__available_license_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_license_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_license_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_license_count => {
                            if !fields.insert(__FieldTag::__total_license_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_license_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_license_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LicensePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.license_assignment_protocol.is_some() {
            state.serialize_entry(
                "licenseAssignmentProtocol",
                &self.license_assignment_protocol,
            )?;
        }
        if !wkt::internal::is_default(&self.available_license_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "availableLicenseCount",
                &__With(&self.available_license_count),
            )?;
        }
        if !wkt::internal::is_default(&self.total_license_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalLicenseCount", &__With(&self.total_license_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for getting a license pool.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLicensePoolRequest {
    /// Required. The name of the license pool to get.
    /// Format: `billingAccounts/{billing_account}/orders/{order}/licensePool`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLicensePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLicensePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLicensePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.GetLicensePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLicensePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLicensePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLicensePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLicensePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLicensePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for updating a license pool.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateLicensePoolRequest {
    /// Required. The license pool to update.
    ///
    /// The license pool's name field is used to identify the license pool to
    /// update. Format:
    /// `billingAccounts/{billing_account}/orders/{order}/licensePool`.
    pub license_pool: std::option::Option<crate::model::LicensePool>,

    /// Required. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLicensePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [license_pool][crate::model::UpdateLicensePoolRequest::license_pool].
    pub fn set_license_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LicensePool>,
    {
        self.license_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [license_pool][crate::model::UpdateLicensePoolRequest::license_pool].
    pub fn set_or_clear_license_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LicensePool>,
    {
        self.license_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateLicensePoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateLicensePoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateLicensePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.UpdateLicensePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateLicensePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __license_pool,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateLicensePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "licensePool" => Ok(__FieldTag::__license_pool),
                            "license_pool" => Ok(__FieldTag::__license_pool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateLicensePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateLicensePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__license_pool => {
                            if !fields.insert(__FieldTag::__license_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_pool",
                                ));
                            }
                            result.license_pool =
                                map.next_value::<std::option::Option<crate::model::LicensePool>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateLicensePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.license_pool.is_some() {
            state.serialize_entry("licensePool", &self.license_pool)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [LicenseManagementService.Assign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign]: crate::client::LicenseManagementService::assign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AssignRequest {
    /// Required. License pool name.
    pub parent: std::string::String,

    /// Required. Username.
    /// Format: `name@domain.com`.
    pub usernames: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AssignRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [usernames][crate::model::AssignRequest::usernames].
    pub fn set_usernames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.usernames = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AssignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssignRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __usernames,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssignRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "usernames" => Ok(__FieldTag::__usernames),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssignRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssignRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__usernames => {
                            if !fields.insert(__FieldTag::__usernames) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usernames",
                                ));
                            }
                            result.usernames = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssignRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.usernames.is_empty() {
            state.serialize_entry("usernames", &self.usernames)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [LicenseManagementService.Assign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Assign]: crate::client::LicenseManagementService::assign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AssignResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AssignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.AssignResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssignResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssignResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssignResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssignResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssignResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [LicenseManagementService.Unassign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign]: crate::client::LicenseManagementService::unassign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UnassignRequest {
    /// Required. License pool name.
    pub parent: std::string::String,

    /// Required. Username.
    /// Format: `name@domain.com`.
    pub usernames: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnassignRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::UnassignRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [usernames][crate::model::UnassignRequest::usernames].
    pub fn set_usernames<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.usernames = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UnassignRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.UnassignRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UnassignRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __usernames,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnassignRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "usernames" => Ok(__FieldTag::__usernames),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UnassignRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnassignRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__usernames => {
                            if !fields.insert(__FieldTag::__usernames) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usernames",
                                ));
                            }
                            result.usernames = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UnassignRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.usernames.is_empty() {
            state.serialize_entry("usernames", &self.usernames)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [LicenseManagementService.Unassign][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.Unassign]: crate::client::LicenseManagementService::unassign
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UnassignResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UnassignResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UnassignResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.UnassignResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UnassignResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UnassignResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UnassignResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UnassignResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UnassignResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [LicenseManagementService.EnumerateLicensedUsers][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers]: crate::client::LicenseManagementService::enumerate_licensed_users
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnumerateLicensedUsersRequest {
    /// Required. License pool name.
    pub parent: std::string::String,

    /// Optional. The maximum number of users to return. The service may return
    /// fewer than this value.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `EnumerateLicensedUsers`
    /// call. Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumerateLicensedUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::EnumerateLicensedUsersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::EnumerateLicensedUsersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::EnumerateLicensedUsersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for EnumerateLicensedUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.EnumerateLicensedUsersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnumerateLicensedUsersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnumerateLicensedUsersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnumerateLicensedUsersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnumerateLicensedUsersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnumerateLicensedUsersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A licensed user.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LicensedUser {
    /// Username.
    /// Format: `name@domain.com`.
    pub username: std::string::String,

    /// Output only. Timestamp when the license was assigned.
    pub assign_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when the license was recently used. This may not be
    /// the most recent usage time, and will be updated regularly (within 24
    /// hours).
    pub recent_usage_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LicensedUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::LicensedUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [assign_time][crate::model::LicensedUser::assign_time].
    pub fn set_assign_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.assign_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assign_time][crate::model::LicensedUser::assign_time].
    pub fn set_or_clear_assign_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.assign_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recent_usage_time][crate::model::LicensedUser::recent_usage_time].
    pub fn set_recent_usage_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recent_usage_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recent_usage_time][crate::model::LicensedUser::recent_usage_time].
    pub fn set_or_clear_recent_usage_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.recent_usage_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LicensedUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LicensedUser"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LicensedUser {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            __assign_time,
            __recent_usage_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LicensedUser")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            "assignTime" => Ok(__FieldTag::__assign_time),
                            "assign_time" => Ok(__FieldTag::__assign_time),
                            "recentUsageTime" => Ok(__FieldTag::__recent_usage_time),
                            "recent_usage_time" => Ok(__FieldTag::__recent_usage_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LicensedUser;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LicensedUser")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assign_time => {
                            if !fields.insert(__FieldTag::__assign_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assign_time",
                                ));
                            }
                            result.assign_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__recent_usage_time => {
                            if !fields.insert(__FieldTag::__recent_usage_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_usage_time",
                                ));
                            }
                            result.recent_usage_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LicensedUser {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if self.assign_time.is_some() {
            state.serialize_entry("assignTime", &self.assign_time)?;
        }
        if self.recent_usage_time.is_some() {
            state.serialize_entry("recentUsageTime", &self.recent_usage_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [LicenseManagementService.EnumerateLicensedUsers][google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers].
///
/// [google.cloud.commerce.consumer.procurement.v1.LicenseManagementService.EnumerateLicensedUsers]: crate::client::LicenseManagementService::enumerate_licensed_users
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnumerateLicensedUsersResponse {
    /// The list of licensed users.
    pub licensed_users: std::vec::Vec<crate::model::LicensedUser>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumerateLicensedUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [licensed_users][crate::model::EnumerateLicensedUsersResponse::licensed_users].
    pub fn set_licensed_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LicensedUser>,
    {
        use std::iter::Iterator;
        self.licensed_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::EnumerateLicensedUsersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for EnumerateLicensedUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.EnumerateLicensedUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for EnumerateLicensedUsersResponse {
    type PageItem = crate::model::LicensedUser;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.licensed_users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnumerateLicensedUsersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __licensed_users,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnumerateLicensedUsersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "licensedUsers" => Ok(__FieldTag::__licensed_users),
                            "licensed_users" => Ok(__FieldTag::__licensed_users),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnumerateLicensedUsersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnumerateLicensedUsersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__licensed_users => {
                            if !fields.insert(__FieldTag::__licensed_users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for licensed_users",
                                ));
                            }
                            result.licensed_users = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LicensedUser>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnumerateLicensedUsersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.licensed_users.is_empty() {
            state.serialize_entry("licensedUsers", &self.licensed_users)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a purchase made by a customer on Cloud Marketplace.
/// Creating an order makes sure that both the Google backend systems
/// as well as external service provider's systems (if needed) allow use of
/// purchased products and ensures the appropriate billing events occur.
///
/// An Order can be made against one Product with multiple add-ons (optional) or
/// one Quote which might reference multiple products.
///
/// Customers typically choose a price plan for each Product purchased when
/// they create an order and can change their plan later, if the product allows.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Order {
    /// Output only. The resource name of the order.
    /// Has the form
    /// `billingAccounts/{billing_account}/orders/{order}`.
    pub name: std::string::String,

    /// Required. The user-specified name of the order.
    pub display_name: std::string::String,

    /// Output only. The items being purchased.
    pub line_items: std::vec::Vec<crate::model::LineItem>,

    /// Output only. Line items that were cancelled.
    pub cancelled_line_items: std::vec::Vec<crate::model::LineItem>,

    /// Output only. The creation timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The weak etag of the order.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Order {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Order::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Order::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [line_items][crate::model::Order::line_items].
    pub fn set_line_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItem>,
    {
        use std::iter::Iterator;
        self.line_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cancelled_line_items][crate::model::Order::cancelled_line_items].
    pub fn set_cancelled_line_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItem>,
    {
        use std::iter::Iterator;
        self.cancelled_line_items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Order::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Order::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Order::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Order::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Order::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Order {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Order"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Order {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __line_items,
            __cancelled_line_items,
            __create_time,
            __update_time,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Order")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "lineItems" => Ok(__FieldTag::__line_items),
                            "line_items" => Ok(__FieldTag::__line_items),
                            "cancelledLineItems" => Ok(__FieldTag::__cancelled_line_items),
                            "cancelled_line_items" => Ok(__FieldTag::__cancelled_line_items),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Order;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Order")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__line_items => {
                            if !fields.insert(__FieldTag::__line_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line_items",
                                ));
                            }
                            result.line_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LineItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cancelled_line_items => {
                            if !fields.insert(__FieldTag::__cancelled_line_items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancelled_line_items",
                                ));
                            }
                            result.cancelled_line_items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LineItem>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Order {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.line_items.is_empty() {
            state.serialize_entry("lineItems", &self.line_items)?;
        }
        if !self.cancelled_line_items.is_empty() {
            state.serialize_entry("cancelledLineItems", &self.cancelled_line_items)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single item within an order.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LineItem {
    /// Output only. Line item ID.
    pub line_item_id: std::string::String,

    /// Output only. Current state and information of this item. It tells what,
    /// e.g. which offer, is currently effective.
    pub line_item_info: std::option::Option<crate::model::LineItemInfo>,

    /// Output only. A change made on the item which is pending and not yet
    /// effective. Absence of this field indicates the line item is not undergoing
    /// a change.
    pub pending_change: std::option::Option<crate::model::LineItemChange>,

    /// Output only. Changes made on the item that are not pending anymore which
    /// might be because they already took effect, were reverted by the customer,
    /// or were rejected by the partner. No more operations are allowed on these
    /// changes.
    pub change_history: std::vec::Vec<crate::model::LineItemChange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LineItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [line_item_id][crate::model::LineItem::line_item_id].
    pub fn set_line_item_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.line_item_id = v.into();
        self
    }

    /// Sets the value of [line_item_info][crate::model::LineItem::line_item_info].
    pub fn set_line_item_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LineItemInfo>,
    {
        self.line_item_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [line_item_info][crate::model::LineItem::line_item_info].
    pub fn set_or_clear_line_item_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LineItemInfo>,
    {
        self.line_item_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pending_change][crate::model::LineItem::pending_change].
    pub fn set_pending_change<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LineItemChange>,
    {
        self.pending_change = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pending_change][crate::model::LineItem::pending_change].
    pub fn set_or_clear_pending_change<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LineItemChange>,
    {
        self.pending_change = v.map(|x| x.into());
        self
    }

    /// Sets the value of [change_history][crate::model::LineItem::change_history].
    pub fn set_change_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItemChange>,
    {
        use std::iter::Iterator;
        self.change_history = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LineItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LineItem"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LineItem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __line_item_id,
            __line_item_info,
            __pending_change,
            __change_history,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LineItem")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lineItemId" => Ok(__FieldTag::__line_item_id),
                            "line_item_id" => Ok(__FieldTag::__line_item_id),
                            "lineItemInfo" => Ok(__FieldTag::__line_item_info),
                            "line_item_info" => Ok(__FieldTag::__line_item_info),
                            "pendingChange" => Ok(__FieldTag::__pending_change),
                            "pending_change" => Ok(__FieldTag::__pending_change),
                            "changeHistory" => Ok(__FieldTag::__change_history),
                            "change_history" => Ok(__FieldTag::__change_history),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LineItem;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LineItem")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__line_item_id => {
                            if !fields.insert(__FieldTag::__line_item_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line_item_id",
                                ));
                            }
                            result.line_item_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__line_item_info => {
                            if !fields.insert(__FieldTag::__line_item_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line_item_info",
                                ));
                            }
                            result.line_item_info = map
                                .next_value::<std::option::Option<crate::model::LineItemInfo>>()?;
                        }
                        __FieldTag::__pending_change => {
                            if !fields.insert(__FieldTag::__pending_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pending_change",
                                ));
                            }
                            result.pending_change = map
                                .next_value::<std::option::Option<crate::model::LineItemChange>>(
                                )?;
                        }
                        __FieldTag::__change_history => {
                            if !fields.insert(__FieldTag::__change_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_history",
                                ));
                            }
                            result.change_history =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LineItemChange>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LineItem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.line_item_id.is_empty() {
            state.serialize_entry("lineItemId", &self.line_item_id)?;
        }
        if self.line_item_info.is_some() {
            state.serialize_entry("lineItemInfo", &self.line_item_info)?;
        }
        if self.pending_change.is_some() {
            state.serialize_entry("pendingChange", &self.pending_change)?;
        }
        if !self.change_history.is_empty() {
            state.serialize_entry("changeHistory", &self.change_history)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A change made on a line item.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LineItemChange {
    /// Output only. Change ID.
    /// All changes made within one order update operation have the same change_id.
    pub change_id: std::string::String,

    /// Required. Type of the change to make.
    pub change_type: crate::model::LineItemChangeType,

    /// Output only. Line item info before the change.
    pub old_line_item_info: std::option::Option<crate::model::LineItemInfo>,

    /// Line item info after the change.
    pub new_line_item_info: std::option::Option<crate::model::LineItemInfo>,

    /// Output only. State of the change.
    pub change_state: crate::model::LineItemChangeState,

    /// Output only. Provider-supplied message explaining the LineItemChange's
    /// state. Mainly used to communicate progress and ETA for provisioning in the
    /// case of `PENDING_APPROVAL`, and to explain why the change request was
    /// denied or canceled in the case of `REJECTED` and `CANCELED` states.
    pub state_reason: std::string::String,

    /// Output only. Predefined enum types for why this line item change is in
    /// current state. For example, a line item change's state could be
    /// `LINE_ITEM_CHANGE_STATE_COMPLETED` because of end-of-term expiration,
    /// immediate cancellation initiated by the user, or system-initiated
    /// cancellation.
    pub change_state_reason_type: crate::model::LineItemChangeStateReasonType,

    /// Output only. A time at which the change became or will become (in case of
    /// pending change) effective.
    pub change_effective_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when change was initiated.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when change was updated, e.g. approved/rejected by
    /// partners or cancelled by the user.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LineItemChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [change_id][crate::model::LineItemChange::change_id].
    pub fn set_change_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.change_id = v.into();
        self
    }

    /// Sets the value of [change_type][crate::model::LineItemChange::change_type].
    pub fn set_change_type<T: std::convert::Into<crate::model::LineItemChangeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.change_type = v.into();
        self
    }

    /// Sets the value of [old_line_item_info][crate::model::LineItemChange::old_line_item_info].
    pub fn set_old_line_item_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LineItemInfo>,
    {
        self.old_line_item_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [old_line_item_info][crate::model::LineItemChange::old_line_item_info].
    pub fn set_or_clear_old_line_item_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LineItemInfo>,
    {
        self.old_line_item_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [new_line_item_info][crate::model::LineItemChange::new_line_item_info].
    pub fn set_new_line_item_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LineItemInfo>,
    {
        self.new_line_item_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_line_item_info][crate::model::LineItemChange::new_line_item_info].
    pub fn set_or_clear_new_line_item_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LineItemInfo>,
    {
        self.new_line_item_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [change_state][crate::model::LineItemChange::change_state].
    pub fn set_change_state<T: std::convert::Into<crate::model::LineItemChangeState>>(
        mut self,
        v: T,
    ) -> Self {
        self.change_state = v.into();
        self
    }

    /// Sets the value of [state_reason][crate::model::LineItemChange::state_reason].
    pub fn set_state_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_reason = v.into();
        self
    }

    /// Sets the value of [change_state_reason_type][crate::model::LineItemChange::change_state_reason_type].
    pub fn set_change_state_reason_type<
        T: std::convert::Into<crate::model::LineItemChangeStateReasonType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.change_state_reason_type = v.into();
        self
    }

    /// Sets the value of [change_effective_time][crate::model::LineItemChange::change_effective_time].
    pub fn set_change_effective_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.change_effective_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [change_effective_time][crate::model::LineItemChange::change_effective_time].
    pub fn set_or_clear_change_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.change_effective_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::LineItemChange::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::LineItemChange::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::LineItemChange::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::LineItemChange::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LineItemChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LineItemChange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LineItemChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __change_id,
            __change_type,
            __old_line_item_info,
            __new_line_item_info,
            __change_state,
            __state_reason,
            __change_state_reason_type,
            __change_effective_time,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LineItemChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "changeId" => Ok(__FieldTag::__change_id),
                            "change_id" => Ok(__FieldTag::__change_id),
                            "changeType" => Ok(__FieldTag::__change_type),
                            "change_type" => Ok(__FieldTag::__change_type),
                            "oldLineItemInfo" => Ok(__FieldTag::__old_line_item_info),
                            "old_line_item_info" => Ok(__FieldTag::__old_line_item_info),
                            "newLineItemInfo" => Ok(__FieldTag::__new_line_item_info),
                            "new_line_item_info" => Ok(__FieldTag::__new_line_item_info),
                            "changeState" => Ok(__FieldTag::__change_state),
                            "change_state" => Ok(__FieldTag::__change_state),
                            "stateReason" => Ok(__FieldTag::__state_reason),
                            "state_reason" => Ok(__FieldTag::__state_reason),
                            "changeStateReasonType" => Ok(__FieldTag::__change_state_reason_type),
                            "change_state_reason_type" => {
                                Ok(__FieldTag::__change_state_reason_type)
                            }
                            "changeEffectiveTime" => Ok(__FieldTag::__change_effective_time),
                            "change_effective_time" => Ok(__FieldTag::__change_effective_time),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LineItemChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LineItemChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__change_id => {
                            if !fields.insert(__FieldTag::__change_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_id",
                                ));
                            }
                            result.change_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__change_type => {
                            if !fields.insert(__FieldTag::__change_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_type",
                                ));
                            }
                            result.change_type = map.next_value::<std::option::Option<crate::model::LineItemChangeType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__old_line_item_info => {
                            if !fields.insert(__FieldTag::__old_line_item_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_line_item_info",
                                ));
                            }
                            result.old_line_item_info = map
                                .next_value::<std::option::Option<crate::model::LineItemInfo>>()?;
                        }
                        __FieldTag::__new_line_item_info => {
                            if !fields.insert(__FieldTag::__new_line_item_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_line_item_info",
                                ));
                            }
                            result.new_line_item_info = map
                                .next_value::<std::option::Option<crate::model::LineItemInfo>>()?;
                        }
                        __FieldTag::__change_state => {
                            if !fields.insert(__FieldTag::__change_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_state",
                                ));
                            }
                            result.change_state = map.next_value::<std::option::Option<crate::model::LineItemChangeState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_reason => {
                            if !fields.insert(__FieldTag::__state_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_reason",
                                ));
                            }
                            result.state_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__change_state_reason_type => {
                            if !fields.insert(__FieldTag::__change_state_reason_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_state_reason_type",
                                ));
                            }
                            result.change_state_reason_type =
                                map.next_value::<std::option::Option<
                                    crate::model::LineItemChangeStateReasonType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__change_effective_time => {
                            if !fields.insert(__FieldTag::__change_effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_effective_time",
                                ));
                            }
                            result.change_effective_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LineItemChange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.change_id.is_empty() {
            state.serialize_entry("changeId", &self.change_id)?;
        }
        if !wkt::internal::is_default(&self.change_type) {
            state.serialize_entry("changeType", &self.change_type)?;
        }
        if self.old_line_item_info.is_some() {
            state.serialize_entry("oldLineItemInfo", &self.old_line_item_info)?;
        }
        if self.new_line_item_info.is_some() {
            state.serialize_entry("newLineItemInfo", &self.new_line_item_info)?;
        }
        if !wkt::internal::is_default(&self.change_state) {
            state.serialize_entry("changeState", &self.change_state)?;
        }
        if !self.state_reason.is_empty() {
            state.serialize_entry("stateReason", &self.state_reason)?;
        }
        if !wkt::internal::is_default(&self.change_state_reason_type) {
            state.serialize_entry("changeStateReasonType", &self.change_state_reason_type)?;
        }
        if self.change_effective_time.is_some() {
            state.serialize_entry("changeEffectiveTime", &self.change_effective_time)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Line item information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LineItemInfo {
    /// Optional. The name of the offer can have either of these formats:
    /// 'billingAccounts/{billing_account}/offers/{offer}',
    /// or 'services/{service}/standardOffers/{offer}'.
    pub offer: std::string::String,

    /// Optional. User-provided parameters.
    pub parameters: std::vec::Vec<crate::model::Parameter>,

    /// Output only. Information about the subscription created, if applicable.
    pub subscription: std::option::Option<crate::model::Subscription>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LineItemInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [offer][crate::model::LineItemInfo::offer].
    pub fn set_offer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.offer = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::LineItemInfo::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subscription][crate::model::LineItemInfo::subscription].
    pub fn set_subscription<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Subscription>,
    {
        self.subscription = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subscription][crate::model::LineItemInfo::subscription].
    pub fn set_or_clear_subscription<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Subscription>,
    {
        self.subscription = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LineItemInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.LineItemInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LineItemInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __offer,
            __parameters,
            __subscription,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LineItemInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "offer" => Ok(__FieldTag::__offer),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "subscription" => Ok(__FieldTag::__subscription),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LineItemInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LineItemInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__offer => {
                            if !fields.insert(__FieldTag::__offer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offer",
                                ));
                            }
                            result.offer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Parameter>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__subscription => {
                            if !fields.insert(__FieldTag::__subscription) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription",
                                ));
                            }
                            result.subscription = map
                                .next_value::<std::option::Option<crate::model::Subscription>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LineItemInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.offer.is_empty() {
            state.serialize_entry("offer", &self.offer)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if self.subscription.is_some() {
            state.serialize_entry("subscription", &self.subscription)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// User-provided Parameters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Parameter {
    /// Name of the parameter.
    pub name: std::string::String,

    /// Value of parameter.
    pub value: std::option::Option<crate::model::parameter::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Parameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Parameter::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Parameter::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::parameter::Value>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::Parameter::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::parameter::Value>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Parameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Parameter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Parameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Parameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Parameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Parameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<crate::model::parameter::Value>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Parameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Parameter].
pub mod parameter {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Value {
        /// The kind of value.
        pub kind: std::option::Option<crate::model::parameter::value::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Value {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<std::option::Option<crate::model::parameter::value::Kind>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::parameter::Value::kind]
        /// if it holds a `Int64Value`, `None` if the field is not set or
        /// holds a different branch.
        pub fn int64_value(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::parameter::value::Kind::Int64Value(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind]
        /// to hold a `Int64Value`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::parameter::value::Kind::Int64Value(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::parameter::Value::kind]
        /// if it holds a `StringValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn string_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::parameter::value::Kind::StringValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind]
        /// to hold a `StringValue`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_string_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::parameter::value::Kind::StringValue(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::parameter::Value::kind]
        /// if it holds a `DoubleValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn double_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::parameter::value::Kind::DoubleValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::parameter::Value::kind]
        /// to hold a `DoubleValue`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::parameter::value::Kind::DoubleValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Value {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Parameter.Value"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Value {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __int64_value,
                __string_value,
                __double_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Value")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "int64Value" => Ok(__FieldTag::__int64_value),
                                "int64_value" => Ok(__FieldTag::__int64_value),
                                "stringValue" => Ok(__FieldTag::__string_value),
                                "string_value" => Ok(__FieldTag::__string_value),
                                "doubleValue" => Ok(__FieldTag::__double_value),
                                "double_value" => Ok(__FieldTag::__double_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Value;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Value")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__int64_value => {
                                if !fields.insert(__FieldTag::__int64_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for int64_value",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.commerce.consumer.procurement.v1.Parameter.Value.int64_value, latest field was int64Value",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::parameter::value::Kind::Int64Value(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__string_value => {
                                if !fields.insert(__FieldTag::__string_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for string_value",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.commerce.consumer.procurement.v1.Parameter.Value.string_value, latest field was stringValue",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::parameter::value::Kind::StringValue(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__double_value => {
                                if !fields.insert(__FieldTag::__double_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for double_value",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.commerce.consumer.procurement.v1.Parameter.Value.double_value, latest field was doubleValue",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::parameter::value::Kind::DoubleValue(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Value {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.int64_value() {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("int64Value", &__With(value))?;
            }
            if let Some(value) = self.string_value() {
                state.serialize_entry("stringValue", value)?;
            }
            if let Some(value) = self.double_value() {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("doubleValue", &__With(value))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Value].
    pub mod value {
        #[allow(unused_imports)]
        use super::*;

        /// The kind of value.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// Represents an int64 value.
            Int64Value(i64),
            /// Represents a string value.
            StringValue(std::string::String),
            /// Represents a double value.
            DoubleValue(f64),
        }
    }
}

/// Subscription information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Subscription {
    /// The timestamp when the subscription begins, if applicable.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The timestamp when the subscription ends, if applicable.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Whether auto renewal is enabled by user choice on current subscription.
    /// This field indicates order/subscription status after pending plan change is
    /// cancelled or rejected.
    pub auto_renewal_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subscription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::Subscription::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Subscription::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Subscription::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Subscription::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_renewal_enabled][crate::model::Subscription::auto_renewal_enabled].
    pub fn set_auto_renewal_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_renewal_enabled = v.into();
        self
    }
}

impl wkt::message::Message for Subscription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.Subscription"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Subscription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            __auto_renewal_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Subscription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "autoRenewalEnabled" => Ok(__FieldTag::__auto_renewal_enabled),
                            "auto_renewal_enabled" => Ok(__FieldTag::__auto_renewal_enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Subscription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Subscription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__auto_renewal_enabled => {
                            if !fields.insert(__FieldTag::__auto_renewal_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_renewal_enabled",
                                ));
                            }
                            result.auto_renewal_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Subscription {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.auto_renewal_enabled) {
            state.serialize_entry("autoRenewalEnabled", &self.auto_renewal_enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ConsumerProcurementService.PlaceOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder]: crate::client::ConsumerProcurementService::place_order
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PlaceOrderRequest {
    /// Required. The resource name of the parent resource.
    /// This field has the form  `billingAccounts/{billing-account-id}`.
    pub parent: std::string::String,

    /// Required. The user-specified name of the order being placed.
    pub display_name: std::string::String,

    /// Optional. Places order for offer. Required when an offer-based order is
    /// being placed.
    pub line_item_info: std::vec::Vec<crate::model::LineItemInfo>,

    /// Optional. A unique identifier for this request.
    /// The server will ignore subsequent requests that provide a duplicate request
    /// ID for at least 24 hours after the first request.
    ///
    /// The request ID must be a valid
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlaceOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PlaceOrderRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PlaceOrderRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [line_item_info][crate::model::PlaceOrderRequest::line_item_info].
    pub fn set_line_item_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LineItemInfo>,
    {
        use std::iter::Iterator;
        self.line_item_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [request_id][crate::model::PlaceOrderRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for PlaceOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.PlaceOrderRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PlaceOrderRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __display_name,
            __line_item_info,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PlaceOrderRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "lineItemInfo" => Ok(__FieldTag::__line_item_info),
                            "line_item_info" => Ok(__FieldTag::__line_item_info),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PlaceOrderRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PlaceOrderRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__line_item_info => {
                            if !fields.insert(__FieldTag::__line_item_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line_item_info",
                                ));
                            }
                            result.line_item_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LineItemInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PlaceOrderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.line_item_info.is_empty() {
            state.serialize_entry("lineItemInfo", &self.line_item_info)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message stored in the metadata field of the Operation returned by
/// [ConsumerProcurementService.PlaceOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.PlaceOrder]: crate::client::ConsumerProcurementService::place_order
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PlaceOrderMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PlaceOrderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PlaceOrderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.PlaceOrderMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PlaceOrderMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PlaceOrderMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PlaceOrderMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PlaceOrderMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PlaceOrderMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ConsumerProcurementService.GetOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.GetOrder]
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.GetOrder]: crate::client::ConsumerProcurementService::get_order
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOrderRequest {
    /// Required. The name of the order to retrieve.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetOrderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.GetOrderRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOrderRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOrderRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOrderRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOrderRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOrderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ConsumerProcurementService.ListOrders][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders]: crate::client::ConsumerProcurementService::list_orders
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOrdersRequest {
    /// Required. The parent resource to query for orders.
    /// This field has the form `billingAccounts/{billing-account-id}`.
    pub parent: std::string::String,

    /// The maximum number of entries requested.
    /// The default page size is 25 and the maximum page size is 200.
    pub page_size: i32,

    /// The token for fetching the next page.
    pub page_token: std::string::String,

    /// Filter that you can use to limit the list request.
    ///
    /// A query string that can match a selected set of attributes
    /// with string values. For example, `display_name=abc`.
    /// Supported query attributes are
    ///
    /// * `display_name`
    ///
    /// If the query contains special characters other than letters,
    /// underscore, or digits, the phrase must be quoted with double quotes. For
    /// example, `display_name="foo:bar"`, where the display name needs to be
    /// quoted because it contains special character colon.
    ///
    /// Queries can be combined with `OR`, and `NOT` to form more complex queries.
    /// You can also group them to force a desired evaluation order.
    /// For example, `display_name=abc OR display_name=def`.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrdersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListOrdersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListOrdersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListOrdersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListOrdersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListOrdersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ListOrdersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOrdersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOrdersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOrdersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOrdersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOrdersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ConsumerProcurementService.ListOrders][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ListOrders]: crate::client::ConsumerProcurementService::list_orders
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOrdersResponse {
    /// The list of orders in this response.
    pub orders: std::vec::Vec<crate::model::Order>,

    /// The token for fetching the next page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOrdersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [orders][crate::model::ListOrdersResponse::orders].
    pub fn set_orders<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Order>,
    {
        use std::iter::Iterator;
        self.orders = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListOrdersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListOrdersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ListOrdersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListOrdersResponse {
    type PageItem = crate::model::Order;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.orders
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOrdersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __orders,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOrdersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "orders" => Ok(__FieldTag::__orders),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOrdersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOrdersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__orders => {
                            if !fields.insert(__FieldTag::__orders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for orders",
                                ));
                            }
                            result.orders = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Order>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOrdersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.orders.is_empty() {
            state.serialize_entry("orders", &self.orders)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ConsumerProcurementService.ModifyOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder]: crate::client::ConsumerProcurementService::modify_order
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyOrderRequest {
    /// Required. Name of the order to update.
    pub name: std::string::String,

    /// Optional. Modifications for an existing Order created by an Offer.
    /// Required when Offer based Order is being modified, except for when going
    /// from an offer to a public plan.
    pub modifications: std::vec::Vec<crate::model::modify_order_request::Modification>,

    /// Optional. Updated display name of the order, leave as empty if you do not
    /// want to update current display name.
    pub display_name: std::string::String,

    /// Optional. The weak etag, which can be optionally populated, of the order
    /// that this modify request is based on. Validation checking will only happen
    /// if the invoker supplies this field.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyOrderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [modifications][crate::model::ModifyOrderRequest::modifications].
    pub fn set_modifications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::modify_order_request::Modification>,
    {
        use std::iter::Iterator;
        self.modifications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::ModifyOrderRequest::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::ModifyOrderRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for ModifyOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ModifyOrderRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModifyOrderRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __modifications,
            __display_name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModifyOrderRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "modifications" => Ok(__FieldTag::__modifications),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModifyOrderRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModifyOrderRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__modifications => {
                            if !fields.insert(__FieldTag::__modifications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for modifications",
                                ));
                            }
                            result.modifications = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::modify_order_request::Modification>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModifyOrderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.modifications.is_empty() {
            state.serialize_entry("modifications", &self.modifications)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ModifyOrderRequest].
pub mod modify_order_request {
    #[allow(unused_imports)]
    use super::*;

    /// Modifications to make on the order.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Modification {
        /// Required. ID of the existing line item to make change to.
        /// Required when change type is
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE] or
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CANCEL].
        pub line_item_id: std::string::String,

        /// Required. Type of change to make.
        pub change_type: crate::model::LineItemChangeType,

        /// Optional. The line item to update to.
        /// Required when change_type is
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CREATE] or
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE].
        pub new_line_item_info: std::option::Option<crate::model::LineItemInfo>,

        /// Optional. Auto renewal behavior of the subscription for the update.
        /// Applied when change_type is
        /// [LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE]. Follows plan default
        /// config when this field is not specified.
        pub auto_renewal_behavior: crate::model::AutoRenewalBehavior,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Modification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line_item_id][crate::model::modify_order_request::Modification::line_item_id].
        pub fn set_line_item_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.line_item_id = v.into();
            self
        }

        /// Sets the value of [change_type][crate::model::modify_order_request::Modification::change_type].
        pub fn set_change_type<T: std::convert::Into<crate::model::LineItemChangeType>>(
            mut self,
            v: T,
        ) -> Self {
            self.change_type = v.into();
            self
        }

        /// Sets the value of [new_line_item_info][crate::model::modify_order_request::Modification::new_line_item_info].
        pub fn set_new_line_item_info<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::LineItemInfo>,
        {
            self.new_line_item_info = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [new_line_item_info][crate::model::modify_order_request::Modification::new_line_item_info].
        pub fn set_or_clear_new_line_item_info<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::LineItemInfo>,
        {
            self.new_line_item_info = v.map(|x| x.into());
            self
        }

        /// Sets the value of [auto_renewal_behavior][crate::model::modify_order_request::Modification::auto_renewal_behavior].
        pub fn set_auto_renewal_behavior<
            T: std::convert::Into<crate::model::AutoRenewalBehavior>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.auto_renewal_behavior = v.into();
            self
        }
    }

    impl wkt::message::Message for Modification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ModifyOrderRequest.Modification"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Modification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __line_item_id,
                __change_type,
                __new_line_item_info,
                __auto_renewal_behavior,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Modification")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lineItemId" => Ok(__FieldTag::__line_item_id),
                                "line_item_id" => Ok(__FieldTag::__line_item_id),
                                "changeType" => Ok(__FieldTag::__change_type),
                                "change_type" => Ok(__FieldTag::__change_type),
                                "newLineItemInfo" => Ok(__FieldTag::__new_line_item_info),
                                "new_line_item_info" => Ok(__FieldTag::__new_line_item_info),
                                "autoRenewalBehavior" => Ok(__FieldTag::__auto_renewal_behavior),
                                "auto_renewal_behavior" => Ok(__FieldTag::__auto_renewal_behavior),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Modification;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Modification")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__line_item_id => {
                                if !fields.insert(__FieldTag::__line_item_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for line_item_id",
                                    ));
                                }
                                result.line_item_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__change_type => {
                                if !fields.insert(__FieldTag::__change_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for change_type",
                                    ));
                                }
                                result.change_type = map.next_value::<std::option::Option<crate::model::LineItemChangeType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__new_line_item_info => {
                                if !fields.insert(__FieldTag::__new_line_item_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for new_line_item_info",
                                    ));
                                }
                                result.new_line_item_info = map
                                    .next_value::<std::option::Option<crate::model::LineItemInfo>>(
                                    )?;
                            }
                            __FieldTag::__auto_renewal_behavior => {
                                if !fields.insert(__FieldTag::__auto_renewal_behavior) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for auto_renewal_behavior",
                                    ));
                                }
                                result.auto_renewal_behavior = map.next_value::<std::option::Option<crate::model::AutoRenewalBehavior>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Modification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.line_item_id.is_empty() {
                state.serialize_entry("lineItemId", &self.line_item_id)?;
            }
            if !wkt::internal::is_default(&self.change_type) {
                state.serialize_entry("changeType", &self.change_type)?;
            }
            if self.new_line_item_info.is_some() {
                state.serialize_entry("newLineItemInfo", &self.new_line_item_info)?;
            }
            if !wkt::internal::is_default(&self.auto_renewal_behavior) {
                state.serialize_entry("autoRenewalBehavior", &self.auto_renewal_behavior)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Message stored in the metadata field of the Operation returned by
/// [ConsumerProcurementService.ModifyOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.ModifyOrder]: crate::client::ConsumerProcurementService::modify_order
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyOrderMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyOrderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ModifyOrderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.ModifyOrderMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModifyOrderMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModifyOrderMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModifyOrderMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModifyOrderMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModifyOrderMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ConsumerProcurementService.CancelOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder]: crate::client::ConsumerProcurementService::cancel_order
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelOrderRequest {
    /// Required. The resource name of the order.
    pub name: std::string::String,

    /// Optional. The weak etag, which can be optionally populated, of the order
    /// that this cancel request is based on. Validation checking will only happen
    /// if the invoker supplies this field.
    pub etag: std::string::String,

    /// Optional. Cancellation policy of this request.
    pub cancellation_policy: crate::model::cancel_order_request::CancellationPolicy,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelOrderRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelOrderRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::CancelOrderRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [cancellation_policy][crate::model::CancelOrderRequest::cancellation_policy].
    pub fn set_cancellation_policy<
        T: std::convert::Into<crate::model::cancel_order_request::CancellationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cancellation_policy = v.into();
        self
    }
}

impl wkt::message::Message for CancelOrderRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.CancelOrderRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelOrderRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __cancellation_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelOrderRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "cancellationPolicy" => Ok(__FieldTag::__cancellation_policy),
                            "cancellation_policy" => Ok(__FieldTag::__cancellation_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelOrderRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelOrderRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cancellation_policy => {
                            if !fields.insert(__FieldTag::__cancellation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancellation_policy",
                                ));
                            }
                            result.cancellation_policy = map
                                .next_value::<std::option::Option<
                                    crate::model::cancel_order_request::CancellationPolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelOrderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.cancellation_policy) {
            state.serialize_entry("cancellationPolicy", &self.cancellation_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CancelOrderRequest].
pub mod cancel_order_request {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the cancellation policy the customer uses to cancel the order.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CancellationPolicy {
        /// If unspecified, cancellation will try to cancel the order, if order
        /// cannot be immediately cancelled, auto renewal will be turned off.
        /// However, caller should avoid using the value as it will yield a
        /// non-deterministic result. This is still supported mainly to maintain
        /// existing integrated usages and ensure backwards compatibility.
        Unspecified,
        /// Request will cancel the whole order immediately, if order cannot be
        /// immediately cancelled, the request will fail.
        CancelImmediately,
        /// Request will cancel the auto renewal, if order is not subscription based,
        /// the request will fail.
        CancelAtTermEnd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CancellationPolicy::value] or
        /// [CancellationPolicy::name].
        UnknownValue(cancellation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cancellation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CancellationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CancelImmediately => std::option::Option::Some(1),
                Self::CancelAtTermEnd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CANCELLATION_POLICY_UNSPECIFIED"),
                Self::CancelImmediately => {
                    std::option::Option::Some("CANCELLATION_POLICY_CANCEL_IMMEDIATELY")
                }
                Self::CancelAtTermEnd => {
                    std::option::Option::Some("CANCELLATION_POLICY_CANCEL_AT_TERM_END")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CancellationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CancellationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CancellationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CancelImmediately,
                2 => Self::CancelAtTermEnd,
                _ => Self::UnknownValue(cancellation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CancellationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CANCELLATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "CANCELLATION_POLICY_CANCEL_IMMEDIATELY" => Self::CancelImmediately,
                "CANCELLATION_POLICY_CANCEL_AT_TERM_END" => Self::CancelAtTermEnd,
                _ => Self::UnknownValue(cancellation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CancellationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CancelImmediately => serializer.serialize_i32(1),
                Self::CancelAtTermEnd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CancellationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CancellationPolicy>::new(
                ".google.cloud.commerce.consumer.procurement.v1.CancelOrderRequest.CancellationPolicy"))
        }
    }
}

/// Message stored in the metadata field of the Operation returned by
/// [ConsumerProcurementService.CancelOrder][google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder].
///
/// [google.cloud.commerce.consumer.procurement.v1.ConsumerProcurementService.CancelOrder]: crate::client::ConsumerProcurementService::cancel_order
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelOrderMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelOrderMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelOrderMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.commerce.consumer.procurement.v1.CancelOrderMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelOrderMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelOrderMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelOrderMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelOrderMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelOrderMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Type of a line item change.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LineItemChangeType {
    /// Sentinel value. Do not use.
    Unspecified,
    /// The change is to create a new line item.
    Create,
    /// The change is to update an existing line item.
    Update,
    /// The change is to cancel an existing line item.
    Cancel,
    /// The change is to revert a cancellation.
    RevertCancellation,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LineItemChangeType::value] or
    /// [LineItemChangeType::name].
    UnknownValue(line_item_change_type::UnknownValue),
}

#[doc(hidden)]
pub mod line_item_change_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LineItemChangeType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Create => std::option::Option::Some(1),
            Self::Update => std::option::Option::Some(2),
            Self::Cancel => std::option::Option::Some(3),
            Self::RevertCancellation => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_UNSPECIFIED"),
            Self::Create => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_CREATE"),
            Self::Update => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_UPDATE"),
            Self::Cancel => std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_CANCEL"),
            Self::RevertCancellation => {
                std::option::Option::Some("LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LineItemChangeType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LineItemChangeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LineItemChangeType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Create,
            2 => Self::Update,
            3 => Self::Cancel,
            4 => Self::RevertCancellation,
            _ => Self::UnknownValue(line_item_change_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LineItemChangeType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINE_ITEM_CHANGE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "LINE_ITEM_CHANGE_TYPE_CREATE" => Self::Create,
            "LINE_ITEM_CHANGE_TYPE_UPDATE" => Self::Update,
            "LINE_ITEM_CHANGE_TYPE_CANCEL" => Self::Cancel,
            "LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION" => Self::RevertCancellation,
            _ => Self::UnknownValue(line_item_change_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LineItemChangeType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Create => serializer.serialize_i32(1),
            Self::Update => serializer.serialize_i32(2),
            Self::Cancel => serializer.serialize_i32(3),
            Self::RevertCancellation => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LineItemChangeType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LineItemChangeType>::new(
            ".google.cloud.commerce.consumer.procurement.v1.LineItemChangeType",
        ))
    }
}

/// State of a change.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LineItemChangeState {
    /// Sentinel value. Do not use.
    Unspecified,
    /// Change is in this state when a change is initiated and waiting for partner
    /// approval. This state is only applicable for pending change.
    PendingApproval,
    /// Change is in this state after it's approved by the partner or auto-approved
    /// but before it takes effect. The change can be overwritten or cancelled
    /// depending on the new line item info property (pending Private Offer change
    /// cannot be cancelled and can only be overwritten by another Private Offer).
    /// This state is only applicable for pending change.
    Approved,
    /// Change is in this state after it's been activated. This state is only
    /// applicable for change in history.
    Completed,
    /// Change is in this state if it was rejected by the partner. This state is
    /// only applicable for change in history.
    Rejected,
    /// Change is in this state if it was abandoned by the user. This state is only
    /// applicable for change in history.
    Abandoned,
    /// Change is in this state if it's currently being provisioned downstream. The
    /// change can't be overwritten or cancelled when it's in this state. This
    /// state is only applicable for pending change.
    Activating,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LineItemChangeState::value] or
    /// [LineItemChangeState::name].
    UnknownValue(line_item_change_state::UnknownValue),
}

#[doc(hidden)]
pub mod line_item_change_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LineItemChangeState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PendingApproval => std::option::Option::Some(1),
            Self::Approved => std::option::Option::Some(2),
            Self::Completed => std::option::Option::Some(3),
            Self::Rejected => std::option::Option::Some(4),
            Self::Abandoned => std::option::Option::Some(5),
            Self::Activating => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_UNSPECIFIED"),
            Self::PendingApproval => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL")
            }
            Self::Approved => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_APPROVED"),
            Self::Completed => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_COMPLETED"),
            Self::Rejected => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REJECTED"),
            Self::Abandoned => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_ABANDONED"),
            Self::Activating => std::option::Option::Some("LINE_ITEM_CHANGE_STATE_ACTIVATING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LineItemChangeState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LineItemChangeState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LineItemChangeState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PendingApproval,
            2 => Self::Approved,
            3 => Self::Completed,
            4 => Self::Rejected,
            5 => Self::Abandoned,
            6 => Self::Activating,
            _ => Self::UnknownValue(line_item_change_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LineItemChangeState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINE_ITEM_CHANGE_STATE_UNSPECIFIED" => Self::Unspecified,
            "LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL" => Self::PendingApproval,
            "LINE_ITEM_CHANGE_STATE_APPROVED" => Self::Approved,
            "LINE_ITEM_CHANGE_STATE_COMPLETED" => Self::Completed,
            "LINE_ITEM_CHANGE_STATE_REJECTED" => Self::Rejected,
            "LINE_ITEM_CHANGE_STATE_ABANDONED" => Self::Abandoned,
            "LINE_ITEM_CHANGE_STATE_ACTIVATING" => Self::Activating,
            _ => Self::UnknownValue(line_item_change_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LineItemChangeState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PendingApproval => serializer.serialize_i32(1),
            Self::Approved => serializer.serialize_i32(2),
            Self::Completed => serializer.serialize_i32(3),
            Self::Rejected => serializer.serialize_i32(4),
            Self::Abandoned => serializer.serialize_i32(5),
            Self::Activating => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LineItemChangeState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<LineItemChangeState>::new(
            ".google.cloud.commerce.consumer.procurement.v1.LineItemChangeState",
        ))
    }
}

/// Predefined types for line item change state reason.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum LineItemChangeStateReasonType {
    /// Default value, indicating there's no predefined type for change state
    /// reason.
    Unspecified,
    /// Change is in current state due to term expiration.
    Expired,
    /// Change is in current state due to user-initiated cancellation.
    UserCancelled,
    /// Change is in current state due to system-initiated cancellation.
    SystemCancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [LineItemChangeStateReasonType::value] or
    /// [LineItemChangeStateReasonType::name].
    UnknownValue(line_item_change_state_reason_type::UnknownValue),
}

#[doc(hidden)]
pub mod line_item_change_state_reason_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl LineItemChangeStateReasonType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Expired => std::option::Option::Some(1),
            Self::UserCancelled => std::option::Option::Some(2),
            Self::SystemCancelled => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED")
            }
            Self::Expired => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED")
            }
            Self::UserCancelled => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED")
            }
            Self::SystemCancelled => {
                std::option::Option::Some("LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for LineItemChangeStateReasonType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for LineItemChangeStateReasonType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for LineItemChangeStateReasonType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Expired,
            2 => Self::UserCancelled,
            3 => Self::SystemCancelled,
            _ => Self::UnknownValue(line_item_change_state_reason_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for LineItemChangeStateReasonType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED" => Self::Unspecified,
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED" => Self::Expired,
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED" => Self::UserCancelled,
            "LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED" => Self::SystemCancelled,
            _ => Self::UnknownValue(line_item_change_state_reason_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for LineItemChangeStateReasonType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Expired => serializer.serialize_i32(1),
            Self::UserCancelled => serializer.serialize_i32(2),
            Self::SystemCancelled => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for LineItemChangeStateReasonType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<LineItemChangeStateReasonType>::new(
                ".google.cloud.commerce.consumer.procurement.v1.LineItemChangeStateReasonType",
            ),
        )
    }
}

/// Indicates the auto renewal behavior customer specifies on subscription.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AutoRenewalBehavior {
    /// If unspecified, the auto renewal behavior will follow the default config.
    Unspecified,
    /// Auto Renewal will be enabled on subscription.
    Enable,
    /// Auto Renewal will be disabled on subscription.
    Disable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AutoRenewalBehavior::value] or
    /// [AutoRenewalBehavior::name].
    UnknownValue(auto_renewal_behavior::UnknownValue),
}

#[doc(hidden)]
pub mod auto_renewal_behavior {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AutoRenewalBehavior {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Enable => std::option::Option::Some(1),
            Self::Disable => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUTO_RENEWAL_BEHAVIOR_UNSPECIFIED"),
            Self::Enable => std::option::Option::Some("AUTO_RENEWAL_BEHAVIOR_ENABLE"),
            Self::Disable => std::option::Option::Some("AUTO_RENEWAL_BEHAVIOR_DISABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AutoRenewalBehavior {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AutoRenewalBehavior {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AutoRenewalBehavior {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Enable,
            2 => Self::Disable,
            _ => Self::UnknownValue(auto_renewal_behavior::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AutoRenewalBehavior {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTO_RENEWAL_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
            "AUTO_RENEWAL_BEHAVIOR_ENABLE" => Self::Enable,
            "AUTO_RENEWAL_BEHAVIOR_DISABLE" => Self::Disable,
            _ => Self::UnknownValue(auto_renewal_behavior::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AutoRenewalBehavior {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Enable => serializer.serialize_i32(1),
            Self::Disable => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AutoRenewalBehavior {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoRenewalBehavior>::new(
            ".google.cloud.commerce.consumer.procurement.v1.AutoRenewalBehavior",
        ))
    }
}
