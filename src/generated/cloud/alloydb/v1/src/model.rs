// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// SqlResult represents the result for the execution of a sql statement.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlResult {
    /// List of columns included in the result. This also includes the data type
    /// of the column.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::SqlResultColumn>,

    /// Rows returned by the SQL statement.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rows: std::vec::Vec<crate::model::SqlResultRow>,
}

impl SqlResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::SqlResult::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultColumn>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows][crate::model::SqlResult::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultRow>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResult"
    }
}

/// Contains the name and datatype of a column in a SQL Result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlResultColumn {
    /// Name of the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Datatype of the column as reported by the postgres driver.
    /// Common type names are "VARCHAR", "TEXT", "NVARCHAR", "DECIMAL", "BOOL",
    /// "INT", and "BIGINT".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,
}

impl SqlResultColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SqlResultColumn::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SqlResultColumn::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for SqlResultColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultColumn"
    }
}

/// A single row from a sql result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlResultRow {
    /// List of values in a row of sql result.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<crate::model::SqlResultValue>,
}

impl SqlResultRow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::SqlResultRow::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlResultRow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultRow"
    }
}

/// A single value in a row from a sql result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlResultValue {
    /// The cell value represented in string format.
    /// Timestamps are converted to string using RFC3339Nano format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<std::string::String>,

    /// Set to true if cell value is null.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub null_value: std::option::Option<bool>,
}

impl SqlResultValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::SqlResultValue::value].
    pub fn set_value<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [null_value][crate::model::SqlResultValue::null_value].
    pub fn set_null_value<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.null_value = v.into();
        self
    }
}

impl wkt::message::Message for SqlResultValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultValue"
    }
}

/// The username/password for a database user. Used for specifying initial
/// users at cluster creation time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserPassword {
    /// The database username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// The initial password for the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,
}

impl UserPassword {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user][crate::model::UserPassword::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [password][crate::model::UserPassword::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for UserPassword {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UserPassword"
    }
}

/// Subset of the source instance configuration that is available when reading
/// the cluster resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationSource {
    /// Output only. The host and port of the on-premises instance in host:port
    /// format
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_port: std::string::String,

    /// Output only. Place holder for the external source identifier(e.g DMS job
    /// name) that created the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reference_id: std::string::String,

    /// Output only. Type of migration source.
    pub source_type: crate::model::migration_source::MigrationSourceType,
}

impl MigrationSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_port][crate::model::MigrationSource::host_port].
    pub fn set_host_port<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_port = v.into();
        self
    }

    /// Sets the value of [reference_id][crate::model::MigrationSource::reference_id].
    pub fn set_reference_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference_id = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::MigrationSource::source_type].
    pub fn set_source_type<
        T: std::convert::Into<crate::model::migration_source::MigrationSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }
}

impl wkt::message::Message for MigrationSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MigrationSource"
    }
}

/// Defines additional types related to [MigrationSource].
pub mod migration_source {
    #[allow(unused_imports)]
    use super::*;

    /// Denote the type of migration source that created this cluster.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MigrationSourceType(i32);

    impl MigrationSourceType {
        /// Migration source is unknown.
        pub const MIGRATION_SOURCE_TYPE_UNSPECIFIED: MigrationSourceType =
            MigrationSourceType::new(0);

        /// DMS source means the cluster was created via DMS migration job.
        pub const DMS: MigrationSourceType = MigrationSourceType::new(1);

        /// Creates a new MigrationSourceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MIGRATION_SOURCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DMS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MIGRATION_SOURCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::MIGRATION_SOURCE_TYPE_UNSPECIFIED)
                }
                "DMS" => std::option::Option::Some(Self::DMS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MigrationSourceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MigrationSourceType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// EncryptionConfig describes the encryption config of a cluster or a backup
/// that is encrypted with a CMEK (customer-managed encryption key).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// The fully-qualified resource name of the KMS key.
    /// Each Cloud KMS key is regionalized and has the following format:
    /// projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfig::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.EncryptionConfig"
    }
}

/// EncryptionInfo describes the encryption information of a cluster or a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionInfo {
    /// Output only. Type of encryption.
    pub encryption_type: crate::model::encryption_info::Type,

    /// Output only. Cloud KMS key versions that are being used to protect the
    /// database or the backup.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub kms_key_versions: std::vec::Vec<std::string::String>,
}

impl EncryptionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_type][crate::model::EncryptionInfo::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::encryption_info::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [kms_key_versions][crate::model::EncryptionInfo::kms_key_versions].
    pub fn set_kms_key_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kms_key_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EncryptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.EncryptionInfo"
    }
}

/// Defines additional types related to [EncryptionInfo].
pub mod encryption_info {
    #[allow(unused_imports)]
    use super::*;

    /// Possible encryption types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Encryption type not specified. Defaults to GOOGLE_DEFAULT_ENCRYPTION.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// The data is encrypted at rest with a key that is fully managed by Google.
        /// No key version will be populated. This is the default state.
        pub const GOOGLE_DEFAULT_ENCRYPTION: Type = Type::new(1);

        /// The data is encrypted at rest with a key that is managed by the customer.
        /// KMS key versions will be populated.
        pub const CUSTOMER_MANAGED_ENCRYPTION: Type = Type::new(2);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GOOGLE_DEFAULT_ENCRYPTION"),
                2 => std::borrow::Cow::Borrowed("CUSTOMER_MANAGED_ENCRYPTION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "GOOGLE_DEFAULT_ENCRYPTION" => {
                    std::option::Option::Some(Self::GOOGLE_DEFAULT_ENCRYPTION)
                }
                "CUSTOMER_MANAGED_ENCRYPTION" => {
                    std::option::Option::Some(Self::CUSTOMER_MANAGED_ENCRYPTION)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// SSL configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslConfig {
    /// Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
    pub ssl_mode: crate::model::ssl_config::SslMode,

    /// Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is
    /// supported currently, and is the default value.
    pub ca_source: crate::model::ssl_config::CaSource,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ssl_mode][crate::model::SslConfig::ssl_mode].
    pub fn set_ssl_mode<T: std::convert::Into<crate::model::ssl_config::SslMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_mode = v.into();
        self
    }

    /// Sets the value of [ca_source][crate::model::SslConfig::ca_source].
    pub fn set_ca_source<T: std::convert::Into<crate::model::ssl_config::CaSource>>(
        mut self,
        v: T,
    ) -> Self {
        self.ca_source = v.into();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SslConfig"
    }
}

/// Defines additional types related to [SslConfig].
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// SSL mode options.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SslMode(i32);

    impl SslMode {
        /// SSL mode is not specified. Defaults to ENCRYPTED_ONLY.
        pub const SSL_MODE_UNSPECIFIED: SslMode = SslMode::new(0);

        /// SSL connections are optional. CA verification not enforced.
        pub const SSL_MODE_ALLOW: SslMode = SslMode::new(1);

        /// SSL connections are required. CA verification not enforced.
        /// Clients may use locally self-signed certificates (default psql client
        /// behavior).
        pub const SSL_MODE_REQUIRE: SslMode = SslMode::new(2);

        /// SSL connections are required. CA verification enforced.
        /// Clients must have certificates signed by a Cluster CA, for example, using
        /// GenerateClientCertificate.
        pub const SSL_MODE_VERIFY_CA: SslMode = SslMode::new(3);

        /// SSL connections are optional. CA verification not enforced.
        pub const ALLOW_UNENCRYPTED_AND_ENCRYPTED: SslMode = SslMode::new(4);

        /// SSL connections are required. CA verification not enforced.
        pub const ENCRYPTED_ONLY: SslMode = SslMode::new(5);

        /// Creates a new SslMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SSL_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SSL_MODE_ALLOW"),
                2 => std::borrow::Cow::Borrowed("SSL_MODE_REQUIRE"),
                3 => std::borrow::Cow::Borrowed("SSL_MODE_VERIFY_CA"),
                4 => std::borrow::Cow::Borrowed("ALLOW_UNENCRYPTED_AND_ENCRYPTED"),
                5 => std::borrow::Cow::Borrowed("ENCRYPTED_ONLY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SSL_MODE_UNSPECIFIED" => std::option::Option::Some(Self::SSL_MODE_UNSPECIFIED),
                "SSL_MODE_ALLOW" => std::option::Option::Some(Self::SSL_MODE_ALLOW),
                "SSL_MODE_REQUIRE" => std::option::Option::Some(Self::SSL_MODE_REQUIRE),
                "SSL_MODE_VERIFY_CA" => std::option::Option::Some(Self::SSL_MODE_VERIFY_CA),
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => {
                    std::option::Option::Some(Self::ALLOW_UNENCRYPTED_AND_ENCRYPTED)
                }
                "ENCRYPTED_ONLY" => std::option::Option::Some(Self::ENCRYPTED_ONLY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SslMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SslMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Certificate Authority (CA) source for SSL/TLS certificates.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CaSource(i32);

    impl CaSource {
        /// Certificate Authority (CA) source not specified. Defaults to
        /// CA_SOURCE_MANAGED.
        pub const CA_SOURCE_UNSPECIFIED: CaSource = CaSource::new(0);

        /// Certificate Authority (CA) managed by the AlloyDB Cluster.
        pub const CA_SOURCE_MANAGED: CaSource = CaSource::new(1);

        /// Creates a new CaSource instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CA_SOURCE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CA_SOURCE_MANAGED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CA_SOURCE_UNSPECIFIED" => std::option::Option::Some(Self::CA_SOURCE_UNSPECIFIED),
                "CA_SOURCE_MANAGED" => std::option::Option::Some(Self::CA_SOURCE_MANAGED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for CaSource {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for CaSource {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message describing the user-specified automated backup policy.
///
/// All fields in the automated backup policy are optional. Defaults for each
/// field are provided if they are not set.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomatedBackupPolicy {
    /// Whether automated automated backups are enabled. If not set, defaults to
    /// true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<bool>,

    /// The length of the time window during which a backup can be
    /// taken. If a backup does not succeed within this time window, it will be
    /// canceled and considered failed.
    ///
    /// The backup window must be at least 5 minutes long. There is no upper bound
    /// on the window. If not set, it defaults to 1 hour.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_window: std::option::Option<wkt::Duration>,

    /// Optional. The encryption config can be specified to encrypt the
    /// backups with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will then use default encryption scheme to
    /// protect the user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// The location where the backup will be stored. Currently, the only supported
    /// option is to store the backup in the same region as the cluster.
    ///
    /// If empty, defaults to the region of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Labels to apply to backups created using this configuration.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::automated_backup_policy::Schedule>,

    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub retention: std::option::Option<crate::model::automated_backup_policy::Retention>,
}

impl AutomatedBackupPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::AutomatedBackupPolicy::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [backup_window][crate::model::AutomatedBackupPolicy::backup_window].
    pub fn set_backup_window<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_window = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::AutomatedBackupPolicy::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AutomatedBackupPolicy::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AutomatedBackupPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `schedule`.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_policy::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::AutomatedBackupPolicy::schedule]
    /// if it holds a `WeeklySchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_weekly_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>>
    {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Schedule::WeeklySchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupPolicy::schedule]
    /// to hold a `WeeklySchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_weekly_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::automated_backup_policy::Schedule::WeeklySchedule(v.into()),
        );
        self
    }

    /// Sets the value of `retention`.
    pub fn set_retention<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_policy::Retention>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = v.into();
        self
    }

    /// The value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// if it holds a `TimeBasedRetention`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_time_based_retention(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
    > {
        #[allow(unreachable_patterns)]
        self.retention.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Retention::TimeBasedRetention(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// if it holds a `QuantityBasedRetention`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_quantity_based_retention(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
    > {
        #[allow(unreachable_patterns)]
        self.retention.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Retention::QuantityBasedRetention(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// to hold a `TimeBasedRetention`.
    ///
    /// Note that all the setters affecting `retention` are
    /// mutually exclusive.
    pub fn set_time_based_retention<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = std::option::Option::Some(
            crate::model::automated_backup_policy::Retention::TimeBasedRetention(v.into()),
        );
        self
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// to hold a `QuantityBasedRetention`.
    ///
    /// Note that all the setters affecting `retention` are
    /// mutually exclusive.
    pub fn set_quantity_based_retention<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = std::option::Option::Some(
            crate::model::automated_backup_policy::Retention::QuantityBasedRetention(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomatedBackupPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy"
    }
}

/// Defines additional types related to [AutomatedBackupPolicy].
pub mod automated_backup_policy {
    #[allow(unused_imports)]
    use super::*;

    /// A weekly schedule starts a backup at prescribed start times within a
    /// day, for the specified days of the week.
    ///
    /// The weekly schedule message is flexible and can be used to create many
    /// types of schedules. For example, to have a daily backup that starts at
    /// 22:00, configure the `start_times` field to have one element "22:00" and
    /// the `days_of_week` field to have all seven days of the week.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WeeklySchedule {
        /// The times during the day to start a backup. The start times are assumed
        /// to be in UTC and to be an exact hour (e.g., 04:00:00).
        ///
        /// If no start times are provided, a single fixed start time is chosen
        /// arbitrarily.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub start_times: std::vec::Vec<gtype::model::TimeOfDay>,

        /// The days of the week to perform a backup.
        ///
        /// If this field is left empty, the default of every day of the week is
        /// used.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,
    }

    impl WeeklySchedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_times][crate::model::automated_backup_policy::WeeklySchedule::start_times].
        pub fn set_start_times<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<gtype::model::TimeOfDay>,
        {
            use std::iter::Iterator;
            self.start_times = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [days_of_week][crate::model::automated_backup_policy::WeeklySchedule::days_of_week].
        pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<gtype::model::DayOfWeek>,
        {
            use std::iter::Iterator;
            self.days_of_week = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WeeklySchedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklySchedule"
        }
    }

    /// A time based retention policy specifies that all backups within a certain
    /// time period should be retained.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TimeBasedRetention {
        /// The retention period.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub retention_period: std::option::Option<wkt::Duration>,
    }

    impl TimeBasedRetention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_period][crate::model::automated_backup_policy::TimeBasedRetention::retention_period].
        pub fn set_retention_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.retention_period = v.into();
            self
        }
    }

    impl wkt::message::Message for TimeBasedRetention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.TimeBasedRetention"
        }
    }

    /// A quantity based policy specifies that a certain number of the most recent
    /// successful backups should be retained.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QuantityBasedRetention {
        /// The number of backups to retain.
        pub count: i32,
    }

    impl QuantityBasedRetention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::automated_backup_policy::QuantityBasedRetention::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for QuantityBasedRetention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.QuantityBasedRetention"
        }
    }

    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Schedule {
        /// Weekly schedule for the Backup.
        WeeklySchedule(std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>),
    }

    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Retention {
        /// Time-based Backup retention policy.
        TimeBasedRetention(
            std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
        ),
        /// Quantity-based Backup retention policy to retain recent backups.
        QuantityBasedRetention(
            std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
        ),
    }
}

/// ContinuousBackupConfig describes the continuous backups recovery
/// configurations of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContinuousBackupConfig {
    /// Whether ContinuousBackup is enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled: std::option::Option<bool>,

    /// The number of days that are eligible to restore from using PITR. To support
    /// the entire recovery window, backups and logs are retained for one day more
    /// than the recovery window. If not set, defaults to 14 days.
    pub recovery_window_days: i32,

    /// The encryption config can be specified to encrypt the
    /// backups with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will then use default encryption scheme to
    /// protect the user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,
}

impl ContinuousBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ContinuousBackupConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [recovery_window_days][crate::model::ContinuousBackupConfig::recovery_window_days].
    pub fn set_recovery_window_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.recovery_window_days = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::ContinuousBackupConfig::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }
}

impl wkt::message::Message for ContinuousBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupConfig"
    }
}

/// ContinuousBackupInfo describes the continuous backup properties of a
/// cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContinuousBackupInfo {
    /// Output only. The encryption information for the WALs and backups required
    /// for ContinuousBackup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Output only. When ContinuousBackup was most recently enabled. Set to null
    /// if ContinuousBackup is not enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enabled_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Days of the week on which a continuous backup is taken. Output
    /// only field. Ignored if passed into the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub schedule: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Output only. The earliest restorable time that can be restored to. Output
    /// only field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub earliest_restorable_time: std::option::Option<wkt::Timestamp>,
}

impl ContinuousBackupInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_info][crate::model::ContinuousBackupInfo::encryption_info].
    pub fn set_encryption_info<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_info = v.into();
        self
    }

    /// Sets the value of [enabled_time][crate::model::ContinuousBackupInfo::enabled_time].
    pub fn set_enabled_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enabled_time = v.into();
        self
    }

    /// Sets the value of [earliest_restorable_time][crate::model::ContinuousBackupInfo::earliest_restorable_time].
    pub fn set_earliest_restorable_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.earliest_restorable_time = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::ContinuousBackupInfo::schedule].
    pub fn set_schedule<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.schedule = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ContinuousBackupInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupInfo"
    }
}

/// Message describing a BackupSource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupSource {
    /// Output only. The system-generated UID of the backup which was used to
    /// create this resource. The UID is generated when the backup is created, and
    /// it is retained until the backup is deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_uid: std::string::String,

    /// Required. The name of the backup resource with the format:
    ///
    /// * projects/{project}/locations/{region}/backups/{backup_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_name: std::string::String,
}

impl BackupSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_uid][crate::model::BackupSource::backup_uid].
    pub fn set_backup_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_uid = v.into();
        self
    }

    /// Sets the value of [backup_name][crate::model::BackupSource::backup_name].
    pub fn set_backup_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_name = v.into();
        self
    }
}

impl wkt::message::Message for BackupSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BackupSource"
    }
}

/// Message describing a ContinuousBackupSource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContinuousBackupSource {
    /// Required. The source cluster from which to restore. This cluster must have
    /// continuous backup enabled for this operation to succeed. For the required
    /// format, see the comment on the Cluster.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,

    /// Required. The point in time to restore to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub point_in_time: std::option::Option<wkt::Timestamp>,
}

impl ContinuousBackupSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::ContinuousBackupSource::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [point_in_time][crate::model::ContinuousBackupSource::point_in_time].
    pub fn set_point_in_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.point_in_time = v.into();
        self
    }
}

impl wkt::message::Message for ContinuousBackupSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupSource"
    }
}

/// MaintenanceUpdatePolicy defines the policy for system updates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceUpdatePolicy {
    /// Preferred windows to perform maintenance. Currently limited to 1.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub maintenance_windows:
        std::vec::Vec<crate::model::maintenance_update_policy::MaintenanceWindow>,
}

impl MaintenanceUpdatePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [maintenance_windows][crate::model::MaintenanceUpdatePolicy::maintenance_windows].
    pub fn set_maintenance_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::maintenance_update_policy::MaintenanceWindow>,
    {
        use std::iter::Iterator;
        self.maintenance_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenanceUpdatePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy"
    }
}

/// Defines additional types related to [MaintenanceUpdatePolicy].
pub mod maintenance_update_policy {
    #[allow(unused_imports)]
    use super::*;

    /// MaintenanceWindow specifies a preferred day and time for maintenance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MaintenanceWindow {
        /// Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
        pub day: gtype::model::DayOfWeek,

        /// Preferred time to start the maintenance operation on the specified day.
        /// Maintenance will start within 1 hour of this time.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<gtype::model::TimeOfDay>,
    }

    impl MaintenanceWindow {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [day][crate::model::maintenance_update_policy::MaintenanceWindow::day].
        pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
            self.day = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::maintenance_update_policy::MaintenanceWindow::start_time].
        pub fn set_start_time<
            T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }
    }

    impl wkt::message::Message for MaintenanceWindow {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy.MaintenanceWindow"
        }
    }
}

/// MaintenanceSchedule stores the maintenance schedule generated from
/// the MaintenanceUpdatePolicy, once a maintenance rollout is triggered, if
/// MaintenanceWindow is set, and if there is no conflicting DenyPeriod.
/// The schedule is cleared once the update takes place. This field cannot be
/// manually changed; modify the MaintenanceUpdatePolicy instead.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceSchedule {
    /// Output only. The scheduled start time for the maintenance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,
}

impl MaintenanceSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::MaintenanceSchedule::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceSchedule"
    }
}

/// A cluster is a collection of regional AlloyDB resources. It can include a
/// primary instance and one or more read pool instances.
/// All cluster resources share a storage layer, which scales as needed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// Output only. The name of the cluster resource with the format:
    ///
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}
    ///   where the cluster ID segment should satisfy the regex expression
    ///   `[a-z0-9-]+`. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the cluster resource name is the name of the parent resource:
    /// * projects/{project}/locations/{region}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Create time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current serving state of the cluster.
    pub state: crate::model::cluster::State,

    /// Output only. The type of the cluster. This is an output-only field and it's
    /// populated at the Cluster creation time or the Cluster promotion
    /// time. The cluster type is determined by which RPC was used to create
    /// the cluster (i.e. `CreateCluster` vs. `CreateSecondaryCluster`
    pub cluster_type: crate::model::cluster::ClusterType,

    /// Optional. The database engine major version. This is an optional field and
    /// it is populated at the Cluster creation time. If a database version is not
    /// supplied at cluster creation time, then a default database version will
    /// be used.
    pub database_version: crate::model::DatabaseVersion,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::cluster::NetworkConfig>,

    /// Required. The resource link for the VPC network in which cluster resources
    /// are created and from which they are accessible via Private IP. The network
    /// must belong to the same project as the cluster. It is specified in the
    /// form: `projects/{project}/global/networks/{network_id}`. This is required
    /// to create a cluster. Deprecated, use network_config.network instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Cluster does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    pub reconciling: bool,

    /// Input only. Initial user to setup during cluster creation. Required.
    /// If used in `RestoreCluster` this is ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub initial_user: std::option::Option<crate::model::UserPassword>,

    /// The automated backup policy for this cluster.
    ///
    /// If no policy is provided then the default policy will be used. If backups
    /// are supported for the cluster, the default policy takes one backup a day,
    /// has a backup window of 1 hour, and retains backups for 14 days.
    /// For more information on the defaults, consult the
    /// documentation for the message type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automated_backup_policy: std::option::Option<crate::model::AutomatedBackupPolicy>,

    /// SSL configuration for this AlloyDB cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl_config: std::option::Option<crate::model::SslConfig>,

    /// Optional. The encryption config can be specified to encrypt the data disks
    /// and other persistent data resources of a cluster with a
    /// customer-managed encryption key (CMEK). When this field is not
    /// specified, the cluster will then use default encryption scheme to
    /// protect the user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Output only. The encryption information for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Optional. Continuous backup configuration for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub continuous_backup_config: std::option::Option<crate::model::ContinuousBackupConfig>,

    /// Output only. Continuous backup properties for this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub continuous_backup_info: std::option::Option<crate::model::ContinuousBackupInfo>,

    /// Cross Region replication config specific to SECONDARY cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_config: std::option::Option<crate::model::cluster::SecondaryConfig>,

    /// Output only. Cross Region replication config specific to PRIMARY cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_config: std::option::Option<crate::model::cluster::PrimaryConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. The configuration for Private Service Connect (PSC) for the
    /// cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_config: std::option::Option<crate::model::cluster::PscConfig>,

    /// Optional. The maintenance update policy determines when to allow or deny
    /// updates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_update_policy: std::option::Option<crate::model::MaintenanceUpdatePolicy>,

    /// Output only. The maintenance schedule for the cluster, generated for a
    /// specific rollout if a maintenance window is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_schedule: std::option::Option<crate::model::MaintenanceSchedule>,

    /// Optional. Subscription type of the cluster.
    pub subscription_type: crate::model::SubscriptionType,

    /// Output only. Metadata for free trial clusters
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trial_metadata: std::option::Option<crate::model::cluster::TrialMetadata>,

    /// Optional. Input only. Immutable. Tag keys/values directly bound to this
    /// resource. For example:
    ///
    /// ```norust
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    /// ```
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::cluster::Source>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Cluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Cluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Cluster::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cluster_type][crate::model::Cluster::cluster_type].
    pub fn set_cluster_type<T: std::convert::Into<crate::model::cluster::ClusterType>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_type = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::Cluster::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::Cluster::network_config].
    pub fn set_network_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::NetworkConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Cluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Cluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Cluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [initial_user][crate::model::Cluster::initial_user].
    pub fn set_initial_user<
        T: std::convert::Into<std::option::Option<crate::model::UserPassword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initial_user = v.into();
        self
    }

    /// Sets the value of [automated_backup_policy][crate::model::Cluster::automated_backup_policy].
    pub fn set_automated_backup_policy<
        T: std::convert::Into<std::option::Option<crate::model::AutomatedBackupPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_policy = v.into();
        self
    }

    /// Sets the value of [ssl_config][crate::model::Cluster::ssl_config].
    pub fn set_ssl_config<T: std::convert::Into<std::option::Option<crate::model::SslConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_config = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::Cluster::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of [encryption_info][crate::model::Cluster::encryption_info].
    pub fn set_encryption_info<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_info = v.into();
        self
    }

    /// Sets the value of [continuous_backup_config][crate::model::Cluster::continuous_backup_config].
    pub fn set_continuous_backup_config<
        T: std::convert::Into<std::option::Option<crate::model::ContinuousBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.continuous_backup_config = v.into();
        self
    }

    /// Sets the value of [continuous_backup_info][crate::model::Cluster::continuous_backup_info].
    pub fn set_continuous_backup_info<
        T: std::convert::Into<std::option::Option<crate::model::ContinuousBackupInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.continuous_backup_info = v.into();
        self
    }

    /// Sets the value of [secondary_config][crate::model::Cluster::secondary_config].
    pub fn set_secondary_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::SecondaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_config = v.into();
        self
    }

    /// Sets the value of [primary_config][crate::model::Cluster::primary_config].
    pub fn set_primary_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::PrimaryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.primary_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::Cluster::psc_config].
    pub fn set_psc_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::PscConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.psc_config = v.into();
        self
    }

    /// Sets the value of [maintenance_update_policy][crate::model::Cluster::maintenance_update_policy].
    pub fn set_maintenance_update_policy<
        T: std::convert::Into<std::option::Option<crate::model::MaintenanceUpdatePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_update_policy = v.into();
        self
    }

    /// Sets the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    pub fn set_maintenance_schedule<
        T: std::convert::Into<std::option::Option<crate::model::MaintenanceSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_schedule = v.into();
        self
    }

    /// Sets the value of [subscription_type][crate::model::Cluster::subscription_type].
    pub fn set_subscription_type<T: std::convert::Into<crate::model::SubscriptionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.subscription_type = v.into();
        self
    }

    /// Sets the value of [trial_metadata][crate::model::Cluster::trial_metadata].
    pub fn set_trial_metadata<
        T: std::convert::Into<std::option::Option<crate::model::cluster::TrialMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trial_metadata = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Cluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Cluster::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::cluster::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `BackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::BackupSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `MigrationSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_migration_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MigrationSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::MigrationSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `BackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_backup_source<T: std::convert::Into<std::boxed::Box<crate::model::BackupSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::cluster::Source::BackupSource(v.into()));
        self
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `MigrationSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_migration_source<
        T: std::convert::Into<std::boxed::Box<crate::model::MigrationSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::cluster::Source::MigrationSource(v.into()));
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Cluster"
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata related to network configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NetworkConfig {
        /// Optional. The resource link for the VPC network in which cluster
        /// resources are created and from which they are accessible via Private IP.
        /// The network must belong to the same project as the cluster. It is
        /// specified in the form:
        /// `projects/{project_number}/global/networks/{network_id}`. This is
        /// required to create a cluster.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub network: std::string::String,

        /// Optional. Name of the allocated IP range for the private IP AlloyDB
        /// cluster, for example: "google-managed-services-default". If set, the
        /// instance IPs for this cluster will be created in the allocated range. The
        /// range name must comply with RFC 1035. Specifically, the name must be 1-63
        /// characters long and match the regular expression
        /// `[a-z]([-a-z0-9]*[a-z0-9])?`.
        /// Field name is intended to be consistent with Cloud SQL.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub allocated_ip_range: std::string::String,
    }

    impl NetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::cluster::NetworkConfig::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [allocated_ip_range][crate::model::cluster::NetworkConfig::allocated_ip_range].
        pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allocated_ip_range = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.NetworkConfig"
        }
    }

    /// Configuration information for the secondary cluster. This should be set
    /// if and only if the cluster is of type SECONDARY.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SecondaryConfig {
        /// The name of the primary cluster name with the format:
        ///
        /// * projects/{project}/locations/{region}/clusters/{cluster_id}
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub primary_cluster_name: std::string::String,
    }

    impl SecondaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primary_cluster_name][crate::model::cluster::SecondaryConfig::primary_cluster_name].
        pub fn set_primary_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.primary_cluster_name = v.into();
            self
        }
    }

    impl wkt::message::Message for SecondaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.SecondaryConfig"
        }
    }

    /// Configuration for the primary cluster. It has the list of clusters that are
    /// replicating from this cluster. This should be set if and only if the
    /// cluster is of type PRIMARY.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrimaryConfig {
        /// Output only. Names of the clusters that are replicating from this
        /// cluster.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub secondary_cluster_names: std::vec::Vec<std::string::String>,
    }

    impl PrimaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [secondary_cluster_names][crate::model::cluster::PrimaryConfig::secondary_cluster_names].
        pub fn set_secondary_cluster_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.secondary_cluster_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PrimaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.PrimaryConfig"
        }
    }

    /// PscConfig contains PSC related configuration at a cluster level.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PscConfig {
        /// Optional. Create an instance that allows connections from Private Service
        /// Connect endpoints to the instance.
        pub psc_enabled: bool,
    }

    impl PscConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [psc_enabled][crate::model::cluster::PscConfig::psc_enabled].
        pub fn set_psc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.psc_enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for PscConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.PscConfig"
        }
    }

    /// Contains information and all metadata related to TRIAL clusters.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrialMetadata {
        /// start time of the trial cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// End time of the trial cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Upgrade time of trial cluster to Standard cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub upgrade_time: std::option::Option<wkt::Timestamp>,

        /// grace end time of the cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub grace_end_time: std::option::Option<wkt::Timestamp>,
    }

    impl TrialMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::cluster::TrialMetadata::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [end_time][crate::model::cluster::TrialMetadata::end_time].
        pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.end_time = v.into();
            self
        }

        /// Sets the value of [upgrade_time][crate::model::cluster::TrialMetadata::upgrade_time].
        pub fn set_upgrade_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.upgrade_time = v.into();
            self
        }

        /// Sets the value of [grace_end_time][crate::model::cluster::TrialMetadata::grace_end_time].
        pub fn set_grace_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.grace_end_time = v.into();
            self
        }
    }

    impl wkt::message::Message for TrialMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.TrialMetadata"
        }
    }

    /// Cluster State
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The state of the cluster is unknown.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The cluster is active and running.
        pub const READY: State = State::new(1);

        /// The cluster is stopped. All instances in the cluster are stopped.
        /// Customers can start a stopped cluster at any point and all their
        /// instances will come back to life with same names and IP resources. In
        /// this state, customer pays for storage.
        /// Associated backups could also be present in a stopped cluster.
        pub const STOPPED: State = State::new(2);

        /// The cluster is empty and has no associated resources.
        /// All instances, associated storage and backups have been deleted.
        pub const EMPTY: State = State::new(3);

        /// The cluster is being created.
        pub const CREATING: State = State::new(4);

        /// The cluster is being deleted.
        pub const DELETING: State = State::new(5);

        /// The creation of the cluster failed.
        pub const FAILED: State = State::new(6);

        /// The cluster is bootstrapping with data from some other source.
        /// Direct mutations to the cluster (e.g. adding read pool) are not allowed.
        pub const BOOTSTRAPPING: State = State::new(7);

        /// The cluster is under maintenance. AlloyDB regularly performs maintenance
        /// and upgrades on customer clusters. Updates on the cluster are
        /// not allowed while the cluster is in this state.
        pub const MAINTENANCE: State = State::new(8);

        /// The cluster is being promoted.
        pub const PROMOTING: State = State::new(9);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("READY"),
                2 => std::borrow::Cow::Borrowed("STOPPED"),
                3 => std::borrow::Cow::Borrowed("EMPTY"),
                4 => std::borrow::Cow::Borrowed("CREATING"),
                5 => std::borrow::Cow::Borrowed("DELETING"),
                6 => std::borrow::Cow::Borrowed("FAILED"),
                7 => std::borrow::Cow::Borrowed("BOOTSTRAPPING"),
                8 => std::borrow::Cow::Borrowed("MAINTENANCE"),
                9 => std::borrow::Cow::Borrowed("PROMOTING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "READY" => std::option::Option::Some(Self::READY),
                "STOPPED" => std::option::Option::Some(Self::STOPPED),
                "EMPTY" => std::option::Option::Some(Self::EMPTY),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "BOOTSTRAPPING" => std::option::Option::Some(Self::BOOTSTRAPPING),
                "MAINTENANCE" => std::option::Option::Some(Self::MAINTENANCE),
                "PROMOTING" => std::option::Option::Some(Self::PROMOTING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of Cluster
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ClusterType(i32);

    impl ClusterType {
        /// The type of the cluster is unknown.
        pub const CLUSTER_TYPE_UNSPECIFIED: ClusterType = ClusterType::new(0);

        /// Primary cluster that support read and write operations.
        pub const PRIMARY: ClusterType = ClusterType::new(1);

        /// Secondary cluster that is replicating from another region.
        /// This only supports read.
        pub const SECONDARY: ClusterType = ClusterType::new(2);

        /// Creates a new ClusterType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CLUSTER_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PRIMARY"),
                2 => std::borrow::Cow::Borrowed("SECONDARY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CLUSTER_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CLUSTER_TYPE_UNSPECIFIED)
                }
                "PRIMARY" => std::option::Option::Some(Self::PRIMARY),
                "SECONDARY" => std::option::Option::Some(Self::SECONDARY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ClusterType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ClusterType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Output only. Cluster created from backup.
        BackupSource(std::boxed::Box<crate::model::BackupSource>),
        /// Output only. Cluster created via DMS migration.
        MigrationSource(std::boxed::Box<crate::model::MigrationSource>),
    }
}

/// An Instance is a computing unit that an end customer can connect to.
/// It's the main unit of computing resources in AlloyDB.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The name of the instance resource with the format:
    ///
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}/instances/{instance_id}
    ///   where the cluster and instance ID segments should satisfy the regex
    ///   expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
    ///   lowercase letters, numbers, and dashes, starting with a letter, and ending
    ///   with a letter or number. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the instance resource name is the name of the parent
    ///   resource:
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Create time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current serving state of the instance.
    pub state: crate::model::instance::State,

    /// Required. The type of the instance. Specified at creation time.
    pub instance_type: crate::model::instance::InstanceType,

    /// Configurations for the machines that host the underlying
    /// database engine.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub machine_config: std::option::Option<crate::model::instance::MachineConfig>,

    /// Availability type of an Instance.
    /// If empty, defaults to REGIONAL for primary instances.
    /// For read pools, availability_type is always UNSPECIFIED. Instances in the
    /// read pools are evenly distributed across available zones within the region
    /// (i.e. read pools with more than one node will have a node in at
    /// least two zones).
    pub availability_type: crate::model::instance::AvailabilityType,

    /// The Compute Engine zone that the instance should serve from, per
    /// <https://cloud.google.com/compute/docs/regions-zones>
    /// This can ONLY be specified for ZONAL instances.
    /// If present for a REGIONAL instance, an error will be thrown.
    /// If this is absent for a ZONAL instance, instance is created in a random
    /// zone with available capacity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gce_zone: std::string::String,

    /// Database flags. Set at instance level.
    ///
    /// * They are copied from primary instance on read instance creation.
    /// * Read instances can set new or override existing flags that are relevant
    ///   for reads, e.g. for enabling columnar cache on a read instance. Flags
    ///   set on read instance may or may not be present on primary.
    ///
    /// This is a list of "key": "value" pairs.
    /// "key": The name of the flag. These flags are passed at instance setup time,
    /// so include both server options and system variables for Postgres. Flags are
    /// specified with underscores, not hyphens.
    /// "value": The value of the flag. Booleans are set to **on** for true
    /// and **off** for false. This field must be omitted if the flag
    /// doesn't take a value.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. This is set for the read-write VM of the PRIMARY instance
    /// only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub writable_node: std::option::Option<crate::model::instance::Node>,

    /// Output only. List of available read-only VMs in this instance, including
    /// the standby for a PRIMARY instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nodes: std::vec::Vec<crate::model::instance::Node>,

    /// Configuration for query insights.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub query_insights_config:
        std::option::Option<crate::model::instance::QueryInsightsInstanceConfig>,

    /// Read pool instance configuration.
    /// This is required if the value of instanceType is READ_POOL.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_pool_config: std::option::Option<crate::model::instance::ReadPoolConfig>,

    /// Output only. The IP address for the Instance.
    /// This is the connection endpoint for an end-user application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Output only. The public IP addresses for the Instance. This is available
    /// ONLY when enable_public_ip is set. This is the connection endpoint for an
    /// end-user application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_ip_address: std::string::String,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Instance does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    pub reconciling: bool,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Client connection specific configurations
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_connection_config:
        std::option::Option<crate::model::instance::ClientConnectionConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. The configuration for Private Service Connect (PSC) for the
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_instance_config: std::option::Option<crate::model::instance::PscInstanceConfig>,

    /// Optional. Instance-level network configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub network_config: std::option::Option<crate::model::instance::InstanceNetworkConfig>,

    /// Output only. All outbound public IP addresses configured for the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub outbound_public_ip_addresses: std::vec::Vec<std::string::String>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Instance::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Instance::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::Instance::instance_type].
    pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [machine_config][crate::model::Instance::machine_config].
    pub fn set_machine_config<
        T: std::convert::Into<std::option::Option<crate::model::instance::MachineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.machine_config = v.into();
        self
    }

    /// Sets the value of [availability_type][crate::model::Instance::availability_type].
    pub fn set_availability_type<
        T: std::convert::Into<crate::model::instance::AvailabilityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [gce_zone][crate::model::Instance::gce_zone].
    pub fn set_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gce_zone = v.into();
        self
    }

    /// Sets the value of [writable_node][crate::model::Instance::writable_node].
    pub fn set_writable_node<
        T: std::convert::Into<std::option::Option<crate::model::instance::Node>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.writable_node = v.into();
        self
    }

    /// Sets the value of [query_insights_config][crate::model::Instance::query_insights_config].
    pub fn set_query_insights_config<
        T: std::convert::Into<
                std::option::Option<crate::model::instance::QueryInsightsInstanceConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query_insights_config = v.into();
        self
    }

    /// Sets the value of [read_pool_config][crate::model::Instance::read_pool_config].
    pub fn set_read_pool_config<
        T: std::convert::Into<std::option::Option<crate::model::instance::ReadPoolConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.read_pool_config = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::Instance::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::Instance::public_ip_address].
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Instance::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Instance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [client_connection_config][crate::model::Instance::client_connection_config].
    pub fn set_client_connection_config<
        T: std::convert::Into<std::option::Option<crate::model::instance::ClientConnectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_connection_config = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [psc_instance_config][crate::model::Instance::psc_instance_config].
    pub fn set_psc_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::instance::PscInstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.psc_instance_config = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::Instance::network_config].
    pub fn set_network_config<
        T: std::convert::Into<std::option::Option<crate::model::instance::InstanceNetworkConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network_config = v.into();
        self
    }

    /// Sets the value of [nodes][crate::model::Instance::nodes].
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::Node>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [outbound_public_ip_addresses][crate::model::Instance::outbound_public_ip_addresses].
    pub fn set_outbound_public_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.outbound_public_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [database_flags][crate::model::Instance::database_flags].
    pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Instance::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// MachineConfig describes the configuration of a machine.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MachineConfig {
        /// The number of CPU's in the VM instance.
        pub cpu_count: i32,
    }

    impl MachineConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu_count][crate::model::instance::MachineConfig::cpu_count].
        pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.cpu_count = v.into();
            self
        }
    }

    impl wkt::message::Message for MachineConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.MachineConfig"
        }
    }

    /// Details of a single node in the instance.
    /// Nodes in an AlloyDB instance are ephemereal, they can change during
    /// update, failover, autohealing and resize operations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Node {
        /// The Compute Engine zone of the VM e.g. "us-central1-b".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub zone_id: std::string::String,

        /// The identifier of the VM e.g. "test-read-0601-407e52be-ms3l".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// The private IP address of the VM e.g. "10.57.0.34".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub ip: std::string::String,

        /// Determined by state of the compute VM and postgres-service health.
        /// Compute VM state can have values listed in
        /// <https://cloud.google.com/compute/docs/instances/instance-life-cycle> and
        /// postgres-service health can have values: HEALTHY and UNHEALTHY.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub state: std::string::String,
    }

    impl Node {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [zone_id][crate::model::instance::Node::zone_id].
        pub fn set_zone_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone_id = v.into();
            self
        }

        /// Sets the value of [id][crate::model::instance::Node::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [ip][crate::model::instance::Node::ip].
        pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip = v.into();
            self
        }

        /// Sets the value of [state][crate::model::instance::Node::state].
        pub fn set_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for Node {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.Node"
        }
    }

    /// QueryInsights Instance specific configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueryInsightsInstanceConfig {
        /// Record application tags for an instance.
        /// This flag is turned "on" by default.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub record_application_tags: std::option::Option<bool>,

        /// Record client address for an instance. Client address is PII information.
        /// This flag is turned "on" by default.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub record_client_address: std::option::Option<bool>,

        /// Query string length. The default value is 1024.
        /// Any integer between 256 and 4500 is considered valid.
        pub query_string_length: u32,

        /// Number of query execution plans captured by Insights per minute
        /// for all queries combined. The default value is 5.
        /// Any integer between 0 and 20 is considered valid.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub query_plans_per_minute: std::option::Option<u32>,
    }

    impl QueryInsightsInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [record_application_tags][crate::model::instance::QueryInsightsInstanceConfig::record_application_tags].
        pub fn set_record_application_tags<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.record_application_tags = v.into();
            self
        }

        /// Sets the value of [record_client_address][crate::model::instance::QueryInsightsInstanceConfig::record_client_address].
        pub fn set_record_client_address<T: std::convert::Into<std::option::Option<bool>>>(
            mut self,
            v: T,
        ) -> Self {
            self.record_client_address = v.into();
            self
        }

        /// Sets the value of [query_string_length][crate::model::instance::QueryInsightsInstanceConfig::query_string_length].
        pub fn set_query_string_length<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
            self.query_string_length = v.into();
            self
        }

        /// Sets the value of [query_plans_per_minute][crate::model::instance::QueryInsightsInstanceConfig::query_plans_per_minute].
        pub fn set_query_plans_per_minute<T: std::convert::Into<std::option::Option<u32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.query_plans_per_minute = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryInsightsInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.QueryInsightsInstanceConfig"
        }
    }

    /// Configuration for a read pool instance.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReadPoolConfig {
        /// Read capacity, i.e. number of nodes in a read pool instance.
        pub node_count: i32,
    }

    impl ReadPoolConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node_count][crate::model::instance::ReadPoolConfig::node_count].
        pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.node_count = v.into();
            self
        }
    }

    impl wkt::message::Message for ReadPoolConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ReadPoolConfig"
        }
    }

    /// Client connection configuration
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClientConnectionConfig {
        /// Optional. Configuration to enforce connectors only (ex: AuthProxy)
        /// connections to the database.
        pub require_connectors: bool,

        /// Optional. SSL configuration option for this instance.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ssl_config: std::option::Option<crate::model::SslConfig>,
    }

    impl ClientConnectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [require_connectors][crate::model::instance::ClientConnectionConfig::require_connectors].
        pub fn set_require_connectors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.require_connectors = v.into();
            self
        }

        /// Sets the value of [ssl_config][crate::model::instance::ClientConnectionConfig::ssl_config].
        pub fn set_ssl_config<
            T: std::convert::Into<std::option::Option<crate::model::SslConfig>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ssl_config = v.into();
            self
        }
    }

    impl wkt::message::Message for ClientConnectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ClientConnectionConfig"
        }
    }

    /// PscInstanceConfig contains PSC related configuration at an
    /// instance level.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PscInstanceConfig {
        /// Output only. The service attachment created when Private
        /// Service Connect (PSC) is enabled for the instance.
        /// The name of the resource will be in the format of
        /// `projects/<alloydb-tenant-project-number>/regions/<region-name>/serviceAttachments/<service-attachment-name>`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_attachment_link: std::string::String,

        /// Optional. List of consumer projects that are allowed to create
        /// PSC endpoints to service-attachments to this instance.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allowed_consumer_projects: std::vec::Vec<std::string::String>,

        /// Output only. The DNS name of the instance for PSC connectivity.
        /// Name convention: \<uid\>.\<uid\>.\<region\>.alloydb-psc.goog
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub psc_dns_name: std::string::String,
    }

    impl PscInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_attachment_link][crate::model::instance::PscInstanceConfig::service_attachment_link].
        pub fn set_service_attachment_link<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_attachment_link = v.into();
            self
        }

        /// Sets the value of [psc_dns_name][crate::model::instance::PscInstanceConfig::psc_dns_name].
        pub fn set_psc_dns_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.psc_dns_name = v.into();
            self
        }

        /// Sets the value of [allowed_consumer_projects][crate::model::instance::PscInstanceConfig::allowed_consumer_projects].
        pub fn set_allowed_consumer_projects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_consumer_projects = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PscInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.PscInstanceConfig"
        }
    }

    /// Metadata related to instance-level network configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceNetworkConfig {
        /// Optional. A list of external network authorized to access this instance.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub authorized_external_networks:
            std::vec::Vec<crate::model::instance::instance_network_config::AuthorizedNetwork>,

        /// Optional. Enabling public ip for the instance.
        pub enable_public_ip: bool,

        /// Optional. Enabling an outbound public IP address to support a database
        /// server sending requests out into the internet.
        pub enable_outbound_public_ip: bool,
    }

    impl InstanceNetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_public_ip][crate::model::instance::InstanceNetworkConfig::enable_public_ip].
        pub fn set_enable_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_public_ip = v.into();
            self
        }

        /// Sets the value of [enable_outbound_public_ip][crate::model::instance::InstanceNetworkConfig::enable_outbound_public_ip].
        pub fn set_enable_outbound_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_outbound_public_ip = v.into();
            self
        }

        /// Sets the value of [authorized_external_networks][crate::model::instance::InstanceNetworkConfig::authorized_external_networks].
        pub fn set_authorized_external_networks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::instance::instance_network_config::AuthorizedNetwork,
                >,
        {
            use std::iter::Iterator;
            self.authorized_external_networks = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for InstanceNetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.InstanceNetworkConfig"
        }
    }

    /// Defines additional types related to [InstanceNetworkConfig].
    pub mod instance_network_config {
        #[allow(unused_imports)]
        use super::*;

        /// AuthorizedNetwork contains metadata for an authorized network.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct AuthorizedNetwork {
            /// CIDR range for one authorzied network of the instance.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub cidr_range: std::string::String,
        }

        impl AuthorizedNetwork {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cidr_range][crate::model::instance::instance_network_config::AuthorizedNetwork::cidr_range].
            pub fn set_cidr_range<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.cidr_range = v.into();
                self
            }
        }

        impl wkt::message::Message for AuthorizedNetwork {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.alloydb.v1.Instance.InstanceNetworkConfig.AuthorizedNetwork"
            }
        }
    }

    /// Instance State
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The state of the instance is unknown.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The instance is active and running.
        pub const READY: State = State::new(1);

        /// The instance is stopped. Instance name and IP resources are preserved.
        pub const STOPPED: State = State::new(2);

        /// The instance is being created.
        pub const CREATING: State = State::new(3);

        /// The instance is being deleted.
        pub const DELETING: State = State::new(4);

        /// The instance is down for maintenance.
        pub const MAINTENANCE: State = State::new(5);

        /// The creation of the instance failed or a fatal error occurred during
        /// an operation on the instance.
        /// Note: Instances in this state would tried to be auto-repaired. And
        /// Customers should be able to restart, update or delete these instances.
        pub const FAILED: State = State::new(6);

        /// Index 7 is used in the producer apis for ROLLED_BACK state. Keeping that
        /// index unused in case that state also needs to exposed via consumer apis
        /// in future.
        /// The instance has been configured to sync data from some other source.
        pub const BOOTSTRAPPING: State = State::new(8);

        /// The instance is being promoted.
        pub const PROMOTING: State = State::new(9);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("READY"),
                2 => std::borrow::Cow::Borrowed("STOPPED"),
                3 => std::borrow::Cow::Borrowed("CREATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                5 => std::borrow::Cow::Borrowed("MAINTENANCE"),
                6 => std::borrow::Cow::Borrowed("FAILED"),
                8 => std::borrow::Cow::Borrowed("BOOTSTRAPPING"),
                9 => std::borrow::Cow::Borrowed("PROMOTING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "READY" => std::option::Option::Some(Self::READY),
                "STOPPED" => std::option::Option::Some(Self::STOPPED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "MAINTENANCE" => std::option::Option::Some(Self::MAINTENANCE),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "BOOTSTRAPPING" => std::option::Option::Some(Self::BOOTSTRAPPING),
                "PROMOTING" => std::option::Option::Some(Self::PROMOTING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Type of an Instance
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct InstanceType(i32);

    impl InstanceType {
        /// The type of the instance is unknown.
        pub const INSTANCE_TYPE_UNSPECIFIED: InstanceType = InstanceType::new(0);

        /// PRIMARY instances support read and write operations.
        pub const PRIMARY: InstanceType = InstanceType::new(1);

        /// READ POOL instances support read operations only. Each read pool instance
        /// consists of one or more homogeneous nodes.
        ///
        /// * Read pool of size 1 can only have zonal availability.
        /// * Read pools with node count of 2 or more can have regional
        ///   availability (nodes are present in 2 or more zones in a region).
        pub const READ_POOL: InstanceType = InstanceType::new(2);

        /// SECONDARY instances support read operations only. SECONDARY instance
        /// is a cross-region read replica
        pub const SECONDARY: InstanceType = InstanceType::new(3);

        /// Creates a new InstanceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("INSTANCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PRIMARY"),
                2 => std::borrow::Cow::Borrowed("READ_POOL"),
                3 => std::borrow::Cow::Borrowed("SECONDARY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "INSTANCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::INSTANCE_TYPE_UNSPECIFIED)
                }
                "PRIMARY" => std::option::Option::Some(Self::PRIMARY),
                "READ_POOL" => std::option::Option::Some(Self::READ_POOL),
                "SECONDARY" => std::option::Option::Some(Self::SECONDARY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The Availability type of an instance. Potential values:
    ///
    /// - ZONAL: The instance serves data from only one zone. Outages in that
    ///   zone affect instance availability.
    /// - REGIONAL: The instance can serve data from more than one zone in a
    ///   region (it is highly available).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AvailabilityType(i32);

    impl AvailabilityType {
        /// This is an unknown Availability type.
        pub const AVAILABILITY_TYPE_UNSPECIFIED: AvailabilityType = AvailabilityType::new(0);

        /// Zonal available instance.
        pub const ZONAL: AvailabilityType = AvailabilityType::new(1);

        /// Regional (or Highly) available instance.
        pub const REGIONAL: AvailabilityType = AvailabilityType::new(2);

        /// Creates a new AvailabilityType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("AVAILABILITY_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ZONAL"),
                2 => std::borrow::Cow::Borrowed("REGIONAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "AVAILABILITY_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::AVAILABILITY_TYPE_UNSPECIFIED)
                }
                "ZONAL" => std::option::Option::Some(Self::ZONAL),
                "REGIONAL" => std::option::Option::Some(Self::REGIONAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AvailabilityType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AvailabilityType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// ConnectionInfo singleton resource.
/// <https://google.aip.dev/156>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionInfo {
    /// The name of the ConnectionInfo singleton resource, e.g.:
    /// projects/{project}/locations/{location}/clusters/*/instances/*/connectionInfo
    /// This field currently has no semantic meaning.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The private network IP address for the Instance. This is the
    /// default IP for the instance and is always created (even if enable_public_ip
    /// is set). This is the connection endpoint for an end-user application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ip_address: std::string::String,

    /// Output only. The public IP addresses for the Instance. This is available
    /// ONLY when enable_public_ip is set. This is the connection endpoint for an
    /// end-user application.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_ip_address: std::string::String,

    /// Output only. The unique ID of the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_uid: std::string::String,
}

impl ConnectionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::ConnectionInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::ConnectionInfo::public_ip_address].
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [instance_uid][crate::model::ConnectionInfo::instance_uid].
    pub fn set_instance_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uid = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ConnectionInfo"
    }
}

/// Message describing Backup object
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The name of the backup resource with the format:
    ///
    /// * projects/{project}/locations/{region}/backups/{backup_id}
    ///   where the cluster and backup ID segments should satisfy the regex
    ///   expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
    ///   lowercase letters, numbers, and dashes, starting with a letter, and ending
    ///   with a letter or number. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the backup resource name is the name of the parent
    ///   resource:
    /// * projects/{project}/locations/{region}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Create time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,

    /// The backup type, which suggests the trigger for the backup.
    #[serde(rename = "type")]
    pub r#type: crate::model::backup::Type,

    /// User-provided description of the backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The system-generated UID of the cluster which was used to
    /// create this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uid: std::string::String,

    /// Required. The full resource name of the backup source cluster
    /// (e.g., projects/{project}/locations/{region}/clusters/{cluster_id}).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>), if
    /// true, indicates that the service is actively updating the resource. This
    /// can happen due to user-triggered updates or system actions like failover or
    /// maintenance.
    pub reconciling: bool,

    /// Optional. The encryption config can be specified to encrypt the
    /// backup with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will then use default encryption scheme to
    /// protect the user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Output only. The encryption information for the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The size of the backup in bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_bytes: i64,

    /// Output only. The time at which after the backup is eligible to be garbage
    /// collected. It is the duration specified by the backup's retention policy,
    /// added to the backup's create_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiry_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The QuantityBasedExpiry of the backup, specified by the
    /// backup's retention policy. Once the expiry quantity is over retention, the
    /// backup is eligible to be garbage collected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiry_quantity: std::option::Option<crate::model::backup::QuantityBasedExpiry>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. The database engine major version of the cluster this backup
    /// was created from. Any restored cluster created from this backup will have
    /// the same database version.
    pub database_version: crate::model::DatabaseVersion,

    /// Optional. Input only. Immutable. Tag keys/values directly bound to this
    /// resource. For example:
    ///
    /// ```norust
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    /// ```
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Backup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Backup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Backup::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Backup::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Backup::type].
    pub fn set_type<T: std::convert::Into<crate::model::backup::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [cluster_uid][crate::model::Backup::cluster_uid].
    pub fn set_cluster_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uid = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::Backup::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Backup::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::Backup::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_encryption_info<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_info = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Backup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Backup::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [expiry_time][crate::model::Backup::expiry_time].
    pub fn set_expiry_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiry_time = v.into();
        self
    }

    /// Sets the value of [expiry_quantity][crate::model::Backup::expiry_quantity].
    pub fn set_expiry_quantity<
        T: std::convert::Into<std::option::Option<crate::model::backup::QuantityBasedExpiry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiry_quantity = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::Backup::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Backup::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Backup::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Backup"
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// A backup's position in a quantity-based retention queue, of backups with
    /// the same source cluster and type, with length, retention, specified by the
    /// backup's retention policy.
    /// Once the position is greater than the retention, the backup is eligible to
    /// be garbage collected.
    ///
    /// Example: 5 backups from the same source cluster and type with a
    /// quantity-based retention of 3 and denoted by backup_id (position,
    /// retention).
    ///
    /// Safe: backup_5 (1, 3), backup_4, (2, 3), backup_3 (3, 3).
    /// Awaiting garbage collection: backup_2 (4, 3), backup_1 (5, 3)
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QuantityBasedExpiry {
        /// Output only. The backup's position among its backups with the same source
        /// cluster and type, by descending chronological order create time(i.e.
        /// newest first).
        pub retention_count: i32,

        /// Output only. The length of the quantity-based queue, specified by the
        /// backup's retention policy.
        pub total_retention_count: i32,
    }

    impl QuantityBasedExpiry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_count][crate::model::backup::QuantityBasedExpiry::retention_count].
        pub fn set_retention_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.retention_count = v.into();
            self
        }

        /// Sets the value of [total_retention_count][crate::model::backup::QuantityBasedExpiry::total_retention_count].
        pub fn set_total_retention_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_retention_count = v.into();
            self
        }
    }

    impl wkt::message::Message for QuantityBasedExpiry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Backup.QuantityBasedExpiry"
        }
    }

    /// Backup State
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The state of the backup is unknown.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The backup is ready.
        pub const READY: State = State::new(1);

        /// The backup is creating.
        pub const CREATING: State = State::new(2);

        /// The backup failed.
        pub const FAILED: State = State::new(3);

        /// The backup is being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("READY"),
                2 => std::borrow::Cow::Borrowed("CREATING"),
                3 => std::borrow::Cow::Borrowed("FAILED"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "READY" => std::option::Option::Some(Self::READY),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Backup Type
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Backup Type is unknown.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// ON_DEMAND backups that were triggered by the customer (e.g., not
        /// AUTOMATED).
        pub const ON_DEMAND: Type = Type::new(1);

        /// AUTOMATED backups triggered by the automated backups scheduler pursuant
        /// to an automated backup policy.
        pub const AUTOMATED: Type = Type::new(2);

        /// CONTINUOUS backups triggered by the automated backups scheduler
        /// due to a continuous backup policy.
        pub const CONTINUOUS: Type = Type::new(3);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ON_DEMAND"),
                2 => std::borrow::Cow::Borrowed("AUTOMATED"),
                3 => std::borrow::Cow::Borrowed("CONTINUOUS"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "ON_DEMAND" => std::option::Option::Some(Self::ON_DEMAND),
                "AUTOMATED" => std::option::Option::Some(Self::AUTOMATED),
                "CONTINUOUS" => std::option::Option::Some(Self::CONTINUOUS),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// SupportedDatabaseFlag gives general information about a database flag,
/// like type and allowed values. This is a static value that is defined
/// on the server side, and it cannot be modified by callers.
/// To set the Database flags on a particular Instance, a caller should modify
/// the Instance.database_flags field.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SupportedDatabaseFlag {
    /// The name of the flag resource, following Google Cloud conventions, e.g.:
    ///
    /// * projects/{project}/locations/{location}/flags/{flag}
    ///   This field currently has no semantic meaning.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the database flag, e.g. "max_allowed_packets".
    /// The is a possibly key for the Instance.database_flags map field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub flag_name: std::string::String,

    pub value_type: crate::model::supported_database_flag::ValueType,

    /// Whether the database flag accepts multiple values. If true,
    /// a comma-separated list of stringified values may be specified.
    pub accepts_multiple_values: bool,

    /// Major database engine versions for which this flag is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_db_versions: std::vec::Vec<crate::model::DatabaseVersion>,

    /// Whether setting or updating this flag on an Instance requires a database
    /// restart. If a flag that requires database restart is set, the backend
    /// will automatically restart the database (making sure to satisfy any
    /// availability SLO's).
    pub requires_db_restart: bool,

    /// The restrictions on the flag value per type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub restrictions: std::option::Option<crate::model::supported_database_flag::Restrictions>,
}

impl SupportedDatabaseFlag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SupportedDatabaseFlag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [flag_name][crate::model::SupportedDatabaseFlag::flag_name].
    pub fn set_flag_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flag_name = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::SupportedDatabaseFlag::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::supported_database_flag::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [accepts_multiple_values][crate::model::SupportedDatabaseFlag::accepts_multiple_values].
    pub fn set_accepts_multiple_values<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.accepts_multiple_values = v.into();
        self
    }

    /// Sets the value of [requires_db_restart][crate::model::SupportedDatabaseFlag::requires_db_restart].
    pub fn set_requires_db_restart<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requires_db_restart = v.into();
        self
    }

    /// Sets the value of [supported_db_versions][crate::model::SupportedDatabaseFlag::supported_db_versions].
    pub fn set_supported_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseVersion>,
    {
        use std::iter::Iterator;
        self.supported_db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `restrictions`.
    pub fn set_restrictions<
        T: std::convert::Into<
                std::option::Option<crate::model::supported_database_flag::Restrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = v.into();
        self
    }

    /// The value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// if it holds a `StringRestrictions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_restrictions(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
    > {
        #[allow(unreachable_patterns)]
        self.restrictions.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::Restrictions::StringRestrictions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// if it holds a `IntegerRestrictions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_integer_restrictions(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
    > {
        #[allow(unreachable_patterns)]
        self.restrictions.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::Restrictions::IntegerRestrictions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// to hold a `StringRestrictions`.
    ///
    /// Note that all the setters affecting `restrictions` are
    /// mutually exclusive.
    pub fn set_string_restrictions<
        T: std::convert::Into<
                std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = std::option::Option::Some(
            crate::model::supported_database_flag::Restrictions::StringRestrictions(v.into()),
        );
        self
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// to hold a `IntegerRestrictions`.
    ///
    /// Note that all the setters affecting `restrictions` are
    /// mutually exclusive.
    pub fn set_integer_restrictions<
        T: std::convert::Into<
                std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = std::option::Option::Some(
            crate::model::supported_database_flag::Restrictions::IntegerRestrictions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SupportedDatabaseFlag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag"
    }
}

/// Defines additional types related to [SupportedDatabaseFlag].
pub mod supported_database_flag {
    #[allow(unused_imports)]
    use super::*;

    /// Restrictions on STRING type values
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StringRestrictions {
        /// The list of allowed values, if bounded. This field will be empty
        /// if there is a unbounded number of allowed values.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allowed_values: std::vec::Vec<std::string::String>,
    }

    impl StringRestrictions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_values][crate::model::supported_database_flag::StringRestrictions::allowed_values].
        pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StringRestrictions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag.StringRestrictions"
        }
    }

    /// Restrictions on INTEGER type values.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IntegerRestrictions {
        /// The minimum value that can be specified, if applicable.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub min_value: std::option::Option<wkt::Int64Value>,

        /// The maximum value that can be specified, if applicable.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
        pub max_value: std::option::Option<wkt::Int64Value>,
    }

    impl IntegerRestrictions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::supported_database_flag::IntegerRestrictions::min_value].
        pub fn set_min_value<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_value = v.into();
            self
        }

        /// Sets the value of [max_value][crate::model::supported_database_flag::IntegerRestrictions::max_value].
        pub fn set_max_value<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_value = v.into();
            self
        }
    }

    impl wkt::message::Message for IntegerRestrictions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag.IntegerRestrictions"
        }
    }

    /// ValueType describes the semantic type of the value that the flag accepts.
    /// Regardless of the ValueType, the Instance.database_flags field accepts the
    /// stringified version of the value, i.e. "20" or "3.14".
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ValueType(i32);

    impl ValueType {
        /// This is an unknown flag type.
        pub const VALUE_TYPE_UNSPECIFIED: ValueType = ValueType::new(0);

        /// String type flag.
        pub const STRING: ValueType = ValueType::new(1);

        /// Integer type flag.
        pub const INTEGER: ValueType = ValueType::new(2);

        /// Float type flag.
        pub const FLOAT: ValueType = ValueType::new(3);

        /// Denotes that the flag does not accept any values.
        pub const NONE: ValueType = ValueType::new(4);

        /// Creates a new ValueType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("VALUE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STRING"),
                2 => std::borrow::Cow::Borrowed("INTEGER"),
                3 => std::borrow::Cow::Borrowed("FLOAT"),
                4 => std::borrow::Cow::Borrowed("NONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "VALUE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::VALUE_TYPE_UNSPECIFIED),
                "STRING" => std::option::Option::Some(Self::STRING),
                "INTEGER" => std::option::Option::Some(Self::INTEGER),
                "FLOAT" => std::option::Option::Some(Self::FLOAT),
                "NONE" => std::option::Option::Some(Self::NONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ValueType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The restrictions on the flag value per type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Restrictions {
        /// Restriction on STRING type value.
        StringRestrictions(
            std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
        ),
        /// Restriction on INTEGER type value.
        IntegerRestrictions(
            std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
        ),
    }
}

/// Message describing User object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct User {
    /// Output only. Name of the resource in the form of
    /// projects/{project}/locations/{location}/cluster/{cluster}/users/{user}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Input only. Password for the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Optional. List of database roles this user has.
    /// The database role strings are subject to the PostgreSQL naming conventions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_roles: std::vec::Vec<std::string::String>,

    /// Optional. Type of this user.
    pub user_type: crate::model::user::UserType,

    /// Input only. If the user already exists and it has additional roles, keep
    /// them granted.
    pub keep_extra_roles: bool,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [password][crate::model::User::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [user_type][crate::model::User::user_type].
    pub fn set_user_type<T: std::convert::Into<crate::model::user::UserType>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_type = v.into();
        self
    }

    /// Sets the value of [keep_extra_roles][crate::model::User::keep_extra_roles].
    pub fn set_keep_extra_roles<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.keep_extra_roles = v.into();
        self
    }

    /// Sets the value of [database_roles][crate::model::User::database_roles].
    pub fn set_database_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_roles = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.User"
    }
}

/// Defines additional types related to [User].
pub mod user {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that details the user type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct UserType(i32);

    impl UserType {
        /// Unspecified user type.
        pub const USER_TYPE_UNSPECIFIED: UserType = UserType::new(0);

        /// The default user type that authenticates via password-based
        /// authentication.
        pub const ALLOYDB_BUILT_IN: UserType = UserType::new(1);

        /// Database user that can authenticate via IAM-Based authentication.
        pub const ALLOYDB_IAM_USER: UserType = UserType::new(2);

        /// Creates a new UserType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("USER_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ALLOYDB_BUILT_IN"),
                2 => std::borrow::Cow::Borrowed("ALLOYDB_IAM_USER"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "USER_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::USER_TYPE_UNSPECIFIED),
                "ALLOYDB_BUILT_IN" => std::option::Option::Some(Self::ALLOYDB_BUILT_IN),
                "ALLOYDB_IAM_USER" => std::option::Option::Some(Self::ALLOYDB_IAM_USER),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for UserType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for UserType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message describing Database object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Database {
    /// Identifier. Name of the resource in the form of
    /// `projects/{project}/locations/{location}/clusters/{cluster}/databases/{database}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Charset for the database.
    /// This field can contain any PostgreSQL supported charset name.
    /// Example values include "UTF8", "SQL_ASCII", etc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub charset: std::string::String,

    /// Optional. Collation for the database.
    /// Name of the custom or native collation for postgres.
    /// Example values include "C", "POSIX", etc
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::Database::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Database::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Database"
    }
}

/// Message for requesting list of Clusters
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Cluster.name field. Additionally, you can perform an
    /// aggregated list operation by specifying a value with the following format:
    ///
    /// * projects/{project}/locations/-
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListClustersRequest"
    }
}

/// Message for response to listing Clusters
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// The list of Cluster
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The view of the cluster to return. Returns all default fields if
    /// not set.
    pub view: crate::model::ClusterView,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetClusterRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ClusterView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetClusterRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSecondaryClusterRequest {
    /// Required. The location of the new cluster. For the required
    /// format, see the comment on the Cluster.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object (the secondary cluster).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. Configuration of the requesting object (the secondary cluster).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl CreateSecondaryClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecondaryClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateSecondaryClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateSecondaryClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSecondaryClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateSecondaryClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateSecondaryClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateSecondaryClusterRequest"
    }
}

/// Message for creating a Cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The location of the new cluster. For the required format, see the
    /// comment on the Cluster.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateClusterRequest"
    }
}

/// Message for updating a Cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Cluster resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if cluster is not found. In
    /// that case, a new cluster is created and `update_mask` is ignored.
    pub allow_missing: bool,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateClusterRequest"
    }
}

/// Message for deleting a Cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. Whether to cascade delete child instances for given cluster.
    pub force: bool,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteClusterRequest"
    }
}

/// Message for switching over to a cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SwitchoverClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl SwitchoverClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SwitchoverClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::SwitchoverClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::SwitchoverClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for SwitchoverClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SwitchoverClusterRequest"
    }
}

/// Message for promoting a Cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PromoteClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl PromoteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PromoteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::PromoteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::PromoteClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::PromoteClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for PromoteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.PromoteClusterRequest"
    }
}

/// Message for restoring a Cluster from a backup or another cluster at a given
/// point in time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreClusterRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Cluster.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Required.
    /// The source to import from.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::restore_cluster_request::Source>,
}

impl RestoreClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::RestoreClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::RestoreClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RestoreClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RestoreClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_cluster_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreClusterRequest::source]
    /// if it holds a `BackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_cluster_request::Source::BackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source][crate::model::RestoreClusterRequest::source]
    /// if it holds a `ContinuousBackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_continuous_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ContinuousBackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_cluster_request::Source::ContinuousBackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
    /// to hold a `BackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_backup_source<T: std::convert::Into<std::boxed::Box<crate::model::BackupSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_cluster_request::Source::BackupSource(v.into()),
        );
        self
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
    /// to hold a `ContinuousBackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_continuous_backup_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ContinuousBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_cluster_request::Source::ContinuousBackupSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestoreClusterRequest"
    }
}

/// Defines additional types related to [RestoreClusterRequest].
pub mod restore_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required.
    /// The source to import from.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Backup source.
        BackupSource(std::boxed::Box<crate::model::BackupSource>),
        /// ContinuousBackup source. Continuous backup needs to be enabled in the
        /// source cluster for this operation to succeed.
        ContinuousBackupSource(std::boxed::Box<crate::model::ContinuousBackupSource>),
    }
}

/// Message for requesting list of Instances
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field. Additionally, you can perform an
    /// aggregated list operation by specifying a value with one of the following
    /// formats:
    ///
    /// * projects/{project}/locations/-/clusters/-
    /// * projects/{project}/locations/{region}/clusters/-
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListInstancesRequest"
    }
}

/// Message for response to listing Instances
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of Instance
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The view of the instance to return.
    pub view: crate::model::InstanceView,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetInstanceRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::InstanceView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetInstanceRequest"
    }
}

/// Message for creating a Instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateInstanceRequest"
    }
}

/// Message for creating a Secondary Instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSecondaryInstanceRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl CreateSecondaryInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecondaryInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateSecondaryInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateSecondaryInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSecondaryInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateSecondaryInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateSecondaryInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateSecondaryInstanceRequest"
    }
}

/// See usage below for notes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequests {
    /// Required. Primary and read replica instances to be created. This list
    /// should not be empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub create_instance_requests: std::vec::Vec<crate::model::CreateInstanceRequest>,
}

impl CreateInstanceRequests {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_instance_requests][crate::model::CreateInstanceRequests::create_instance_requests].
    pub fn set_create_instance_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateInstanceRequest>,
    {
        use std::iter::Iterator;
        self.create_instance_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequests {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateInstanceRequests"
    }
}

/// Message for creating a batch of instances under the specified cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateInstancesRequest {
    /// Required. The name of the parent resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Resources being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requests: std::option::Option<crate::model::CreateInstanceRequests>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl BatchCreateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateInstancesRequest::requests].
    pub fn set_requests<
        T: std::convert::Into<std::option::Option<crate::model::CreateInstanceRequests>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requests = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::BatchCreateInstancesRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesRequest"
    }
}

/// Message for creating batches of instances in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateInstancesResponse {
    /// Created instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,
}

impl BatchCreateInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::BatchCreateInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesResponse"
    }
}

/// Message for metadata that is specific to BatchCreateInstances API.
/// NEXT_ID: 3
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateInstancesMetadata {
    /// The instances being created in the API call. Each string in this list
    /// is the server defined resource path for target instances in the request
    /// and for the format of each string, see the comment on the Instance.name
    /// field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_targets: std::vec::Vec<std::string::String>,

    /// A map representing state of the instances involved in the
    /// BatchCreateInstances operation during the operation execution.
    /// The instance state will be in STATE_UNSPECIFIED state if the instance has
    /// not yet been picked up for processing.
    /// The key of the map is the name of the instance resource.
    /// For the format, see the comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub instance_statuses:
        std::collections::HashMap<std::string::String, crate::model::BatchCreateInstanceStatus>,
}

impl BatchCreateInstancesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_targets][crate::model::BatchCreateInstancesMetadata::instance_targets].
    pub fn set_instance_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_statuses][crate::model::BatchCreateInstancesMetadata::instance_statuses].
    pub fn set_instance_statuses<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BatchCreateInstanceStatus>,
    {
        use std::iter::Iterator;
        self.instance_statuses = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesMetadata"
    }
}

/// Message for current status of an instance in the BatchCreateInstances
/// operation.
/// For example, lets say a BatchCreateInstances workflow has 4 instances,
/// Instance1 through Instance4. Lets also assume that 2 instances succeeded
/// but the third failed to create and the 4th was never picked up for creation
/// because of failure of the previous one. Then, resulting states would look
/// something like:
///
/// . Instance1 = ROLLED_BACK
/// . Instance2 = ROLLED_BACK
/// . Instance3 = FAILED
/// . Instance4 = FAILED
///
/// However, while the operation is running, the instance might be in other
/// states including PENDING_CREATE, ACTIVE, DELETING and CREATING. The states
/// / do not get further updated once the operation is done.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchCreateInstanceStatus {
    /// The current state of an instance involved in the batch create operation.
    /// Once the operation is complete, the final state of the instances in the
    /// LRO can be one of:
    ///
    /// . ACTIVE, indicating that instances were created successfully
    /// . FAILED, indicating that a particular instance failed creation
    /// . ROLLED_BACK indicating that although the instance was created
    ///   successfully, it had to be rolled back and deleted due to failure in
    ///   other steps of the workflow.
    pub state: crate::model::batch_create_instance_status::State,

    /// DEPRECATED - Use the error field instead.
    /// Error, if any error occurred and is available, during instance creation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_msg: std::string::String,

    /// The RPC status of the instance creation operation. This field will be
    /// present if an error happened during the instance creation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    #[serde(rename = "type")]
    pub r#type: crate::model::instance::InstanceType,
}

impl BatchCreateInstanceStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchCreateInstanceStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_create_instance_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_msg][crate::model::BatchCreateInstanceStatus::error_msg].
    pub fn set_error_msg<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_msg = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BatchCreateInstanceStatus::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::BatchCreateInstanceStatus::type].
    pub fn set_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for BatchCreateInstanceStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstanceStatus"
    }
}

/// Defines additional types related to [BatchCreateInstanceStatus].
pub mod batch_create_instance_status {
    #[allow(unused_imports)]
    use super::*;

    /// State contains all valid instance states for the BatchCreateInstances
    /// operation. This is mainly used for status reporting through the LRO
    /// metadata.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The state of the instance is unknown.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Instance is pending creation and has not yet been picked up for
        /// processing in the backend.
        pub const PENDING_CREATE: State = State::new(1);

        /// The instance is active and running.
        pub const READY: State = State::new(2);

        /// The instance is being created.
        pub const CREATING: State = State::new(3);

        /// The instance is being deleted.
        pub const DELETING: State = State::new(4);

        /// The creation of the instance failed or a fatal error occurred during
        /// an operation on the instance or a batch of instances.
        pub const FAILED: State = State::new(5);

        /// The instance was created successfully, but was rolled back and deleted
        /// due to some other failure during BatchCreateInstances operation.
        pub const ROLLED_BACK: State = State::new(6);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PENDING_CREATE"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("CREATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                5 => std::borrow::Cow::Borrowed("FAILED"),
                6 => std::borrow::Cow::Borrowed("ROLLED_BACK"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "PENDING_CREATE" => std::option::Option::Some(Self::PENDING_CREATE),
                "READY" => std::option::Option::Some(Self::READY),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "ROLLED_BACK" => std::option::Option::Some(Self::ROLLED_BACK),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for updating a Instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Instance resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if instance is not found. In
    /// that case, a new instance is created and `update_mask` is ignored.
    pub allow_missing: bool,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateInstanceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateInstanceRequest"
    }
}

/// Message for deleting a Instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. The current etag of the Instance.
    /// If an etag is provided and does not match the current etag of the Instance,
    /// deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstanceRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteInstanceRequest"
    }
}

/// Message for triggering failover on an Instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FailoverInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl FailoverInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FailoverInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::FailoverInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::FailoverInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for FailoverInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.FailoverInstanceRequest"
    }
}

/// Message for triggering fault injection on an instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InjectFaultRequest {
    /// Required. The type of fault to be injected in an instance.
    pub fault_type: crate::model::inject_fault_request::FaultType,

    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,
}

impl InjectFaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fault_type][crate::model::InjectFaultRequest::fault_type].
    pub fn set_fault_type<T: std::convert::Into<crate::model::inject_fault_request::FaultType>>(
        mut self,
        v: T,
    ) -> Self {
        self.fault_type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::InjectFaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InjectFaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::InjectFaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for InjectFaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.InjectFaultRequest"
    }
}

/// Defines additional types related to [InjectFaultRequest].
pub mod inject_fault_request {
    #[allow(unused_imports)]
    use super::*;

    /// FaultType contains all valid types of faults that can be injected to an
    /// instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct FaultType(i32);

    impl FaultType {
        /// The fault type is unknown.
        pub const FAULT_TYPE_UNSPECIFIED: FaultType = FaultType::new(0);

        /// Stop the VM
        pub const STOP_VM: FaultType = FaultType::new(1);

        /// Creates a new FaultType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("FAULT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STOP_VM"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "FAULT_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::FAULT_TYPE_UNSPECIFIED),
                "STOP_VM" => std::option::Option::Some(Self::STOP_VM),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for FaultType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for FaultType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestartInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. Full name of the nodes as obtained from INSTANCE_VIEW_FULL to
    /// restart upon. Applicable only to read instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_ids: std::vec::Vec<std::string::String>,
}

impl RestartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RestartInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RestartInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [node_ids][crate::model::RestartInstanceRequest::node_ids].
    pub fn set_node_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.node_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RestartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestartInstanceRequest"
    }
}

/// Request for ExecuteSql rpc.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecuteSqlRequest {
    /// Required. The instance where the SQL will be executed. For the required
    /// format, see the comment on the Instance.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance: std::string::String,

    /// Required. Name of the database where the query will be executed.
    /// Note - Value provided should be the same as expected from `SELECT
    /// current_database();` and NOT as a resource reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database: std::string::String,

    /// Required. Database user to be used for executing the SQL.
    /// Note - Value provided should be the same as expected from
    /// `SELECT current_user;` and NOT as a resource reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// Required. SQL statement to execute on database. Any valid statement is
    /// permitted, including DDL, DML, DQL statements.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_statement: std::string::String,

    /// Oneof field to support other credential mechanisms in future like
    /// SecretManager etc.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub user_credential: std::option::Option<crate::model::execute_sql_request::UserCredential>,
}

impl ExecuteSqlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::ExecuteSqlRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ExecuteSqlRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [user][crate::model::ExecuteSqlRequest::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [sql_statement][crate::model::ExecuteSqlRequest::sql_statement].
    pub fn set_sql_statement<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_statement = v.into();
        self
    }

    /// Sets the value of `user_credential`.
    pub fn set_user_credential<
        T: std::convert::Into<std::option::Option<crate::model::execute_sql_request::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_credential = v.into();
        self
    }

    /// The value of [user_credential][crate::model::ExecuteSqlRequest::user_credential]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.user_credential.as_ref().and_then(|v| match v {
            crate::model::execute_sql_request::UserCredential::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_credential][crate::model::ExecuteSqlRequest::user_credential]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `user_credential` are
    /// mutually exclusive.
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_credential = std::option::Option::Some(
            crate::model::execute_sql_request::UserCredential::Password(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecuteSqlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlRequest"
    }
}

/// Defines additional types related to [ExecuteSqlRequest].
pub mod execute_sql_request {
    #[allow(unused_imports)]
    use super::*;

    /// Oneof field to support other credential mechanisms in future like
    /// SecretManager etc.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum UserCredential {
        /// Optional. The database native user’s password.
        Password(std::string::String),
    }
}

/// Execute a SQL statement response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecuteSqlResponse {
    /// SqlResult represents the results for the execution of sql statements.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sql_results: std::vec::Vec<crate::model::SqlResult>,

    /// Any additional metadata information regarding the execution of the sql
    /// statement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::ExecuteSqlMetadata>,
}

impl ExecuteSqlResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata][crate::model::ExecuteSqlResponse::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::ExecuteSqlMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [sql_results][crate::model::ExecuteSqlResponse::sql_results].
    pub fn set_sql_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResult>,
    {
        use std::iter::Iterator;
        self.sql_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ExecuteSqlResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlResponse"
    }
}

/// Any additional metadata information regarding the execution of the SQL
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecuteSqlMetadata {
    /// Message related to SQL execution. Marked as core content since it
    /// can potentially contain details related to the query or result set. This
    /// field can be used to convey messages such as "when the SQL result set
    /// exceeds the acceptable response size limits."
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Set to true if SQL returned a result set larger than the acceptable
    /// response size limits and the result was truncated.
    pub partial_result: bool,

    /// The time duration taken to execute the sql statement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sql_statement_execution_duration: std::option::Option<wkt::Duration>,

    /// Status of SQL execution.
    pub status: crate::model::execute_sql_metadata::Status,
}

impl ExecuteSqlMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ExecuteSqlMetadata::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [partial_result][crate::model::ExecuteSqlMetadata::partial_result].
    pub fn set_partial_result<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partial_result = v.into();
        self
    }

    /// Sets the value of [sql_statement_execution_duration][crate::model::ExecuteSqlMetadata::sql_statement_execution_duration].
    pub fn set_sql_statement_execution_duration<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.sql_statement_execution_duration = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ExecuteSqlMetadata::status].
    pub fn set_status<T: std::convert::Into<crate::model::execute_sql_metadata::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ExecuteSqlMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlMetadata"
    }
}

/// Defines additional types related to [ExecuteSqlMetadata].
pub mod execute_sql_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Status contains all valid Status a SQL execution can end up in.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Status(i32);

    impl Status {
        /// The status is unknown.
        pub const STATUS_UNSPECIFIED: Status = Status::new(0);

        /// No error during SQL execution i.e. All SQL statements ran to completion.
        /// The "message" will be empty.
        pub const OK: Status = Status::new(1);

        /// Same as OK, except indicates that only partial results were
        /// returned. The "message" field will contain details on why results were
        /// truncated.
        pub const PARTIAL: Status = Status::new(2);

        /// Error during SQL execution. Atleast 1 SQL statement execution resulted in
        /// a error. Side effects of other statements are rolled back.  The "message"
        /// field will contain human readable error given by Postgres of the first
        /// bad SQL statement. SQL execution errors don't constitute API errors as
        /// defined in <https://google.aip.dev/193> but will be returned as part of
        /// this message.
        pub const ERROR: Status = Status::new(3);

        /// Creates a new Status instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATUS_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("OK"),
                2 => std::borrow::Cow::Borrowed("PARTIAL"),
                3 => std::borrow::Cow::Borrowed("ERROR"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATUS_UNSPECIFIED" => std::option::Option::Some(Self::STATUS_UNSPECIFIED),
                "OK" => std::option::Option::Some(Self::OK),
                "PARTIAL" => std::option::Option::Some(Self::PARTIAL),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message for requesting list of Backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. Parent value for ListBackupsRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListBackupsRequest"
    }
}

/// Message for response to listing Backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of Backup
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetBackupRequest"
    }
}

/// Message for creating a Backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateBackupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateBackupRequest"
    }
}

/// Message for updating a Backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if instance is not found. In
    /// that case, a new backup is created and `update_mask` is ignored.
    pub allow_missing: bool,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateBackupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateBackupRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateBackupRequest"
    }
}

/// Message for deleting a Backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the resource. For the required format, see the comment on
    /// the Backup.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. The current etag of the Backup.
    /// If an etag is provided and does not match the current etag of the Backup,
    /// deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteBackupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteBackupRequest"
    }
}

/// Message for listing the information about the supported Database flags.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSupportedDatabaseFlagsRequest {
    /// Required. The name of the parent resource. The required format is:
    ///
    /// * projects/{project}/locations/{location}
    ///
    /// Regardless of the parent specified here, as long it is contains a valid
    /// project and location, the service will return a static list of supported
    /// flags resources. Note that we do not yet support region-specific
    /// flags.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListSupportedDatabaseFlagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSupportedDatabaseFlagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSupportedDatabaseFlagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSupportedDatabaseFlagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSupportedDatabaseFlagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListSupportedDatabaseFlagsRequest"
    }
}

/// Message for response to listing SupportedDatabaseFlags.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSupportedDatabaseFlagsResponse {
    /// The list of SupportedDatabaseFlags.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub supported_database_flags: std::vec::Vec<crate::model::SupportedDatabaseFlag>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSupportedDatabaseFlagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSupportedDatabaseFlagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [supported_database_flags][crate::model::ListSupportedDatabaseFlagsResponse::supported_database_flags].
    pub fn set_supported_database_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SupportedDatabaseFlag>,
    {
        use std::iter::Iterator;
        self.supported_database_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSupportedDatabaseFlagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListSupportedDatabaseFlagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSupportedDatabaseFlagsResponse {
    type PageItem = crate::model::SupportedDatabaseFlag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.supported_database_flags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for requests to generate a client certificate signed by the Cluster
/// CA.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateClientCertificateRequest {
    /// Required. The name of the parent resource. The required format is:
    ///
    /// * projects/{project}/locations/{location}/clusters/{cluster}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. An optional hint to the endpoint to generate the client
    /// certificate with the requested duration. The duration can be from 1 hour to
    /// 24 hours. The endpoint may or may not honor the hint. If the hint is left
    /// unspecified or is not honored, then the endpoint will pick an appropriate
    /// default duration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cert_duration: std::option::Option<wkt::Duration>,

    /// Optional. The public key from the client.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,

    /// Optional. An optional hint to the endpoint to generate a client
    /// ceritificate that can be used by AlloyDB connectors to exchange additional
    /// metadata with the server after TLS handshake.
    pub use_metadata_exchange: bool,
}

impl GenerateClientCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GenerateClientCertificateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::GenerateClientCertificateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [cert_duration][crate::model::GenerateClientCertificateRequest::cert_duration].
    pub fn set_cert_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cert_duration = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::GenerateClientCertificateRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [use_metadata_exchange][crate::model::GenerateClientCertificateRequest::use_metadata_exchange].
    pub fn set_use_metadata_exchange<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_metadata_exchange = v.into();
        self
    }
}

impl wkt::message::Message for GenerateClientCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GenerateClientCertificateRequest"
    }
}

/// Message returned by a GenerateClientCertificate operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateClientCertificateResponse {
    /// Output only. The pem-encoded chain that may be used to verify the X.509
    /// certificate. Expected to be in issuer-to-root order according to RFC 5246.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pem_certificate_chain: std::vec::Vec<std::string::String>,

    /// Optional. The pem-encoded cluster ca X.509 certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_cert: std::string::String,
}

impl GenerateClientCertificateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ca_cert][crate::model::GenerateClientCertificateResponse::ca_cert].
    pub fn set_ca_cert<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_cert = v.into();
        self
    }

    /// Sets the value of [pem_certificate_chain][crate::model::GenerateClientCertificateResponse::pem_certificate_chain].
    pub fn set_pem_certificate_chain<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pem_certificate_chain = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerateClientCertificateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GenerateClientCertificateResponse"
    }
}

/// Request message for GetConnectionInfo.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionInfoRequest {
    /// Required. The name of the parent resource. The required format is:
    /// projects/{project}/locations/{location}/clusters/{cluster}/instances/{instance}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl GetConnectionInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetConnectionInfoRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::GetConnectionInfoRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetConnectionInfoRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// Request specific metadata, if any.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request_specific: std::option::Option<crate::model::operation_metadata::RequestSpecific>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of `request_specific`.
    pub fn set_request_specific<
        T: std::convert::Into<std::option::Option<crate::model::operation_metadata::RequestSpecific>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = v.into();
        self
    }

    /// The value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// if it holds a `BatchCreateInstancesMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_batch_create_instances_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BatchCreateInstancesMetadata>> {
        #[allow(unreachable_patterns)]
        self.request_specific.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// to hold a `BatchCreateInstancesMetadata`.
    ///
    /// Note that all the setters affecting `request_specific` are
    /// mutually exclusive.
    pub fn set_batch_create_instances_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::BatchCreateInstancesMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = std::option::Option::Some(
            crate::model::operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.OperationMetadata"
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Request specific metadata, if any.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RequestSpecific {
        /// Output only. BatchCreateInstances related metadata.
        BatchCreateInstancesMetadata(std::boxed::Box<crate::model::BatchCreateInstancesMetadata>),
    }
}

/// Message for requesting list of Users
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsersRequest {
    /// Required. Parent value for ListUsersRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUsersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListUsersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListUsersRequest"
    }
}

/// Message for response to listing Users
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsersResponse {
    /// The list of User
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub users: std::vec::Vec<crate::model::User>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListUsersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [users][crate::model::ListUsersResponse::users].
    pub fn set_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>,
    {
        use std::iter::Iterator;
        self.users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsersResponse {
    type PageItem = crate::model::User;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a User
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetUserRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the User.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetUserRequest"
    }
}

/// Message for creating a User
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateUserRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user: std::option::Option<crate::model::User>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,
}

impl CreateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::CreateUserRequest::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [user][crate::model::CreateUserRequest::user].
    pub fn set_user<T: std::convert::Into<std::option::Option<crate::model::User>>>(
        mut self,
        v: T,
    ) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateUserRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateUserRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateUserRequest"
    }
}

/// Message for updating a User
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateUserRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// User resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user: std::option::Option<crate::model::User>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. Allow missing fields in the update mask.
    pub allow_missing: bool,
}

impl UpdateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [user][crate::model::UpdateUserRequest::user].
    pub fn set_user<T: std::convert::Into<std::option::Option<crate::model::User>>>(
        mut self,
        v: T,
    ) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateUserRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateUserRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateUserRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateUserRequest"
    }
}

/// Message for deleting a User
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteUserRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the User.name field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,
}

impl DeleteUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteUserRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteUserRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteUserRequest"
    }
}

/// Message for requesting list of Databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatabasesRequest {
    /// Required. Parent value for ListDatabasesRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of databases to return. The service may return
    /// fewer than this value. If unspecified, 2000 is the default page_size. The
    /// max value of page_size will be 4000, values above max will be coerced to
    /// max.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListDatabases` call.
    /// This should be provided to retrieve the subsequent page.
    /// This field is currently not supported, its value will be ignored if passed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    /// This field is currently not supported, its value will be ignored if passed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListDatabasesRequest"
    }
}

/// Message for response to listing Databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatabasesResponse {
    /// The list of databases
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub databases: std::vec::Vec<crate::model::Database>,

    /// A token identifying the next page of results the server should return.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [databases][crate::model::ListDatabasesResponse::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatabasesResponse {
    type PageItem = crate::model::Database;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// View on Instance. Pass this enum to rpcs that returns an Instance message to
/// control which subsets of fields to get.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct InstanceView(i32);

impl InstanceView {
    /// INSTANCE_VIEW_UNSPECIFIED Not specified, equivalent to BASIC.
    pub const INSTANCE_VIEW_UNSPECIFIED: InstanceView = InstanceView::new(0);

    /// BASIC server responses for a primary or read instance include all the
    /// relevant instance details, excluding the details of each node in the
    /// instance. The default value.
    pub const INSTANCE_VIEW_BASIC: InstanceView = InstanceView::new(1);

    /// FULL response is equivalent to BASIC for primary instance (for now).
    /// For read pool instance, this includes details of each node in the pool.
    pub const INSTANCE_VIEW_FULL: InstanceView = InstanceView::new(2);

    /// Creates a new InstanceView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("INSTANCE_VIEW_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("INSTANCE_VIEW_BASIC"),
            2 => std::borrow::Cow::Borrowed("INSTANCE_VIEW_FULL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "INSTANCE_VIEW_UNSPECIFIED" => {
                std::option::Option::Some(Self::INSTANCE_VIEW_UNSPECIFIED)
            }
            "INSTANCE_VIEW_BASIC" => std::option::Option::Some(Self::INSTANCE_VIEW_BASIC),
            "INSTANCE_VIEW_FULL" => std::option::Option::Some(Self::INSTANCE_VIEW_FULL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for InstanceView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for InstanceView {
    fn default() -> Self {
        Self::new(0)
    }
}

/// View on Cluster. Pass this enum to rpcs that returns a cluster message to
/// control which subsets of fields to get.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ClusterView(i32);

impl ClusterView {
    /// CLUSTER_VIEW_UNSPECIFIED Not specified, equivalent to BASIC.
    pub const CLUSTER_VIEW_UNSPECIFIED: ClusterView = ClusterView::new(0);

    /// BASIC server responses include all the relevant cluster details, excluding
    /// Cluster.ContinuousBackupInfo.EarliestRestorableTime and other view-specific
    /// fields. The default value.
    pub const CLUSTER_VIEW_BASIC: ClusterView = ClusterView::new(1);

    /// CONTINUOUS_BACKUP response returns all the fields from BASIC plus
    /// the earliest restorable time if continuous backups are enabled.
    /// May increase latency.
    pub const CLUSTER_VIEW_CONTINUOUS_BACKUP: ClusterView = ClusterView::new(2);

    /// Creates a new ClusterView instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("CLUSTER_VIEW_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("CLUSTER_VIEW_BASIC"),
            2 => std::borrow::Cow::Borrowed("CLUSTER_VIEW_CONTINUOUS_BACKUP"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "CLUSTER_VIEW_UNSPECIFIED" => std::option::Option::Some(Self::CLUSTER_VIEW_UNSPECIFIED),
            "CLUSTER_VIEW_BASIC" => std::option::Option::Some(Self::CLUSTER_VIEW_BASIC),
            "CLUSTER_VIEW_CONTINUOUS_BACKUP" => {
                std::option::Option::Some(Self::CLUSTER_VIEW_CONTINUOUS_BACKUP)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ClusterView {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ClusterView {
    fn default() -> Self {
        Self::new(0)
    }
}

/// The supported database engine versions.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DatabaseVersion(i32);

impl DatabaseVersion {
    /// This is an unknown database version.
    pub const DATABASE_VERSION_UNSPECIFIED: DatabaseVersion = DatabaseVersion::new(0);

    /// DEPRECATED - The database version is Postgres 13.
    pub const POSTGRES_13: DatabaseVersion = DatabaseVersion::new(1);

    /// The database version is Postgres 14.
    pub const POSTGRES_14: DatabaseVersion = DatabaseVersion::new(2);

    /// The database version is Postgres 15.
    pub const POSTGRES_15: DatabaseVersion = DatabaseVersion::new(3);

    /// The database version is Postgres 16.
    pub const POSTGRES_16: DatabaseVersion = DatabaseVersion::new(4);

    /// Creates a new DatabaseVersion instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("DATABASE_VERSION_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("POSTGRES_13"),
            2 => std::borrow::Cow::Borrowed("POSTGRES_14"),
            3 => std::borrow::Cow::Borrowed("POSTGRES_15"),
            4 => std::borrow::Cow::Borrowed("POSTGRES_16"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "DATABASE_VERSION_UNSPECIFIED" => {
                std::option::Option::Some(Self::DATABASE_VERSION_UNSPECIFIED)
            }
            "POSTGRES_13" => std::option::Option::Some(Self::POSTGRES_13),
            "POSTGRES_14" => std::option::Option::Some(Self::POSTGRES_14),
            "POSTGRES_15" => std::option::Option::Some(Self::POSTGRES_15),
            "POSTGRES_16" => std::option::Option::Some(Self::POSTGRES_16),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for DatabaseVersion {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for DatabaseVersion {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Subscription_type added to distinguish between Standard and Trial
/// subscriptions. By default, a subscription type is considered STANDARD unless
/// explicitly specified.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct SubscriptionType(i32);

impl SubscriptionType {
    /// This is an unknown subscription type. By default, the subscription type is
    /// STANDARD.
    pub const SUBSCRIPTION_TYPE_UNSPECIFIED: SubscriptionType = SubscriptionType::new(0);

    /// Standard subscription.
    pub const STANDARD: SubscriptionType = SubscriptionType::new(1);

    /// Trial subscription.
    pub const TRIAL: SubscriptionType = SubscriptionType::new(2);

    /// Creates a new SubscriptionType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("SUBSCRIPTION_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("STANDARD"),
            2 => std::borrow::Cow::Borrowed("TRIAL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "SUBSCRIPTION_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::SUBSCRIPTION_TYPE_UNSPECIFIED)
            }
            "STANDARD" => std::option::Option::Some(Self::STANDARD),
            "TRIAL" => std::option::Option::Some(Self::TRIAL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for SubscriptionType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for SubscriptionType {
    fn default() -> Self {
        Self::new(0)
    }
}
