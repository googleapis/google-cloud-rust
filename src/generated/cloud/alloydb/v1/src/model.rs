// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// The source CloudSQL backup resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSQLBackupRunSource {
    /// The project ID of the source CloudSQL instance. This should be the same as
    /// the AlloyDB cluster's project.
    pub project: std::string::String,

    /// Required. The CloudSQL instance ID.
    pub instance_id: std::string::String,

    /// Required. The CloudSQL backup run ID.
    pub backup_run_id: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSQLBackupRunSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::CloudSQLBackupRunSource::project].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CloudSQLBackupRunSource;
    /// let x = CloudSQLBackupRunSource::new().set_project("example");
    /// ```
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CloudSQLBackupRunSource::instance_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CloudSQLBackupRunSource;
    /// let x = CloudSQLBackupRunSource::new().set_instance_id("example");
    /// ```
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [backup_run_id][crate::model::CloudSQLBackupRunSource::backup_run_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CloudSQLBackupRunSource;
    /// let x = CloudSQLBackupRunSource::new().set_backup_run_id(42);
    /// ```
    pub fn set_backup_run_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_run_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudSQLBackupRunSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CloudSQLBackupRunSource"
    }
}

/// Message for registering Restoring from CloudSQL resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreFromCloudSQLRequest {
    /// Required. The location of the new cluster. For the required format, see the
    /// comment on Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// The source CloudSQL resource to restore from.
    pub source: std::option::Option<crate::model::restore_from_cloud_sql_request::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreFromCloudSQLRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreFromCloudSQLRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreFromCloudSQLRequest;
    /// let x = RestoreFromCloudSQLRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::RestoreFromCloudSQLRequest::cluster_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreFromCloudSQLRequest;
    /// let x = RestoreFromCloudSQLRequest::new().set_cluster_id("example");
    /// ```
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::RestoreFromCloudSQLRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreFromCloudSQLRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = RestoreFromCloudSQLRequest::new().set_cluster(Cluster::default()/* use setters */);
    /// ```
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::RestoreFromCloudSQLRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreFromCloudSQLRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = RestoreFromCloudSQLRequest::new().set_or_clear_cluster(Some(Cluster::default()/* use setters */));
    /// let x = RestoreFromCloudSQLRequest::new().set_or_clear_cluster(None::<Cluster>);
    /// ```
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::RestoreFromCloudSQLRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreFromCloudSQLRequest;
    /// use google_cloud_alloydb_v1::model::restore_from_cloud_sql_request;
    /// use google_cloud_alloydb_v1::model::CloudSQLBackupRunSource;
    /// let x = RestoreFromCloudSQLRequest::new().set_source(Some(restore_from_cloud_sql_request::Source::CloudsqlBackupRunSource(CloudSQLBackupRunSource::default().into())));
    /// ```
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::restore_from_cloud_sql_request::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreFromCloudSQLRequest::source]
    /// if it holds a `CloudsqlBackupRunSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloudsql_backup_run_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSQLBackupRunSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_from_cloud_sql_request::Source::CloudsqlBackupRunSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreFromCloudSQLRequest::source]
    /// to hold a `CloudsqlBackupRunSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreFromCloudSQLRequest;
    /// use google_cloud_alloydb_v1::model::CloudSQLBackupRunSource;
    /// let x = RestoreFromCloudSQLRequest::new().set_cloudsql_backup_run_source(CloudSQLBackupRunSource::default()/* use setters */);
    /// assert!(x.cloudsql_backup_run_source().is_some());
    /// ```
    pub fn set_cloudsql_backup_run_source<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSQLBackupRunSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_from_cloud_sql_request::Source::CloudsqlBackupRunSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreFromCloudSQLRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestoreFromCloudSQLRequest"
    }
}

/// Defines additional types related to [RestoreFromCloudSQLRequest].
pub mod restore_from_cloud_sql_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source CloudSQL resource to restore from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Cluster created from CloudSQL backup run.
        CloudsqlBackupRunSource(std::boxed::Box<crate::model::CloudSQLBackupRunSource>),
    }
}

/// SqlResult represents the result for the execution of a sql statement.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResult {
    /// List of columns included in the result. This also includes the data type
    /// of the column.
    pub columns: std::vec::Vec<crate::model::SqlResultColumn>,

    /// Rows returned by the SQL statement.
    pub rows: std::vec::Vec<crate::model::SqlResultRow>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::SqlResult::columns].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResult;
    /// use google_cloud_alloydb_v1::model::SqlResultColumn;
    /// let x = SqlResult::new()
    ///     .set_columns([
    ///         SqlResultColumn::default()/* use setters */,
    ///         SqlResultColumn::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultColumn>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows][crate::model::SqlResult::rows].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResult;
    /// use google_cloud_alloydb_v1::model::SqlResultRow;
    /// let x = SqlResult::new()
    ///     .set_rows([
    ///         SqlResultRow::default()/* use setters */,
    ///         SqlResultRow::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultRow>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResult"
    }
}

/// Contains the name and datatype of a column in a SQL Result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResultColumn {
    /// Name of the column.
    pub name: std::string::String,

    /// Datatype of the column as reported by the postgres driver.
    /// Common type names are "VARCHAR", "TEXT", "NVARCHAR", "DECIMAL", "BOOL",
    /// "INT", and "BIGINT".
    pub r#type: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResultColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SqlResultColumn::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResultColumn;
    /// let x = SqlResultColumn::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SqlResultColumn::type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResultColumn;
    /// let x = SqlResultColumn::new().set_type("example");
    /// ```
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for SqlResultColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultColumn"
    }
}

/// A single row from a sql result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResultRow {
    /// List of values in a row of sql result.
    pub values: std::vec::Vec<crate::model::SqlResultValue>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResultRow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::SqlResultRow::values].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResultRow;
    /// use google_cloud_alloydb_v1::model::SqlResultValue;
    /// let x = SqlResultRow::new()
    ///     .set_values([
    ///         SqlResultValue::default()/* use setters */,
    ///         SqlResultValue::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlResultRow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultRow"
    }
}

/// A single value in a row from a sql result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResultValue {
    /// The cell value represented in string format.
    /// Timestamps are converted to string using RFC3339Nano format.
    pub value: std::option::Option<std::string::String>,

    /// Set to true if cell value is null.
    pub null_value: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResultValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::SqlResultValue::value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResultValue;
    /// let x = SqlResultValue::new().set_value("example");
    /// ```
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::SqlResultValue::value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResultValue;
    /// let x = SqlResultValue::new().set_or_clear_value("example");
    /// let x = SqlResultValue::new().set_or_clear_value(Some("example"));
    /// let x = SqlResultValue::new().set_or_clear_value(None::<String>);
    /// ```
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [null_value][crate::model::SqlResultValue::null_value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResultValue;
    /// let x = SqlResultValue::new().set_null_value(true);
    /// ```
    pub fn set_null_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.null_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [null_value][crate::model::SqlResultValue::null_value].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SqlResultValue;
    /// let x = SqlResultValue::new().set_or_clear_null_value(Some(false));
    /// let x = SqlResultValue::new().set_or_clear_null_value(None::<bool>);
    /// ```
    pub fn set_or_clear_null_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.null_value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlResultValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultValue"
    }
}

/// The username/password for a database user. Used for specifying initial
/// users at cluster creation time.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserPassword {
    /// The database username.
    pub user: std::string::String,

    /// The initial password for the user.
    pub password: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserPassword {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user][crate::model::UserPassword::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UserPassword;
    /// let x = UserPassword::new().set_user("example");
    /// ```
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [password][crate::model::UserPassword::password].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UserPassword;
    /// let x = UserPassword::new().set_password("example");
    /// ```
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for UserPassword {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UserPassword"
    }
}

/// Subset of the source instance configuration that is available when reading
/// the cluster resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationSource {
    /// Output only. The host and port of the on-premises instance in host:port
    /// format
    pub host_port: std::string::String,

    /// Output only. Place holder for the external source identifier(e.g DMS job
    /// name) that created the cluster.
    pub reference_id: std::string::String,

    /// Output only. Type of migration source.
    pub source_type: crate::model::migration_source::MigrationSourceType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_port][crate::model::MigrationSource::host_port].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::MigrationSource;
    /// let x = MigrationSource::new().set_host_port("example");
    /// ```
    pub fn set_host_port<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_port = v.into();
        self
    }

    /// Sets the value of [reference_id][crate::model::MigrationSource::reference_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::MigrationSource;
    /// let x = MigrationSource::new().set_reference_id("example");
    /// ```
    pub fn set_reference_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference_id = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::MigrationSource::source_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::MigrationSource;
    /// use google_cloud_alloydb_v1::model::migration_source::MigrationSourceType;
    /// let x0 = MigrationSource::new().set_source_type(MigrationSourceType::Dms);
    /// ```
    pub fn set_source_type<
        T: std::convert::Into<crate::model::migration_source::MigrationSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }
}

impl wkt::message::Message for MigrationSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MigrationSource"
    }
}

/// Defines additional types related to [MigrationSource].
pub mod migration_source {
    #[allow(unused_imports)]
    use super::*;

    /// Denote the type of migration source that created this cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MigrationSourceType {
        /// Migration source is unknown.
        Unspecified,
        /// DMS source means the cluster was created via DMS migration job.
        Dms,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MigrationSourceType::value] or
        /// [MigrationSourceType::name].
        UnknownValue(migration_source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod migration_source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MigrationSourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dms => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MIGRATION_SOURCE_TYPE_UNSPECIFIED"),
                Self::Dms => std::option::Option::Some("DMS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MigrationSourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MigrationSourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MigrationSourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dms,
                _ => Self::UnknownValue(migration_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MigrationSourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIGRATION_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DMS" => Self::Dms,
                _ => Self::UnknownValue(migration_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MigrationSourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dms => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MigrationSourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationSourceType>::new(
                ".google.cloud.alloydb.v1.MigrationSource.MigrationSourceType",
            ))
        }
    }
}

/// EncryptionConfig describes the encryption config of a cluster or a backup
/// that is encrypted with a CMEK (customer-managed encryption key).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// The fully-qualified resource name of the KMS key.
    /// Each Cloud KMS key is regionalized and has the following format:
    /// projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
    pub kms_key_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfig::kms_key_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = EncryptionConfig::new().set_kms_key_name("example");
    /// ```
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.EncryptionConfig"
    }
}

/// EncryptionInfo describes the encryption information of a cluster or a backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionInfo {
    /// Output only. Type of encryption.
    pub encryption_type: crate::model::encryption_info::Type,

    /// Output only. Cloud KMS key versions that are being used to protect the
    /// database or the backup.
    pub kms_key_versions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_type][crate::model::EncryptionInfo::encryption_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// use google_cloud_alloydb_v1::model::encryption_info::Type;
    /// let x0 = EncryptionInfo::new().set_encryption_type(Type::GoogleDefaultEncryption);
    /// let x1 = EncryptionInfo::new().set_encryption_type(Type::CustomerManagedEncryption);
    /// ```
    pub fn set_encryption_type<T: std::convert::Into<crate::model::encryption_info::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [kms_key_versions][crate::model::EncryptionInfo::kms_key_versions].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// let x = EncryptionInfo::new().set_kms_key_versions(["a", "b", "c"]);
    /// ```
    pub fn set_kms_key_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kms_key_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EncryptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.EncryptionInfo"
    }
}

/// Defines additional types related to [EncryptionInfo].
pub mod encryption_info {
    #[allow(unused_imports)]
    use super::*;

    /// Possible encryption types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Encryption type not specified. Defaults to GOOGLE_DEFAULT_ENCRYPTION.
        Unspecified,
        /// The data is encrypted at rest with a key that is fully managed by Google.
        /// No key version will be populated. This is the default state.
        GoogleDefaultEncryption,
        /// The data is encrypted at rest with a key that is managed by the customer.
        /// KMS key versions will be populated.
        CustomerManagedEncryption,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleDefaultEncryption => std::option::Option::Some(1),
                Self::CustomerManagedEncryption => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::GoogleDefaultEncryption => {
                    std::option::Option::Some("GOOGLE_DEFAULT_ENCRYPTION")
                }
                Self::CustomerManagedEncryption => {
                    std::option::Option::Some("CUSTOMER_MANAGED_ENCRYPTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleDefaultEncryption,
                2 => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_DEFAULT_ENCRYPTION" => Self::GoogleDefaultEncryption,
                "CUSTOMER_MANAGED_ENCRYPTION" => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleDefaultEncryption => serializer.serialize_i32(1),
                Self::CustomerManagedEncryption => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.alloydb.v1.EncryptionInfo.Type",
            ))
        }
    }
}

/// SSL configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SslConfig {
    /// Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
    pub ssl_mode: crate::model::ssl_config::SslMode,

    /// Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is
    /// supported currently, and is the default value.
    pub ca_source: crate::model::ssl_config::CaSource,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ssl_mode][crate::model::SslConfig::ssl_mode].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SslConfig;
    /// use google_cloud_alloydb_v1::model::ssl_config::SslMode;
    /// let x0 = SslConfig::new().set_ssl_mode(SslMode::AllowUnencryptedAndEncrypted);
    /// let x1 = SslConfig::new().set_ssl_mode(SslMode::EncryptedOnly);
    /// ```
    pub fn set_ssl_mode<T: std::convert::Into<crate::model::ssl_config::SslMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_mode = v.into();
        self
    }

    /// Sets the value of [ca_source][crate::model::SslConfig::ca_source].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SslConfig;
    /// use google_cloud_alloydb_v1::model::ssl_config::CaSource;
    /// let x0 = SslConfig::new().set_ca_source(CaSource::Managed);
    /// ```
    pub fn set_ca_source<T: std::convert::Into<crate::model::ssl_config::CaSource>>(
        mut self,
        v: T,
    ) -> Self {
        self.ca_source = v.into();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SslConfig"
    }
}

/// Defines additional types related to [SslConfig].
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// SSL mode options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslMode {
        /// SSL mode is not specified. Defaults to ENCRYPTED_ONLY.
        Unspecified,
        /// SSL connections are optional. CA verification not enforced.
        #[deprecated]
        Allow,
        /// SSL connections are required. CA verification not enforced.
        /// Clients may use locally self-signed certificates (default psql client
        /// behavior).
        #[deprecated]
        Require,
        /// SSL connections are required. CA verification enforced.
        /// Clients must have certificates signed by a Cluster CA, for example, using
        /// GenerateClientCertificate.
        #[deprecated]
        VerifyCa,
        /// SSL connections are optional. CA verification not enforced.
        AllowUnencryptedAndEncrypted,
        /// SSL connections are required. CA verification not enforced.
        EncryptedOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslMode::value] or
        /// [SslMode::name].
        UnknownValue(ssl_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Require => std::option::Option::Some(2),
                Self::VerifyCa => std::option::Option::Some(3),
                Self::AllowUnencryptedAndEncrypted => std::option::Option::Some(4),
                Self::EncryptedOnly => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_MODE_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("SSL_MODE_ALLOW"),
                Self::Require => std::option::Option::Some("SSL_MODE_REQUIRE"),
                Self::VerifyCa => std::option::Option::Some("SSL_MODE_VERIFY_CA"),
                Self::AllowUnencryptedAndEncrypted => {
                    std::option::Option::Some("ALLOW_UNENCRYPTED_AND_ENCRYPTED")
                }
                Self::EncryptedOnly => std::option::Option::Some("ENCRYPTED_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Require,
                3 => Self::VerifyCa,
                4 => Self::AllowUnencryptedAndEncrypted,
                5 => Self::EncryptedOnly,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SslMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_MODE_UNSPECIFIED" => Self::Unspecified,
                "SSL_MODE_ALLOW" => Self::Allow,
                "SSL_MODE_REQUIRE" => Self::Require,
                "SSL_MODE_VERIFY_CA" => Self::VerifyCa,
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => Self::AllowUnencryptedAndEncrypted,
                "ENCRYPTED_ONLY" => Self::EncryptedOnly,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SslMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Require => serializer.serialize_i32(2),
                Self::VerifyCa => serializer.serialize_i32(3),
                Self::AllowUnencryptedAndEncrypted => serializer.serialize_i32(4),
                Self::EncryptedOnly => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslMode>::new(
                ".google.cloud.alloydb.v1.SslConfig.SslMode",
            ))
        }
    }

    /// Certificate Authority (CA) source for SSL/TLS certificates.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CaSource {
        /// Certificate Authority (CA) source not specified. Defaults to
        /// CA_SOURCE_MANAGED.
        Unspecified,
        /// Certificate Authority (CA) managed by the AlloyDB Cluster.
        Managed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CaSource::value] or
        /// [CaSource::name].
        UnknownValue(ca_source::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ca_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CaSource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Managed => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CA_SOURCE_UNSPECIFIED"),
                Self::Managed => std::option::Option::Some("CA_SOURCE_MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CaSource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CaSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CaSource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Managed,
                _ => Self::UnknownValue(ca_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CaSource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CA_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "CA_SOURCE_MANAGED" => Self::Managed,
                _ => Self::UnknownValue(ca_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CaSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Managed => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CaSource>::new(
                ".google.cloud.alloydb.v1.SslConfig.CaSource",
            ))
        }
    }
}

/// Message describing the user-specified automated backup policy.
///
/// All fields in the automated backup policy are optional. Defaults for each
/// field are provided if they are not set.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomatedBackupPolicy {
    /// Whether automated automated backups are enabled. If not set, defaults to
    /// true.
    pub enabled: std::option::Option<bool>,

    /// The length of the time window during which a backup can be
    /// taken. If a backup does not succeed within this time window, it will be
    /// canceled and considered failed.
    ///
    /// The backup window must be at least 5 minutes long. There is no upper bound
    /// on the window. If not set, it defaults to 1 hour.
    pub backup_window: std::option::Option<wkt::Duration>,

    /// Optional. The encryption config can be specified to encrypt the
    /// backups with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will use the cluster's encryption config.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// The location where the backup will be stored. Currently, the only supported
    /// option is to store the backup in the same region as the cluster.
    ///
    /// If empty, defaults to the region of the cluster.
    pub location: std::string::String,

    /// Labels to apply to backups created using this configuration.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    pub schedule: std::option::Option<crate::model::automated_backup_policy::Schedule>,

    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    pub retention: std::option::Option<crate::model::automated_backup_policy::Retention>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomatedBackupPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::AutomatedBackupPolicy::enabled].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// let x = AutomatedBackupPolicy::new().set_enabled(true);
    /// ```
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::AutomatedBackupPolicy::enabled].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// let x = AutomatedBackupPolicy::new().set_or_clear_enabled(Some(false));
    /// let x = AutomatedBackupPolicy::new().set_or_clear_enabled(None::<bool>);
    /// ```
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_window][crate::model::AutomatedBackupPolicy::backup_window].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use wkt::Duration;
    /// let x = AutomatedBackupPolicy::new().set_backup_window(Duration::default()/* use setters */);
    /// ```
    pub fn set_backup_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.backup_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_window][crate::model::AutomatedBackupPolicy::backup_window].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use wkt::Duration;
    /// let x = AutomatedBackupPolicy::new().set_or_clear_backup_window(Some(Duration::default()/* use setters */));
    /// let x = AutomatedBackupPolicy::new().set_or_clear_backup_window(None::<Duration>);
    /// ```
    pub fn set_or_clear_backup_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.backup_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_config][crate::model::AutomatedBackupPolicy::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = AutomatedBackupPolicy::new().set_encryption_config(EncryptionConfig::default()/* use setters */);
    /// ```
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::AutomatedBackupPolicy::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = AutomatedBackupPolicy::new().set_or_clear_encryption_config(Some(EncryptionConfig::default()/* use setters */));
    /// let x = AutomatedBackupPolicy::new().set_or_clear_encryption_config(None::<EncryptionConfig>);
    /// ```
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::AutomatedBackupPolicy::location].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// let x = AutomatedBackupPolicy::new().set_location("example");
    /// ```
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AutomatedBackupPolicy::labels].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// let x = AutomatedBackupPolicy::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupPolicy::schedule].
    ///
    /// Note that all the setters affecting `schedule` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use google_cloud_alloydb_v1::model::automated_backup_policy;
    /// use google_cloud_alloydb_v1::model::automated_backup_policy::WeeklySchedule;
    /// let x = AutomatedBackupPolicy::new().set_schedule(Some(automated_backup_policy::Schedule::WeeklySchedule(WeeklySchedule::default().into())));
    /// ```
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_policy::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::AutomatedBackupPolicy::schedule]
    /// if it holds a `WeeklySchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn weekly_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>>
    {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Schedule::WeeklySchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupPolicy::schedule]
    /// to hold a `WeeklySchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use google_cloud_alloydb_v1::model::automated_backup_policy::WeeklySchedule;
    /// let x = AutomatedBackupPolicy::new().set_weekly_schedule(WeeklySchedule::default()/* use setters */);
    /// assert!(x.weekly_schedule().is_some());
    /// ```
    pub fn set_weekly_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::automated_backup_policy::Schedule::WeeklySchedule(v.into()),
        );
        self
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention].
    ///
    /// Note that all the setters affecting `retention` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use google_cloud_alloydb_v1::model::automated_backup_policy;
    /// use google_cloud_alloydb_v1::model::automated_backup_policy::TimeBasedRetention;
    /// let x = AutomatedBackupPolicy::new().set_retention(Some(automated_backup_policy::Retention::TimeBasedRetention(TimeBasedRetention::default().into())));
    /// ```
    pub fn set_retention<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_policy::Retention>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = v.into();
        self
    }

    /// The value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// if it holds a `TimeBasedRetention`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_based_retention(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
    > {
        #[allow(unreachable_patterns)]
        self.retention.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Retention::TimeBasedRetention(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// to hold a `TimeBasedRetention`.
    ///
    /// Note that all the setters affecting `retention` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use google_cloud_alloydb_v1::model::automated_backup_policy::TimeBasedRetention;
    /// let x = AutomatedBackupPolicy::new().set_time_based_retention(TimeBasedRetention::default()/* use setters */);
    /// assert!(x.time_based_retention().is_some());
    /// assert!(x.quantity_based_retention().is_none());
    /// ```
    pub fn set_time_based_retention<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = std::option::Option::Some(
            crate::model::automated_backup_policy::Retention::TimeBasedRetention(v.into()),
        );
        self
    }

    /// The value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// if it holds a `QuantityBasedRetention`, `None` if the field is not set or
    /// holds a different branch.
    pub fn quantity_based_retention(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
    > {
        #[allow(unreachable_patterns)]
        self.retention.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Retention::QuantityBasedRetention(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// to hold a `QuantityBasedRetention`.
    ///
    /// Note that all the setters affecting `retention` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// use google_cloud_alloydb_v1::model::automated_backup_policy::QuantityBasedRetention;
    /// let x = AutomatedBackupPolicy::new().set_quantity_based_retention(QuantityBasedRetention::default()/* use setters */);
    /// assert!(x.quantity_based_retention().is_some());
    /// assert!(x.time_based_retention().is_none());
    /// ```
    pub fn set_quantity_based_retention<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = std::option::Option::Some(
            crate::model::automated_backup_policy::Retention::QuantityBasedRetention(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomatedBackupPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy"
    }
}

/// Defines additional types related to [AutomatedBackupPolicy].
pub mod automated_backup_policy {
    #[allow(unused_imports)]
    use super::*;

    /// A weekly schedule starts a backup at prescribed start times within a
    /// day, for the specified days of the week.
    ///
    /// The weekly schedule message is flexible and can be used to create many
    /// types of schedules. For example, to have a daily backup that starts at
    /// 22:00, configure the `start_times` field to have one element "22:00" and
    /// the `days_of_week` field to have all seven days of the week.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WeeklySchedule {
        /// The times during the day to start a backup. The start times are assumed
        /// to be in UTC and to be an exact hour (e.g., 04:00:00).
        ///
        /// If no start times are provided, a single fixed start time is chosen
        /// arbitrarily.
        pub start_times: std::vec::Vec<gtype::model::TimeOfDay>,

        /// The days of the week to perform a backup.
        ///
        /// If this field is left empty, the default of every day of the week is
        /// used.
        pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WeeklySchedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_times][crate::model::automated_backup_policy::WeeklySchedule::start_times].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::automated_backup_policy::WeeklySchedule;
        /// use gtype::model::TimeOfDay;
        /// let x = WeeklySchedule::new()
        ///     .set_start_times([
        ///         TimeOfDay::default()/* use setters */,
        ///         TimeOfDay::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_start_times<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<gtype::model::TimeOfDay>,
        {
            use std::iter::Iterator;
            self.start_times = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [days_of_week][crate::model::automated_backup_policy::WeeklySchedule::days_of_week].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::automated_backup_policy::WeeklySchedule;
        /// use gtype::model::DayOfWeek;
        /// let x = WeeklySchedule::new().set_days_of_week([
        ///     DayOfWeek::Monday,
        ///     DayOfWeek::Tuesday,
        ///     DayOfWeek::Wednesday,
        /// ]);
        /// ```
        pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<gtype::model::DayOfWeek>,
        {
            use std::iter::Iterator;
            self.days_of_week = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WeeklySchedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklySchedule"
        }
    }

    /// A time based retention policy specifies that all backups within a certain
    /// time period should be retained.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeBasedRetention {
        /// The retention period.
        pub retention_period: std::option::Option<wkt::Duration>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeBasedRetention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_period][crate::model::automated_backup_policy::TimeBasedRetention::retention_period].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::automated_backup_policy::TimeBasedRetention;
        /// use wkt::Duration;
        /// let x = TimeBasedRetention::new().set_retention_period(Duration::default()/* use setters */);
        /// ```
        pub fn set_retention_period<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_period = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [retention_period][crate::model::automated_backup_policy::TimeBasedRetention::retention_period].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::automated_backup_policy::TimeBasedRetention;
        /// use wkt::Duration;
        /// let x = TimeBasedRetention::new().set_or_clear_retention_period(Some(Duration::default()/* use setters */));
        /// let x = TimeBasedRetention::new().set_or_clear_retention_period(None::<Duration>);
        /// ```
        pub fn set_or_clear_retention_period<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_period = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TimeBasedRetention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.TimeBasedRetention"
        }
    }

    /// A quantity based policy specifies that a certain number of the most recent
    /// successful backups should be retained.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QuantityBasedRetention {
        /// The number of backups to retain.
        pub count: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QuantityBasedRetention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::automated_backup_policy::QuantityBasedRetention::count].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::automated_backup_policy::QuantityBasedRetention;
        /// let x = QuantityBasedRetention::new().set_count(42);
        /// ```
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for QuantityBasedRetention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.QuantityBasedRetention"
        }
    }

    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schedule {
        /// Weekly schedule for the Backup.
        WeeklySchedule(std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>),
    }

    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Retention {
        /// Time-based Backup retention policy.
        TimeBasedRetention(
            std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
        ),
        /// Quantity-based Backup retention policy to retain recent backups.
        QuantityBasedRetention(
            std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
        ),
    }
}

/// ContinuousBackupConfig describes the continuous backups recovery
/// configurations of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ContinuousBackupConfig {
    /// Whether ContinuousBackup is enabled.
    pub enabled: std::option::Option<bool>,

    /// The number of days that are eligible to restore from using PITR. To support
    /// the entire recovery window, backups and logs are retained for one day more
    /// than the recovery window. If not set, defaults to 14 days.
    pub recovery_window_days: i32,

    /// The encryption config can be specified to encrypt the
    /// backups with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will use the cluster's encryption config.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContinuousBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ContinuousBackupConfig::enabled].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupConfig;
    /// let x = ContinuousBackupConfig::new().set_enabled(true);
    /// ```
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::ContinuousBackupConfig::enabled].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupConfig;
    /// let x = ContinuousBackupConfig::new().set_or_clear_enabled(Some(false));
    /// let x = ContinuousBackupConfig::new().set_or_clear_enabled(None::<bool>);
    /// ```
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recovery_window_days][crate::model::ContinuousBackupConfig::recovery_window_days].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupConfig;
    /// let x = ContinuousBackupConfig::new().set_recovery_window_days(42);
    /// ```
    pub fn set_recovery_window_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.recovery_window_days = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::ContinuousBackupConfig::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupConfig;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = ContinuousBackupConfig::new().set_encryption_config(EncryptionConfig::default()/* use setters */);
    /// ```
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::ContinuousBackupConfig::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupConfig;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = ContinuousBackupConfig::new().set_or_clear_encryption_config(Some(EncryptionConfig::default()/* use setters */));
    /// let x = ContinuousBackupConfig::new().set_or_clear_encryption_config(None::<EncryptionConfig>);
    /// ```
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ContinuousBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupConfig"
    }
}

/// ContinuousBackupInfo describes the continuous backup properties of a
/// cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ContinuousBackupInfo {
    /// Output only. The encryption information for the WALs and backups required
    /// for ContinuousBackup.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Output only. When ContinuousBackup was most recently enabled. Set to null
    /// if ContinuousBackup is not enabled.
    pub enabled_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Days of the week on which a continuous backup is taken.
    pub schedule: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Output only. The earliest restorable time that can be restored to. If
    /// continuous backups and recovery was recently enabled, the earliest
    /// restorable time is the creation time of the earliest eligible backup within
    /// this cluster's continuous backup recovery window. After a cluster has had
    /// continuous backups enabled for the duration of its recovery window, the
    /// earliest restorable time becomes "now minus the recovery window". For
    /// example, assuming a point in time recovery is attempted at 04/16/2025
    /// 3:23:00PM with a 14d recovery window, the earliest restorable time would be
    /// 04/02/2025 3:23:00PM. This field is only visible if the
    /// CLUSTER_VIEW_CONTINUOUS_BACKUP cluster view is provided.
    pub earliest_restorable_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContinuousBackupInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_info][crate::model::ContinuousBackupInfo::encryption_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// let x = ContinuousBackupInfo::new().set_encryption_info(EncryptionInfo::default()/* use setters */);
    /// ```
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::ContinuousBackupInfo::encryption_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// let x = ContinuousBackupInfo::new().set_or_clear_encryption_info(Some(EncryptionInfo::default()/* use setters */));
    /// let x = ContinuousBackupInfo::new().set_or_clear_encryption_info(None::<EncryptionInfo>);
    /// ```
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enabled_time][crate::model::ContinuousBackupInfo::enabled_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// use wkt::Timestamp;
    /// let x = ContinuousBackupInfo::new().set_enabled_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_enabled_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enabled_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled_time][crate::model::ContinuousBackupInfo::enabled_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// use wkt::Timestamp;
    /// let x = ContinuousBackupInfo::new().set_or_clear_enabled_time(Some(Timestamp::default()/* use setters */));
    /// let x = ContinuousBackupInfo::new().set_or_clear_enabled_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_enabled_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enabled_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule][crate::model::ContinuousBackupInfo::schedule].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// use gtype::model::DayOfWeek;
    /// let x = ContinuousBackupInfo::new().set_schedule([
    ///     DayOfWeek::Monday,
    ///     DayOfWeek::Tuesday,
    ///     DayOfWeek::Wednesday,
    /// ]);
    /// ```
    pub fn set_schedule<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.schedule = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [earliest_restorable_time][crate::model::ContinuousBackupInfo::earliest_restorable_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// use wkt::Timestamp;
    /// let x = ContinuousBackupInfo::new().set_earliest_restorable_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_earliest_restorable_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.earliest_restorable_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [earliest_restorable_time][crate::model::ContinuousBackupInfo::earliest_restorable_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// use wkt::Timestamp;
    /// let x = ContinuousBackupInfo::new().set_or_clear_earliest_restorable_time(Some(Timestamp::default()/* use setters */));
    /// let x = ContinuousBackupInfo::new().set_or_clear_earliest_restorable_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_earliest_restorable_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.earliest_restorable_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ContinuousBackupInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupInfo"
    }
}

/// Message describing a BackupSource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupSource {
    /// Output only. The system-generated UID of the backup which was used to
    /// create this resource. The UID is generated when the backup is created, and
    /// it is retained until the backup is deleted.
    pub backup_uid: std::string::String,

    /// Required. The name of the backup resource with the format:
    ///
    /// * projects/{project}/locations/{region}/backups/{backup_id}
    pub backup_name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_uid][crate::model::BackupSource::backup_uid].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BackupSource;
    /// let x = BackupSource::new().set_backup_uid("example");
    /// ```
    pub fn set_backup_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_uid = v.into();
        self
    }

    /// Sets the value of [backup_name][crate::model::BackupSource::backup_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BackupSource;
    /// let x = BackupSource::new().set_backup_name("example");
    /// ```
    pub fn set_backup_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_name = v.into();
        self
    }
}

impl wkt::message::Message for BackupSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BackupSource"
    }
}

/// Message describing a ContinuousBackupSource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ContinuousBackupSource {
    /// Required. The source cluster from which to restore. This cluster must have
    /// continuous backup enabled for this operation to succeed. For the required
    /// format, see the comment on the Cluster.name field.
    pub cluster: std::string::String,

    /// Required. The point in time to restore to.
    pub point_in_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContinuousBackupSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::ContinuousBackupSource::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupSource;
    /// let x = ContinuousBackupSource::new().set_cluster("example");
    /// ```
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [point_in_time][crate::model::ContinuousBackupSource::point_in_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupSource;
    /// use wkt::Timestamp;
    /// let x = ContinuousBackupSource::new().set_point_in_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_point_in_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.point_in_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [point_in_time][crate::model::ContinuousBackupSource::point_in_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ContinuousBackupSource;
    /// use wkt::Timestamp;
    /// let x = ContinuousBackupSource::new().set_or_clear_point_in_time(Some(Timestamp::default()/* use setters */));
    /// let x = ContinuousBackupSource::new().set_or_clear_point_in_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_point_in_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.point_in_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ContinuousBackupSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupSource"
    }
}

/// MaintenanceUpdatePolicy defines the policy for system updates.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceUpdatePolicy {
    /// Preferred windows to perform maintenance. Currently limited to 1.
    pub maintenance_windows:
        std::vec::Vec<crate::model::maintenance_update_policy::MaintenanceWindow>,

    /// Periods to deny maintenance. Currently limited to 1.
    pub deny_maintenance_periods:
        std::vec::Vec<crate::model::maintenance_update_policy::DenyMaintenancePeriod>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceUpdatePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [maintenance_windows][crate::model::MaintenanceUpdatePolicy::maintenance_windows].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::MaintenanceUpdatePolicy;
    /// use google_cloud_alloydb_v1::model::maintenance_update_policy::MaintenanceWindow;
    /// let x = MaintenanceUpdatePolicy::new()
    ///     .set_maintenance_windows([
    ///         MaintenanceWindow::default()/* use setters */,
    ///         MaintenanceWindow::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_maintenance_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::maintenance_update_policy::MaintenanceWindow>,
    {
        use std::iter::Iterator;
        self.maintenance_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deny_maintenance_periods][crate::model::MaintenanceUpdatePolicy::deny_maintenance_periods].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::MaintenanceUpdatePolicy;
    /// use google_cloud_alloydb_v1::model::maintenance_update_policy::DenyMaintenancePeriod;
    /// let x = MaintenanceUpdatePolicy::new()
    ///     .set_deny_maintenance_periods([
    ///         DenyMaintenancePeriod::default()/* use setters */,
    ///         DenyMaintenancePeriod::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_deny_maintenance_periods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::maintenance_update_policy::DenyMaintenancePeriod>,
    {
        use std::iter::Iterator;
        self.deny_maintenance_periods = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenanceUpdatePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy"
    }
}

/// Defines additional types related to [MaintenanceUpdatePolicy].
pub mod maintenance_update_policy {
    #[allow(unused_imports)]
    use super::*;

    /// MaintenanceWindow specifies a preferred day and time for maintenance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MaintenanceWindow {
        /// Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
        pub day: gtype::model::DayOfWeek,

        /// Preferred time to start the maintenance operation on the specified day.
        /// Maintenance will start within 1 hour of this time.
        pub start_time: std::option::Option<gtype::model::TimeOfDay>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MaintenanceWindow {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [day][crate::model::maintenance_update_policy::MaintenanceWindow::day].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::MaintenanceWindow;
        /// use gtype::model::DayOfWeek;
        /// let x0 = MaintenanceWindow::new().set_day(DayOfWeek::Monday);
        /// let x1 = MaintenanceWindow::new().set_day(DayOfWeek::Tuesday);
        /// let x2 = MaintenanceWindow::new().set_day(DayOfWeek::Wednesday);
        /// ```
        pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
            self.day = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::maintenance_update_policy::MaintenanceWindow::start_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::MaintenanceWindow;
        /// use gtype::model::TimeOfDay;
        /// let x = MaintenanceWindow::new().set_start_time(TimeOfDay::default()/* use setters */);
        /// ```
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::maintenance_update_policy::MaintenanceWindow::start_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::MaintenanceWindow;
        /// use gtype::model::TimeOfDay;
        /// let x = MaintenanceWindow::new().set_or_clear_start_time(Some(TimeOfDay::default()/* use setters */));
        /// let x = MaintenanceWindow::new().set_or_clear_start_time(None::<TimeOfDay>);
        /// ```
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MaintenanceWindow {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy.MaintenanceWindow"
        }
    }

    /// DenyMaintenancePeriod definition. Excepting emergencies, maintenance
    /// will not be scheduled to start within this deny period. The start_date must
    /// be less than the end_date.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DenyMaintenancePeriod {
        /// Deny period start date.
        /// This can be:
        ///
        /// * A full date, with non-zero year, month and day values OR
        /// * A month and day value, with a zero year for recurring
        pub start_date: std::option::Option<gtype::model::Date>,

        /// Deny period end date.
        /// This can be:
        ///
        /// * A full date, with non-zero year, month and day values OR
        /// * A month and day value, with a zero year for recurring
        pub end_date: std::option::Option<gtype::model::Date>,

        /// Time in UTC when the deny period starts on start_date and ends on
        /// end_date. This can be:
        ///
        /// * Full time OR
        /// * All zeros for 00:00:00 UTC
        pub time: std::option::Option<gtype::model::TimeOfDay>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DenyMaintenancePeriod {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::start_date].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::DenyMaintenancePeriod;
        /// use gtype::model::Date;
        /// let x = DenyMaintenancePeriod::new().set_start_date(Date::default()/* use setters */);
        /// ```
        pub fn set_start_date<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.start_date = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::start_date].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::DenyMaintenancePeriod;
        /// use gtype::model::Date;
        /// let x = DenyMaintenancePeriod::new().set_or_clear_start_date(Some(Date::default()/* use setters */));
        /// let x = DenyMaintenancePeriod::new().set_or_clear_start_date(None::<Date>);
        /// ```
        pub fn set_or_clear_start_date<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.start_date = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::end_date].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::DenyMaintenancePeriod;
        /// use gtype::model::Date;
        /// let x = DenyMaintenancePeriod::new().set_end_date(Date::default()/* use setters */);
        /// ```
        pub fn set_end_date<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.end_date = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::end_date].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::DenyMaintenancePeriod;
        /// use gtype::model::Date;
        /// let x = DenyMaintenancePeriod::new().set_or_clear_end_date(Some(Date::default()/* use setters */));
        /// let x = DenyMaintenancePeriod::new().set_or_clear_end_date(None::<Date>);
        /// ```
        pub fn set_or_clear_end_date<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.end_date = v.map(|x| x.into());
            self
        }

        /// Sets the value of [time][crate::model::maintenance_update_policy::DenyMaintenancePeriod::time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::DenyMaintenancePeriod;
        /// use gtype::model::TimeOfDay;
        /// let x = DenyMaintenancePeriod::new().set_time(TimeOfDay::default()/* use setters */);
        /// ```
        pub fn set_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time][crate::model::maintenance_update_policy::DenyMaintenancePeriod::time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::maintenance_update_policy::DenyMaintenancePeriod;
        /// use gtype::model::TimeOfDay;
        /// let x = DenyMaintenancePeriod::new().set_or_clear_time(Some(TimeOfDay::default()/* use setters */));
        /// let x = DenyMaintenancePeriod::new().set_or_clear_time(None::<TimeOfDay>);
        /// ```
        pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DenyMaintenancePeriod {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy.DenyMaintenancePeriod"
        }
    }
}

/// MaintenanceSchedule stores the maintenance schedule generated from
/// the MaintenanceUpdatePolicy, once a maintenance rollout is triggered, if
/// MaintenanceWindow is set, and if there is no conflicting DenyPeriod.
/// The schedule is cleared once the update takes place. This field cannot be
/// manually changed; modify the MaintenanceUpdatePolicy instead.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceSchedule {
    /// Output only. The scheduled start time for the maintenance.
    pub start_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::MaintenanceSchedule::start_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::MaintenanceSchedule;
    /// use wkt::Timestamp;
    /// let x = MaintenanceSchedule::new().set_start_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::MaintenanceSchedule::start_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::MaintenanceSchedule;
    /// use wkt::Timestamp;
    /// let x = MaintenanceSchedule::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
    /// let x = MaintenanceSchedule::new().set_or_clear_start_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaintenanceSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceSchedule"
    }
}

/// A cluster is a collection of regional AlloyDB resources. It can include a
/// primary instance and one or more read pool instances.
/// All cluster resources share a storage layer, which scales as needed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// Output only. The name of the cluster resource with the format:
    ///
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}
    ///   where the cluster ID segment should satisfy the regex expression
    ///   `[a-z0-9-]+`. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the cluster resource name is the name of the parent resource:
    /// * projects/{project}/locations/{region}
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Cluster.
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    pub uid: std::string::String,

    /// Output only. Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current serving state of the cluster.
    pub state: crate::model::cluster::State,

    /// Output only. The type of the cluster. This is an output-only field and it's
    /// populated at the Cluster creation time or the Cluster promotion
    /// time. The cluster type is determined by which RPC was used to create
    /// the cluster (i.e. `CreateCluster` vs. `CreateSecondaryCluster`
    pub cluster_type: crate::model::cluster::ClusterType,

    /// Optional. The database engine major version. This is an optional field and
    /// it is populated at the Cluster creation time. If a database version is not
    /// supplied at cluster creation time, then a default database version will
    /// be used.
    pub database_version: crate::model::DatabaseVersion,

    pub network_config: std::option::Option<crate::model::cluster::NetworkConfig>,

    /// Required. The resource link for the VPC network in which cluster resources
    /// are created and from which they are accessible via Private IP. The network
    /// must belong to the same project as the cluster. It is specified in the
    /// form: `projects/{project}/global/networks/{network_id}`. This is required
    /// to create a cluster. Deprecated, use network_config.network instead.
    #[deprecated]
    pub network: std::string::String,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Cluster does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    pub reconciling: bool,

    /// Input only. Initial user to setup during cluster creation. Required.
    /// If used in `RestoreCluster` this is ignored.
    pub initial_user: std::option::Option<crate::model::UserPassword>,

    /// The automated backup policy for this cluster.
    ///
    /// If no policy is provided then the default policy will be used. If backups
    /// are supported for the cluster, the default policy takes one backup a day,
    /// has a backup window of 1 hour, and retains backups for 14 days.
    /// For more information on the defaults, consult the
    /// documentation for the message type.
    pub automated_backup_policy: std::option::Option<crate::model::AutomatedBackupPolicy>,

    /// SSL configuration for this AlloyDB cluster.
    #[deprecated]
    pub ssl_config: std::option::Option<crate::model::SslConfig>,

    /// Optional. The encryption config can be specified to encrypt the data disks
    /// and other persistent data resources of a cluster with a
    /// customer-managed encryption key (CMEK). When this field is not
    /// specified, the cluster will then use default encryption scheme to
    /// protect the user data.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Output only. The encryption information for the cluster.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Optional. Continuous backup configuration for this cluster.
    pub continuous_backup_config: std::option::Option<crate::model::ContinuousBackupConfig>,

    /// Output only. Continuous backup properties for this cluster.
    pub continuous_backup_info: std::option::Option<crate::model::ContinuousBackupInfo>,

    /// Cross Region replication config specific to SECONDARY cluster.
    pub secondary_config: std::option::Option<crate::model::cluster::SecondaryConfig>,

    /// Output only. Cross Region replication config specific to PRIMARY cluster.
    pub primary_config: std::option::Option<crate::model::cluster::PrimaryConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. The configuration for Private Service Connect (PSC) for the
    /// cluster.
    pub psc_config: std::option::Option<crate::model::cluster::PscConfig>,

    /// Optional. The maintenance update policy determines when to allow or deny
    /// updates.
    pub maintenance_update_policy: std::option::Option<crate::model::MaintenanceUpdatePolicy>,

    /// Output only. The maintenance schedule for the cluster, generated for a
    /// specific rollout if a maintenance window is set.
    pub maintenance_schedule: std::option::Option<crate::model::MaintenanceSchedule>,

    /// Optional. Subscription type of the cluster.
    pub subscription_type: crate::model::SubscriptionType,

    /// Output only. Metadata for free trial clusters
    pub trial_metadata: std::option::Option<crate::model::cluster::TrialMetadata>,

    /// Optional. Input only. Immutable. Tag keys/values directly bound to this
    /// resource. For example:
    ///
    /// ```norust
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    /// ```
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    pub source: std::option::Option<crate::model::cluster::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Cluster::display_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Cluster::uid].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_uid("example");
    /// ```
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use wkt::Timestamp;
    /// let x = Cluster::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Cluster::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use wkt::Timestamp;
    /// let x = Cluster::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use wkt::Timestamp;
    /// let x = Cluster::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Cluster::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use wkt::Timestamp;
    /// let x = Cluster::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Cluster::delete_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use wkt::Timestamp;
    /// let x = Cluster::new().set_delete_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Cluster::delete_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use wkt::Timestamp;
    /// let x = Cluster::new().set_or_clear_delete_time(Some(Timestamp::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_delete_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::State;
    /// let x0 = Cluster::new().set_state(State::Ready);
    /// let x1 = Cluster::new().set_state(State::Stopped);
    /// let x2 = Cluster::new().set_state(State::Empty);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cluster_type][crate::model::Cluster::cluster_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::ClusterType;
    /// let x0 = Cluster::new().set_cluster_type(ClusterType::Primary);
    /// let x1 = Cluster::new().set_cluster_type(ClusterType::Secondary);
    /// ```
    pub fn set_cluster_type<T: std::convert::Into<crate::model::cluster::ClusterType>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_type = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::Cluster::database_version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::DatabaseVersion;
    /// let x0 = Cluster::new().set_database_version(DatabaseVersion::Postgres14);
    /// let x1 = Cluster::new().set_database_version(DatabaseVersion::Postgres15);
    /// let x2 = Cluster::new().set_database_version(DatabaseVersion::Postgres16);
    /// ```
    pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::Cluster::network_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::NetworkConfig;
    /// let x = Cluster::new().set_network_config(NetworkConfig::default()/* use setters */);
    /// ```
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::Cluster::network_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::NetworkConfig;
    /// let x = Cluster::new().set_or_clear_network_config(Some(NetworkConfig::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_network_config(None::<NetworkConfig>);
    /// ```
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::Cluster::network].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_network("example");
    /// ```
    #[deprecated]
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Cluster::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Cluster::annotations].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_annotations([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [reconciling][crate::model::Cluster::reconciling].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_reconciling(true);
    /// ```
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [initial_user][crate::model::Cluster::initial_user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::UserPassword;
    /// let x = Cluster::new().set_initial_user(UserPassword::default()/* use setters */);
    /// ```
    pub fn set_initial_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserPassword>,
    {
        self.initial_user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_user][crate::model::Cluster::initial_user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::UserPassword;
    /// let x = Cluster::new().set_or_clear_initial_user(Some(UserPassword::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_initial_user(None::<UserPassword>);
    /// ```
    pub fn set_or_clear_initial_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserPassword>,
    {
        self.initial_user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_backup_policy][crate::model::Cluster::automated_backup_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// let x = Cluster::new().set_automated_backup_policy(AutomatedBackupPolicy::default()/* use setters */);
    /// ```
    pub fn set_automated_backup_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupPolicy>,
    {
        self.automated_backup_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automated_backup_policy][crate::model::Cluster::automated_backup_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::AutomatedBackupPolicy;
    /// let x = Cluster::new().set_or_clear_automated_backup_policy(Some(AutomatedBackupPolicy::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_automated_backup_policy(None::<AutomatedBackupPolicy>);
    /// ```
    pub fn set_or_clear_automated_backup_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupPolicy>,
    {
        self.automated_backup_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_config][crate::model::Cluster::ssl_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::SslConfig;
    /// let x = Cluster::new().set_ssl_config(SslConfig::default()/* use setters */);
    /// ```
    #[deprecated]
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::Cluster::ssl_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::SslConfig;
    /// let x = Cluster::new().set_or_clear_ssl_config(Some(SslConfig::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_ssl_config(None::<SslConfig>);
    /// ```
    #[deprecated]
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_config][crate::model::Cluster::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = Cluster::new().set_encryption_config(EncryptionConfig::default()/* use setters */);
    /// ```
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::Cluster::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = Cluster::new().set_or_clear_encryption_config(Some(EncryptionConfig::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_encryption_config(None::<EncryptionConfig>);
    /// ```
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_info][crate::model::Cluster::encryption_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// let x = Cluster::new().set_encryption_info(EncryptionInfo::default()/* use setters */);
    /// ```
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::Cluster::encryption_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// let x = Cluster::new().set_or_clear_encryption_info(Some(EncryptionInfo::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_encryption_info(None::<EncryptionInfo>);
    /// ```
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [continuous_backup_config][crate::model::Cluster::continuous_backup_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::ContinuousBackupConfig;
    /// let x = Cluster::new().set_continuous_backup_config(ContinuousBackupConfig::default()/* use setters */);
    /// ```
    pub fn set_continuous_backup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupConfig>,
    {
        self.continuous_backup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [continuous_backup_config][crate::model::Cluster::continuous_backup_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::ContinuousBackupConfig;
    /// let x = Cluster::new().set_or_clear_continuous_backup_config(Some(ContinuousBackupConfig::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_continuous_backup_config(None::<ContinuousBackupConfig>);
    /// ```
    pub fn set_or_clear_continuous_backup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupConfig>,
    {
        self.continuous_backup_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [continuous_backup_info][crate::model::Cluster::continuous_backup_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// let x = Cluster::new().set_continuous_backup_info(ContinuousBackupInfo::default()/* use setters */);
    /// ```
    pub fn set_continuous_backup_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupInfo>,
    {
        self.continuous_backup_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [continuous_backup_info][crate::model::Cluster::continuous_backup_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::ContinuousBackupInfo;
    /// let x = Cluster::new().set_or_clear_continuous_backup_info(Some(ContinuousBackupInfo::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_continuous_backup_info(None::<ContinuousBackupInfo>);
    /// ```
    pub fn set_or_clear_continuous_backup_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupInfo>,
    {
        self.continuous_backup_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_config][crate::model::Cluster::secondary_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::SecondaryConfig;
    /// let x = Cluster::new().set_secondary_config(SecondaryConfig::default()/* use setters */);
    /// ```
    pub fn set_secondary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SecondaryConfig>,
    {
        self.secondary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_config][crate::model::Cluster::secondary_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::SecondaryConfig;
    /// let x = Cluster::new().set_or_clear_secondary_config(Some(SecondaryConfig::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_secondary_config(None::<SecondaryConfig>);
    /// ```
    pub fn set_or_clear_secondary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SecondaryConfig>,
    {
        self.secondary_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [primary_config][crate::model::Cluster::primary_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::PrimaryConfig;
    /// let x = Cluster::new().set_primary_config(PrimaryConfig::default()/* use setters */);
    /// ```
    pub fn set_primary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PrimaryConfig>,
    {
        self.primary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_config][crate::model::Cluster::primary_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::PrimaryConfig;
    /// let x = Cluster::new().set_or_clear_primary_config(Some(PrimaryConfig::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_primary_config(None::<PrimaryConfig>);
    /// ```
    pub fn set_or_clear_primary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PrimaryConfig>,
    {
        self.primary_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_satisfies_pzs(true);
    /// ```
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::Cluster::psc_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::PscConfig;
    /// let x = Cluster::new().set_psc_config(PscConfig::default()/* use setters */);
    /// ```
    pub fn set_psc_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PscConfig>,
    {
        self.psc_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_config][crate::model::Cluster::psc_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::PscConfig;
    /// let x = Cluster::new().set_or_clear_psc_config(Some(PscConfig::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_psc_config(None::<PscConfig>);
    /// ```
    pub fn set_or_clear_psc_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PscConfig>,
    {
        self.psc_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_update_policy][crate::model::Cluster::maintenance_update_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::MaintenanceUpdatePolicy;
    /// let x = Cluster::new().set_maintenance_update_policy(MaintenanceUpdatePolicy::default()/* use setters */);
    /// ```
    pub fn set_maintenance_update_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceUpdatePolicy>,
    {
        self.maintenance_update_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_update_policy][crate::model::Cluster::maintenance_update_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::MaintenanceUpdatePolicy;
    /// let x = Cluster::new().set_or_clear_maintenance_update_policy(Some(MaintenanceUpdatePolicy::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_maintenance_update_policy(None::<MaintenanceUpdatePolicy>);
    /// ```
    pub fn set_or_clear_maintenance_update_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceUpdatePolicy>,
    {
        self.maintenance_update_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::MaintenanceSchedule;
    /// let x = Cluster::new().set_maintenance_schedule(MaintenanceSchedule::default()/* use setters */);
    /// ```
    pub fn set_maintenance_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceSchedule>,
    {
        self.maintenance_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::MaintenanceSchedule;
    /// let x = Cluster::new().set_or_clear_maintenance_schedule(Some(MaintenanceSchedule::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_maintenance_schedule(None::<MaintenanceSchedule>);
    /// ```
    pub fn set_or_clear_maintenance_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceSchedule>,
    {
        self.maintenance_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subscription_type][crate::model::Cluster::subscription_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::SubscriptionType;
    /// let x0 = Cluster::new().set_subscription_type(SubscriptionType::Standard);
    /// let x1 = Cluster::new().set_subscription_type(SubscriptionType::Trial);
    /// ```
    pub fn set_subscription_type<T: std::convert::Into<crate::model::SubscriptionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.subscription_type = v.into();
        self
    }

    /// Sets the value of [trial_metadata][crate::model::Cluster::trial_metadata].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
    /// let x = Cluster::new().set_trial_metadata(TrialMetadata::default()/* use setters */);
    /// ```
    pub fn set_trial_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::TrialMetadata>,
    {
        self.trial_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trial_metadata][crate::model::Cluster::trial_metadata].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
    /// let x = Cluster::new().set_or_clear_trial_metadata(Some(TrialMetadata::default()/* use setters */));
    /// let x = Cluster::new().set_or_clear_trial_metadata(None::<TrialMetadata>);
    /// ```
    pub fn set_or_clear_trial_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::TrialMetadata>,
    {
        self.trial_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::Cluster::tags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// let x = Cluster::new().set_tags([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source][crate::model::Cluster::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::cluster;
    /// use google_cloud_alloydb_v1::model::BackupSource;
    /// let x = Cluster::new().set_source(Some(cluster::Source::BackupSource(BackupSource::default().into())));
    /// ```
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::cluster::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `BackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::BackupSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `BackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::BackupSource;
    /// let x = Cluster::new().set_backup_source(BackupSource::default()/* use setters */);
    /// assert!(x.backup_source().is_some());
    /// assert!(x.migration_source().is_none());
    /// assert!(x.cloudsql_backup_run_source().is_none());
    /// ```
    pub fn set_backup_source<T: std::convert::Into<std::boxed::Box<crate::model::BackupSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::cluster::Source::BackupSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `MigrationSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn migration_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MigrationSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::MigrationSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `MigrationSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::MigrationSource;
    /// let x = Cluster::new().set_migration_source(MigrationSource::default()/* use setters */);
    /// assert!(x.migration_source().is_some());
    /// assert!(x.backup_source().is_none());
    /// assert!(x.cloudsql_backup_run_source().is_none());
    /// ```
    pub fn set_migration_source<
        T: std::convert::Into<std::boxed::Box<crate::model::MigrationSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::cluster::Source::MigrationSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `CloudsqlBackupRunSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloudsql_backup_run_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSQLBackupRunSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::CloudsqlBackupRunSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `CloudsqlBackupRunSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Cluster;
    /// use google_cloud_alloydb_v1::model::CloudSQLBackupRunSource;
    /// let x = Cluster::new().set_cloudsql_backup_run_source(CloudSQLBackupRunSource::default()/* use setters */);
    /// assert!(x.cloudsql_backup_run_source().is_some());
    /// assert!(x.backup_source().is_none());
    /// assert!(x.migration_source().is_none());
    /// ```
    pub fn set_cloudsql_backup_run_source<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSQLBackupRunSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::cluster::Source::CloudsqlBackupRunSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Cluster"
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata related to network configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkConfig {
        /// Optional. The resource link for the VPC network in which cluster
        /// resources are created and from which they are accessible via Private IP.
        /// The network must belong to the same project as the cluster. It is
        /// specified in the form:
        /// `projects/{project_number}/global/networks/{network_id}`. This is
        /// required to create a cluster.
        pub network: std::string::String,

        /// Optional. Name of the allocated IP range for the private IP AlloyDB
        /// cluster, for example: "google-managed-services-default". If set, the
        /// instance IPs for this cluster will be created in the allocated range. The
        /// range name must comply with RFC 1035. Specifically, the name must be 1-63
        /// characters long and match the regular expression
        /// `[a-z]([-a-z0-9]*[a-z0-9])?`.
        /// Field name is intended to be consistent with Cloud SQL.
        pub allocated_ip_range: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::cluster::NetworkConfig::network].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::NetworkConfig;
        /// let x = NetworkConfig::new().set_network("example");
        /// ```
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [allocated_ip_range][crate::model::cluster::NetworkConfig::allocated_ip_range].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::NetworkConfig;
        /// let x = NetworkConfig::new().set_allocated_ip_range("example");
        /// ```
        pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allocated_ip_range = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.NetworkConfig"
        }
    }

    /// Configuration information for the secondary cluster. This should be set
    /// if and only if the cluster is of type SECONDARY.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SecondaryConfig {
        /// The name of the primary cluster name with the format:
        ///
        /// * projects/{project}/locations/{region}/clusters/{cluster_id}
        pub primary_cluster_name: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SecondaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primary_cluster_name][crate::model::cluster::SecondaryConfig::primary_cluster_name].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::SecondaryConfig;
        /// let x = SecondaryConfig::new().set_primary_cluster_name("example");
        /// ```
        pub fn set_primary_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.primary_cluster_name = v.into();
            self
        }
    }

    impl wkt::message::Message for SecondaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.SecondaryConfig"
        }
    }

    /// Configuration for the primary cluster. It has the list of clusters that are
    /// replicating from this cluster. This should be set if and only if the
    /// cluster is of type PRIMARY.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PrimaryConfig {
        /// Output only. Names of the clusters that are replicating from this
        /// cluster.
        pub secondary_cluster_names: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrimaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [secondary_cluster_names][crate::model::cluster::PrimaryConfig::secondary_cluster_names].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::PrimaryConfig;
        /// let x = PrimaryConfig::new().set_secondary_cluster_names(["a", "b", "c"]);
        /// ```
        pub fn set_secondary_cluster_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.secondary_cluster_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PrimaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.PrimaryConfig"
        }
    }

    /// PscConfig contains PSC related configuration at a cluster level.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscConfig {
        /// Optional. Create an instance that allows connections from Private Service
        /// Connect endpoints to the instance.
        pub psc_enabled: bool,

        /// Output only. The project number that needs to be allowlisted on the
        /// network attachment to enable outbound connectivity.
        pub service_owned_project_number: i64,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [psc_enabled][crate::model::cluster::PscConfig::psc_enabled].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::PscConfig;
        /// let x = PscConfig::new().set_psc_enabled(true);
        /// ```
        pub fn set_psc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.psc_enabled = v.into();
            self
        }

        /// Sets the value of [service_owned_project_number][crate::model::cluster::PscConfig::service_owned_project_number].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::PscConfig;
        /// let x = PscConfig::new().set_service_owned_project_number(42);
        /// ```
        pub fn set_service_owned_project_number<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_owned_project_number = v.into();
            self
        }
    }

    impl wkt::message::Message for PscConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.PscConfig"
        }
    }

    /// Contains information and all metadata related to TRIAL clusters.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TrialMetadata {
        /// start time of the trial cluster.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// End time of the trial cluster.
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Upgrade time of trial cluster to Standard cluster.
        pub upgrade_time: std::option::Option<wkt::Timestamp>,

        /// grace end time of the cluster.
        pub grace_end_time: std::option::Option<wkt::Timestamp>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TrialMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::cluster::TrialMetadata::start_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_start_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::cluster::TrialMetadata::start_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_or_clear_start_time(Some(Timestamp::default()/* use setters */));
        /// let x = TrialMetadata::new().set_or_clear_start_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::cluster::TrialMetadata::end_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_end_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::cluster::TrialMetadata::end_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
        /// let x = TrialMetadata::new().set_or_clear_end_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [upgrade_time][crate::model::cluster::TrialMetadata::upgrade_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_upgrade_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_upgrade_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.upgrade_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [upgrade_time][crate::model::cluster::TrialMetadata::upgrade_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_or_clear_upgrade_time(Some(Timestamp::default()/* use setters */));
        /// let x = TrialMetadata::new().set_or_clear_upgrade_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_upgrade_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.upgrade_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [grace_end_time][crate::model::cluster::TrialMetadata::grace_end_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_grace_end_time(Timestamp::default()/* use setters */);
        /// ```
        pub fn set_grace_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.grace_end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [grace_end_time][crate::model::cluster::TrialMetadata::grace_end_time].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::cluster::TrialMetadata;
        /// use wkt::Timestamp;
        /// let x = TrialMetadata::new().set_or_clear_grace_end_time(Some(Timestamp::default()/* use setters */));
        /// let x = TrialMetadata::new().set_or_clear_grace_end_time(None::<Timestamp>);
        /// ```
        pub fn set_or_clear_grace_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.grace_end_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TrialMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.TrialMetadata"
        }
    }

    /// Cluster State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the cluster is unknown.
        Unspecified,
        /// The cluster is active and running.
        Ready,
        /// This is unused. Even when all instances in the cluster are stopped, the
        /// cluster remains in READY state.
        Stopped,
        /// The cluster is empty and has no associated resources.
        /// All instances, associated storage and backups have been deleted.
        Empty,
        /// The cluster is being created.
        Creating,
        /// The cluster is being deleted.
        Deleting,
        /// The creation of the cluster failed.
        Failed,
        /// The cluster is bootstrapping with data from some other source.
        /// Direct mutations to the cluster (e.g. adding read pool) are not allowed.
        Bootstrapping,
        /// The cluster is under maintenance. AlloyDB regularly performs maintenance
        /// and upgrades on customer clusters. Updates on the cluster are
        /// not allowed while the cluster is in this state.
        Maintenance,
        /// The cluster is being promoted.
        Promoting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Stopped => std::option::Option::Some(2),
                Self::Empty => std::option::Option::Some(3),
                Self::Creating => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Bootstrapping => std::option::Option::Some(7),
                Self::Maintenance => std::option::Option::Some(8),
                Self::Promoting => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Empty => std::option::Option::Some("EMPTY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Bootstrapping => std::option::Option::Some("BOOTSTRAPPING"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Promoting => std::option::Option::Some("PROMOTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Stopped,
                3 => Self::Empty,
                4 => Self::Creating,
                5 => Self::Deleting,
                6 => Self::Failed,
                7 => Self::Bootstrapping,
                8 => Self::Maintenance,
                9 => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "STOPPED" => Self::Stopped,
                "EMPTY" => Self::Empty,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "BOOTSTRAPPING" => Self::Bootstrapping,
                "MAINTENANCE" => Self::Maintenance,
                "PROMOTING" => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Stopped => serializer.serialize_i32(2),
                Self::Empty => serializer.serialize_i32(3),
                Self::Creating => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Bootstrapping => serializer.serialize_i32(7),
                Self::Maintenance => serializer.serialize_i32(8),
                Self::Promoting => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.Cluster.State",
            ))
        }
    }

    /// Type of Cluster
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterType {
        /// The type of the cluster is unknown.
        Unspecified,
        /// Primary cluster that support read and write operations.
        Primary,
        /// Secondary cluster that is replicating from another region.
        /// This only supports read.
        Secondary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClusterType::value] or
        /// [ClusterType::name].
        UnknownValue(cluster_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClusterType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::Secondary => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_TYPE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Secondary => std::option::Option::Some("SECONDARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClusterType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClusterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClusterType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::Secondary,
                _ => Self::UnknownValue(cluster_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClusterType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "SECONDARY" => Self::Secondary,
                _ => Self::UnknownValue(cluster_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClusterType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::Secondary => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClusterType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterType>::new(
                ".google.cloud.alloydb.v1.Cluster.ClusterType",
            ))
        }
    }

    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Output only. Cluster created from backup.
        BackupSource(std::boxed::Box<crate::model::BackupSource>),
        /// Output only. Cluster created via DMS migration.
        MigrationSource(std::boxed::Box<crate::model::MigrationSource>),
        /// Output only. Cluster created from CloudSQL snapshot.
        CloudsqlBackupRunSource(std::boxed::Box<crate::model::CloudSQLBackupRunSource>),
    }
}

/// An Instance is a computing unit that an end customer can connect to.
/// It's the main unit of computing resources in AlloyDB.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The name of the instance resource with the format:
    ///
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}/instances/{instance_id}
    ///   where the cluster and instance ID segments should satisfy the regex
    ///   expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
    ///   lowercase letters, numbers, and dashes, starting with a letter, and ending
    ///   with a letter or number. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the instance resource name is the name of the parent
    ///   resource:
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Instance.
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    pub uid: std::string::String,

    /// Output only. Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current serving state of the instance.
    pub state: crate::model::instance::State,

    /// Required. The type of the instance. Specified at creation time.
    pub instance_type: crate::model::instance::InstanceType,

    /// Configurations for the machines that host the underlying
    /// database engine.
    pub machine_config: std::option::Option<crate::model::instance::MachineConfig>,

    /// Availability type of an Instance.
    /// If empty, defaults to REGIONAL for primary instances.
    /// For read pools, availability_type is always UNSPECIFIED. Instances in the
    /// read pools are evenly distributed across available zones within the region
    /// (i.e. read pools with more than one node will have a node in at
    /// least two zones).
    pub availability_type: crate::model::instance::AvailabilityType,

    /// The Compute Engine zone that the instance should serve from, per
    /// <https://cloud.google.com/compute/docs/regions-zones>
    /// This can ONLY be specified for ZONAL instances.
    /// If present for a REGIONAL instance, an error will be thrown.
    /// If this is absent for a ZONAL instance, instance is created in a random
    /// zone with available capacity.
    pub gce_zone: std::string::String,

    /// Database flags. Set at the instance level.
    /// They are copied from the primary instance on secondary instance creation.
    /// Flags that have restrictions default to the value at primary
    /// instance on read instances during creation. Read instances can set new
    /// flags or override existing flags that are relevant for reads, for example,
    /// for enabling columnar cache on a read instance. Flags set on read instance
    /// might or might not be present on the primary instance.
    ///
    /// This is a list of "key": "value" pairs.
    /// "key": The name of the flag. These flags are passed at instance setup time,
    /// so include both server options and system variables for Postgres. Flags are
    /// specified with underscores, not hyphens.
    /// "value": The value of the flag. Booleans are set to **on** for true
    /// and **off** for false. This field must be omitted if the flag
    /// doesn't take a value.
    pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. This is set for the read-write VM of the PRIMARY instance
    /// only.
    pub writable_node: std::option::Option<crate::model::instance::Node>,

    /// Output only. List of available read-only VMs in this instance, including
    /// the standby for a PRIMARY instance.
    pub nodes: std::vec::Vec<crate::model::instance::Node>,

    /// Configuration for query insights.
    pub query_insights_config:
        std::option::Option<crate::model::instance::QueryInsightsInstanceConfig>,

    /// Configuration for observability.
    pub observability_config:
        std::option::Option<crate::model::instance::ObservabilityInstanceConfig>,

    /// Read pool instance configuration.
    /// This is required if the value of instanceType is READ_POOL.
    pub read_pool_config: std::option::Option<crate::model::instance::ReadPoolConfig>,

    /// Output only. The IP address for the Instance.
    /// This is the connection endpoint for an end-user application.
    pub ip_address: std::string::String,

    /// Output only. The public IP addresses for the Instance. This is available
    /// ONLY when enable_public_ip is set. This is the connection endpoint for an
    /// end-user application.
    pub public_ip_address: std::string::String,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Instance does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    pub reconciling: bool,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Client connection specific configurations
    pub client_connection_config:
        std::option::Option<crate::model::instance::ClientConnectionConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. The configuration for Private Service Connect (PSC) for the
    /// instance.
    pub psc_instance_config: std::option::Option<crate::model::instance::PscInstanceConfig>,

    /// Optional. Instance-level network configuration.
    pub network_config: std::option::Option<crate::model::instance::InstanceNetworkConfig>,

    /// Output only. All outbound public IP addresses configured for the instance.
    pub outbound_public_ip_addresses: std::vec::Vec<std::string::String>,

    /// Optional. Specifies whether an instance needs to spin up. Once the instance
    /// is active, the activation policy can be updated to the `NEVER` to stop the
    /// instance. Likewise, the activation policy can be updated to `ALWAYS` to
    /// start the instance.
    /// There are restrictions around when an instance can/cannot be activated (for
    /// example, a read pool instance should be stopped before stopping primary
    /// etc.). Please refer to the API documentation for more details.
    pub activation_policy: crate::model::instance::ActivationPolicy,

    /// Optional. The configuration for Managed Connection Pool (MCP).
    pub connection_pool_config: std::option::Option<crate::model::instance::ConnectionPoolConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Instance::uid].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_uid("example");
    /// ```
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Instance::delete_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_delete_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Instance::delete_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use wkt::Timestamp;
    /// let x = Instance::new().set_or_clear_delete_time(Some(Timestamp::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_delete_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::State;
    /// let x0 = Instance::new().set_state(State::Ready);
    /// let x1 = Instance::new().set_state(State::Stopped);
    /// let x2 = Instance::new().set_state(State::Creating);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::Instance::instance_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::InstanceType;
    /// let x0 = Instance::new().set_instance_type(InstanceType::Primary);
    /// let x1 = Instance::new().set_instance_type(InstanceType::ReadPool);
    /// let x2 = Instance::new().set_instance_type(InstanceType::Secondary);
    /// ```
    pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [machine_config][crate::model::Instance::machine_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::MachineConfig;
    /// let x = Instance::new().set_machine_config(MachineConfig::default()/* use setters */);
    /// ```
    pub fn set_machine_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::MachineConfig>,
    {
        self.machine_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_config][crate::model::Instance::machine_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::MachineConfig;
    /// let x = Instance::new().set_or_clear_machine_config(Some(MachineConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_machine_config(None::<MachineConfig>);
    /// ```
    pub fn set_or_clear_machine_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::MachineConfig>,
    {
        self.machine_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [availability_type][crate::model::Instance::availability_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::AvailabilityType;
    /// let x0 = Instance::new().set_availability_type(AvailabilityType::Zonal);
    /// let x1 = Instance::new().set_availability_type(AvailabilityType::Regional);
    /// ```
    pub fn set_availability_type<
        T: std::convert::Into<crate::model::instance::AvailabilityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [gce_zone][crate::model::Instance::gce_zone].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_gce_zone("example");
    /// ```
    pub fn set_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gce_zone = v.into();
        self
    }

    /// Sets the value of [database_flags][crate::model::Instance::database_flags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_database_flags([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [writable_node][crate::model::Instance::writable_node].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::Node;
    /// let x = Instance::new().set_writable_node(Node::default()/* use setters */);
    /// ```
    pub fn set_writable_node<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::Node>,
    {
        self.writable_node = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [writable_node][crate::model::Instance::writable_node].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::Node;
    /// let x = Instance::new().set_or_clear_writable_node(Some(Node::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_writable_node(None::<Node>);
    /// ```
    pub fn set_or_clear_writable_node<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::Node>,
    {
        self.writable_node = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nodes][crate::model::Instance::nodes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::Node;
    /// let x = Instance::new()
    ///     .set_nodes([
    ///         Node::default()/* use setters */,
    ///         Node::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::Node>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [query_insights_config][crate::model::Instance::query_insights_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
    /// let x = Instance::new().set_query_insights_config(QueryInsightsInstanceConfig::default()/* use setters */);
    /// ```
    pub fn set_query_insights_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::QueryInsightsInstanceConfig>,
    {
        self.query_insights_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_insights_config][crate::model::Instance::query_insights_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
    /// let x = Instance::new().set_or_clear_query_insights_config(Some(QueryInsightsInstanceConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_query_insights_config(None::<QueryInsightsInstanceConfig>);
    /// ```
    pub fn set_or_clear_query_insights_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::QueryInsightsInstanceConfig>,
    {
        self.query_insights_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [observability_config][crate::model::Instance::observability_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
    /// let x = Instance::new().set_observability_config(ObservabilityInstanceConfig::default()/* use setters */);
    /// ```
    pub fn set_observability_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::ObservabilityInstanceConfig>,
    {
        self.observability_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [observability_config][crate::model::Instance::observability_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
    /// let x = Instance::new().set_or_clear_observability_config(Some(ObservabilityInstanceConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_observability_config(None::<ObservabilityInstanceConfig>);
    /// ```
    pub fn set_or_clear_observability_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::ObservabilityInstanceConfig>,
    {
        self.observability_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [read_pool_config][crate::model::Instance::read_pool_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ReadPoolConfig;
    /// let x = Instance::new().set_read_pool_config(ReadPoolConfig::default()/* use setters */);
    /// ```
    pub fn set_read_pool_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::ReadPoolConfig>,
    {
        self.read_pool_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_pool_config][crate::model::Instance::read_pool_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ReadPoolConfig;
    /// let x = Instance::new().set_or_clear_read_pool_config(Some(ReadPoolConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_read_pool_config(None::<ReadPoolConfig>);
    /// ```
    pub fn set_or_clear_read_pool_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::ReadPoolConfig>,
    {
        self.read_pool_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_address][crate::model::Instance::ip_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_ip_address("example");
    /// ```
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::Instance::public_ip_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_public_ip_address("example");
    /// ```
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Instance::reconciling].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_reconciling(true);
    /// ```
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Instance::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Instance::annotations].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_annotations([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [client_connection_config][crate::model::Instance::client_connection_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ClientConnectionConfig;
    /// let x = Instance::new().set_client_connection_config(ClientConnectionConfig::default()/* use setters */);
    /// ```
    pub fn set_client_connection_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::ClientConnectionConfig>,
    {
        self.client_connection_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_connection_config][crate::model::Instance::client_connection_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ClientConnectionConfig;
    /// let x = Instance::new().set_or_clear_client_connection_config(Some(ClientConnectionConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_client_connection_config(None::<ClientConnectionConfig>);
    /// ```
    pub fn set_or_clear_client_connection_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::ClientConnectionConfig>,
    {
        self.client_connection_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_satisfies_pzs(true);
    /// ```
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [psc_instance_config][crate::model::Instance::psc_instance_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::PscInstanceConfig;
    /// let x = Instance::new().set_psc_instance_config(PscInstanceConfig::default()/* use setters */);
    /// ```
    pub fn set_psc_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::PscInstanceConfig>,
    {
        self.psc_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_instance_config][crate::model::Instance::psc_instance_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::PscInstanceConfig;
    /// let x = Instance::new().set_or_clear_psc_instance_config(Some(PscInstanceConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_psc_instance_config(None::<PscInstanceConfig>);
    /// ```
    pub fn set_or_clear_psc_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::PscInstanceConfig>,
    {
        self.psc_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_config][crate::model::Instance::network_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::InstanceNetworkConfig;
    /// let x = Instance::new().set_network_config(InstanceNetworkConfig::default()/* use setters */);
    /// ```
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::InstanceNetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::Instance::network_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::InstanceNetworkConfig;
    /// let x = Instance::new().set_or_clear_network_config(Some(InstanceNetworkConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_network_config(None::<InstanceNetworkConfig>);
    /// ```
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::InstanceNetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [outbound_public_ip_addresses][crate::model::Instance::outbound_public_ip_addresses].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// let x = Instance::new().set_outbound_public_ip_addresses(["a", "b", "c"]);
    /// ```
    pub fn set_outbound_public_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.outbound_public_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [activation_policy][crate::model::Instance::activation_policy].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ActivationPolicy;
    /// let x0 = Instance::new().set_activation_policy(ActivationPolicy::Always);
    /// let x1 = Instance::new().set_activation_policy(ActivationPolicy::Never);
    /// ```
    pub fn set_activation_policy<
        T: std::convert::Into<crate::model::instance::ActivationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.activation_policy = v.into();
        self
    }

    /// Sets the value of [connection_pool_config][crate::model::Instance::connection_pool_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ConnectionPoolConfig;
    /// let x = Instance::new().set_connection_pool_config(ConnectionPoolConfig::default()/* use setters */);
    /// ```
    pub fn set_connection_pool_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::ConnectionPoolConfig>,
    {
        self.connection_pool_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_pool_config][crate::model::Instance::connection_pool_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Instance;
    /// use google_cloud_alloydb_v1::model::instance::ConnectionPoolConfig;
    /// let x = Instance::new().set_or_clear_connection_pool_config(Some(ConnectionPoolConfig::default()/* use setters */));
    /// let x = Instance::new().set_or_clear_connection_pool_config(None::<ConnectionPoolConfig>);
    /// ```
    pub fn set_or_clear_connection_pool_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::ConnectionPoolConfig>,
    {
        self.connection_pool_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// MachineConfig describes the configuration of a machine.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MachineConfig {
        /// The number of CPU's in the VM instance.
        pub cpu_count: i32,

        /// Machine type of the VM instance. E.g. "n2-highmem-4",
        /// "n2-highmem-8", "c4a-highmem-4-lssd".
        /// cpu_count must match the number of vCPUs in the machine type.
        pub machine_type: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MachineConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu_count][crate::model::instance::MachineConfig::cpu_count].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::MachineConfig;
        /// let x = MachineConfig::new().set_cpu_count(42);
        /// ```
        pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.cpu_count = v.into();
            self
        }

        /// Sets the value of [machine_type][crate::model::instance::MachineConfig::machine_type].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::MachineConfig;
        /// let x = MachineConfig::new().set_machine_type("example");
        /// ```
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }
    }

    impl wkt::message::Message for MachineConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.MachineConfig"
        }
    }

    /// Details of a single node in the instance.
    /// Nodes in an AlloyDB instance are ephemeral, they can change during
    /// update, failover, autohealing and resize operations.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Node {
        /// Output only. The Compute Engine zone of the VM e.g. "us-central1-b".
        pub zone_id: std::string::String,

        /// Output only. The identifier of the VM e.g.
        /// "test-read-0601-407e52be-ms3l".
        pub id: std::string::String,

        /// Output only. The private IP address of the VM e.g. "10.57.0.34".
        pub ip: std::string::String,

        /// Output only. Determined by state of the compute VM and postgres-service
        /// health. Compute VM state can have values listed in
        /// <https://cloud.google.com/compute/docs/instances/instance-life-cycle> and
        /// postgres-service health can have values: HEALTHY and UNHEALTHY.
        pub state: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Node {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [zone_id][crate::model::instance::Node::zone_id].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::Node;
        /// let x = Node::new().set_zone_id("example");
        /// ```
        pub fn set_zone_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone_id = v.into();
            self
        }

        /// Sets the value of [id][crate::model::instance::Node::id].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::Node;
        /// let x = Node::new().set_id("example");
        /// ```
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [ip][crate::model::instance::Node::ip].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::Node;
        /// let x = Node::new().set_ip("example");
        /// ```
        pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip = v.into();
            self
        }

        /// Sets the value of [state][crate::model::instance::Node::state].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::Node;
        /// let x = Node::new().set_state("example");
        /// ```
        pub fn set_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for Node {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.Node"
        }
    }

    /// QueryInsights Instance specific configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryInsightsInstanceConfig {
        /// Record application tags for an instance.
        /// This flag is turned "on" by default.
        pub record_application_tags: std::option::Option<bool>,

        /// Record client address for an instance. Client address is PII information.
        /// This flag is turned "on" by default.
        pub record_client_address: std::option::Option<bool>,

        /// Query string length. The default value is 1024.
        /// Any integer between 256 and 4500 is considered valid.
        pub query_string_length: u32,

        /// Number of query execution plans captured by Insights per minute
        /// for all queries combined. The default value is 5.
        /// Any integer between 0 and 20 is considered valid.
        pub query_plans_per_minute: std::option::Option<u32>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryInsightsInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [record_application_tags][crate::model::instance::QueryInsightsInstanceConfig::record_application_tags].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
        /// let x = QueryInsightsInstanceConfig::new().set_record_application_tags(true);
        /// ```
        pub fn set_record_application_tags<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [record_application_tags][crate::model::instance::QueryInsightsInstanceConfig::record_application_tags].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
        /// let x = QueryInsightsInstanceConfig::new().set_or_clear_record_application_tags(Some(false));
        /// let x = QueryInsightsInstanceConfig::new().set_or_clear_record_application_tags(None::<bool>);
        /// ```
        pub fn set_or_clear_record_application_tags<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = v.map(|x| x.into());
            self
        }

        /// Sets the value of [record_client_address][crate::model::instance::QueryInsightsInstanceConfig::record_client_address].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
        /// let x = QueryInsightsInstanceConfig::new().set_record_client_address(true);
        /// ```
        pub fn set_record_client_address<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_client_address = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [record_client_address][crate::model::instance::QueryInsightsInstanceConfig::record_client_address].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
        /// let x = QueryInsightsInstanceConfig::new().set_or_clear_record_client_address(Some(false));
        /// let x = QueryInsightsInstanceConfig::new().set_or_clear_record_client_address(None::<bool>);
        /// ```
        pub fn set_or_clear_record_client_address<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_client_address = v.map(|x| x.into());
            self
        }

        /// Sets the value of [query_string_length][crate::model::instance::QueryInsightsInstanceConfig::query_string_length].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
        /// let x = QueryInsightsInstanceConfig::new().set_query_string_length(42);
        /// ```
        pub fn set_query_string_length<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
            self.query_string_length = v.into();
            self
        }

        /// Sets the value of [query_plans_per_minute][crate::model::instance::QueryInsightsInstanceConfig::query_plans_per_minute].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
        /// let x = QueryInsightsInstanceConfig::new().set_query_plans_per_minute(42);
        /// ```
        pub fn set_query_plans_per_minute<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.query_plans_per_minute = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_plans_per_minute][crate::model::instance::QueryInsightsInstanceConfig::query_plans_per_minute].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::QueryInsightsInstanceConfig;
        /// let x = QueryInsightsInstanceConfig::new().set_or_clear_query_plans_per_minute(Some(42));
        /// let x = QueryInsightsInstanceConfig::new().set_or_clear_query_plans_per_minute(None::<i32>);
        /// ```
        pub fn set_or_clear_query_plans_per_minute<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.query_plans_per_minute = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for QueryInsightsInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.QueryInsightsInstanceConfig"
        }
    }

    /// Observability Instance specific configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ObservabilityInstanceConfig {
        /// Observability feature status for an instance.
        /// This flag is turned "off" by default.
        pub enabled: std::option::Option<bool>,

        /// Preserve comments in query string for an instance.
        /// This flag is turned "off" by default.
        pub preserve_comments: std::option::Option<bool>,

        /// Track wait events during query execution for an instance.
        /// This flag is turned "on" by default but tracking is enabled only after
        /// observability enabled flag is also turned on.
        pub track_wait_events: std::option::Option<bool>,

        /// Output only. Track wait event types during query execution for an
        /// instance. This flag is turned "on" by default but tracking is enabled
        /// only after observability enabled flag is also turned on. This is
        /// read-only flag and only modifiable by internal API.
        pub track_wait_event_types: std::option::Option<bool>,

        /// Query string length. The default value is 10k.
        pub max_query_string_length: std::option::Option<i32>,

        /// Record application tags for an instance.
        /// This flag is turned "off" by default.
        pub record_application_tags: std::option::Option<bool>,

        /// Number of query execution plans captured by Insights per minute
        /// for all queries combined. The default value is 200.
        /// Any integer between 0 to 200 is considered valid.
        pub query_plans_per_minute: std::option::Option<i32>,

        /// Track actively running queries on the instance.
        /// If not set, this flag is "off" by default.
        pub track_active_queries: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ObservabilityInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::instance::ObservabilityInstanceConfig::enabled].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_enabled(true);
        /// ```
        pub fn set_enabled<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enabled = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [enabled][crate::model::instance::ObservabilityInstanceConfig::enabled].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_enabled(Some(false));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_enabled(None::<bool>);
        /// ```
        pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enabled = v.map(|x| x.into());
            self
        }

        /// Sets the value of [preserve_comments][crate::model::instance::ObservabilityInstanceConfig::preserve_comments].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_preserve_comments(true);
        /// ```
        pub fn set_preserve_comments<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.preserve_comments = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [preserve_comments][crate::model::instance::ObservabilityInstanceConfig::preserve_comments].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_preserve_comments(Some(false));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_preserve_comments(None::<bool>);
        /// ```
        pub fn set_or_clear_preserve_comments<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.preserve_comments = v.map(|x| x.into());
            self
        }

        /// Sets the value of [track_wait_events][crate::model::instance::ObservabilityInstanceConfig::track_wait_events].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_track_wait_events(true);
        /// ```
        pub fn set_track_wait_events<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_events = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [track_wait_events][crate::model::instance::ObservabilityInstanceConfig::track_wait_events].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_track_wait_events(Some(false));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_track_wait_events(None::<bool>);
        /// ```
        pub fn set_or_clear_track_wait_events<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_events = v.map(|x| x.into());
            self
        }

        /// Sets the value of [track_wait_event_types][crate::model::instance::ObservabilityInstanceConfig::track_wait_event_types].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_track_wait_event_types(true);
        /// ```
        pub fn set_track_wait_event_types<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_event_types = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [track_wait_event_types][crate::model::instance::ObservabilityInstanceConfig::track_wait_event_types].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_track_wait_event_types(Some(false));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_track_wait_event_types(None::<bool>);
        /// ```
        pub fn set_or_clear_track_wait_event_types<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_event_types = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_query_string_length][crate::model::instance::ObservabilityInstanceConfig::max_query_string_length].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_max_query_string_length(42);
        /// ```
        pub fn set_max_query_string_length<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_query_string_length = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_query_string_length][crate::model::instance::ObservabilityInstanceConfig::max_query_string_length].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_max_query_string_length(Some(42));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_max_query_string_length(None::<i32>);
        /// ```
        pub fn set_or_clear_max_query_string_length<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_query_string_length = v.map(|x| x.into());
            self
        }

        /// Sets the value of [record_application_tags][crate::model::instance::ObservabilityInstanceConfig::record_application_tags].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_record_application_tags(true);
        /// ```
        pub fn set_record_application_tags<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [record_application_tags][crate::model::instance::ObservabilityInstanceConfig::record_application_tags].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_record_application_tags(Some(false));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_record_application_tags(None::<bool>);
        /// ```
        pub fn set_or_clear_record_application_tags<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = v.map(|x| x.into());
            self
        }

        /// Sets the value of [query_plans_per_minute][crate::model::instance::ObservabilityInstanceConfig::query_plans_per_minute].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_query_plans_per_minute(42);
        /// ```
        pub fn set_query_plans_per_minute<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.query_plans_per_minute = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_plans_per_minute][crate::model::instance::ObservabilityInstanceConfig::query_plans_per_minute].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_query_plans_per_minute(Some(42));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_query_plans_per_minute(None::<i32>);
        /// ```
        pub fn set_or_clear_query_plans_per_minute<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.query_plans_per_minute = v.map(|x| x.into());
            self
        }

        /// Sets the value of [track_active_queries][crate::model::instance::ObservabilityInstanceConfig::track_active_queries].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_track_active_queries(true);
        /// ```
        pub fn set_track_active_queries<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_active_queries = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [track_active_queries][crate::model::instance::ObservabilityInstanceConfig::track_active_queries].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ObservabilityInstanceConfig;
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_track_active_queries(Some(false));
        /// let x = ObservabilityInstanceConfig::new().set_or_clear_track_active_queries(None::<bool>);
        /// ```
        pub fn set_or_clear_track_active_queries<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_active_queries = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ObservabilityInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ObservabilityInstanceConfig"
        }
    }

    /// Configuration for a read pool instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReadPoolConfig {
        /// Read capacity, i.e. number of nodes in a read pool instance.
        pub node_count: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReadPoolConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node_count][crate::model::instance::ReadPoolConfig::node_count].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ReadPoolConfig;
        /// let x = ReadPoolConfig::new().set_node_count(42);
        /// ```
        pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.node_count = v.into();
            self
        }
    }

    impl wkt::message::Message for ReadPoolConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ReadPoolConfig"
        }
    }

    /// Client connection configuration
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClientConnectionConfig {
        /// Optional. Configuration to enforce connectors only (ex: AuthProxy)
        /// connections to the database.
        pub require_connectors: bool,

        /// Optional. SSL configuration option for this instance.
        pub ssl_config: std::option::Option<crate::model::SslConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClientConnectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [require_connectors][crate::model::instance::ClientConnectionConfig::require_connectors].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ClientConnectionConfig;
        /// let x = ClientConnectionConfig::new().set_require_connectors(true);
        /// ```
        pub fn set_require_connectors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.require_connectors = v.into();
            self
        }

        /// Sets the value of [ssl_config][crate::model::instance::ClientConnectionConfig::ssl_config].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ClientConnectionConfig;
        /// use google_cloud_alloydb_v1::model::SslConfig;
        /// let x = ClientConnectionConfig::new().set_ssl_config(SslConfig::default()/* use setters */);
        /// ```
        pub fn set_ssl_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::SslConfig>,
        {
            self.ssl_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ssl_config][crate::model::instance::ClientConnectionConfig::ssl_config].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ClientConnectionConfig;
        /// use google_cloud_alloydb_v1::model::SslConfig;
        /// let x = ClientConnectionConfig::new().set_or_clear_ssl_config(Some(SslConfig::default()/* use setters */));
        /// let x = ClientConnectionConfig::new().set_or_clear_ssl_config(None::<SslConfig>);
        /// ```
        pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::SslConfig>,
        {
            self.ssl_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ClientConnectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ClientConnectionConfig"
        }
    }

    /// Configuration for setting up a PSC interface to enable outbound
    /// connectivity.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscInterfaceConfig {
        /// The network attachment resource created in the consumer network to which
        /// the PSC interface will be linked. This is of the format:
        /// "projects/${CONSUMER_PROJECT}/regions/${REGION}/networkAttachments/${NETWORK_ATTACHMENT_NAME}".
        /// The network attachment must be in the same region as the instance.
        pub network_attachment_resource: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscInterfaceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_attachment_resource][crate::model::instance::PscInterfaceConfig::network_attachment_resource].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscInterfaceConfig;
        /// let x = PscInterfaceConfig::new().set_network_attachment_resource("example");
        /// ```
        pub fn set_network_attachment_resource<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_attachment_resource = v.into();
            self
        }
    }

    impl wkt::message::Message for PscInterfaceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.PscInterfaceConfig"
        }
    }

    /// Configuration for setting up PSC service automation. Consumer projects in
    /// the configs will be allowlisted automatically for the instance.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscAutoConnectionConfig {
        /// The consumer project to which the PSC service automation endpoint will
        /// be created.
        pub consumer_project: std::string::String,

        /// The consumer network for the PSC service automation, example:
        /// "projects/vpc-host-project/global/networks/default".
        /// The consumer network might be hosted a different project than the
        /// consumer project.
        pub consumer_network: std::string::String,

        /// Output only. The IP address of the PSC service automation endpoint.
        pub ip_address: std::string::String,

        /// Output only. The status of the PSC service automation connection.
        /// Possible values:
        /// "STATE_UNSPECIFIED" - An invalid state as the default case.
        /// "ACTIVE" - The connection has been created successfully.
        /// "FAILED" - The connection is not functional since some resources on the
        /// connection fail to be created.
        /// "CREATING" - The connection is being created.
        /// "DELETING" - The connection is being deleted.
        /// "CREATE_REPAIRING" - The connection is being repaired to complete
        /// creation.
        /// "DELETE_REPAIRING" - The connection is being repaired to complete
        /// deletion.
        pub status: std::string::String,

        /// Output only. The status of the service connection policy.
        /// Possible values:
        /// "STATE_UNSPECIFIED" - Default state, when Connection Map is created
        /// initially.
        /// "VALID" - Set when policy and map configuration is valid, and their
        /// matching can lead to allowing creation of PSC Connections subject to
        /// other constraints like connections limit.
        /// "CONNECTION_POLICY_MISSING" - No Service Connection Policy found for
        /// this network and Service Class
        /// "POLICY_LIMIT_REACHED" - Service Connection Policy limit reached for
        /// this network and Service Class
        /// "CONSUMER_INSTANCE_PROJECT_NOT_ALLOWLISTED" - The consumer instance
        /// project is not in AllowedGoogleProducersResourceHierarchyLevels of the
        /// matching ServiceConnectionPolicy.
        pub consumer_network_status: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscAutoConnectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [consumer_project][crate::model::instance::PscAutoConnectionConfig::consumer_project].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscAutoConnectionConfig;
        /// let x = PscAutoConnectionConfig::new().set_consumer_project("example");
        /// ```
        pub fn set_consumer_project<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_project = v.into();
            self
        }

        /// Sets the value of [consumer_network][crate::model::instance::PscAutoConnectionConfig::consumer_network].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscAutoConnectionConfig;
        /// let x = PscAutoConnectionConfig::new().set_consumer_network("example");
        /// ```
        pub fn set_consumer_network<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_network = v.into();
            self
        }

        /// Sets the value of [ip_address][crate::model::instance::PscAutoConnectionConfig::ip_address].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscAutoConnectionConfig;
        /// let x = PscAutoConnectionConfig::new().set_ip_address("example");
        /// ```
        pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip_address = v.into();
            self
        }

        /// Sets the value of [status][crate::model::instance::PscAutoConnectionConfig::status].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscAutoConnectionConfig;
        /// let x = PscAutoConnectionConfig::new().set_status("example");
        /// ```
        pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [consumer_network_status][crate::model::instance::PscAutoConnectionConfig::consumer_network_status].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscAutoConnectionConfig;
        /// let x = PscAutoConnectionConfig::new().set_consumer_network_status("example");
        /// ```
        pub fn set_consumer_network_status<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_network_status = v.into();
            self
        }
    }

    impl wkt::message::Message for PscAutoConnectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.PscAutoConnectionConfig"
        }
    }

    /// PscInstanceConfig contains PSC related configuration at an
    /// instance level.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscInstanceConfig {
        /// Output only. The service attachment created when Private
        /// Service Connect (PSC) is enabled for the instance.
        /// The name of the resource will be in the format of
        /// `projects/<alloydb-tenant-project-number>/regions/<region-name>/serviceAttachments/<service-attachment-name>`
        pub service_attachment_link: std::string::String,

        /// Optional. List of consumer projects that are allowed to create
        /// PSC endpoints to service-attachments to this instance.
        pub allowed_consumer_projects: std::vec::Vec<std::string::String>,

        /// Output only. The DNS name of the instance for PSC connectivity.
        /// Name convention: \<uid\>.\<uid\>.\<region\>.alloydb-psc.goog
        pub psc_dns_name: std::string::String,

        /// Optional. Configurations for setting up PSC interfaces attached to the
        /// instance which are used for outbound connectivity. Only primary instances
        /// can have PSC interface attached. Currently we only support 0 or 1 PSC
        /// interface.
        pub psc_interface_configs: std::vec::Vec<crate::model::instance::PscInterfaceConfig>,

        /// Optional. Configurations for setting up PSC service automation.
        pub psc_auto_connections: std::vec::Vec<crate::model::instance::PscAutoConnectionConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_attachment_link][crate::model::instance::PscInstanceConfig::service_attachment_link].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscInstanceConfig;
        /// let x = PscInstanceConfig::new().set_service_attachment_link("example");
        /// ```
        pub fn set_service_attachment_link<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_attachment_link = v.into();
            self
        }

        /// Sets the value of [allowed_consumer_projects][crate::model::instance::PscInstanceConfig::allowed_consumer_projects].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscInstanceConfig;
        /// let x = PscInstanceConfig::new().set_allowed_consumer_projects(["a", "b", "c"]);
        /// ```
        pub fn set_allowed_consumer_projects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_consumer_projects = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [psc_dns_name][crate::model::instance::PscInstanceConfig::psc_dns_name].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscInstanceConfig;
        /// let x = PscInstanceConfig::new().set_psc_dns_name("example");
        /// ```
        pub fn set_psc_dns_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.psc_dns_name = v.into();
            self
        }

        /// Sets the value of [psc_interface_configs][crate::model::instance::PscInstanceConfig::psc_interface_configs].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscInstanceConfig;
        /// use google_cloud_alloydb_v1::model::instance::PscInterfaceConfig;
        /// let x = PscInstanceConfig::new()
        ///     .set_psc_interface_configs([
        ///         PscInterfaceConfig::default()/* use setters */,
        ///         PscInterfaceConfig::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_psc_interface_configs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance::PscInterfaceConfig>,
        {
            use std::iter::Iterator;
            self.psc_interface_configs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [psc_auto_connections][crate::model::instance::PscInstanceConfig::psc_auto_connections].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::PscInstanceConfig;
        /// use google_cloud_alloydb_v1::model::instance::PscAutoConnectionConfig;
        /// let x = PscInstanceConfig::new()
        ///     .set_psc_auto_connections([
        ///         PscAutoConnectionConfig::default()/* use setters */,
        ///         PscAutoConnectionConfig::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_psc_auto_connections<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance::PscAutoConnectionConfig>,
        {
            use std::iter::Iterator;
            self.psc_auto_connections = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PscInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.PscInstanceConfig"
        }
    }

    /// Metadata related to instance-level network configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceNetworkConfig {
        /// Optional. A list of external network authorized to access this instance.
        pub authorized_external_networks:
            std::vec::Vec<crate::model::instance::instance_network_config::AuthorizedNetwork>,

        /// Optional. Enabling public ip for the instance.
        pub enable_public_ip: bool,

        /// Optional. Enabling an outbound public IP address to support a database
        /// server sending requests out into the internet.
        pub enable_outbound_public_ip: bool,

        /// Output only. The resource link for the VPC network in which instance
        /// resources are created and from which they are accessible via Private IP.
        /// This will be the same value as the parent cluster's network. It is
        /// specified in the form: //
        /// `projects/{project_number}/global/networks/{network_id}`.
        pub network: std::string::String,

        /// Optional. Name of the allocated IP range for the private IP AlloyDB
        /// instance, for example: "google-managed-services-default". If set, the
        /// instance IPs will be created from this allocated range and will override
        /// the IP range used by the parent cluster. The range name must comply with
        /// [RFC 1035](http://datatracker.ietf.org/doc/html/rfc1035). Specifically,
        /// the name must be 1-63 characters long and match the regular expression
        /// [a-z]([-a-z0-9]*[a-z0-9])?.
        pub allocated_ip_range_override: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceNetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [authorized_external_networks][crate::model::instance::InstanceNetworkConfig::authorized_external_networks].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::InstanceNetworkConfig;
        /// use google_cloud_alloydb_v1::model::instance::instance_network_config::AuthorizedNetwork;
        /// let x = InstanceNetworkConfig::new()
        ///     .set_authorized_external_networks([
        ///         AuthorizedNetwork::default()/* use setters */,
        ///         AuthorizedNetwork::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_authorized_external_networks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::instance::instance_network_config::AuthorizedNetwork,
                >,
        {
            use std::iter::Iterator;
            self.authorized_external_networks = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [enable_public_ip][crate::model::instance::InstanceNetworkConfig::enable_public_ip].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::InstanceNetworkConfig;
        /// let x = InstanceNetworkConfig::new().set_enable_public_ip(true);
        /// ```
        pub fn set_enable_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_public_ip = v.into();
            self
        }

        /// Sets the value of [enable_outbound_public_ip][crate::model::instance::InstanceNetworkConfig::enable_outbound_public_ip].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::InstanceNetworkConfig;
        /// let x = InstanceNetworkConfig::new().set_enable_outbound_public_ip(true);
        /// ```
        pub fn set_enable_outbound_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_outbound_public_ip = v.into();
            self
        }

        /// Sets the value of [network][crate::model::instance::InstanceNetworkConfig::network].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::InstanceNetworkConfig;
        /// let x = InstanceNetworkConfig::new().set_network("example");
        /// ```
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [allocated_ip_range_override][crate::model::instance::InstanceNetworkConfig::allocated_ip_range_override].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::InstanceNetworkConfig;
        /// let x = InstanceNetworkConfig::new().set_allocated_ip_range_override("example");
        /// ```
        pub fn set_allocated_ip_range_override<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allocated_ip_range_override = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceNetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.InstanceNetworkConfig"
        }
    }

    /// Defines additional types related to [InstanceNetworkConfig].
    pub mod instance_network_config {
        #[allow(unused_imports)]
        use super::*;

        /// AuthorizedNetwork contains metadata for an authorized network.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AuthorizedNetwork {
            /// CIDR range for one authorzied network of the instance.
            pub cidr_range: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuthorizedNetwork {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cidr_range][crate::model::instance::instance_network_config::AuthorizedNetwork::cidr_range].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::instance::instance_network_config::AuthorizedNetwork;
            /// let x = AuthorizedNetwork::new().set_cidr_range("example");
            /// ```
            pub fn set_cidr_range<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.cidr_range = v.into();
                self
            }
        }

        impl wkt::message::Message for AuthorizedNetwork {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.alloydb.v1.Instance.InstanceNetworkConfig.AuthorizedNetwork"
            }
        }
    }

    /// Configuration for Managed Connection Pool (MCP).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConnectionPoolConfig {
        /// Optional. Whether to enable Managed Connection Pool (MCP).
        pub enabled: bool,

        /// Optional. Connection Pool flags, as a list of "key": "value" pairs.
        pub flags: std::collections::HashMap<std::string::String, std::string::String>,

        /// Output only. The number of running poolers per instance.
        pub pooler_count: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectionPoolConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::instance::ConnectionPoolConfig::enabled].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ConnectionPoolConfig;
        /// let x = ConnectionPoolConfig::new().set_enabled(true);
        /// ```
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [flags][crate::model::instance::ConnectionPoolConfig::flags].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ConnectionPoolConfig;
        /// let x = ConnectionPoolConfig::new().set_flags([
        ///     ("key0", "abc"),
        ///     ("key1", "xyz"),
        /// ]);
        /// ```
        pub fn set_flags<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [pooler_count][crate::model::instance::ConnectionPoolConfig::pooler_count].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::instance::ConnectionPoolConfig;
        /// let x = ConnectionPoolConfig::new().set_pooler_count(42);
        /// ```
        pub fn set_pooler_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.pooler_count = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectionPoolConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ConnectionPoolConfig"
        }
    }

    /// Instance State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the instance is unknown.
        Unspecified,
        /// The instance is active and running.
        Ready,
        /// The instance is stopped. Instance name and IP resources are preserved.
        Stopped,
        /// The instance is being created.
        Creating,
        /// The instance is being deleted.
        Deleting,
        /// The instance is down for maintenance.
        Maintenance,
        /// The creation of the instance failed or a fatal error occurred during
        /// an operation on the instance.
        /// Note: Instances in this state would tried to be auto-repaired. And
        /// Customers should be able to restart, update or delete these instances.
        Failed,
        /// Index 7 is used in the producer apis for ROLLED_BACK state. Keeping that
        /// index unused in case that state also needs to exposed via consumer apis
        /// in future.
        /// The instance has been configured to sync data from some other source.
        Bootstrapping,
        /// The instance is being promoted.
        Promoting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Stopped => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Maintenance => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Bootstrapping => std::option::Option::Some(8),
                Self::Promoting => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Bootstrapping => std::option::Option::Some("BOOTSTRAPPING"),
                Self::Promoting => std::option::Option::Some("PROMOTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Stopped,
                3 => Self::Creating,
                4 => Self::Deleting,
                5 => Self::Maintenance,
                6 => Self::Failed,
                8 => Self::Bootstrapping,
                9 => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "STOPPED" => Self::Stopped,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "MAINTENANCE" => Self::Maintenance,
                "FAILED" => Self::Failed,
                "BOOTSTRAPPING" => Self::Bootstrapping,
                "PROMOTING" => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Stopped => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Maintenance => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Bootstrapping => serializer.serialize_i32(8),
                Self::Promoting => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.Instance.State",
            ))
        }
    }

    /// Type of an Instance
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceType {
        /// The type of the instance is unknown.
        Unspecified,
        /// PRIMARY instances support read and write operations.
        Primary,
        /// READ POOL instances support read operations only. Each read pool instance
        /// consists of one or more homogeneous nodes.
        ///
        /// * Read pool of size 1 can only have zonal availability.
        /// * Read pools with node count of 2 or more can have regional
        ///   availability (nodes are present in 2 or more zones in a region).
        ReadPool,
        /// SECONDARY instances support read operations only. SECONDARY instance
        /// is a cross-region read replica
        Secondary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceType::value] or
        /// [InstanceType::name].
        UnknownValue(instance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::ReadPool => std::option::Option::Some(2),
                Self::Secondary => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_TYPE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::ReadPool => std::option::Option::Some("READ_POOL"),
                Self::Secondary => std::option::Option::Some("SECONDARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::ReadPool,
                3 => Self::Secondary,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "READ_POOL" => Self::ReadPool,
                "SECONDARY" => Self::Secondary,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::ReadPool => serializer.serialize_i32(2),
                Self::Secondary => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceType>::new(
                ".google.cloud.alloydb.v1.Instance.InstanceType",
            ))
        }
    }

    /// The Availability type of an instance. Potential values:
    ///
    /// - ZONAL: The instance serves data from only one zone. Outages in that
    ///   zone affect instance availability.
    /// - REGIONAL: The instance can serve data from more than one zone in a
    ///   region (it is highly available).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AvailabilityType {
        /// This is an unknown Availability type.
        Unspecified,
        /// Zonal available instance.
        Zonal,
        /// Regional (or Highly) available instance.
        Regional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AvailabilityType::value] or
        /// [AvailabilityType::name].
        UnknownValue(availability_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod availability_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AvailabilityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Zonal => std::option::Option::Some(1),
                Self::Regional => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AVAILABILITY_TYPE_UNSPECIFIED"),
                Self::Zonal => std::option::Option::Some("ZONAL"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AvailabilityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AvailabilityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AvailabilityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Zonal,
                2 => Self::Regional,
                _ => Self::UnknownValue(availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AvailabilityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AVAILABILITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ZONAL" => Self::Zonal,
                "REGIONAL" => Self::Regional,
                _ => Self::UnknownValue(availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AvailabilityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Zonal => serializer.serialize_i32(1),
                Self::Regional => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AvailabilityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AvailabilityType>::new(
                ".google.cloud.alloydb.v1.Instance.AvailabilityType",
            ))
        }
    }

    /// Specifies whether an instance needs to spin up.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ActivationPolicy {
        /// The policy is not specified.
        Unspecified,
        /// The instance is running.
        Always,
        /// The instance is not running.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ActivationPolicy::value] or
        /// [ActivationPolicy::name].
        UnknownValue(activation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod activation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ActivationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTIVATION_POLICY_UNSPECIFIED"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ActivationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ActivationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ActivationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Never,
                _ => Self::UnknownValue(activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ActivationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTIVATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                _ => Self::UnknownValue(activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ActivationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ActivationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActivationPolicy>::new(
                ".google.cloud.alloydb.v1.Instance.ActivationPolicy",
            ))
        }
    }
}

/// ConnectionInfo singleton resource.
/// <https://google.aip.dev/156>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectionInfo {
    /// The name of the ConnectionInfo singleton resource, e.g.:
    /// projects/{project}/locations/{location}/clusters/*/instances/*/connectionInfo
    /// This field currently has no semantic meaning.
    pub name: std::string::String,

    /// Output only. The private network IP address for the Instance. This is the
    /// default IP for the instance and is always created (even if enable_public_ip
    /// is set). This is the connection endpoint for an end-user application.
    pub ip_address: std::string::String,

    /// Output only. The public IP addresses for the Instance. This is available
    /// ONLY when enable_public_ip is set. This is the connection endpoint for an
    /// end-user application.
    pub public_ip_address: std::string::String,

    /// Output only. The unique ID of the Instance.
    pub instance_uid: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionInfo::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ConnectionInfo;
    /// let x = ConnectionInfo::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::ConnectionInfo::ip_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ConnectionInfo;
    /// let x = ConnectionInfo::new().set_ip_address("example");
    /// ```
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::ConnectionInfo::public_ip_address].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ConnectionInfo;
    /// let x = ConnectionInfo::new().set_public_ip_address("example");
    /// ```
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [instance_uid][crate::model::ConnectionInfo::instance_uid].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ConnectionInfo;
    /// let x = ConnectionInfo::new().set_instance_uid("example");
    /// ```
    pub fn set_instance_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uid = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ConnectionInfo"
    }
}

/// Message describing Backup object
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The name of the backup resource with the format:
    ///
    /// * projects/{project}/locations/{region}/backups/{backup_id}
    ///   where the cluster and backup ID segments should satisfy the regex
    ///   expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
    ///   lowercase letters, numbers, and dashes, starting with a letter, and ending
    ///   with a letter or number. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the backup resource name is the name of the parent
    ///   resource:
    /// * projects/{project}/locations/{region}
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Backup.
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    pub uid: std::string::String,

    /// Output only. Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    ///
    /// Users should not infer any meaning from this field. Its value is generally
    /// unrelated to the timing of the backup creation operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when the resource finished being created.
    pub create_completion_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,

    /// The backup type, which suggests the trigger for the backup.
    pub r#type: crate::model::backup::Type,

    /// User-provided description of the backup.
    pub description: std::string::String,

    /// Output only. The system-generated UID of the cluster which was used to
    /// create this resource.
    pub cluster_uid: std::string::String,

    /// Required. The full resource name of the backup source cluster
    /// (e.g., projects/{project}/locations/{region}/clusters/{cluster_id}).
    pub cluster_name: std::string::String,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>), if
    /// true, indicates that the service is actively updating the resource. This
    /// can happen due to user-triggered updates or system actions like failover or
    /// maintenance.
    pub reconciling: bool,

    /// Optional. The encryption config can be specified to encrypt the
    /// backup with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will then use default encryption scheme to
    /// protect the user data.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Output only. The encryption information for the backup.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The size of the backup in bytes.
    pub size_bytes: i64,

    /// Output only. The time at which after the backup is eligible to be garbage
    /// collected. It is the duration specified by the backup's retention policy,
    /// added to the backup's create_time.
    pub expiry_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The QuantityBasedExpiry of the backup, specified by the
    /// backup's retention policy. Once the expiry quantity is over retention, the
    /// backup is eligible to be garbage collected.
    pub expiry_quantity: std::option::Option<crate::model::backup::QuantityBasedExpiry>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. The database engine major version of the cluster this backup
    /// was created from. Any restored cluster created from this backup will have
    /// the same database version.
    pub database_version: crate::model::DatabaseVersion,

    /// Optional. Input only. Immutable. Tag keys/values directly bound to this
    /// resource. For example:
    ///
    /// ```norust
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    /// ```
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Backup::display_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_display_name("example");
    /// ```
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Backup::uid].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_uid("example");
    /// ```
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Backup::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Backup::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_update_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Backup::update_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_or_clear_update_time(Some(Timestamp::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_update_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Backup::delete_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_delete_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Backup::delete_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_or_clear_delete_time(Some(Timestamp::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_delete_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_completion_time][crate::model::Backup::create_completion_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_create_completion_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_completion_time][crate::model::Backup::create_completion_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_or_clear_create_completion_time(Some(Timestamp::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_create_completion_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_labels([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::backup::State;
    /// let x0 = Backup::new().set_state(State::Ready);
    /// let x1 = Backup::new().set_state(State::Creating);
    /// let x2 = Backup::new().set_state(State::Failed);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Backup::type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::backup::Type;
    /// let x0 = Backup::new().set_type(Type::OnDemand);
    /// let x1 = Backup::new().set_type(Type::Automated);
    /// let x2 = Backup::new().set_type(Type::Continuous);
    /// ```
    pub fn set_type<T: std::convert::Into<crate::model::backup::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_description("example");
    /// ```
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [cluster_uid][crate::model::Backup::cluster_uid].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_cluster_uid("example");
    /// ```
    pub fn set_cluster_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uid = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::Backup::cluster_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_cluster_name("example");
    /// ```
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Backup::reconciling].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_reconciling(true);
    /// ```
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::Backup::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = Backup::new().set_encryption_config(EncryptionConfig::default()/* use setters */);
    /// ```
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::Backup::encryption_config].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::EncryptionConfig;
    /// let x = Backup::new().set_or_clear_encryption_config(Some(EncryptionConfig::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_encryption_config(None::<EncryptionConfig>);
    /// ```
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_info][crate::model::Backup::encryption_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// let x = Backup::new().set_encryption_info(EncryptionInfo::default()/* use setters */);
    /// ```
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::Backup::encryption_info].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::EncryptionInfo;
    /// let x = Backup::new().set_or_clear_encryption_info(Some(EncryptionInfo::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_encryption_info(None::<EncryptionInfo>);
    /// ```
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Backup::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Backup::annotations].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_annotations([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Backup::size_bytes].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_size_bytes(42);
    /// ```
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [expiry_time][crate::model::Backup::expiry_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_expiry_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_expiry_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiry_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiry_time][crate::model::Backup::expiry_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use wkt::Timestamp;
    /// let x = Backup::new().set_or_clear_expiry_time(Some(Timestamp::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_expiry_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_expiry_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiry_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expiry_quantity][crate::model::Backup::expiry_quantity].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::backup::QuantityBasedExpiry;
    /// let x = Backup::new().set_expiry_quantity(QuantityBasedExpiry::default()/* use setters */);
    /// ```
    pub fn set_expiry_quantity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup::QuantityBasedExpiry>,
    {
        self.expiry_quantity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiry_quantity][crate::model::Backup::expiry_quantity].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::backup::QuantityBasedExpiry;
    /// let x = Backup::new().set_or_clear_expiry_quantity(Some(QuantityBasedExpiry::default()/* use setters */));
    /// let x = Backup::new().set_or_clear_expiry_quantity(None::<QuantityBasedExpiry>);
    /// ```
    pub fn set_or_clear_expiry_quantity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup::QuantityBasedExpiry>,
    {
        self.expiry_quantity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_satisfies_pzs(true);
    /// ```
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::Backup::database_version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// use google_cloud_alloydb_v1::model::DatabaseVersion;
    /// let x0 = Backup::new().set_database_version(DatabaseVersion::Postgres14);
    /// let x1 = Backup::new().set_database_version(DatabaseVersion::Postgres15);
    /// let x2 = Backup::new().set_database_version(DatabaseVersion::Postgres16);
    /// ```
    pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::Backup::tags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Backup;
    /// let x = Backup::new().set_tags([
    ///     ("key0", "abc"),
    ///     ("key1", "xyz"),
    /// ]);
    /// ```
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Backup"
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// A backup's position in a quantity-based retention queue, of backups with
    /// the same source cluster and type, with length, retention, specified by the
    /// backup's retention policy.
    /// Once the position is greater than the retention, the backup is eligible to
    /// be garbage collected.
    ///
    /// Example: 5 backups from the same source cluster and type with a
    /// quantity-based retention of 3 and denoted by backup_id (position,
    /// retention).
    ///
    /// Safe: backup_5 (1, 3), backup_4, (2, 3), backup_3 (3, 3).
    /// Awaiting garbage collection: backup_2 (4, 3), backup_1 (5, 3)
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QuantityBasedExpiry {
        /// Output only. The backup's position among its backups with the same source
        /// cluster and type, by descending chronological order create time(i.e.
        /// newest first).
        pub retention_count: i32,

        /// Output only. The length of the quantity-based queue, specified by the
        /// backup's retention policy.
        pub total_retention_count: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QuantityBasedExpiry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_count][crate::model::backup::QuantityBasedExpiry::retention_count].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::backup::QuantityBasedExpiry;
        /// let x = QuantityBasedExpiry::new().set_retention_count(42);
        /// ```
        pub fn set_retention_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.retention_count = v.into();
            self
        }

        /// Sets the value of [total_retention_count][crate::model::backup::QuantityBasedExpiry::total_retention_count].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::backup::QuantityBasedExpiry;
        /// let x = QuantityBasedExpiry::new().set_total_retention_count(42);
        /// ```
        pub fn set_total_retention_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_retention_count = v.into();
            self
        }
    }

    impl wkt::message::Message for QuantityBasedExpiry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Backup.QuantityBasedExpiry"
        }
    }

    /// Backup State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the backup is unknown.
        Unspecified,
        /// The backup is ready.
        Ready,
        /// The backup is creating.
        Creating,
        /// The backup failed.
        Failed,
        /// The backup is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Failed,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.Backup.State",
            ))
        }
    }

    /// Backup Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Backup Type is unknown.
        Unspecified,
        /// ON_DEMAND backups that were triggered by the customer (e.g., not
        /// AUTOMATED).
        OnDemand,
        /// AUTOMATED backups triggered by the automated backups scheduler pursuant
        /// to an automated backup policy.
        Automated,
        /// CONTINUOUS backups triggered by the automated backups scheduler
        /// due to a continuous backup policy.
        Continuous,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Automated => std::option::Option::Some(2),
                Self::Continuous => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Automated => std::option::Option::Some("AUTOMATED"),
                Self::Continuous => std::option::Option::Some("CONTINUOUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Automated,
                3 => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "AUTOMATED" => Self::Automated,
                "CONTINUOUS" => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Automated => serializer.serialize_i32(2),
                Self::Continuous => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.alloydb.v1.Backup.Type",
            ))
        }
    }
}

/// SupportedDatabaseFlag gives general information about a database flag,
/// like type and allowed values. This is a static value that is defined
/// on the server side, and it cannot be modified by callers.
/// To set the Database flags on a particular Instance, a caller should modify
/// the Instance.database_flags field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SupportedDatabaseFlag {
    /// The name of the flag resource, following Google Cloud conventions, e.g.:
    ///
    /// * projects/{project}/locations/{location}/flags/{flag}
    ///   This field currently has no semantic meaning.
    pub name: std::string::String,

    /// The name of the database flag, e.g. "max_allowed_packets".
    /// The is a possibly key for the Instance.database_flags map field.
    pub flag_name: std::string::String,

    pub value_type: crate::model::supported_database_flag::ValueType,

    /// Whether the database flag accepts multiple values. If true,
    /// a comma-separated list of stringified values may be specified.
    pub accepts_multiple_values: bool,

    /// Major database engine versions for which this flag is supported.
    pub supported_db_versions: std::vec::Vec<crate::model::DatabaseVersion>,

    /// Whether setting or updating this flag on an Instance requires a database
    /// restart. If a flag that requires database restart is set, the backend
    /// will automatically restart the database (making sure to satisfy any
    /// availability SLO's).
    pub requires_db_restart: bool,

    /// The scope of the flag.
    pub scope: crate::model::supported_database_flag::Scope,

    /// The restrictions on the flag value per type.
    pub restrictions: std::option::Option<crate::model::supported_database_flag::Restrictions>,

    /// The recommended value for the flag by type, if applicable.
    pub recommended_value:
        std::option::Option<crate::model::supported_database_flag::RecommendedValue>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SupportedDatabaseFlag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SupportedDatabaseFlag::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// let x = SupportedDatabaseFlag::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [flag_name][crate::model::SupportedDatabaseFlag::flag_name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// let x = SupportedDatabaseFlag::new().set_flag_name("example");
    /// ```
    pub fn set_flag_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flag_name = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::SupportedDatabaseFlag::value_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use google_cloud_alloydb_v1::model::supported_database_flag::ValueType;
    /// let x0 = SupportedDatabaseFlag::new().set_value_type(ValueType::String);
    /// let x1 = SupportedDatabaseFlag::new().set_value_type(ValueType::Integer);
    /// let x2 = SupportedDatabaseFlag::new().set_value_type(ValueType::Float);
    /// ```
    pub fn set_value_type<
        T: std::convert::Into<crate::model::supported_database_flag::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [accepts_multiple_values][crate::model::SupportedDatabaseFlag::accepts_multiple_values].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// let x = SupportedDatabaseFlag::new().set_accepts_multiple_values(true);
    /// ```
    pub fn set_accepts_multiple_values<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.accepts_multiple_values = v.into();
        self
    }

    /// Sets the value of [supported_db_versions][crate::model::SupportedDatabaseFlag::supported_db_versions].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use google_cloud_alloydb_v1::model::DatabaseVersion;
    /// let x = SupportedDatabaseFlag::new().set_supported_db_versions([
    ///     DatabaseVersion::Postgres14,
    ///     DatabaseVersion::Postgres15,
    ///     DatabaseVersion::Postgres16,
    /// ]);
    /// ```
    pub fn set_supported_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseVersion>,
    {
        use std::iter::Iterator;
        self.supported_db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [requires_db_restart][crate::model::SupportedDatabaseFlag::requires_db_restart].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// let x = SupportedDatabaseFlag::new().set_requires_db_restart(true);
    /// ```
    pub fn set_requires_db_restart<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requires_db_restart = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::SupportedDatabaseFlag::scope].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use google_cloud_alloydb_v1::model::supported_database_flag::Scope;
    /// let x0 = SupportedDatabaseFlag::new().set_scope(Scope::Database);
    /// let x1 = SupportedDatabaseFlag::new().set_scope(Scope::ConnectionPool);
    /// ```
    pub fn set_scope<T: std::convert::Into<crate::model::supported_database_flag::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions].
    ///
    /// Note that all the setters affecting `restrictions` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use google_cloud_alloydb_v1::model::supported_database_flag;
    /// use google_cloud_alloydb_v1::model::supported_database_flag::StringRestrictions;
    /// let x = SupportedDatabaseFlag::new().set_restrictions(Some(supported_database_flag::Restrictions::StringRestrictions(StringRestrictions::default().into())));
    /// ```
    pub fn set_restrictions<
        T: std::convert::Into<
                std::option::Option<crate::model::supported_database_flag::Restrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = v.into();
        self
    }

    /// The value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// if it holds a `StringRestrictions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_restrictions(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
    > {
        #[allow(unreachable_patterns)]
        self.restrictions.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::Restrictions::StringRestrictions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// to hold a `StringRestrictions`.
    ///
    /// Note that all the setters affecting `restrictions` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use google_cloud_alloydb_v1::model::supported_database_flag::StringRestrictions;
    /// let x = SupportedDatabaseFlag::new().set_string_restrictions(StringRestrictions::default()/* use setters */);
    /// assert!(x.string_restrictions().is_some());
    /// assert!(x.integer_restrictions().is_none());
    /// ```
    pub fn set_string_restrictions<
        T: std::convert::Into<
                std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = std::option::Option::Some(
            crate::model::supported_database_flag::Restrictions::StringRestrictions(v.into()),
        );
        self
    }

    /// The value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// if it holds a `IntegerRestrictions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integer_restrictions(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
    > {
        #[allow(unreachable_patterns)]
        self.restrictions.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::Restrictions::IntegerRestrictions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// to hold a `IntegerRestrictions`.
    ///
    /// Note that all the setters affecting `restrictions` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use google_cloud_alloydb_v1::model::supported_database_flag::IntegerRestrictions;
    /// let x = SupportedDatabaseFlag::new().set_integer_restrictions(IntegerRestrictions::default()/* use setters */);
    /// assert!(x.integer_restrictions().is_some());
    /// assert!(x.string_restrictions().is_none());
    /// ```
    pub fn set_integer_restrictions<
        T: std::convert::Into<
                std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = std::option::Option::Some(
            crate::model::supported_database_flag::Restrictions::IntegerRestrictions(v.into()),
        );
        self
    }

    /// Sets the value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value].
    ///
    /// Note that all the setters affecting `recommended_value` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use google_cloud_alloydb_v1::model::supported_database_flag;
    /// let x = SupportedDatabaseFlag::new().set_recommended_value(Some(supported_database_flag::RecommendedValue::RecommendedStringValue("example".to_string())));
    /// ```
    pub fn set_recommended_value<
        T: std::convert::Into<
                std::option::Option<crate::model::supported_database_flag::RecommendedValue>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_value = v.into();
        self
    }

    /// The value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// if it holds a `RecommendedStringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recommended_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.recommended_value.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::RecommendedValue::RecommendedStringValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// to hold a `RecommendedStringValue`.
    ///
    /// Note that all the setters affecting `recommended_value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// let x = SupportedDatabaseFlag::new().set_recommended_string_value("example");
    /// assert!(x.recommended_string_value().is_some());
    /// assert!(x.recommended_integer_value().is_none());
    /// ```
    pub fn set_recommended_string_value<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_value = std::option::Option::Some(
            crate::model::supported_database_flag::RecommendedValue::RecommendedStringValue(
                v.into(),
            ),
        );
        self
    }

    /// The value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// if it holds a `RecommendedIntegerValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recommended_integer_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<wkt::Int64Value>> {
        #[allow(unreachable_patterns)]
        self.recommended_value.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::RecommendedValue::RecommendedIntegerValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// to hold a `RecommendedIntegerValue`.
    ///
    /// Note that all the setters affecting `recommended_value` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// use wkt::Int64Value;
    /// let x = SupportedDatabaseFlag::new().set_recommended_integer_value(Int64Value::default()/* use setters */);
    /// assert!(x.recommended_integer_value().is_some());
    /// assert!(x.recommended_string_value().is_none());
    /// ```
    pub fn set_recommended_integer_value<
        T: std::convert::Into<std::boxed::Box<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_value = std::option::Option::Some(
            crate::model::supported_database_flag::RecommendedValue::RecommendedIntegerValue(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SupportedDatabaseFlag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag"
    }
}

/// Defines additional types related to [SupportedDatabaseFlag].
pub mod supported_database_flag {
    #[allow(unused_imports)]
    use super::*;

    /// Restrictions on STRING type values
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StringRestrictions {
        /// The list of allowed values, if bounded. This field will be empty
        /// if there is a unbounded number of allowed values.
        pub allowed_values: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StringRestrictions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_values][crate::model::supported_database_flag::StringRestrictions::allowed_values].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::supported_database_flag::StringRestrictions;
        /// let x = StringRestrictions::new().set_allowed_values(["a", "b", "c"]);
        /// ```
        pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StringRestrictions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag.StringRestrictions"
        }
    }

    /// Restrictions on INTEGER type values.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IntegerRestrictions {
        /// The minimum value that can be specified, if applicable.
        pub min_value: std::option::Option<wkt::Int64Value>,

        /// The maximum value that can be specified, if applicable.
        pub max_value: std::option::Option<wkt::Int64Value>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IntegerRestrictions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::supported_database_flag::IntegerRestrictions::min_value].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::supported_database_flag::IntegerRestrictions;
        /// use wkt::Int64Value;
        /// let x = IntegerRestrictions::new().set_min_value(Int64Value::default()/* use setters */);
        /// ```
        pub fn set_min_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.min_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_value][crate::model::supported_database_flag::IntegerRestrictions::min_value].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::supported_database_flag::IntegerRestrictions;
        /// use wkt::Int64Value;
        /// let x = IntegerRestrictions::new().set_or_clear_min_value(Some(Int64Value::default()/* use setters */));
        /// let x = IntegerRestrictions::new().set_or_clear_min_value(None::<Int64Value>);
        /// ```
        pub fn set_or_clear_min_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.min_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_value][crate::model::supported_database_flag::IntegerRestrictions::max_value].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::supported_database_flag::IntegerRestrictions;
        /// use wkt::Int64Value;
        /// let x = IntegerRestrictions::new().set_max_value(Int64Value::default()/* use setters */);
        /// ```
        pub fn set_max_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.max_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_value][crate::model::supported_database_flag::IntegerRestrictions::max_value].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::supported_database_flag::IntegerRestrictions;
        /// use wkt::Int64Value;
        /// let x = IntegerRestrictions::new().set_or_clear_max_value(Some(Int64Value::default()/* use setters */));
        /// let x = IntegerRestrictions::new().set_or_clear_max_value(None::<Int64Value>);
        /// ```
        pub fn set_or_clear_max_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.max_value = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for IntegerRestrictions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag.IntegerRestrictions"
        }
    }

    /// ValueType describes the semantic type of the value that the flag accepts.
    /// Regardless of the ValueType, the Instance.database_flags field accepts the
    /// stringified version of the value, i.e. "20" or "3.14".
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// This is an unknown flag type.
        Unspecified,
        /// String type flag.
        String,
        /// Integer type flag.
        Integer,
        /// Float type flag.
        Float,
        /// Denotes that the flag does not accept any values.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(1),
                Self::Integer => std::option::Option::Some(2),
                Self::Float => std::option::Option::Some(3),
                Self::None => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Integer => std::option::Option::Some("INTEGER"),
                Self::Float => std::option::Option::Some("FLOAT"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::String,
                2 => Self::Integer,
                3 => Self::Float,
                4 => Self::None,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "INTEGER" => Self::Integer,
                "FLOAT" => Self::Float,
                "NONE" => Self::None,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(1),
                Self::Integer => serializer.serialize_i32(2),
                Self::Float => serializer.serialize_i32(3),
                Self::None => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.alloydb.v1.SupportedDatabaseFlag.ValueType",
            ))
        }
    }

    /// The scope of the flag.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// The scope of the flag is not specified. Default is DATABASE.
        Unspecified,
        /// The flag is a database flag.
        Database,
        /// The flag is a connection pool flag.
        ConnectionPool,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::ConnectionPool => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::ConnectionPool => std::option::Option::Some("CONNECTION_POOL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::ConnectionPool,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "CONNECTION_POOL" => Self::ConnectionPool,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::ConnectionPool => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.alloydb.v1.SupportedDatabaseFlag.Scope",
            ))
        }
    }

    /// The restrictions on the flag value per type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Restrictions {
        /// Restriction on STRING type value.
        StringRestrictions(
            std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
        ),
        /// Restriction on INTEGER type value.
        IntegerRestrictions(
            std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
        ),
    }

    /// The recommended value for the flag by type, if applicable.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RecommendedValue {
        /// The recommended value for a STRING flag.
        RecommendedStringValue(std::string::String),
        /// The recommended value for an INTEGER flag.
        RecommendedIntegerValue(std::boxed::Box<wkt::Int64Value>),
    }
}

/// Message describing User object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct User {
    /// Output only. Name of the resource in the form of
    /// projects/{project}/locations/{location}/cluster/{cluster}/users/{user}.
    pub name: std::string::String,

    /// Input only. Password for the user.
    pub password: std::string::String,

    /// Optional. List of database roles this user has.
    /// The database role strings are subject to the PostgreSQL naming conventions.
    pub database_roles: std::vec::Vec<std::string::String>,

    /// Optional. Type of this user.
    pub user_type: crate::model::user::UserType,

    /// Input only. If the user already exists and it has additional roles, keep
    /// them granted.
    pub keep_extra_roles: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::User::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::User;
    /// let x = User::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [password][crate::model::User::password].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::User;
    /// let x = User::new().set_password("example");
    /// ```
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database_roles][crate::model::User::database_roles].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::User;
    /// let x = User::new().set_database_roles(["a", "b", "c"]);
    /// ```
    pub fn set_database_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_type][crate::model::User::user_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::User;
    /// use google_cloud_alloydb_v1::model::user::UserType;
    /// let x0 = User::new().set_user_type(UserType::AlloydbBuiltIn);
    /// let x1 = User::new().set_user_type(UserType::AlloydbIamUser);
    /// ```
    pub fn set_user_type<T: std::convert::Into<crate::model::user::UserType>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_type = v.into();
        self
    }

    /// Sets the value of [keep_extra_roles][crate::model::User::keep_extra_roles].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::User;
    /// let x = User::new().set_keep_extra_roles(true);
    /// ```
    pub fn set_keep_extra_roles<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.keep_extra_roles = v.into();
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.User"
    }
}

/// Defines additional types related to [User].
pub mod user {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that details the user type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserType {
        /// Unspecified user type.
        Unspecified,
        /// The default user type that authenticates via password-based
        /// authentication.
        AlloydbBuiltIn,
        /// Database user that can authenticate via IAM-Based authentication.
        AlloydbIamUser,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserType::value] or
        /// [UserType::name].
        UnknownValue(user_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AlloydbBuiltIn => std::option::Option::Some(1),
                Self::AlloydbIamUser => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_TYPE_UNSPECIFIED"),
                Self::AlloydbBuiltIn => std::option::Option::Some("ALLOYDB_BUILT_IN"),
                Self::AlloydbIamUser => std::option::Option::Some("ALLOYDB_IAM_USER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AlloydbBuiltIn,
                2 => Self::AlloydbIamUser,
                _ => Self::UnknownValue(user_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALLOYDB_BUILT_IN" => Self::AlloydbBuiltIn,
                "ALLOYDB_IAM_USER" => Self::AlloydbIamUser,
                _ => Self::UnknownValue(user_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AlloydbBuiltIn => serializer.serialize_i32(1),
                Self::AlloydbIamUser => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserType>::new(
                ".google.cloud.alloydb.v1.User.UserType",
            ))
        }
    }
}

/// Message describing Database object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Database {
    /// Identifier. Name of the resource in the form of
    /// `projects/{project}/locations/{location}/clusters/{cluster}/databases/{database}`.
    pub name: std::string::String,

    /// Optional. Immutable. Charset for the database.
    /// This field can contain any PostgreSQL supported charset name.
    /// Example values include "UTF8", "SQL_ASCII", etc.
    pub charset: std::string::String,

    /// Optional. Immutable. lc_collate for the database.
    /// String sort order.
    /// Example values include "C", "POSIX", etc.
    pub collation: std::string::String,

    /// Optional. Immutable. lc_ctype for the database.
    /// Character classification (What is a letter? The upper-case equivalent?).
    /// Example values include "C", "POSIX", etc.
    pub character_type: std::string::String,

    /// Input only. Immutable. Template of the database to be used for creating a
    /// new database.
    pub database_template: std::string::String,

    /// Optional. Whether the database is a template database.
    pub is_template_database: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Database;
    /// let x = Database::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::Database::charset].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Database;
    /// let x = Database::new().set_charset("example");
    /// ```
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Database::collation].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Database;
    /// let x = Database::new().set_collation("example");
    /// ```
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [character_type][crate::model::Database::character_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Database;
    /// let x = Database::new().set_character_type("example");
    /// ```
    pub fn set_character_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.character_type = v.into();
        self
    }

    /// Sets the value of [database_template][crate::model::Database::database_template].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Database;
    /// let x = Database::new().set_database_template("example");
    /// ```
    pub fn set_database_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_template = v.into();
        self
    }

    /// Sets the value of [is_template_database][crate::model::Database::is_template_database].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Database;
    /// let x = Database::new().set_is_template_database(true);
    /// ```
    pub fn set_is_template_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_template_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [is_template_database][crate::model::Database::is_template_database].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::Database;
    /// let x = Database::new().set_or_clear_is_template_database(Some(false));
    /// let x = Database::new().set_or_clear_is_template_database(None::<bool>);
    /// ```
    pub fn set_or_clear_is_template_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_template_database = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Database"
    }
}

/// Message for requesting list of Clusters
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Cluster.name field. Additionally, you can perform an
    /// aggregated list operation by specifying a value with the following format:
    ///
    /// * projects/{project}/locations/-
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersRequest;
    /// let x = ListClustersRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersRequest;
    /// let x = ListClustersRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersRequest;
    /// let x = ListClustersRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersRequest;
    /// let x = ListClustersRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersRequest;
    /// let x = ListClustersRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListClustersRequest"
    }
}

/// Message for response to listing Clusters
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// The list of Cluster
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersResponse;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = ListClustersResponse::new()
    ///     .set_clusters([
    ///         Cluster::default()/* use setters */,
    ///         Cluster::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersResponse;
    /// let x = ListClustersResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListClustersResponse;
    /// let x = ListClustersResponse::new().set_unreachable(["a", "b", "c"]);
    /// ```
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field.
    pub name: std::string::String,

    /// Optional. The view of the cluster to return. Returns all default fields if
    /// not set.
    pub view: crate::model::ClusterView,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetClusterRequest;
    /// let x = GetClusterRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetClusterRequest::view].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetClusterRequest;
    /// use google_cloud_alloydb_v1::model::ClusterView;
    /// let x0 = GetClusterRequest::new().set_view(ClusterView::Basic);
    /// let x1 = GetClusterRequest::new().set_view(ClusterView::ContinuousBackup);
    /// ```
    pub fn set_view<T: std::convert::Into<crate::model::ClusterView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetClusterRequest"
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSecondaryClusterRequest {
    /// Required. The location of the new cluster. For the required
    /// format, see the comment on the Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object (the secondary cluster).
    pub cluster_id: std::string::String,

    /// Required. Configuration of the requesting object (the secondary cluster).
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSecondaryClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecondaryClusterRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryClusterRequest;
    /// let x = CreateSecondaryClusterRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateSecondaryClusterRequest::cluster_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryClusterRequest;
    /// let x = CreateSecondaryClusterRequest::new().set_cluster_id("example");
    /// ```
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateSecondaryClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = CreateSecondaryClusterRequest::new().set_cluster(Cluster::default()/* use setters */);
    /// ```
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateSecondaryClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = CreateSecondaryClusterRequest::new().set_or_clear_cluster(Some(Cluster::default()/* use setters */));
    /// let x = CreateSecondaryClusterRequest::new().set_or_clear_cluster(None::<Cluster>);
    /// ```
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSecondaryClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryClusterRequest;
    /// let x = CreateSecondaryClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateSecondaryClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryClusterRequest;
    /// let x = CreateSecondaryClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateSecondaryClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateSecondaryClusterRequest"
    }
}

/// Message for creating a Cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The location of the new cluster. For the required format, see the
    /// comment on the Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateClusterRequest;
    /// let x = CreateClusterRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateClusterRequest;
    /// let x = CreateClusterRequest::new().set_cluster_id("example");
    /// ```
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = CreateClusterRequest::new().set_cluster(Cluster::default()/* use setters */);
    /// ```
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = CreateClusterRequest::new().set_or_clear_cluster(Some(Cluster::default()/* use setters */));
    /// let x = CreateClusterRequest::new().set_or_clear_cluster(None::<Cluster>);
    /// ```
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateClusterRequest;
    /// let x = CreateClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateClusterRequest;
    /// let x = CreateClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateClusterRequest"
    }
}

/// Message for updating a Cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Cluster resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if cluster is not found. In
    /// that case, a new cluster is created and `update_mask` is ignored.
    pub allow_missing: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateClusterRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateClusterRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateClusterRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateClusterRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateClusterRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = UpdateClusterRequest::new().set_cluster(Cluster::default()/* use setters */);
    /// ```
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = UpdateClusterRequest::new().set_or_clear_cluster(Some(Cluster::default()/* use setters */));
    /// let x = UpdateClusterRequest::new().set_or_clear_cluster(None::<Cluster>);
    /// ```
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateClusterRequest;
    /// let x = UpdateClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateClusterRequest;
    /// let x = UpdateClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateClusterRequest::allow_missing].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateClusterRequest;
    /// let x = UpdateClusterRequest::new().set_allow_missing(true);
    /// ```
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateClusterRequest"
    }
}

/// Destination for Export. Export will be done to cloud storage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required. The path to the file in Google Cloud Storage where the export
    /// will be stored. The URI is in the form `gs://bucketName/fileName`.
    pub uri: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsDestination::uri].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GcsDestination;
    /// let x = GcsDestination::new().set_uri("example");
    /// ```
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GcsDestination"
    }
}

/// Export cluster request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. Name of the database where the export command will be executed.
    /// Note - Value provided should be the same as expected from
    /// `SELECT current_database();` and NOT as a resource reference.
    pub database: std::string::String,

    /// Oneof field to support other destinations in future.
    pub destination: std::option::Option<crate::model::export_cluster_request::Destination>,

    /// Required field to specify export file type and options.
    pub export_options: std::option::Option<crate::model::export_cluster_request::ExportOptions>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportClusterRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterRequest;
    /// let x = ExportClusterRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ExportClusterRequest::database].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterRequest;
    /// let x = ExportClusterRequest::new().set_database("example");
    /// ```
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportClusterRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterRequest;
    /// use google_cloud_alloydb_v1::model::export_cluster_request;
    /// use google_cloud_alloydb_v1::model::GcsDestination;
    /// let x = ExportClusterRequest::new().set_destination(Some(export_cluster_request::Destination::GcsDestination(GcsDestination::default().into())));
    /// ```
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_cluster_request::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportClusterRequest::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_cluster_request::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportClusterRequest::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterRequest;
    /// use google_cloud_alloydb_v1::model::GcsDestination;
    /// let x = ExportClusterRequest::new().set_gcs_destination(GcsDestination::default()/* use setters */);
    /// assert!(x.gcs_destination().is_some());
    /// ```
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_cluster_request::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options].
    ///
    /// Note that all the setters affecting `export_options` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterRequest;
    /// use google_cloud_alloydb_v1::model::export_cluster_request;
    /// use google_cloud_alloydb_v1::model::export_cluster_request::CsvExportOptions;
    /// let x = ExportClusterRequest::new().set_export_options(Some(export_cluster_request::ExportOptions::CsvExportOptions(CsvExportOptions::default().into())));
    /// ```
    pub fn set_export_options<
        T: std::convert::Into<
                std::option::Option<crate::model::export_cluster_request::ExportOptions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_options = v.into();
        self
    }

    /// The value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// if it holds a `CsvExportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_export_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.export_options.as_ref().and_then(|v| match v {
            crate::model::export_cluster_request::ExportOptions::CsvExportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// to hold a `CsvExportOptions`.
    ///
    /// Note that all the setters affecting `export_options` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterRequest;
    /// use google_cloud_alloydb_v1::model::export_cluster_request::CsvExportOptions;
    /// let x = ExportClusterRequest::new().set_csv_export_options(CsvExportOptions::default()/* use setters */);
    /// assert!(x.csv_export_options().is_some());
    /// assert!(x.sql_export_options().is_none());
    /// ```
    pub fn set_csv_export_options<
        T: std::convert::Into<std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_options = std::option::Option::Some(
            crate::model::export_cluster_request::ExportOptions::CsvExportOptions(v.into()),
        );
        self
    }

    /// The value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// if it holds a `SqlExportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_export_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.export_options.as_ref().and_then(|v| match v {
            crate::model::export_cluster_request::ExportOptions::SqlExportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// to hold a `SqlExportOptions`.
    ///
    /// Note that all the setters affecting `export_options` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterRequest;
    /// use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
    /// let x = ExportClusterRequest::new().set_sql_export_options(SqlExportOptions::default()/* use setters */);
    /// assert!(x.sql_export_options().is_some());
    /// assert!(x.csv_export_options().is_none());
    /// ```
    pub fn set_sql_export_options<
        T: std::convert::Into<std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_options = std::option::Option::Some(
            crate::model::export_cluster_request::ExportOptions::SqlExportOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterRequest"
    }
}

/// Defines additional types related to [ExportClusterRequest].
pub mod export_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Options for exporting data in CSV format.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CsvExportOptions {
        /// Required. The SELECT query used to extract the data.
        pub select_query: std::string::String,

        /// Optional. Specifies the character that separates columns within each row
        /// (line) of the file. The default is comma. The value of this argument has
        /// to be a character in Hex ASCII Code.
        pub field_delimiter: std::string::String,

        /// Optional. Specifies the quoting character to be used when a data value is
        /// quoted. The default is double-quote. The value of this argument has to be
        /// a character in Hex ASCII Code.
        pub quote_character: std::string::String,

        /// Optional. Specifies the character that should appear before a data
        /// character that needs to be escaped. The default is the same as quote
        /// character. The value of this argument has to be a character in Hex ASCII
        /// Code.
        pub escape_character: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [select_query][crate::model::export_cluster_request::CsvExportOptions::select_query].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::CsvExportOptions;
        /// let x = CsvExportOptions::new().set_select_query("example");
        /// ```
        pub fn set_select_query<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.select_query = v.into();
            self
        }

        /// Sets the value of [field_delimiter][crate::model::export_cluster_request::CsvExportOptions::field_delimiter].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::CsvExportOptions;
        /// let x = CsvExportOptions::new().set_field_delimiter("example");
        /// ```
        pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.field_delimiter = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::export_cluster_request::CsvExportOptions::quote_character].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::CsvExportOptions;
        /// let x = CsvExportOptions::new().set_quote_character("example");
        /// ```
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::export_cluster_request::CsvExportOptions::escape_character].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::CsvExportOptions;
        /// let x = CsvExportOptions::new().set_escape_character("example");
        /// ```
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.escape_character = v.into();
            self
        }
    }

    impl wkt::message::Message for CsvExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterRequest.CsvExportOptions"
        }
    }

    /// Options for exporting data in SQL format.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlExportOptions {
        /// Optional. Tables to export from.
        pub tables: std::vec::Vec<std::string::String>,

        /// Optional. If true, only export the schema.
        pub schema_only: std::option::Option<bool>,

        /// Optional. If true, output commands to DROP all the dumped database
        /// objects prior to outputting the commands for creating them.
        pub clean_target_objects: std::option::Option<bool>,

        /// Optional. If true, use DROP ... IF EXISTS commands to check for the
        /// object's existence before dropping it in clean_target_objects mode.
        pub if_exist_target_objects: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tables][crate::model::export_cluster_request::SqlExportOptions::tables].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
        /// let x = SqlExportOptions::new().set_tables(["a", "b", "c"]);
        /// ```
        pub fn set_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tables = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [schema_only][crate::model::export_cluster_request::SqlExportOptions::schema_only].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
        /// let x = SqlExportOptions::new().set_schema_only(true);
        /// ```
        pub fn set_schema_only<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.schema_only = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [schema_only][crate::model::export_cluster_request::SqlExportOptions::schema_only].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
        /// let x = SqlExportOptions::new().set_or_clear_schema_only(Some(false));
        /// let x = SqlExportOptions::new().set_or_clear_schema_only(None::<bool>);
        /// ```
        pub fn set_or_clear_schema_only<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.schema_only = v.map(|x| x.into());
            self
        }

        /// Sets the value of [clean_target_objects][crate::model::export_cluster_request::SqlExportOptions::clean_target_objects].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
        /// let x = SqlExportOptions::new().set_clean_target_objects(true);
        /// ```
        pub fn set_clean_target_objects<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.clean_target_objects = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [clean_target_objects][crate::model::export_cluster_request::SqlExportOptions::clean_target_objects].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
        /// let x = SqlExportOptions::new().set_or_clear_clean_target_objects(Some(false));
        /// let x = SqlExportOptions::new().set_or_clear_clean_target_objects(None::<bool>);
        /// ```
        pub fn set_or_clear_clean_target_objects<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.clean_target_objects = v.map(|x| x.into());
            self
        }

        /// Sets the value of [if_exist_target_objects][crate::model::export_cluster_request::SqlExportOptions::if_exist_target_objects].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
        /// let x = SqlExportOptions::new().set_if_exist_target_objects(true);
        /// ```
        pub fn set_if_exist_target_objects<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.if_exist_target_objects = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [if_exist_target_objects][crate::model::export_cluster_request::SqlExportOptions::if_exist_target_objects].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::export_cluster_request::SqlExportOptions;
        /// let x = SqlExportOptions::new().set_or_clear_if_exist_target_objects(Some(false));
        /// let x = SqlExportOptions::new().set_or_clear_if_exist_target_objects(None::<bool>);
        /// ```
        pub fn set_or_clear_if_exist_target_objects<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.if_exist_target_objects = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterRequest.SqlExportOptions"
        }
    }

    /// Oneof field to support other destinations in future.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Required. Option to export data to cloud storage.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }

    /// Required field to specify export file type and options.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExportOptions {
        /// Options for exporting data in CSV format. Required field to be set for
        /// CSV file type.
        CsvExportOptions(std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>),
        /// Options for exporting data in SQL format. Required field to be set for
        /// SQL file type.
        SqlExportOptions(std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>),
    }
}

/// Response of export cluster rpc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportClusterResponse {
    /// Oneof field to support other destinations in future.
    pub destination: std::option::Option<crate::model::export_cluster_response::Destination>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportClusterResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ExportClusterResponse::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterResponse;
    /// use google_cloud_alloydb_v1::model::export_cluster_response;
    /// use google_cloud_alloydb_v1::model::GcsDestination;
    /// let x = ExportClusterResponse::new().set_destination(Some(export_cluster_response::Destination::GcsDestination(GcsDestination::default().into())));
    /// ```
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_cluster_response::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportClusterResponse::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_cluster_response::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportClusterResponse::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExportClusterResponse;
    /// use google_cloud_alloydb_v1::model::GcsDestination;
    /// let x = ExportClusterResponse::new().set_gcs_destination(GcsDestination::default()/* use setters */);
    /// assert!(x.gcs_destination().is_some());
    /// ```
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_cluster_response::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportClusterResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterResponse"
    }
}

/// Defines additional types related to [ExportClusterResponse].
pub mod export_cluster_response {
    #[allow(unused_imports)]
    use super::*;

    /// Oneof field to support other destinations in future.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Required. Option to export data to cloud storage.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// Import cluster request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. The path to the file in Google Cloud Storage where the source
    /// file for import will be stored. The URI is in the form
    /// `gs://bucketName/fileName`.
    pub gcs_uri: std::string::String,

    /// Optional. Name of the database to which the import will be done.
    /// For import from SQL file, this is required only if the file does not
    /// specify a database.
    /// Note - Value provided should be the same as expected from `SELECT
    /// current_database();` and NOT as a resource reference.
    pub database: std::string::String,

    /// Optional. Database user to be used for importing the data.
    /// Note - Value provided should be the same as expected from
    /// `SELECT current_user;` and NOT as a resource reference.
    pub user: std::string::String,

    /// oneof field to support various import formats like SQL and CSV.
    pub import_options: std::option::Option<crate::model::import_cluster_request::ImportOptions>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportClusterRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterRequest;
    /// let x = ImportClusterRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [gcs_uri][crate::model::ImportClusterRequest::gcs_uri].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterRequest;
    /// let x = ImportClusterRequest::new().set_gcs_uri("example");
    /// ```
    pub fn set_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_uri = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ImportClusterRequest::database].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterRequest;
    /// let x = ImportClusterRequest::new().set_database("example");
    /// ```
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [user][crate::model::ImportClusterRequest::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterRequest;
    /// let x = ImportClusterRequest::new().set_user("example");
    /// ```
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options].
    ///
    /// Note that all the setters affecting `import_options` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterRequest;
    /// use google_cloud_alloydb_v1::model::import_cluster_request;
    /// use google_cloud_alloydb_v1::model::import_cluster_request::SqlImportOptions;
    /// let x = ImportClusterRequest::new().set_import_options(Some(import_cluster_request::ImportOptions::SqlImportOptions(SqlImportOptions::default().into())));
    /// ```
    pub fn set_import_options<
        T: std::convert::Into<
                std::option::Option<crate::model::import_cluster_request::ImportOptions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_options = v.into();
        self
    }

    /// The value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// if it holds a `SqlImportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_import_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.import_options.as_ref().and_then(|v| match v {
            crate::model::import_cluster_request::ImportOptions::SqlImportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// to hold a `SqlImportOptions`.
    ///
    /// Note that all the setters affecting `import_options` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterRequest;
    /// use google_cloud_alloydb_v1::model::import_cluster_request::SqlImportOptions;
    /// let x = ImportClusterRequest::new().set_sql_import_options(SqlImportOptions::default()/* use setters */);
    /// assert!(x.sql_import_options().is_some());
    /// assert!(x.csv_import_options().is_none());
    /// ```
    pub fn set_sql_import_options<
        T: std::convert::Into<std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_options = std::option::Option::Some(
            crate::model::import_cluster_request::ImportOptions::SqlImportOptions(v.into()),
        );
        self
    }

    /// The value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// if it holds a `CsvImportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_import_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.import_options.as_ref().and_then(|v| match v {
            crate::model::import_cluster_request::ImportOptions::CsvImportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// to hold a `CsvImportOptions`.
    ///
    /// Note that all the setters affecting `import_options` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterRequest;
    /// use google_cloud_alloydb_v1::model::import_cluster_request::CsvImportOptions;
    /// let x = ImportClusterRequest::new().set_csv_import_options(CsvImportOptions::default()/* use setters */);
    /// assert!(x.csv_import_options().is_some());
    /// assert!(x.sql_import_options().is_none());
    /// ```
    pub fn set_csv_import_options<
        T: std::convert::Into<std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_options = std::option::Option::Some(
            crate::model::import_cluster_request::ImportOptions::CsvImportOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterRequest"
    }
}

/// Defines additional types related to [ImportClusterRequest].
pub mod import_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Options for importing data in SQL format.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlImportOptions {
        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SqlImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterRequest.SqlImportOptions"
        }
    }

    /// Options for importing data in CSV format.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CsvImportOptions {
        /// Required. The database table to import CSV file into.
        pub table: std::string::String,

        /// Optional. The columns to which CSV data is imported. If not specified,
        /// all columns of the database table are loaded with CSV data.
        pub columns: std::vec::Vec<std::string::String>,

        /// Optional. Specifies the character that separates columns within each row
        /// (line) of the file. The default is comma. The value of this argument has
        /// to be a character in Hex ASCII Code.
        pub field_delimiter: std::string::String,

        /// Optional. Specifies the quoting character to be used when a data value is
        /// quoted. The default is double-quote. The value of this argument has to be
        /// a character in Hex ASCII Code.
        pub quote_character: std::string::String,

        /// Optional. Specifies the character that should appear before a data
        /// character that needs to be escaped. The default is same as quote
        /// character. The value of this argument has to be a character in Hex ASCII
        /// Code.
        pub escape_character: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::import_cluster_request::CsvImportOptions::table].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::import_cluster_request::CsvImportOptions;
        /// let x = CsvImportOptions::new().set_table("example");
        /// ```
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [columns][crate::model::import_cluster_request::CsvImportOptions::columns].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::import_cluster_request::CsvImportOptions;
        /// let x = CsvImportOptions::new().set_columns(["a", "b", "c"]);
        /// ```
        pub fn set_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.columns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [field_delimiter][crate::model::import_cluster_request::CsvImportOptions::field_delimiter].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::import_cluster_request::CsvImportOptions;
        /// let x = CsvImportOptions::new().set_field_delimiter("example");
        /// ```
        pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.field_delimiter = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::import_cluster_request::CsvImportOptions::quote_character].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::import_cluster_request::CsvImportOptions;
        /// let x = CsvImportOptions::new().set_quote_character("example");
        /// ```
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::import_cluster_request::CsvImportOptions::escape_character].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::import_cluster_request::CsvImportOptions;
        /// let x = CsvImportOptions::new().set_escape_character("example");
        /// ```
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.escape_character = v.into();
            self
        }
    }

    impl wkt::message::Message for CsvImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterRequest.CsvImportOptions"
        }
    }

    /// oneof field to support various import formats like SQL and CSV.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportOptions {
        /// Options for importing data in SQL format.
        SqlImportOptions(std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>),
        /// Options for importing data in CSV format.
        CsvImportOptions(std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>),
    }
}

/// Response of import rpc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportClusterResponse {
    /// Required. Size of the object downloaded from Google Cloud Storage in bytes.
    pub bytes_downloaded: i64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportClusterResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bytes_downloaded][crate::model::ImportClusterResponse::bytes_downloaded].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ImportClusterResponse;
    /// let x = ImportClusterResponse::new().set_bytes_downloaded(42);
    /// ```
    pub fn set_bytes_downloaded<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_downloaded = v.into();
        self
    }
}

impl wkt::message::Message for ImportClusterResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterResponse"
    }
}

/// Upgrades a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. The version the cluster is going to be upgraded to.
    pub version: crate::model::DatabaseVersion,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// upgrade will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeClusterRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterRequest;
    /// let x = UpgradeClusterRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpgradeClusterRequest::version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterRequest;
    /// use google_cloud_alloydb_v1::model::DatabaseVersion;
    /// let x0 = UpgradeClusterRequest::new().set_version(DatabaseVersion::Postgres14);
    /// let x1 = UpgradeClusterRequest::new().set_version(DatabaseVersion::Postgres15);
    /// let x2 = UpgradeClusterRequest::new().set_version(DatabaseVersion::Postgres16);
    /// ```
    pub fn set_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterRequest;
    /// let x = UpgradeClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpgradeClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterRequest;
    /// let x = UpgradeClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UpgradeClusterRequest::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterRequest;
    /// let x = UpgradeClusterRequest::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterRequest"
    }
}

/// UpgradeClusterResponse contains the response for upgrade cluster operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterResponse {
    /// Status of upgrade operation.
    pub status: crate::model::upgrade_cluster_response::Status,

    /// A user friendly message summarising the upgrade operation details and the
    /// next steps for the user if there is any.
    pub message: std::string::String,

    /// Array of upgrade details for the current cluster and all the secondary
    /// clusters associated with this cluster.
    pub cluster_upgrade_details:
        std::vec::Vec<crate::model::upgrade_cluster_response::ClusterUpgradeDetails>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::UpgradeClusterResponse::status].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterResponse;
    /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Status;
    /// let x0 = UpgradeClusterResponse::new().set_status(Status::NotStarted);
    /// let x1 = UpgradeClusterResponse::new().set_status(Status::InProgress);
    /// let x2 = UpgradeClusterResponse::new().set_status(Status::Success);
    /// ```
    pub fn set_status<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [message][crate::model::UpgradeClusterResponse::message].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterResponse;
    /// let x = UpgradeClusterResponse::new().set_message("example");
    /// ```
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [cluster_upgrade_details][crate::model::UpgradeClusterResponse::cluster_upgrade_details].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterResponse;
    /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::ClusterUpgradeDetails;
    /// let x = UpgradeClusterResponse::new()
    ///     .set_cluster_upgrade_details([
    ///         ClusterUpgradeDetails::default()/* use setters */,
    ///         ClusterUpgradeDetails::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_cluster_upgrade_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::upgrade_cluster_response::ClusterUpgradeDetails>,
    {
        use std::iter::Iterator;
        self.cluster_upgrade_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpgradeClusterResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse"
    }
}

/// Defines additional types related to [UpgradeClusterResponse].
pub mod upgrade_cluster_response {
    #[allow(unused_imports)]
    use super::*;

    /// Stage information for different stages in the upgrade process.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StageInfo {
        /// The stage.
        pub stage: crate::model::upgrade_cluster_response::Stage,

        /// Status of the stage.
        pub status: crate::model::upgrade_cluster_response::Status,

        /// logs_url is the URL for the logs associated with a stage if that stage
        /// has logs. Right now, only three stages have logs: ALLOYDB_PRECHECK,
        /// PG_UPGRADE_CHECK, PRIMARY_INSTANCE_UPGRADE.
        pub logs_url: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StageInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [stage][crate::model::upgrade_cluster_response::StageInfo::stage].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::StageInfo;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Stage;
        /// let x0 = StageInfo::new().set_stage(Stage::AlloydbPrecheck);
        /// let x1 = StageInfo::new().set_stage(Stage::PgUpgradeCheck);
        /// let x2 = StageInfo::new().set_stage(Stage::PrepareForUpgrade);
        /// ```
        pub fn set_stage<T: std::convert::Into<crate::model::upgrade_cluster_response::Stage>>(
            mut self,
            v: T,
        ) -> Self {
            self.stage = v.into();
            self
        }

        /// Sets the value of [status][crate::model::upgrade_cluster_response::StageInfo::status].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::StageInfo;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Status;
        /// let x0 = StageInfo::new().set_status(Status::NotStarted);
        /// let x1 = StageInfo::new().set_status(Status::InProgress);
        /// let x2 = StageInfo::new().set_status(Status::Success);
        /// ```
        pub fn set_status<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [logs_url][crate::model::upgrade_cluster_response::StageInfo::logs_url].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::StageInfo;
        /// let x = StageInfo::new().set_logs_url("example");
        /// ```
        pub fn set_logs_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.logs_url = v.into();
            self
        }
    }

    impl wkt::message::Message for StageInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse.StageInfo"
        }
    }

    /// Details regarding the upgrade of instances associated with a cluster.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceUpgradeDetails {
        /// Normalized name of the instance.
        pub name: std::string::String,

        /// Upgrade status of the instance.
        pub upgrade_status: crate::model::upgrade_cluster_response::Status,

        /// Instance type.
        pub instance_type: crate::model::instance::InstanceType,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceUpgradeDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::upgrade_cluster_response::InstanceUpgradeDetails::name].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::InstanceUpgradeDetails;
        /// let x = InstanceUpgradeDetails::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [upgrade_status][crate::model::upgrade_cluster_response::InstanceUpgradeDetails::upgrade_status].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::InstanceUpgradeDetails;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Status;
        /// let x0 = InstanceUpgradeDetails::new().set_upgrade_status(Status::NotStarted);
        /// let x1 = InstanceUpgradeDetails::new().set_upgrade_status(Status::InProgress);
        /// let x2 = InstanceUpgradeDetails::new().set_upgrade_status(Status::Success);
        /// ```
        pub fn set_upgrade_status<
            T: std::convert::Into<crate::model::upgrade_cluster_response::Status>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upgrade_status = v.into();
            self
        }

        /// Sets the value of [instance_type][crate::model::upgrade_cluster_response::InstanceUpgradeDetails::instance_type].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::InstanceUpgradeDetails;
        /// use google_cloud_alloydb_v1::model::instance::InstanceType;
        /// let x0 = InstanceUpgradeDetails::new().set_instance_type(InstanceType::Primary);
        /// let x1 = InstanceUpgradeDetails::new().set_instance_type(InstanceType::ReadPool);
        /// let x2 = InstanceUpgradeDetails::new().set_instance_type(InstanceType::Secondary);
        /// ```
        pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_type = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceUpgradeDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse.InstanceUpgradeDetails"
        }
    }

    /// Upgrade details of a cluster. This cluster can be primary or secondary.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterUpgradeDetails {
        /// Normalized name of the cluster
        pub name: std::string::String,

        /// Upgrade status of the cluster.
        pub upgrade_status: crate::model::upgrade_cluster_response::Status,

        /// Cluster type which can either be primary or secondary.
        pub cluster_type: crate::model::cluster::ClusterType,

        /// Database version of the cluster after the upgrade operation. This will be
        /// the target version if the upgrade was successful otherwise it remains the
        /// same as that before the upgrade operation.
        pub database_version: crate::model::DatabaseVersion,

        /// Array containing stage info associated with this cluster.
        pub stage_info: std::vec::Vec<crate::model::upgrade_cluster_response::StageInfo>,

        /// Upgrade details of the instances directly associated with this cluster.
        pub instance_upgrade_details:
            std::vec::Vec<crate::model::upgrade_cluster_response::InstanceUpgradeDetails>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterUpgradeDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::name].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::ClusterUpgradeDetails;
        /// let x = ClusterUpgradeDetails::new().set_name("example");
        /// ```
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [upgrade_status][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::upgrade_status].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::ClusterUpgradeDetails;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Status;
        /// let x0 = ClusterUpgradeDetails::new().set_upgrade_status(Status::NotStarted);
        /// let x1 = ClusterUpgradeDetails::new().set_upgrade_status(Status::InProgress);
        /// let x2 = ClusterUpgradeDetails::new().set_upgrade_status(Status::Success);
        /// ```
        pub fn set_upgrade_status<
            T: std::convert::Into<crate::model::upgrade_cluster_response::Status>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upgrade_status = v.into();
            self
        }

        /// Sets the value of [cluster_type][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::cluster_type].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::ClusterUpgradeDetails;
        /// use google_cloud_alloydb_v1::model::cluster::ClusterType;
        /// let x0 = ClusterUpgradeDetails::new().set_cluster_type(ClusterType::Primary);
        /// let x1 = ClusterUpgradeDetails::new().set_cluster_type(ClusterType::Secondary);
        /// ```
        pub fn set_cluster_type<T: std::convert::Into<crate::model::cluster::ClusterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_type = v.into();
            self
        }

        /// Sets the value of [database_version][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::database_version].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::ClusterUpgradeDetails;
        /// use google_cloud_alloydb_v1::model::DatabaseVersion;
        /// let x0 = ClusterUpgradeDetails::new().set_database_version(DatabaseVersion::Postgres14);
        /// let x1 = ClusterUpgradeDetails::new().set_database_version(DatabaseVersion::Postgres15);
        /// let x2 = ClusterUpgradeDetails::new().set_database_version(DatabaseVersion::Postgres16);
        /// ```
        pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
            mut self,
            v: T,
        ) -> Self {
            self.database_version = v.into();
            self
        }

        /// Sets the value of [stage_info][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::stage_info].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::ClusterUpgradeDetails;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::StageInfo;
        /// let x = ClusterUpgradeDetails::new()
        ///     .set_stage_info([
        ///         StageInfo::default()/* use setters */,
        ///         StageInfo::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_stage_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::upgrade_cluster_response::StageInfo>,
        {
            use std::iter::Iterator;
            self.stage_info = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [instance_upgrade_details][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::instance_upgrade_details].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_response::ClusterUpgradeDetails;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::InstanceUpgradeDetails;
        /// let x = ClusterUpgradeDetails::new()
        ///     .set_instance_upgrade_details([
        ///         InstanceUpgradeDetails::default()/* use setters */,
        ///         InstanceUpgradeDetails::default()/* use (different) setters */,
        ///     ]);
        /// ```
        pub fn set_instance_upgrade_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::upgrade_cluster_response::InstanceUpgradeDetails>,
        {
            use std::iter::Iterator;
            self.instance_upgrade_details = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ClusterUpgradeDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse.ClusterUpgradeDetails"
        }
    }

    /// Status of upgrade operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unspecified status.
        Unspecified,
        /// Not started.
        NotStarted,
        /// In progress.
        InProgress,
        /// Operation succeeded.
        Success,
        /// Operation failed.
        Failed,
        /// Operation partially succeeded.
        PartialSuccess,
        /// Cancel is in progress.
        CancelInProgress,
        /// Cancellation complete.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotStarted => std::option::Option::Some(4),
                Self::InProgress => std::option::Option::Some(5),
                Self::Success => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::PartialSuccess => std::option::Option::Some(3),
                Self::CancelInProgress => std::option::Option::Some(6),
                Self::Cancelled => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                Self::CancelInProgress => std::option::Option::Some("CANCEL_IN_PROGRESS"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Success,
                2 => Self::Failed,
                3 => Self::PartialSuccess,
                4 => Self::NotStarted,
                5 => Self::InProgress,
                6 => Self::CancelInProgress,
                7 => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "NOT_STARTED" => Self::NotStarted,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCESS" => Self::Success,
                "FAILED" => Self::Failed,
                "PARTIAL_SUCCESS" => Self::PartialSuccess,
                "CANCEL_IN_PROGRESS" => Self::CancelInProgress,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotStarted => serializer.serialize_i32(4),
                Self::InProgress => serializer.serialize_i32(5),
                Self::Success => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::PartialSuccess => serializer.serialize_i32(3),
                Self::CancelInProgress => serializer.serialize_i32(6),
                Self::Cancelled => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.alloydb.v1.UpgradeClusterResponse.Status",
            ))
        }
    }

    /// Stage in the upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Stage {
        /// Unspecified stage.
        Unspecified,
        /// Pre-upgrade custom checks, not covered by pg_upgrade.
        AlloydbPrecheck,
        /// Pre-upgrade pg_upgrade checks.
        PgUpgradeCheck,
        /// Clone the original cluster.
        PrepareForUpgrade,
        /// Upgrade the primary instance(downtime).
        PrimaryInstanceUpgrade,
        /// This stage is read pool upgrade.
        ReadPoolInstancesUpgrade,
        /// Rollback in case of critical failures.
        Rollback,
        /// Cleanup.
        Cleanup,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Stage::value] or
        /// [Stage::name].
        UnknownValue(stage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Stage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AlloydbPrecheck => std::option::Option::Some(1),
                Self::PgUpgradeCheck => std::option::Option::Some(2),
                Self::PrepareForUpgrade => std::option::Option::Some(5),
                Self::PrimaryInstanceUpgrade => std::option::Option::Some(3),
                Self::ReadPoolInstancesUpgrade => std::option::Option::Some(4),
                Self::Rollback => std::option::Option::Some(6),
                Self::Cleanup => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STAGE_UNSPECIFIED"),
                Self::AlloydbPrecheck => std::option::Option::Some("ALLOYDB_PRECHECK"),
                Self::PgUpgradeCheck => std::option::Option::Some("PG_UPGRADE_CHECK"),
                Self::PrepareForUpgrade => std::option::Option::Some("PREPARE_FOR_UPGRADE"),
                Self::PrimaryInstanceUpgrade => {
                    std::option::Option::Some("PRIMARY_INSTANCE_UPGRADE")
                }
                Self::ReadPoolInstancesUpgrade => {
                    std::option::Option::Some("READ_POOL_INSTANCES_UPGRADE")
                }
                Self::Rollback => std::option::Option::Some("ROLLBACK"),
                Self::Cleanup => std::option::Option::Some("CLEANUP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Stage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Stage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Stage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AlloydbPrecheck,
                2 => Self::PgUpgradeCheck,
                3 => Self::PrimaryInstanceUpgrade,
                4 => Self::ReadPoolInstancesUpgrade,
                5 => Self::PrepareForUpgrade,
                6 => Self::Rollback,
                7 => Self::Cleanup,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Stage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STAGE_UNSPECIFIED" => Self::Unspecified,
                "ALLOYDB_PRECHECK" => Self::AlloydbPrecheck,
                "PG_UPGRADE_CHECK" => Self::PgUpgradeCheck,
                "PREPARE_FOR_UPGRADE" => Self::PrepareForUpgrade,
                "PRIMARY_INSTANCE_UPGRADE" => Self::PrimaryInstanceUpgrade,
                "READ_POOL_INSTANCES_UPGRADE" => Self::ReadPoolInstancesUpgrade,
                "ROLLBACK" => Self::Rollback,
                "CLEANUP" => Self::Cleanup,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Stage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AlloydbPrecheck => serializer.serialize_i32(1),
                Self::PgUpgradeCheck => serializer.serialize_i32(2),
                Self::PrepareForUpgrade => serializer.serialize_i32(5),
                Self::PrimaryInstanceUpgrade => serializer.serialize_i32(3),
                Self::ReadPoolInstancesUpgrade => serializer.serialize_i32(4),
                Self::Rollback => serializer.serialize_i32(6),
                Self::Cleanup => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Stage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Stage>::new(
                ".google.cloud.alloydb.v1.UpgradeClusterResponse.Stage",
            ))
        }
    }
}

/// Message for deleting a Cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. Whether to cascade delete child instances for given cluster.
    pub force: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteClusterRequest;
    /// let x = DeleteClusterRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteClusterRequest;
    /// let x = DeleteClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteClusterRequest::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteClusterRequest;
    /// let x = DeleteClusterRequest::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteClusterRequest;
    /// let x = DeleteClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteClusterRequest::force].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteClusterRequest;
    /// let x = DeleteClusterRequest::new().set_force(true);
    /// ```
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteClusterRequest"
    }
}

/// Message for switching over to a cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SwitchoverClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SwitchoverClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SwitchoverClusterRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SwitchoverClusterRequest;
    /// let x = SwitchoverClusterRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::SwitchoverClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SwitchoverClusterRequest;
    /// let x = SwitchoverClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::SwitchoverClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::SwitchoverClusterRequest;
    /// let x = SwitchoverClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for SwitchoverClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SwitchoverClusterRequest"
    }
}

/// Message for promoting a Cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PromoteClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PromoteClusterRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::PromoteClusterRequest;
    /// let x = PromoteClusterRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::PromoteClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::PromoteClusterRequest;
    /// let x = PromoteClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::PromoteClusterRequest::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::PromoteClusterRequest;
    /// let x = PromoteClusterRequest::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::PromoteClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::PromoteClusterRequest;
    /// let x = PromoteClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for PromoteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.PromoteClusterRequest"
    }
}

/// Message for restoring a Cluster from a backup or another cluster at a given
/// point in time.
/// NEXT_ID: 11
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreClusterRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Required.
    /// The source to import from.
    pub source: std::option::Option<crate::model::restore_cluster_request::Source>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreClusterRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// let x = RestoreClusterRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::RestoreClusterRequest::cluster_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// let x = RestoreClusterRequest::new().set_cluster_id("example");
    /// ```
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::RestoreClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = RestoreClusterRequest::new().set_cluster(Cluster::default()/* use setters */);
    /// ```
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::RestoreClusterRequest::cluster].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// use google_cloud_alloydb_v1::model::Cluster;
    /// let x = RestoreClusterRequest::new().set_or_clear_cluster(Some(Cluster::default()/* use setters */));
    /// let x = RestoreClusterRequest::new().set_or_clear_cluster(None::<Cluster>);
    /// ```
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::RestoreClusterRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// let x = RestoreClusterRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RestoreClusterRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// let x = RestoreClusterRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// use google_cloud_alloydb_v1::model::restore_cluster_request;
    /// use google_cloud_alloydb_v1::model::BackupSource;
    /// let x = RestoreClusterRequest::new().set_source(Some(restore_cluster_request::Source::BackupSource(BackupSource::default().into())));
    /// ```
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_cluster_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreClusterRequest::source]
    /// if it holds a `BackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_cluster_request::Source::BackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
    /// to hold a `BackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// use google_cloud_alloydb_v1::model::BackupSource;
    /// let x = RestoreClusterRequest::new().set_backup_source(BackupSource::default()/* use setters */);
    /// assert!(x.backup_source().is_some());
    /// assert!(x.continuous_backup_source().is_none());
    /// ```
    pub fn set_backup_source<T: std::convert::Into<std::boxed::Box<crate::model::BackupSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_cluster_request::Source::BackupSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::RestoreClusterRequest::source]
    /// if it holds a `ContinuousBackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn continuous_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ContinuousBackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_cluster_request::Source::ContinuousBackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
    /// to hold a `ContinuousBackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestoreClusterRequest;
    /// use google_cloud_alloydb_v1::model::ContinuousBackupSource;
    /// let x = RestoreClusterRequest::new().set_continuous_backup_source(ContinuousBackupSource::default()/* use setters */);
    /// assert!(x.continuous_backup_source().is_some());
    /// assert!(x.backup_source().is_none());
    /// ```
    pub fn set_continuous_backup_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ContinuousBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_cluster_request::Source::ContinuousBackupSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestoreClusterRequest"
    }
}

/// Defines additional types related to [RestoreClusterRequest].
pub mod restore_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required.
    /// The source to import from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Backup source.
        BackupSource(std::boxed::Box<crate::model::BackupSource>),
        /// ContinuousBackup source. Continuous backup needs to be enabled in the
        /// source cluster for this operation to succeed.
        ContinuousBackupSource(std::boxed::Box<crate::model::ContinuousBackupSource>),
    }
}

/// Message for requesting list of Instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field. Additionally, you can perform an
    /// aggregated list operation by specifying a value with one of the following
    /// formats:
    ///
    /// * projects/{project}/locations/-/clusters/-
    /// * projects/{project}/locations/{region}/clusters/-
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesRequest;
    /// let x = ListInstancesRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListInstancesRequest"
    }
}

/// Message for response to listing Instances
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of Instance
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesResponse;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = ListInstancesResponse::new()
    ///     .set_instances([
    ///         Instance::default()/* use setters */,
    ///         Instance::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesResponse;
    /// let x = ListInstancesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListInstancesResponse;
    /// let x = ListInstancesResponse::new().set_unreachable(["a", "b", "c"]);
    /// ```
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// The view of the instance to return.
    pub view: crate::model::InstanceView,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetInstanceRequest;
    /// let x = GetInstanceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetInstanceRequest::view].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetInstanceRequest;
    /// use google_cloud_alloydb_v1::model::InstanceView;
    /// let x0 = GetInstanceRequest::new().set_view(InstanceView::Basic);
    /// let x1 = GetInstanceRequest::new().set_view(InstanceView::Full);
    /// ```
    pub fn set_view<T: std::convert::Into<crate::model::InstanceView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetInstanceRequest"
    }
}

/// Message for creating a Instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub instance_id: std::string::String,

    /// Required. The resource being created
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateInstanceRequest;
    /// let x = CreateInstanceRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateInstanceRequest;
    /// let x = CreateInstanceRequest::new().set_instance_id("example");
    /// ```
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateInstanceRequest;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = CreateInstanceRequest::new().set_instance(Instance::default()/* use setters */);
    /// ```
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateInstanceRequest;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = CreateInstanceRequest::new().set_or_clear_instance(Some(Instance::default()/* use setters */));
    /// let x = CreateInstanceRequest::new().set_or_clear_instance(None::<Instance>);
    /// ```
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateInstanceRequest;
    /// let x = CreateInstanceRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateInstanceRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateInstanceRequest;
    /// let x = CreateInstanceRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateInstanceRequest"
    }
}

/// Message for creating a Secondary Instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSecondaryInstanceRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub instance_id: std::string::String,

    /// Required. The resource being created
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSecondaryInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecondaryInstanceRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryInstanceRequest;
    /// let x = CreateSecondaryInstanceRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateSecondaryInstanceRequest::instance_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryInstanceRequest;
    /// let x = CreateSecondaryInstanceRequest::new().set_instance_id("example");
    /// ```
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateSecondaryInstanceRequest::instance].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryInstanceRequest;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = CreateSecondaryInstanceRequest::new().set_instance(Instance::default()/* use setters */);
    /// ```
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateSecondaryInstanceRequest::instance].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryInstanceRequest;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = CreateSecondaryInstanceRequest::new().set_or_clear_instance(Some(Instance::default()/* use setters */));
    /// let x = CreateSecondaryInstanceRequest::new().set_or_clear_instance(None::<Instance>);
    /// ```
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSecondaryInstanceRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryInstanceRequest;
    /// let x = CreateSecondaryInstanceRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateSecondaryInstanceRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateSecondaryInstanceRequest;
    /// let x = CreateSecondaryInstanceRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateSecondaryInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateSecondaryInstanceRequest"
    }
}

/// See usage below for notes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequests {
    /// Required. Primary and read replica instances to be created. This list
    /// should not be empty.
    pub create_instance_requests: std::vec::Vec<crate::model::CreateInstanceRequest>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequests {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_instance_requests][crate::model::CreateInstanceRequests::create_instance_requests].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateInstanceRequests;
    /// use google_cloud_alloydb_v1::model::CreateInstanceRequest;
    /// let x = CreateInstanceRequests::new()
    ///     .set_create_instance_requests([
    ///         CreateInstanceRequest::default()/* use setters */,
    ///         CreateInstanceRequest::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_create_instance_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateInstanceRequest>,
    {
        use std::iter::Iterator;
        self.create_instance_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequests {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateInstanceRequests"
    }
}

/// Message for creating a batch of instances under the specified cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstancesRequest {
    /// Required. The name of the parent resource.
    pub parent: std::string::String,

    /// Required. Resources being created.
    pub requests: std::option::Option<crate::model::CreateInstanceRequests>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateInstancesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstancesRequest;
    /// let x = BatchCreateInstancesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateInstancesRequest::requests].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstancesRequest;
    /// use google_cloud_alloydb_v1::model::CreateInstanceRequests;
    /// let x = BatchCreateInstancesRequest::new().set_requests(CreateInstanceRequests::default()/* use setters */);
    /// ```
    pub fn set_requests<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateInstanceRequests>,
    {
        self.requests = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requests][crate::model::BatchCreateInstancesRequest::requests].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstancesRequest;
    /// use google_cloud_alloydb_v1::model::CreateInstanceRequests;
    /// let x = BatchCreateInstancesRequest::new().set_or_clear_requests(Some(CreateInstanceRequests::default()/* use setters */));
    /// let x = BatchCreateInstancesRequest::new().set_or_clear_requests(None::<CreateInstanceRequests>);
    /// ```
    pub fn set_or_clear_requests<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateInstanceRequests>,
    {
        self.requests = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::BatchCreateInstancesRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstancesRequest;
    /// let x = BatchCreateInstancesRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesRequest"
    }
}

/// Message for creating batches of instances in a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstancesResponse {
    /// Created instances.
    pub instances: std::vec::Vec<crate::model::Instance>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::BatchCreateInstancesResponse::instances].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstancesResponse;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = BatchCreateInstancesResponse::new()
    ///     .set_instances([
    ///         Instance::default()/* use setters */,
    ///         Instance::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesResponse"
    }
}

/// Message for metadata that is specific to BatchCreateInstances API.
/// NEXT_ID: 3
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstancesMetadata {
    /// The instances being created in the API call. Each string in this list
    /// is the server defined resource path for target instances in the request
    /// and for the format of each string, see the comment on the Instance.name
    /// field.
    pub instance_targets: std::vec::Vec<std::string::String>,

    /// A map representing state of the instances involved in the
    /// BatchCreateInstances operation during the operation execution.
    /// The instance state will be in STATE_UNSPECIFIED state if the instance has
    /// not yet been picked up for processing.
    /// The key of the map is the name of the instance resource.
    /// For the format, see the comment on the Instance.name field.
    pub instance_statuses:
        std::collections::HashMap<std::string::String, crate::model::BatchCreateInstanceStatus>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstancesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_targets][crate::model::BatchCreateInstancesMetadata::instance_targets].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstancesMetadata;
    /// let x = BatchCreateInstancesMetadata::new().set_instance_targets(["a", "b", "c"]);
    /// ```
    pub fn set_instance_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_statuses][crate::model::BatchCreateInstancesMetadata::instance_statuses].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstancesMetadata;
    /// use google_cloud_alloydb_v1::model::BatchCreateInstanceStatus;
    /// let x = BatchCreateInstancesMetadata::new().set_instance_statuses([
    ///     ("key0", BatchCreateInstanceStatus::default()/* use setters */),
    ///     ("key1", BatchCreateInstanceStatus::default()/* use (different) setters */),
    /// ]);
    /// ```
    pub fn set_instance_statuses<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BatchCreateInstanceStatus>,
    {
        use std::iter::Iterator;
        self.instance_statuses = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesMetadata"
    }
}

/// Message for current status of an instance in the BatchCreateInstances
/// operation.
/// For example, lets say a BatchCreateInstances workflow has 4 instances,
/// Instance1 through Instance4. Lets also assume that 2 instances succeeded
/// but the third failed to create and the 4th was never picked up for creation
/// because of failure of the previous one. Then, resulting states would look
/// something like:
///
/// 1. Instance1 = ROLLED_BACK
/// 1. Instance2 = ROLLED_BACK
/// 1. Instance3 = FAILED
/// 1. Instance4 = FAILED
///
/// However, while the operation is running, the instance might be in other
/// states including PENDING_CREATE, ACTIVE, DELETING and CREATING. The states
/// / do not get further updated once the operation is done.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstanceStatus {
    /// The current state of an instance involved in the batch create operation.
    /// Once the operation is complete, the final state of the instances in the
    /// LRO can be one of:
    ///
    /// 1. ACTIVE, indicating that instances were created successfully
    /// 1. FAILED, indicating that a particular instance failed creation
    /// 1. ROLLED_BACK indicating that although the instance was created
    ///    successfully, it had to be rolled back and deleted due to failure in
    ///    other steps of the workflow.
    pub state: crate::model::batch_create_instance_status::State,

    /// DEPRECATED - Use the error field instead.
    /// Error, if any error occurred and is available, during instance creation.
    pub error_msg: std::string::String,

    /// The RPC status of the instance creation operation. This field will be
    /// present if an error happened during the instance creation.
    pub error: std::option::Option<rpc::model::Status>,

    pub r#type: crate::model::instance::InstanceType,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstanceStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchCreateInstanceStatus::state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstanceStatus;
    /// use google_cloud_alloydb_v1::model::batch_create_instance_status::State;
    /// let x0 = BatchCreateInstanceStatus::new().set_state(State::PendingCreate);
    /// let x1 = BatchCreateInstanceStatus::new().set_state(State::Ready);
    /// let x2 = BatchCreateInstanceStatus::new().set_state(State::Creating);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::batch_create_instance_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_msg][crate::model::BatchCreateInstanceStatus::error_msg].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstanceStatus;
    /// let x = BatchCreateInstanceStatus::new().set_error_msg("example");
    /// ```
    pub fn set_error_msg<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_msg = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BatchCreateInstanceStatus::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstanceStatus;
    /// use rpc::model::Status;
    /// let x = BatchCreateInstanceStatus::new().set_error(Status::default()/* use setters */);
    /// ```
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::BatchCreateInstanceStatus::error].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstanceStatus;
    /// use rpc::model::Status;
    /// let x = BatchCreateInstanceStatus::new().set_or_clear_error(Some(Status::default()/* use setters */));
    /// let x = BatchCreateInstanceStatus::new().set_or_clear_error(None::<Status>);
    /// ```
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::BatchCreateInstanceStatus::type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::BatchCreateInstanceStatus;
    /// use google_cloud_alloydb_v1::model::instance::InstanceType;
    /// let x0 = BatchCreateInstanceStatus::new().set_type(InstanceType::Primary);
    /// let x1 = BatchCreateInstanceStatus::new().set_type(InstanceType::ReadPool);
    /// let x2 = BatchCreateInstanceStatus::new().set_type(InstanceType::Secondary);
    /// ```
    pub fn set_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for BatchCreateInstanceStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstanceStatus"
    }
}

/// Defines additional types related to [BatchCreateInstanceStatus].
pub mod batch_create_instance_status {
    #[allow(unused_imports)]
    use super::*;

    /// State contains all valid instance states for the BatchCreateInstances
    /// operation. This is mainly used for status reporting through the LRO
    /// metadata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the instance is unknown.
        Unspecified,
        /// Instance is pending creation and has not yet been picked up for
        /// processing in the backend.
        PendingCreate,
        /// The instance is active and running.
        Ready,
        /// The instance is being created.
        Creating,
        /// The instance is being deleted.
        Deleting,
        /// The creation of the instance failed or a fatal error occurred during
        /// an operation on the instance or a batch of instances.
        Failed,
        /// The instance was created successfully, but was rolled back and deleted
        /// due to some other failure during BatchCreateInstances operation.
        RolledBack,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PendingCreate => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::RolledBack => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::PendingCreate => std::option::Option::Some("PENDING_CREATE"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::RolledBack => std::option::Option::Some("ROLLED_BACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PendingCreate,
                2 => Self::Ready,
                3 => Self::Creating,
                4 => Self::Deleting,
                5 => Self::Failed,
                6 => Self::RolledBack,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING_CREATE" => Self::PendingCreate,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "ROLLED_BACK" => Self::RolledBack,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PendingCreate => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::RolledBack => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.BatchCreateInstanceStatus.State",
            ))
        }
    }
}

/// Message for updating a Instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Instance resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if instance is not found. In
    /// that case, a new instance is created and `update_mask` is ignored.
    pub allow_missing: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateInstanceRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstanceRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateInstanceRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateInstanceRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateInstanceRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateInstanceRequest;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = UpdateInstanceRequest::new().set_instance(Instance::default()/* use setters */);
    /// ```
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateInstanceRequest;
    /// use google_cloud_alloydb_v1::model::Instance;
    /// let x = UpdateInstanceRequest::new().set_or_clear_instance(Some(Instance::default()/* use setters */));
    /// let x = UpdateInstanceRequest::new().set_or_clear_instance(None::<Instance>);
    /// ```
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateInstanceRequest;
    /// let x = UpdateInstanceRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInstanceRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateInstanceRequest;
    /// let x = UpdateInstanceRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateInstanceRequest::allow_missing].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateInstanceRequest;
    /// let x = UpdateInstanceRequest::new().set_allow_missing(true);
    /// ```
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateInstanceRequest"
    }
}

/// Message for deleting a Instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. The current etag of the Instance.
    /// If an etag is provided and does not match the current etag of the Instance,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteInstanceRequest;
    /// let x = DeleteInstanceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteInstanceRequest;
    /// let x = DeleteInstanceRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstanceRequest::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteInstanceRequest;
    /// let x = DeleteInstanceRequest::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteInstanceRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteInstanceRequest;
    /// let x = DeleteInstanceRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteInstanceRequest"
    }
}

/// Message for triggering failover on an Instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FailoverInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailoverInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FailoverInstanceRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::FailoverInstanceRequest;
    /// let x = FailoverInstanceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::FailoverInstanceRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::FailoverInstanceRequest;
    /// let x = FailoverInstanceRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::FailoverInstanceRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::FailoverInstanceRequest;
    /// let x = FailoverInstanceRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for FailoverInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.FailoverInstanceRequest"
    }
}

/// Message for triggering fault injection on an instance
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InjectFaultRequest {
    /// Required. The type of fault to be injected in an instance.
    pub fault_type: crate::model::inject_fault_request::FaultType,

    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InjectFaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fault_type][crate::model::InjectFaultRequest::fault_type].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::InjectFaultRequest;
    /// use google_cloud_alloydb_v1::model::inject_fault_request::FaultType;
    /// let x0 = InjectFaultRequest::new().set_fault_type(FaultType::StopVm);
    /// ```
    pub fn set_fault_type<T: std::convert::Into<crate::model::inject_fault_request::FaultType>>(
        mut self,
        v: T,
    ) -> Self {
        self.fault_type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::InjectFaultRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::InjectFaultRequest;
    /// let x = InjectFaultRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InjectFaultRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::InjectFaultRequest;
    /// let x = InjectFaultRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::InjectFaultRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::InjectFaultRequest;
    /// let x = InjectFaultRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for InjectFaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.InjectFaultRequest"
    }
}

/// Defines additional types related to [InjectFaultRequest].
pub mod inject_fault_request {
    #[allow(unused_imports)]
    use super::*;

    /// FaultType contains all valid types of faults that can be injected to an
    /// instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FaultType {
        /// The fault type is unknown.
        Unspecified,
        /// Stop the VM
        StopVm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FaultType::value] or
        /// [FaultType::name].
        UnknownValue(fault_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod fault_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FaultType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StopVm => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAULT_TYPE_UNSPECIFIED"),
                Self::StopVm => std::option::Option::Some("STOP_VM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FaultType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FaultType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FaultType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StopVm,
                _ => Self::UnknownValue(fault_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FaultType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAULT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STOP_VM" => Self::StopVm,
                _ => Self::UnknownValue(fault_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FaultType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StopVm => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FaultType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FaultType>::new(
                ".google.cloud.alloydb.v1.InjectFaultRequest.FaultType",
            ))
        }
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestartInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. Full name of the nodes as obtained from INSTANCE_VIEW_FULL to
    /// restart upon. Applicable only to read instances.
    pub node_ids: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartInstanceRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestartInstanceRequest;
    /// let x = RestartInstanceRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RestartInstanceRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestartInstanceRequest;
    /// let x = RestartInstanceRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RestartInstanceRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestartInstanceRequest;
    /// let x = RestartInstanceRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [node_ids][crate::model::RestartInstanceRequest::node_ids].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::RestartInstanceRequest;
    /// let x = RestartInstanceRequest::new().set_node_ids(["a", "b", "c"]);
    /// ```
    pub fn set_node_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.node_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RestartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestartInstanceRequest"
    }
}

/// Request for ExecuteSql rpc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteSqlRequest {
    /// Required. The instance where the SQL will be executed. For the required
    /// format, see the comment on the Instance.name field.
    pub instance: std::string::String,

    /// Required. Name of the database where the query will be executed.
    /// Note - Value provided should be the same as expected from `SELECT
    /// current_database();` and NOT as a resource reference.
    pub database: std::string::String,

    /// Required. Database user to be used for executing the SQL.
    /// Note - Value provided should be the same as expected from
    /// `SELECT current_user;` and NOT as a resource reference.
    pub user: std::string::String,

    /// Required. SQL statement to execute on database. Any valid statement is
    /// permitted, including DDL, DML, DQL statements.
    pub sql_statement: std::string::String,

    /// Optional. If set, validates the sql statement by performing
    /// syntax and semantic validation and doesn't execute the query.
    pub validate_only: bool,

    /// Oneof field to support other credential mechanisms in future like
    /// SecretManager etc.
    pub user_credential: std::option::Option<crate::model::execute_sql_request::UserCredential>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteSqlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::ExecuteSqlRequest::instance].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlRequest;
    /// let x = ExecuteSqlRequest::new().set_instance("example");
    /// ```
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ExecuteSqlRequest::database].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlRequest;
    /// let x = ExecuteSqlRequest::new().set_database("example");
    /// ```
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [user][crate::model::ExecuteSqlRequest::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlRequest;
    /// let x = ExecuteSqlRequest::new().set_user("example");
    /// ```
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [sql_statement][crate::model::ExecuteSqlRequest::sql_statement].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlRequest;
    /// let x = ExecuteSqlRequest::new().set_sql_statement("example");
    /// ```
    pub fn set_sql_statement<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_statement = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::ExecuteSqlRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlRequest;
    /// let x = ExecuteSqlRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [user_credential][crate::model::ExecuteSqlRequest::user_credential].
    ///
    /// Note that all the setters affecting `user_credential` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlRequest;
    /// use google_cloud_alloydb_v1::model::execute_sql_request;
    /// let x = ExecuteSqlRequest::new().set_user_credential(Some(execute_sql_request::UserCredential::Password("example".to_string())));
    /// ```
    pub fn set_user_credential<
        T: std::convert::Into<std::option::Option<crate::model::execute_sql_request::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_credential = v.into();
        self
    }

    /// The value of [user_credential][crate::model::ExecuteSqlRequest::user_credential]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.user_credential.as_ref().and_then(|v| match v {
            crate::model::execute_sql_request::UserCredential::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_credential][crate::model::ExecuteSqlRequest::user_credential]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `user_credential` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlRequest;
    /// let x = ExecuteSqlRequest::new().set_password("example");
    /// assert!(x.password().is_some());
    /// ```
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_credential = std::option::Option::Some(
            crate::model::execute_sql_request::UserCredential::Password(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecuteSqlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlRequest"
    }
}

/// Defines additional types related to [ExecuteSqlRequest].
pub mod execute_sql_request {
    #[allow(unused_imports)]
    use super::*;

    /// Oneof field to support other credential mechanisms in future like
    /// SecretManager etc.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserCredential {
        /// Optional. The database native users password.
        Password(std::string::String),
    }
}

/// Execute a SQL statement response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteSqlResponse {
    /// SqlResult represents the results for the execution of sql statements.
    pub sql_results: std::vec::Vec<crate::model::SqlResult>,

    /// Any additional metadata information regarding the execution of the sql
    /// statement.
    pub metadata: std::option::Option<crate::model::ExecuteSqlMetadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteSqlResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_results][crate::model::ExecuteSqlResponse::sql_results].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlResponse;
    /// use google_cloud_alloydb_v1::model::SqlResult;
    /// let x = ExecuteSqlResponse::new()
    ///     .set_sql_results([
    ///         SqlResult::default()/* use setters */,
    ///         SqlResult::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_sql_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResult>,
    {
        use std::iter::Iterator;
        self.sql_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::ExecuteSqlResponse::metadata].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlResponse;
    /// use google_cloud_alloydb_v1::model::ExecuteSqlMetadata;
    /// let x = ExecuteSqlResponse::new().set_metadata(ExecuteSqlMetadata::default()/* use setters */);
    /// ```
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecuteSqlMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::ExecuteSqlResponse::metadata].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlResponse;
    /// use google_cloud_alloydb_v1::model::ExecuteSqlMetadata;
    /// let x = ExecuteSqlResponse::new().set_or_clear_metadata(Some(ExecuteSqlMetadata::default()/* use setters */));
    /// let x = ExecuteSqlResponse::new().set_or_clear_metadata(None::<ExecuteSqlMetadata>);
    /// ```
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecuteSqlMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExecuteSqlResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlResponse"
    }
}

/// Any additional metadata information regarding the execution of the SQL
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteSqlMetadata {
    /// Message related to SQL execution. Marked as core content since it
    /// can potentially contain details related to the query or result set. This
    /// field can be used to convey messages such as "when the SQL result set
    /// exceeds the acceptable response size limits."
    pub message: std::string::String,

    /// Set to true if SQL returned a result set larger than the acceptable
    /// response size limits and the result was truncated.
    pub partial_result: bool,

    /// The time duration taken to execute the sql statement.
    pub sql_statement_execution_duration: std::option::Option<wkt::Duration>,

    /// Status of SQL execution.
    pub status: crate::model::execute_sql_metadata::Status,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteSqlMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ExecuteSqlMetadata::message].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlMetadata;
    /// let x = ExecuteSqlMetadata::new().set_message("example");
    /// ```
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [partial_result][crate::model::ExecuteSqlMetadata::partial_result].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlMetadata;
    /// let x = ExecuteSqlMetadata::new().set_partial_result(true);
    /// ```
    pub fn set_partial_result<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partial_result = v.into();
        self
    }

    /// Sets the value of [sql_statement_execution_duration][crate::model::ExecuteSqlMetadata::sql_statement_execution_duration].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlMetadata;
    /// use wkt::Duration;
    /// let x = ExecuteSqlMetadata::new().set_sql_statement_execution_duration(Duration::default()/* use setters */);
    /// ```
    pub fn set_sql_statement_execution_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.sql_statement_execution_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sql_statement_execution_duration][crate::model::ExecuteSqlMetadata::sql_statement_execution_duration].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlMetadata;
    /// use wkt::Duration;
    /// let x = ExecuteSqlMetadata::new().set_or_clear_sql_statement_execution_duration(Some(Duration::default()/* use setters */));
    /// let x = ExecuteSqlMetadata::new().set_or_clear_sql_statement_execution_duration(None::<Duration>);
    /// ```
    pub fn set_or_clear_sql_statement_execution_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.sql_statement_execution_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::ExecuteSqlMetadata::status].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ExecuteSqlMetadata;
    /// use google_cloud_alloydb_v1::model::execute_sql_metadata::Status;
    /// let x0 = ExecuteSqlMetadata::new().set_status(Status::Ok);
    /// let x1 = ExecuteSqlMetadata::new().set_status(Status::Partial);
    /// let x2 = ExecuteSqlMetadata::new().set_status(Status::Error);
    /// ```
    pub fn set_status<T: std::convert::Into<crate::model::execute_sql_metadata::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ExecuteSqlMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlMetadata"
    }
}

/// Defines additional types related to [ExecuteSqlMetadata].
pub mod execute_sql_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Status contains all valid Status a SQL execution can end up in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// The status is unknown.
        Unspecified,
        /// No error during SQL execution i.e. All SQL statements ran to completion.
        /// The "message" will be empty.
        Ok,
        /// Same as OK, except indicates that only partial results were
        /// returned. The "message" field will contain details on why results were
        /// truncated.
        Partial,
        /// Error during SQL execution. Atleast 1 SQL statement execution resulted in
        /// a error. Side effects of other statements are rolled back.  The "message"
        /// field will contain human readable error given by Postgres of the first
        /// bad SQL statement. SQL execution errors don't constitute API errors as
        /// defined in <https://google.aip.dev/193> but will be returned as part of
        /// this message.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(1),
                Self::Partial => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::Partial => std::option::Option::Some("PARTIAL"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ok,
                2 => Self::Partial,
                3 => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "PARTIAL" => Self::Partial,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(1),
                Self::Partial => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.alloydb.v1.ExecuteSqlMetadata.Status",
            ))
        }
    }
}

/// Message for requesting list of Backups
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. Parent value for ListBackupsRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsRequest;
    /// let x = ListBackupsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsRequest;
    /// let x = ListBackupsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsRequest;
    /// let x = ListBackupsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsRequest;
    /// let x = ListBackupsRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsRequest;
    /// let x = ListBackupsRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListBackupsRequest"
    }
}

/// Message for response to listing Backups
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of Backup
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsResponse;
    /// use google_cloud_alloydb_v1::model::Backup;
    /// let x = ListBackupsResponse::new()
    ///     .set_backups([
    ///         Backup::default()/* use setters */,
    ///         Backup::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsResponse;
    /// let x = ListBackupsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListBackupsResponse;
    /// let x = ListBackupsResponse::new().set_unreachable(["a", "b", "c"]);
    /// ```
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Backup
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetBackupRequest;
    /// let x = GetBackupRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetBackupRequest"
    }
}

/// Message for creating a Backup
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub backup_id: std::string::String,

    /// Required. The resource being created
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateBackupRequest;
    /// let x = CreateBackupRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateBackupRequest;
    /// let x = CreateBackupRequest::new().set_backup_id("example");
    /// ```
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateBackupRequest;
    /// use google_cloud_alloydb_v1::model::Backup;
    /// let x = CreateBackupRequest::new().set_backup(Backup::default()/* use setters */);
    /// ```
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::CreateBackupRequest::backup].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateBackupRequest;
    /// use google_cloud_alloydb_v1::model::Backup;
    /// let x = CreateBackupRequest::new().set_or_clear_backup(Some(Backup::default()/* use setters */));
    /// let x = CreateBackupRequest::new().set_or_clear_backup(None::<Backup>);
    /// ```
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateBackupRequest;
    /// let x = CreateBackupRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateBackupRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateBackupRequest;
    /// let x = CreateBackupRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateBackupRequest"
    }
}

/// Message for updating a Backup
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if instance is not found. In
    /// that case, a new backup is created and `update_mask` is ignored.
    pub allow_missing: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateBackupRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateBackupRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateBackupRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateBackupRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateBackupRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateBackupRequest;
    /// use google_cloud_alloydb_v1::model::Backup;
    /// let x = UpdateBackupRequest::new().set_backup(Backup::default()/* use setters */);
    /// ```
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::UpdateBackupRequest::backup].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateBackupRequest;
    /// use google_cloud_alloydb_v1::model::Backup;
    /// let x = UpdateBackupRequest::new().set_or_clear_backup(Some(Backup::default()/* use setters */));
    /// let x = UpdateBackupRequest::new().set_or_clear_backup(None::<Backup>);
    /// ```
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBackupRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateBackupRequest;
    /// let x = UpdateBackupRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateBackupRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateBackupRequest;
    /// let x = UpdateBackupRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateBackupRequest::allow_missing].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateBackupRequest;
    /// let x = UpdateBackupRequest::new().set_allow_missing(true);
    /// ```
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateBackupRequest"
    }
}

/// Message for deleting a Backup
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the resource. For the required format, see the comment on
    /// the Backup.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. The current etag of the Backup.
    /// If an etag is provided and does not match the current etag of the Backup,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteBackupRequest;
    /// let x = DeleteBackupRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteBackupRequest;
    /// let x = DeleteBackupRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteBackupRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteBackupRequest;
    /// let x = DeleteBackupRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupRequest::etag].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteBackupRequest;
    /// let x = DeleteBackupRequest::new().set_etag("example");
    /// ```
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteBackupRequest"
    }
}

/// Message for listing the information about the supported Database flags.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSupportedDatabaseFlagsRequest {
    /// Required. The name of the parent resource. The required format is:
    ///
    /// * projects/{project}/locations/{location}
    ///
    /// Regardless of the parent specified here, as long it is contains a valid
    /// project and location, the service will return a static list of supported
    /// flags resources. Note that we do not yet support region-specific
    /// flags.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. The scope for which supported flags are requested. If not
    /// specified, default is DATABASE.
    pub scope: crate::model::supported_database_flag::Scope,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSupportedDatabaseFlagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSupportedDatabaseFlagsRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListSupportedDatabaseFlagsRequest;
    /// let x = ListSupportedDatabaseFlagsRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSupportedDatabaseFlagsRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListSupportedDatabaseFlagsRequest;
    /// let x = ListSupportedDatabaseFlagsRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSupportedDatabaseFlagsRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListSupportedDatabaseFlagsRequest;
    /// let x = ListSupportedDatabaseFlagsRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::ListSupportedDatabaseFlagsRequest::scope].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListSupportedDatabaseFlagsRequest;
    /// use google_cloud_alloydb_v1::model::supported_database_flag::Scope;
    /// let x0 = ListSupportedDatabaseFlagsRequest::new().set_scope(Scope::Database);
    /// let x1 = ListSupportedDatabaseFlagsRequest::new().set_scope(Scope::ConnectionPool);
    /// ```
    pub fn set_scope<T: std::convert::Into<crate::model::supported_database_flag::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for ListSupportedDatabaseFlagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListSupportedDatabaseFlagsRequest"
    }
}

/// Message for response to listing SupportedDatabaseFlags.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSupportedDatabaseFlagsResponse {
    /// The list of SupportedDatabaseFlags.
    pub supported_database_flags: std::vec::Vec<crate::model::SupportedDatabaseFlag>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSupportedDatabaseFlagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [supported_database_flags][crate::model::ListSupportedDatabaseFlagsResponse::supported_database_flags].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListSupportedDatabaseFlagsResponse;
    /// use google_cloud_alloydb_v1::model::SupportedDatabaseFlag;
    /// let x = ListSupportedDatabaseFlagsResponse::new()
    ///     .set_supported_database_flags([
    ///         SupportedDatabaseFlag::default()/* use setters */,
    ///         SupportedDatabaseFlag::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_supported_database_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SupportedDatabaseFlag>,
    {
        use std::iter::Iterator;
        self.supported_database_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSupportedDatabaseFlagsResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListSupportedDatabaseFlagsResponse;
    /// let x = ListSupportedDatabaseFlagsResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSupportedDatabaseFlagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListSupportedDatabaseFlagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSupportedDatabaseFlagsResponse {
    type PageItem = crate::model::SupportedDatabaseFlag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.supported_database_flags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for requests to generate a client certificate signed by the Cluster
/// CA.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateClientCertificateRequest {
    /// Required. The name of the parent resource. The required format is:
    ///
    /// * projects/{project}/locations/{location}/clusters/{cluster}
    pub parent: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. An optional hint to the endpoint to generate the client
    /// certificate with the requested duration. The duration can be from 1 hour to
    /// 24 hours. The endpoint may or may not honor the hint. If the hint is left
    /// unspecified or is not honored, then the endpoint will pick an appropriate
    /// default duration.
    pub cert_duration: std::option::Option<wkt::Duration>,

    /// Optional. The public key from the client.
    pub public_key: std::string::String,

    /// Optional. An optional hint to the endpoint to generate a client certificate
    /// that can be used by AlloyDB connectors to exchange additional metadata with
    /// the server after TLS handshake.
    pub use_metadata_exchange: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateClientCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GenerateClientCertificateRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateRequest;
    /// let x = GenerateClientCertificateRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::GenerateClientCertificateRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateRequest;
    /// let x = GenerateClientCertificateRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [cert_duration][crate::model::GenerateClientCertificateRequest::cert_duration].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateRequest;
    /// use wkt::Duration;
    /// let x = GenerateClientCertificateRequest::new().set_cert_duration(Duration::default()/* use setters */);
    /// ```
    pub fn set_cert_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cert_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cert_duration][crate::model::GenerateClientCertificateRequest::cert_duration].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateRequest;
    /// use wkt::Duration;
    /// let x = GenerateClientCertificateRequest::new().set_or_clear_cert_duration(Some(Duration::default()/* use setters */));
    /// let x = GenerateClientCertificateRequest::new().set_or_clear_cert_duration(None::<Duration>);
    /// ```
    pub fn set_or_clear_cert_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cert_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [public_key][crate::model::GenerateClientCertificateRequest::public_key].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateRequest;
    /// let x = GenerateClientCertificateRequest::new().set_public_key("example");
    /// ```
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [use_metadata_exchange][crate::model::GenerateClientCertificateRequest::use_metadata_exchange].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateRequest;
    /// let x = GenerateClientCertificateRequest::new().set_use_metadata_exchange(true);
    /// ```
    pub fn set_use_metadata_exchange<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_metadata_exchange = v.into();
        self
    }
}

impl wkt::message::Message for GenerateClientCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GenerateClientCertificateRequest"
    }
}

/// Message returned by a GenerateClientCertificate operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateClientCertificateResponse {
    /// Output only. The pem-encoded chain that may be used to verify the X.509
    /// certificate. Expected to be in issuer-to-root order according to RFC 5246.
    pub pem_certificate_chain: std::vec::Vec<std::string::String>,

    /// Optional. The pem-encoded cluster ca X.509 certificate.
    pub ca_cert: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateClientCertificateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pem_certificate_chain][crate::model::GenerateClientCertificateResponse::pem_certificate_chain].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateResponse;
    /// let x = GenerateClientCertificateResponse::new().set_pem_certificate_chain(["a", "b", "c"]);
    /// ```
    pub fn set_pem_certificate_chain<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pem_certificate_chain = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ca_cert][crate::model::GenerateClientCertificateResponse::ca_cert].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GenerateClientCertificateResponse;
    /// let x = GenerateClientCertificateResponse::new().set_ca_cert("example");
    /// ```
    pub fn set_ca_cert<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_cert = v.into();
        self
    }
}

impl wkt::message::Message for GenerateClientCertificateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GenerateClientCertificateResponse"
    }
}

/// Request message for GetConnectionInfo.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionInfoRequest {
    /// Required. The name of the parent resource. The required format is:
    /// projects/{project}/locations/{location}/clusters/{cluster}/instances/{instance}
    pub parent: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetConnectionInfoRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetConnectionInfoRequest;
    /// let x = GetConnectionInfoRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::GetConnectionInfoRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetConnectionInfoRequest;
    /// let x = GetConnectionInfoRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetConnectionInfoRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    /// Request specific metadata, if any.
    pub request_specific: std::option::Option<crate::model::operation_metadata::RequestSpecific>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// use wkt::Timestamp;
    /// let x = OperationMetadata::new().set_create_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// use wkt::Timestamp;
    /// let x = OperationMetadata::new().set_or_clear_create_time(Some(Timestamp::default()/* use setters */));
    /// let x = OperationMetadata::new().set_or_clear_create_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// use wkt::Timestamp;
    /// let x = OperationMetadata::new().set_end_time(Timestamp::default()/* use setters */);
    /// ```
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// use wkt::Timestamp;
    /// let x = OperationMetadata::new().set_or_clear_end_time(Some(Timestamp::default()/* use setters */));
    /// let x = OperationMetadata::new().set_or_clear_end_time(None::<Timestamp>);
    /// ```
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// let x = OperationMetadata::new().set_target("example");
    /// ```
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// let x = OperationMetadata::new().set_verb("example");
    /// ```
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// let x = OperationMetadata::new().set_status_message("example");
    /// ```
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// let x = OperationMetadata::new().set_requested_cancellation(true);
    /// ```
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// let x = OperationMetadata::new().set_api_version("example");
    /// ```
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [request_specific][crate::model::OperationMetadata::request_specific].
    ///
    /// Note that all the setters affecting `request_specific` are mutually
    /// exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// use google_cloud_alloydb_v1::model::operation_metadata;
    /// use google_cloud_alloydb_v1::model::BatchCreateInstancesMetadata;
    /// let x = OperationMetadata::new().set_request_specific(Some(operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(BatchCreateInstancesMetadata::default().into())));
    /// ```
    pub fn set_request_specific<
        T: std::convert::Into<std::option::Option<crate::model::operation_metadata::RequestSpecific>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = v.into();
        self
    }

    /// The value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// if it holds a `BatchCreateInstancesMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn batch_create_instances_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BatchCreateInstancesMetadata>> {
        #[allow(unreachable_patterns)]
        self.request_specific.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// to hold a `BatchCreateInstancesMetadata`.
    ///
    /// Note that all the setters affecting `request_specific` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// use google_cloud_alloydb_v1::model::BatchCreateInstancesMetadata;
    /// let x = OperationMetadata::new().set_batch_create_instances_metadata(BatchCreateInstancesMetadata::default()/* use setters */);
    /// assert!(x.batch_create_instances_metadata().is_some());
    /// assert!(x.upgrade_cluster_status().is_none());
    /// ```
    pub fn set_batch_create_instances_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::BatchCreateInstancesMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = std::option::Option::Some(
            crate::model::operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(
                v.into(),
            ),
        );
        self
    }

    /// The value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// if it holds a `UpgradeClusterStatus`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade_cluster_status(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeClusterStatus>> {
        #[allow(unreachable_patterns)]
        self.request_specific.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::RequestSpecific::UpgradeClusterStatus(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// to hold a `UpgradeClusterStatus`.
    ///
    /// Note that all the setters affecting `request_specific` are
    /// mutually exclusive.
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::OperationMetadata;
    /// use google_cloud_alloydb_v1::model::UpgradeClusterStatus;
    /// let x = OperationMetadata::new().set_upgrade_cluster_status(UpgradeClusterStatus::default()/* use setters */);
    /// assert!(x.upgrade_cluster_status().is_some());
    /// assert!(x.batch_create_instances_metadata().is_none());
    /// ```
    pub fn set_upgrade_cluster_status<
        T: std::convert::Into<std::boxed::Box<crate::model::UpgradeClusterStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = std::option::Option::Some(
            crate::model::operation_metadata::RequestSpecific::UpgradeClusterStatus(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.OperationMetadata"
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Request specific metadata, if any.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RequestSpecific {
        /// Output only. BatchCreateInstances related metadata.
        BatchCreateInstancesMetadata(std::boxed::Box<crate::model::BatchCreateInstancesMetadata>),
        /// Output only. UpgradeClusterStatus related metadata.
        UpgradeClusterStatus(std::boxed::Box<crate::model::UpgradeClusterStatus>),
    }
}

/// Message for current status of the Major Version Upgrade operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterStatus {
    /// Cluster Major Version Upgrade state.
    pub state: crate::model::upgrade_cluster_response::Status,

    /// Whether the operation is cancellable.
    pub cancellable: bool,

    /// Source database major version.
    pub source_version: crate::model::DatabaseVersion,

    /// Target database major version.
    pub target_version: crate::model::DatabaseVersion,

    /// Status of all upgrade stages.
    pub stages: std::vec::Vec<crate::model::upgrade_cluster_status::StageStatus>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::UpgradeClusterStatus::state].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterStatus;
    /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Status;
    /// let x0 = UpgradeClusterStatus::new().set_state(Status::NotStarted);
    /// let x1 = UpgradeClusterStatus::new().set_state(Status::InProgress);
    /// let x2 = UpgradeClusterStatus::new().set_state(Status::Success);
    /// ```
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cancellable][crate::model::UpgradeClusterStatus::cancellable].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterStatus;
    /// let x = UpgradeClusterStatus::new().set_cancellable(true);
    /// ```
    pub fn set_cancellable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancellable = v.into();
        self
    }

    /// Sets the value of [source_version][crate::model::UpgradeClusterStatus::source_version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterStatus;
    /// use google_cloud_alloydb_v1::model::DatabaseVersion;
    /// let x0 = UpgradeClusterStatus::new().set_source_version(DatabaseVersion::Postgres14);
    /// let x1 = UpgradeClusterStatus::new().set_source_version(DatabaseVersion::Postgres15);
    /// let x2 = UpgradeClusterStatus::new().set_source_version(DatabaseVersion::Postgres16);
    /// ```
    pub fn set_source_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeClusterStatus::target_version].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterStatus;
    /// use google_cloud_alloydb_v1::model::DatabaseVersion;
    /// let x0 = UpgradeClusterStatus::new().set_target_version(DatabaseVersion::Postgres14);
    /// let x1 = UpgradeClusterStatus::new().set_target_version(DatabaseVersion::Postgres15);
    /// let x2 = UpgradeClusterStatus::new().set_target_version(DatabaseVersion::Postgres16);
    /// ```
    pub fn set_target_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [stages][crate::model::UpgradeClusterStatus::stages].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpgradeClusterStatus;
    /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::StageStatus;
    /// let x = UpgradeClusterStatus::new()
    ///     .set_stages([
    ///         StageStatus::default()/* use setters */,
    ///         StageStatus::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::upgrade_cluster_status::StageStatus>,
    {
        use std::iter::Iterator;
        self.stages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpgradeClusterStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus"
    }
}

/// Defines additional types related to [UpgradeClusterStatus].
pub mod upgrade_cluster_status {
    #[allow(unused_imports)]
    use super::*;

    /// Status of an upgrade stage.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StageStatus {
        /// Upgrade stage.
        pub stage: crate::model::upgrade_cluster_response::Stage,

        /// State of this stage.
        pub state: crate::model::upgrade_cluster_response::Status,

        /// Output only. Timing information for the stage execution.
        pub schedule:
            std::option::Option<crate::model::upgrade_cluster_status::stage_status::StageSchedule>,

        /// Stage specific status information, if any.
        pub stage_specific_status: std::option::Option<
            crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StageStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [stage][crate::model::upgrade_cluster_status::StageStatus::stage].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::StageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Stage;
        /// let x0 = StageStatus::new().set_stage(Stage::AlloydbPrecheck);
        /// let x1 = StageStatus::new().set_stage(Stage::PgUpgradeCheck);
        /// let x2 = StageStatus::new().set_stage(Stage::PrepareForUpgrade);
        /// ```
        pub fn set_stage<T: std::convert::Into<crate::model::upgrade_cluster_response::Stage>>(
            mut self,
            v: T,
        ) -> Self {
            self.stage = v.into();
            self
        }

        /// Sets the value of [state][crate::model::upgrade_cluster_status::StageStatus::state].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::StageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_response::Status;
        /// let x0 = StageStatus::new().set_state(Status::NotStarted);
        /// let x1 = StageStatus::new().set_state(Status::InProgress);
        /// let x2 = StageStatus::new().set_state(Status::Success);
        /// ```
        pub fn set_state<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [schedule][crate::model::upgrade_cluster_status::StageStatus::schedule].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::StageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
        /// let x = StageStatus::new().set_schedule(StageSchedule::default()/* use setters */);
        /// ```
        pub fn set_schedule<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::upgrade_cluster_status::stage_status::StageSchedule,
                >,
        {
            self.schedule = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [schedule][crate::model::upgrade_cluster_status::StageStatus::schedule].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::StageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
        /// let x = StageStatus::new().set_or_clear_schedule(Some(StageSchedule::default()/* use setters */));
        /// let x = StageStatus::new().set_or_clear_schedule(None::<StageSchedule>);
        /// ```
        pub fn set_or_clear_schedule<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::upgrade_cluster_status::stage_status::StageSchedule,
                >,
        {
            self.schedule = v.map(|x| x.into());
            self
        }

        /// Sets the value of [stage_specific_status][crate::model::upgrade_cluster_status::StageStatus::stage_specific_status].
        ///
        /// Note that all the setters affecting `stage_specific_status` are mutually
        /// exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::StageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus;
        /// let x = StageStatus::new().set_stage_specific_status(Some(upgrade_cluster_status::stage_status::StageSpecificStatus::ReadPoolInstancesUpgrade(ReadPoolInstancesUpgradeStageStatus::default().into())));
        /// ```
        pub fn set_stage_specific_status<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.stage_specific_status = v.into();
            self
        }

        /// The value of [stage_specific_status][crate::model::upgrade_cluster_status::StageStatus::stage_specific_status]
        /// if it holds a `ReadPoolInstancesUpgrade`, `None` if the field is not set or
        /// holds a different branch.
        pub fn read_pool_instances_upgrade(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.stage_specific_status.as_ref().and_then(|v| match v {
                crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus::ReadPoolInstancesUpgrade(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [stage_specific_status][crate::model::upgrade_cluster_status::StageStatus::stage_specific_status]
        /// to hold a `ReadPoolInstancesUpgrade`.
        ///
        /// Note that all the setters affecting `stage_specific_status` are
        /// mutually exclusive.
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::StageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus;
        /// let x = StageStatus::new().set_read_pool_instances_upgrade(ReadPoolInstancesUpgradeStageStatus::default()/* use setters */);
        /// assert!(x.read_pool_instances_upgrade().is_some());
        /// ```
        pub fn set_read_pool_instances_upgrade<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.stage_specific_status = std::option::Option::Some(
                crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus::ReadPoolInstancesUpgrade(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for StageStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus.StageStatus"
        }
    }

    /// Defines additional types related to [StageStatus].
    pub mod stage_status {
        #[allow(unused_imports)]
        use super::*;

        /// Timing information for the stage execution.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct StageSchedule {
            /// When the stage is expected to start. Set only if the stage has not
            /// started yet.
            pub estimated_start_time: std::option::Option<wkt::Timestamp>,

            /// Actual start time of the stage. Set only if the stage has started.
            pub actual_start_time: std::option::Option<wkt::Timestamp>,

            /// When the stage is expected to end. Set only if the stage has not
            /// completed yet.
            pub estimated_end_time: std::option::Option<wkt::Timestamp>,

            /// Actual end time of the stage. Set only if the stage has completed.
            pub actual_end_time: std::option::Option<wkt::Timestamp>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl StageSchedule {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [estimated_start_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::estimated_start_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_estimated_start_time(Timestamp::default()/* use setters */);
            /// ```
            pub fn set_estimated_start_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.estimated_start_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [estimated_start_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::estimated_start_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_or_clear_estimated_start_time(Some(Timestamp::default()/* use setters */));
            /// let x = StageSchedule::new().set_or_clear_estimated_start_time(None::<Timestamp>);
            /// ```
            pub fn set_or_clear_estimated_start_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.estimated_start_time = v.map(|x| x.into());
                self
            }

            /// Sets the value of [actual_start_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::actual_start_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_actual_start_time(Timestamp::default()/* use setters */);
            /// ```
            pub fn set_actual_start_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.actual_start_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [actual_start_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::actual_start_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_or_clear_actual_start_time(Some(Timestamp::default()/* use setters */));
            /// let x = StageSchedule::new().set_or_clear_actual_start_time(None::<Timestamp>);
            /// ```
            pub fn set_or_clear_actual_start_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.actual_start_time = v.map(|x| x.into());
                self
            }

            /// Sets the value of [estimated_end_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::estimated_end_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_estimated_end_time(Timestamp::default()/* use setters */);
            /// ```
            pub fn set_estimated_end_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.estimated_end_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [estimated_end_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::estimated_end_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_or_clear_estimated_end_time(Some(Timestamp::default()/* use setters */));
            /// let x = StageSchedule::new().set_or_clear_estimated_end_time(None::<Timestamp>);
            /// ```
            pub fn set_or_clear_estimated_end_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.estimated_end_time = v.map(|x| x.into());
                self
            }

            /// Sets the value of [actual_end_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::actual_end_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_actual_end_time(Timestamp::default()/* use setters */);
            /// ```
            pub fn set_actual_end_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.actual_end_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [actual_end_time][crate::model::upgrade_cluster_status::stage_status::StageSchedule::actual_end_time].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::stage_status::StageSchedule;
            /// use wkt::Timestamp;
            /// let x = StageSchedule::new().set_or_clear_actual_end_time(Some(Timestamp::default()/* use setters */));
            /// let x = StageSchedule::new().set_or_clear_actual_end_time(None::<Timestamp>);
            /// ```
            pub fn set_or_clear_actual_end_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.actual_end_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for StageSchedule {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus.StageStatus.StageSchedule"
            }
        }

        /// Stage specific status information, if any.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum StageSpecificStatus {
            /// Read pool instances upgrade metadata.
            ReadPoolInstancesUpgrade(
                std::boxed::Box<
                    crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus,
                >,
            ),
        }
    }

    /// Read pool instances upgrade specific status.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReadPoolInstancesUpgradeStageStatus {
        /// Read pool instances upgrade statistics.
        pub upgrade_stats: std::option::Option<
            crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReadPoolInstancesUpgradeStageStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upgrade_stats][crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus::upgrade_stats].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats;
        /// let x = ReadPoolInstancesUpgradeStageStatus::new().set_upgrade_stats(Stats::default()/* use setters */);
        /// ```
        pub fn set_upgrade_stats<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats>
        {
            self.upgrade_stats = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [upgrade_stats][crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus::upgrade_stats].
        ///
        /// # Example
        /// ```
        /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus;
        /// use google_cloud_alloydb_v1::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats;
        /// let x = ReadPoolInstancesUpgradeStageStatus::new().set_or_clear_upgrade_stats(Some(Stats::default()/* use setters */));
        /// let x = ReadPoolInstancesUpgradeStageStatus::new().set_or_clear_upgrade_stats(None::<Stats>);
        /// ```
        pub fn set_or_clear_upgrade_stats<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats>
        {
            self.upgrade_stats = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ReadPoolInstancesUpgradeStageStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus.ReadPoolInstancesUpgradeStageStatus"
        }
    }

    /// Defines additional types related to [ReadPoolInstancesUpgradeStageStatus].
    pub mod read_pool_instances_upgrade_stage_status {
        #[allow(unused_imports)]
        use super::*;

        /// Upgrade stats for read pool instances.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Stats {
            /// Number of read pool instances for which upgrade has not started.
            pub not_started: i32,

            /// Number of read pool instances undergoing upgrade.
            pub ongoing: i32,

            /// Number of read pool instances successfully upgraded.
            pub success: i32,

            /// Number of read pool instances which failed to upgrade.
            pub failed: i32,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Stats {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [not_started][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::not_started].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats;
            /// let x = Stats::new().set_not_started(42);
            /// ```
            pub fn set_not_started<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.not_started = v.into();
                self
            }

            /// Sets the value of [ongoing][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::ongoing].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats;
            /// let x = Stats::new().set_ongoing(42);
            /// ```
            pub fn set_ongoing<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.ongoing = v.into();
                self
            }

            /// Sets the value of [success][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::success].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats;
            /// let x = Stats::new().set_success(42);
            /// ```
            pub fn set_success<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.success = v.into();
                self
            }

            /// Sets the value of [failed][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::failed].
            ///
            /// # Example
            /// ```
            /// # use google_cloud_alloydb_v1::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats;
            /// let x = Stats::new().set_failed(42);
            /// ```
            pub fn set_failed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.failed = v.into();
                self
            }
        }

        impl wkt::message::Message for Stats {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus.ReadPoolInstancesUpgradeStageStatus.Stats"
            }
        }
    }
}

/// Message for requesting list of Users
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersRequest {
    /// Required. Parent value for ListUsersRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsersRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersRequest;
    /// let x = ListUsersRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsersRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersRequest;
    /// let x = ListUsersRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsersRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersRequest;
    /// let x = ListUsersRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUsersRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersRequest;
    /// let x = ListUsersRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListUsersRequest::order_by].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersRequest;
    /// let x = ListUsersRequest::new().set_order_by("example");
    /// ```
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListUsersRequest"
    }
}

/// Message for response to listing Users
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersResponse {
    /// The list of User
    pub users: std::vec::Vec<crate::model::User>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [users][crate::model::ListUsersResponse::users].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersResponse;
    /// use google_cloud_alloydb_v1::model::User;
    /// let x = ListUsersResponse::new()
    ///     .set_users([
    ///         User::default()/* use setters */,
    ///         User::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>,
    {
        use std::iter::Iterator;
        self.users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsersResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersResponse;
    /// let x = ListUsersResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsersResponse::unreachable].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListUsersResponse;
    /// let x = ListUsersResponse::new().set_unreachable(["a", "b", "c"]);
    /// ```
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsersResponse {
    type PageItem = crate::model::User;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a User
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUserRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the User.name field.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::GetUserRequest;
    /// let x = GetUserRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetUserRequest"
    }
}

/// Message for creating a User
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUserRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub user_id: std::string::String,

    /// Required. The resource being created
    pub user: std::option::Option<crate::model::User>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateUserRequest;
    /// let x = CreateUserRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::CreateUserRequest::user_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateUserRequest;
    /// let x = CreateUserRequest::new().set_user_id("example");
    /// ```
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [user][crate::model::CreateUserRequest::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateUserRequest;
    /// use google_cloud_alloydb_v1::model::User;
    /// let x = CreateUserRequest::new().set_user(User::default()/* use setters */);
    /// ```
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::CreateUserRequest::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateUserRequest;
    /// use google_cloud_alloydb_v1::model::User;
    /// let x = CreateUserRequest::new().set_or_clear_user(Some(User::default()/* use setters */));
    /// let x = CreateUserRequest::new().set_or_clear_user(None::<User>);
    /// ```
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateUserRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateUserRequest;
    /// let x = CreateUserRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateUserRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::CreateUserRequest;
    /// let x = CreateUserRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateUserRequest"
    }
}

/// Message for updating a User
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateUserRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// User resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub user: std::option::Option<crate::model::User>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. Allow missing fields in the update mask.
    pub allow_missing: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateUserRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateUserRequest::new().set_update_mask(FieldMask::default()/* use setters */);
    /// ```
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateUserRequest;
    /// use wkt::FieldMask;
    /// let x = UpdateUserRequest::new().set_or_clear_update_mask(Some(FieldMask::default()/* use setters */));
    /// let x = UpdateUserRequest::new().set_or_clear_update_mask(None::<FieldMask>);
    /// ```
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::UpdateUserRequest::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateUserRequest;
    /// use google_cloud_alloydb_v1::model::User;
    /// let x = UpdateUserRequest::new().set_user(User::default()/* use setters */);
    /// ```
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::UpdateUserRequest::user].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateUserRequest;
    /// use google_cloud_alloydb_v1::model::User;
    /// let x = UpdateUserRequest::new().set_or_clear_user(Some(User::default()/* use setters */));
    /// let x = UpdateUserRequest::new().set_or_clear_user(None::<User>);
    /// ```
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateUserRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateUserRequest;
    /// let x = UpdateUserRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateUserRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateUserRequest;
    /// let x = UpdateUserRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateUserRequest::allow_missing].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::UpdateUserRequest;
    /// let x = UpdateUserRequest::new().set_allow_missing(true);
    /// ```
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateUserRequest"
    }
}

/// Message for deleting a User
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUserRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the User.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserRequest::name].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteUserRequest;
    /// let x = DeleteUserRequest::new().set_name("example");
    /// ```
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteUserRequest::request_id].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteUserRequest;
    /// let x = DeleteUserRequest::new().set_request_id("example");
    /// ```
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteUserRequest::validate_only].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::DeleteUserRequest;
    /// let x = DeleteUserRequest::new().set_validate_only(true);
    /// ```
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteUserRequest"
    }
}

/// Message for ListDatabases request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesRequest {
    /// Required. Parent value for ListDatabasesRequest.
    pub parent: std::string::String,

    /// Optional. The maximum number of databases to return. The service may return
    /// fewer than this value. If unspecified, 2000 is the default page_size. The
    /// max value of page_size will be 4000, values above max will be coerced to
    /// max.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListDatabases` call.
    /// This should be provided to retrieve the subsequent page.
    /// This field is currently not supported, its value will be ignored if passed.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    /// This field is currently not supported, its value will be ignored if passed.
    pub filter: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListDatabasesRequest;
    /// let x = ListDatabasesRequest::new().set_parent("example");
    /// ```
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatabasesRequest::page_size].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListDatabasesRequest;
    /// let x = ListDatabasesRequest::new().set_page_size(42);
    /// ```
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatabasesRequest::page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListDatabasesRequest;
    /// let x = ListDatabasesRequest::new().set_page_token("example");
    /// ```
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatabasesRequest::filter].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListDatabasesRequest;
    /// let x = ListDatabasesRequest::new().set_filter("example");
    /// ```
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListDatabasesRequest"
    }
}

/// Message for ListDatabases response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesResponse {
    /// The list of databases.
    pub databases: std::vec::Vec<crate::model::Database>,

    /// A token identifying the next page of results the server should return.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [databases][crate::model::ListDatabasesResponse::databases].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListDatabasesResponse;
    /// use google_cloud_alloydb_v1::model::Database;
    /// let x = ListDatabasesResponse::new()
    ///     .set_databases([
    ///         Database::default()/* use setters */,
    ///         Database::default()/* use (different) setters */,
    ///     ]);
    /// ```
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatabasesResponse::next_page_token].
    ///
    /// # Example
    /// ```
    /// # use google_cloud_alloydb_v1::model::ListDatabasesResponse;
    /// let x = ListDatabasesResponse::new().set_next_page_token("example");
    /// ```
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatabasesResponse {
    type PageItem = crate::model::Database;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// View on Instance. Pass this enum to rpcs that returns an Instance message to
/// control which subsets of fields to get.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InstanceView {
    /// INSTANCE_VIEW_UNSPECIFIED Not specified, equivalent to BASIC.
    Unspecified,
    /// BASIC server responses for a primary or read instance include all the
    /// relevant instance details, excluding the details of each node in the
    /// instance. The default value.
    Basic,
    /// FULL response is equivalent to BASIC for primary instance (for now).
    /// For read pool instance, this includes details of each node in the pool.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InstanceView::value] or
    /// [InstanceView::name].
    UnknownValue(instance_view::UnknownValue),
}

#[doc(hidden)]
pub mod instance_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InstanceView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INSTANCE_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("INSTANCE_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("INSTANCE_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InstanceView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InstanceView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InstanceView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(instance_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InstanceView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INSTANCE_VIEW_UNSPECIFIED" => Self::Unspecified,
            "INSTANCE_VIEW_BASIC" => Self::Basic,
            "INSTANCE_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(instance_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InstanceView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InstanceView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceView>::new(
            ".google.cloud.alloydb.v1.InstanceView",
        ))
    }
}

/// View on Cluster. Pass this enum to rpcs that returns a cluster message to
/// control which subsets of fields to get.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ClusterView {
    /// CLUSTER_VIEW_UNSPECIFIED Not specified, equivalent to BASIC.
    Unspecified,
    /// BASIC server responses include all the relevant cluster details, excluding
    /// Cluster.ContinuousBackupInfo.EarliestRestorableTime and other view-specific
    /// fields. The default value.
    Basic,
    /// CONTINUOUS_BACKUP response returns all the fields from BASIC plus
    /// the earliest restorable time if continuous backups are enabled.
    /// May increase latency.
    ContinuousBackup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ClusterView::value] or
    /// [ClusterView::name].
    UnknownValue(cluster_view::UnknownValue),
}

#[doc(hidden)]
pub mod cluster_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ClusterView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::ContinuousBackup => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CLUSTER_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("CLUSTER_VIEW_BASIC"),
            Self::ContinuousBackup => std::option::Option::Some("CLUSTER_VIEW_CONTINUOUS_BACKUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ClusterView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ClusterView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ClusterView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::ContinuousBackup,
            _ => Self::UnknownValue(cluster_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ClusterView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CLUSTER_VIEW_UNSPECIFIED" => Self::Unspecified,
            "CLUSTER_VIEW_BASIC" => Self::Basic,
            "CLUSTER_VIEW_CONTINUOUS_BACKUP" => Self::ContinuousBackup,
            _ => Self::UnknownValue(cluster_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ClusterView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::ContinuousBackup => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ClusterView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterView>::new(
            ".google.cloud.alloydb.v1.ClusterView",
        ))
    }
}

/// The supported database engine versions.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseVersion {
    /// This is an unknown database version.
    Unspecified,
    /// DEPRECATED - The database version is Postgres 13.
    #[deprecated]
    Postgres13,
    /// The database version is Postgres 14.
    Postgres14,
    /// The database version is Postgres 15.
    Postgres15,
    /// The database version is Postgres 16.
    Postgres16,
    /// The database version is Postgres 17.
    Postgres17,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseVersion::value] or
    /// [DatabaseVersion::name].
    UnknownValue(database_version::UnknownValue),
}

#[doc(hidden)]
pub mod database_version {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseVersion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Postgres13 => std::option::Option::Some(1),
            Self::Postgres14 => std::option::Option::Some(2),
            Self::Postgres15 => std::option::Option::Some(3),
            Self::Postgres16 => std::option::Option::Some(4),
            Self::Postgres17 => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_VERSION_UNSPECIFIED"),
            Self::Postgres13 => std::option::Option::Some("POSTGRES_13"),
            Self::Postgres14 => std::option::Option::Some("POSTGRES_14"),
            Self::Postgres15 => std::option::Option::Some("POSTGRES_15"),
            Self::Postgres16 => std::option::Option::Some("POSTGRES_16"),
            Self::Postgres17 => std::option::Option::Some("POSTGRES_17"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Postgres13,
            2 => Self::Postgres14,
            3 => Self::Postgres15,
            4 => Self::Postgres16,
            5 => Self::Postgres17,
            _ => Self::UnknownValue(database_version::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseVersion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_VERSION_UNSPECIFIED" => Self::Unspecified,
            "POSTGRES_13" => Self::Postgres13,
            "POSTGRES_14" => Self::Postgres14,
            "POSTGRES_15" => Self::Postgres15,
            "POSTGRES_16" => Self::Postgres16,
            "POSTGRES_17" => Self::Postgres17,
            _ => Self::UnknownValue(database_version::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Postgres13 => serializer.serialize_i32(1),
            Self::Postgres14 => serializer.serialize_i32(2),
            Self::Postgres15 => serializer.serialize_i32(3),
            Self::Postgres16 => serializer.serialize_i32(4),
            Self::Postgres17 => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseVersion>::new(
            ".google.cloud.alloydb.v1.DatabaseVersion",
        ))
    }
}

/// Subscription_type added to distinguish between Standard and Trial
/// subscriptions. By default, a subscription type is considered STANDARD unless
/// explicitly specified.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SubscriptionType {
    /// This is an unknown subscription type. By default, the subscription type is
    /// STANDARD.
    Unspecified,
    /// Standard subscription.
    Standard,
    /// Trial subscription.
    Trial,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SubscriptionType::value] or
    /// [SubscriptionType::name].
    UnknownValue(subscription_type::UnknownValue),
}

#[doc(hidden)]
pub mod subscription_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SubscriptionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Trial => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SUBSCRIPTION_TYPE_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("STANDARD"),
            Self::Trial => std::option::Option::Some("TRIAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SubscriptionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SubscriptionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SubscriptionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Trial,
            _ => Self::UnknownValue(subscription_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SubscriptionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SUBSCRIPTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "STANDARD" => Self::Standard,
            "TRIAL" => Self::Trial,
            _ => Self::UnknownValue(subscription_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SubscriptionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Trial => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SubscriptionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SubscriptionType>::new(
            ".google.cloud.alloydb.v1.SubscriptionType",
        ))
    }
}
