// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The source CloudSQL backup resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSQLBackupRunSource {
    /// The project ID of the source CloudSQL instance. This should be the same as
    /// the AlloyDB cluster's project.
    pub project: std::string::String,

    /// Required. The CloudSQL instance ID.
    pub instance_id: std::string::String,

    /// Required. The CloudSQL backup run ID.
    pub backup_run_id: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSQLBackupRunSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::CloudSQLBackupRunSource::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CloudSQLBackupRunSource::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [backup_run_id][crate::model::CloudSQLBackupRunSource::backup_run_id].
    pub fn set_backup_run_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.backup_run_id = v.into();
        self
    }
}

impl wkt::message::Message for CloudSQLBackupRunSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CloudSQLBackupRunSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSQLBackupRunSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __instance_id,
            __backup_run_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSQLBackupRunSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "backupRunId" => Ok(__FieldTag::__backup_run_id),
                            "backup_run_id" => Ok(__FieldTag::__backup_run_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSQLBackupRunSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSQLBackupRunSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_run_id => {
                            if !fields.insert(__FieldTag::__backup_run_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_run_id",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.backup_run_id =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSQLBackupRunSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !wkt::internal::is_default(&self.backup_run_id) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("backupRunId", &__With(&self.backup_run_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for registering Restoring from CloudSQL resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreFromCloudSQLRequest {
    /// Required. The location of the new cluster. For the required format, see the
    /// comment on Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// The source CloudSQL resource to restore from.
    pub source: std::option::Option<crate::model::restore_from_cloud_sql_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreFromCloudSQLRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreFromCloudSQLRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::RestoreFromCloudSQLRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::RestoreFromCloudSQLRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::RestoreFromCloudSQLRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::RestoreFromCloudSQLRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::restore_from_cloud_sql_request::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreFromCloudSQLRequest::source]
    /// if it holds a `CloudsqlBackupRunSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloudsql_backup_run_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSQLBackupRunSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_from_cloud_sql_request::Source::CloudsqlBackupRunSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreFromCloudSQLRequest::source]
    /// to hold a `CloudsqlBackupRunSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloudsql_backup_run_source<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSQLBackupRunSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_from_cloud_sql_request::Source::CloudsqlBackupRunSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreFromCloudSQLRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestoreFromCloudSQLRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreFromCloudSQLRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloudsql_backup_run_source,
            __parent,
            __cluster_id,
            __cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreFromCloudSQLRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudsqlBackupRunSource" => {
                                Ok(__FieldTag::__cloudsql_backup_run_source)
                            }
                            "cloudsql_backup_run_source" => {
                                Ok(__FieldTag::__cloudsql_backup_run_source)
                            }
                            "parent" => Ok(__FieldTag::__parent),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "cluster" => Ok(__FieldTag::__cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreFromCloudSQLRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreFromCloudSQLRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloudsql_backup_run_source => {
                            if !fields.insert(__FieldTag::__cloudsql_backup_run_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloudsql_backup_run_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.alloydb.v1.RestoreFromCloudSQLRequest.cloudsql_backup_run_source, latest field was cloudsqlBackupRunSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::restore_from_cloud_sql_request::Source::CloudsqlBackupRunSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudSQLBackupRunSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreFromCloudSQLRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloudsql_backup_run_source() {
            state.serialize_entry("cloudsqlBackupRunSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreFromCloudSQLRequest].
pub mod restore_from_cloud_sql_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source CloudSQL resource to restore from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Cluster created from CloudSQL backup run.
        CloudsqlBackupRunSource(std::boxed::Box<crate::model::CloudSQLBackupRunSource>),
    }
}

/// SqlResult represents the result for the execution of a sql statement.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResult {
    /// List of columns included in the result. This also includes the data type
    /// of the column.
    pub columns: std::vec::Vec<crate::model::SqlResultColumn>,

    /// Rows returned by the SQL statement.
    pub rows: std::vec::Vec<crate::model::SqlResultRow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::SqlResult::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultColumn>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rows][crate::model::SqlResult::rows].
    pub fn set_rows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultRow>,
    {
        use std::iter::Iterator;
        self.rows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            __rows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            "rows" => Ok(__FieldTag::__rows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlResultColumn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rows => {
                            if !fields.insert(__FieldTag::__rows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rows",
                                ));
                            }
                            result.rows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SqlResultRow>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self.rows.is_empty() {
            state.serialize_entry("rows", &self.rows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains the name and datatype of a column in a SQL Result.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResultColumn {
    /// Name of the column.
    pub name: std::string::String,

    /// Datatype of the column as reported by the postgres driver.
    /// Common type names are "VARCHAR", "TEXT", "NVARCHAR", "DECIMAL", "BOOL",
    /// "INT", and "BIGINT".
    pub r#type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResultColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SqlResultColumn::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SqlResultColumn::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for SqlResultColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlResultColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlResultColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlResultColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlResultColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlResultColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single row from a sql result.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResultRow {
    /// List of values in a row of sql result.
    pub values: std::vec::Vec<crate::model::SqlResultValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResultRow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::SqlResultRow::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResultValue>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlResultRow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultRow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlResultRow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlResultRow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlResultRow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlResultRow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SqlResultValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlResultRow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single value in a row from a sql result.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlResultValue {
    /// The cell value represented in string format.
    /// Timestamps are converted to string using RFC3339Nano format.
    pub value: std::option::Option<std::string::String>,

    /// Set to true if cell value is null.
    pub null_value: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlResultValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::SqlResultValue::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::SqlResultValue::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [null_value][crate::model::SqlResultValue::null_value].
    pub fn set_null_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.null_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [null_value][crate::model::SqlResultValue::null_value].
    pub fn set_or_clear_null_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.null_value = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SqlResultValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SqlResultValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlResultValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __null_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlResultValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "nullValue" => Ok(__FieldTag::__null_value),
                            "null_value" => Ok(__FieldTag::__null_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlResultValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlResultValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__null_value => {
                            if !fields.insert(__FieldTag::__null_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for null_value",
                                ));
                            }
                            result.null_value = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlResultValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if self.null_value.is_some() {
            state.serialize_entry("nullValue", &self.null_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The username/password for a database user. Used for specifying initial
/// users at cluster creation time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UserPassword {
    /// The database username.
    pub user: std::string::String,

    /// The initial password for the user.
    pub password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserPassword {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user][crate::model::UserPassword::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [password][crate::model::UserPassword::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for UserPassword {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UserPassword"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserPassword {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user,
            __password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserPassword")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "user" => Ok(__FieldTag::__user),
                            "password" => Ok(__FieldTag::__password),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserPassword;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserPassword")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserPassword {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Subset of the source instance configuration that is available when reading
/// the cluster resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationSource {
    /// Output only. The host and port of the on-premises instance in host:port
    /// format
    pub host_port: std::string::String,

    /// Output only. Place holder for the external source identifier(e.g DMS job
    /// name) that created the cluster.
    pub reference_id: std::string::String,

    /// Output only. Type of migration source.
    pub source_type: crate::model::migration_source::MigrationSourceType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_port][crate::model::MigrationSource::host_port].
    pub fn set_host_port<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_port = v.into();
        self
    }

    /// Sets the value of [reference_id][crate::model::MigrationSource::reference_id].
    pub fn set_reference_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference_id = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::MigrationSource::source_type].
    pub fn set_source_type<
        T: std::convert::Into<crate::model::migration_source::MigrationSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }
}

impl wkt::message::Message for MigrationSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MigrationSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host_port,
            __reference_id,
            __source_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostPort" => Ok(__FieldTag::__host_port),
                            "host_port" => Ok(__FieldTag::__host_port),
                            "referenceId" => Ok(__FieldTag::__reference_id),
                            "reference_id" => Ok(__FieldTag::__reference_id),
                            "sourceType" => Ok(__FieldTag::__source_type),
                            "source_type" => Ok(__FieldTag::__source_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host_port => {
                            if !fields.insert(__FieldTag::__host_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host_port",
                                ));
                            }
                            result.host_port = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reference_id => {
                            if !fields.insert(__FieldTag::__reference_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_id",
                                ));
                            }
                            result.reference_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_type => {
                            if !fields.insert(__FieldTag::__source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_type",
                                ));
                            }
                            result.source_type = map
                                .next_value::<std::option::Option<
                                    crate::model::migration_source::MigrationSourceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host_port.is_empty() {
            state.serialize_entry("hostPort", &self.host_port)?;
        }
        if !self.reference_id.is_empty() {
            state.serialize_entry("referenceId", &self.reference_id)?;
        }
        if !wkt::internal::is_default(&self.source_type) {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MigrationSource].
pub mod migration_source {
    #[allow(unused_imports)]
    use super::*;

    /// Denote the type of migration source that created this cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MigrationSourceType {
        /// Migration source is unknown.
        Unspecified,
        /// DMS source means the cluster was created via DMS migration job.
        Dms,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MigrationSourceType::value] or
        /// [MigrationSourceType::name].
        UnknownValue(migration_source_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod migration_source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MigrationSourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dms => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MIGRATION_SOURCE_TYPE_UNSPECIFIED"),
                Self::Dms => std::option::Option::Some("DMS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MigrationSourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MigrationSourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MigrationSourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dms,
                _ => Self::UnknownValue(migration_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MigrationSourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIGRATION_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DMS" => Self::Dms,
                _ => Self::UnknownValue(migration_source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MigrationSourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dms => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MigrationSourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationSourceType>::new(
                ".google.cloud.alloydb.v1.MigrationSource.MigrationSourceType",
            ))
        }
    }
}

/// EncryptionConfig describes the encryption config of a cluster or a backup
/// that is encrypted with a CMEK (customer-managed encryption key).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// The fully-qualified resource name of the KMS key.
    /// Each Cloud KMS key is regionalized and has the following format:
    /// projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
    pub kms_key_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::EncryptionConfig::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.EncryptionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// EncryptionInfo describes the encryption information of a cluster or a backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionInfo {
    /// Output only. Type of encryption.
    pub encryption_type: crate::model::encryption_info::Type,

    /// Output only. Cloud KMS key versions that are being used to protect the
    /// database or the backup.
    pub kms_key_versions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_type][crate::model::EncryptionInfo::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::encryption_info::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [kms_key_versions][crate::model::EncryptionInfo::kms_key_versions].
    pub fn set_kms_key_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kms_key_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EncryptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.EncryptionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_type,
            __kms_key_versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionType" => Ok(__FieldTag::__encryption_type),
                            "encryption_type" => Ok(__FieldTag::__encryption_type),
                            "kmsKeyVersions" => Ok(__FieldTag::__kms_key_versions),
                            "kms_key_versions" => Ok(__FieldTag::__kms_key_versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_type => {
                            if !fields.insert(__FieldTag::__encryption_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_type",
                                ));
                            }
                            result.encryption_type = map.next_value::<std::option::Option<crate::model::encryption_info::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kms_key_versions => {
                            if !fields.insert(__FieldTag::__kms_key_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_versions",
                                ));
                            }
                            result.kms_key_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.encryption_type) {
            state.serialize_entry("encryptionType", &self.encryption_type)?;
        }
        if !self.kms_key_versions.is_empty() {
            state.serialize_entry("kmsKeyVersions", &self.kms_key_versions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EncryptionInfo].
pub mod encryption_info {
    #[allow(unused_imports)]
    use super::*;

    /// Possible encryption types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Encryption type not specified. Defaults to GOOGLE_DEFAULT_ENCRYPTION.
        Unspecified,
        /// The data is encrypted at rest with a key that is fully managed by Google.
        /// No key version will be populated. This is the default state.
        GoogleDefaultEncryption,
        /// The data is encrypted at rest with a key that is managed by the customer.
        /// KMS key versions will be populated.
        CustomerManagedEncryption,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleDefaultEncryption => std::option::Option::Some(1),
                Self::CustomerManagedEncryption => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::GoogleDefaultEncryption => {
                    std::option::Option::Some("GOOGLE_DEFAULT_ENCRYPTION")
                }
                Self::CustomerManagedEncryption => {
                    std::option::Option::Some("CUSTOMER_MANAGED_ENCRYPTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleDefaultEncryption,
                2 => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_DEFAULT_ENCRYPTION" => Self::GoogleDefaultEncryption,
                "CUSTOMER_MANAGED_ENCRYPTION" => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleDefaultEncryption => serializer.serialize_i32(1),
                Self::CustomerManagedEncryption => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.alloydb.v1.EncryptionInfo.Type",
            ))
        }
    }
}

/// SSL configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SslConfig {
    /// Optional. SSL mode. Specifies client-server SSL/TLS connection behavior.
    pub ssl_mode: crate::model::ssl_config::SslMode,

    /// Optional. Certificate Authority (CA) source. Only CA_SOURCE_MANAGED is
    /// supported currently, and is the default value.
    pub ca_source: crate::model::ssl_config::CaSource,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ssl_mode][crate::model::SslConfig::ssl_mode].
    pub fn set_ssl_mode<T: std::convert::Into<crate::model::ssl_config::SslMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_mode = v.into();
        self
    }

    /// Sets the value of [ca_source][crate::model::SslConfig::ca_source].
    pub fn set_ca_source<T: std::convert::Into<crate::model::ssl_config::CaSource>>(
        mut self,
        v: T,
    ) -> Self {
        self.ca_source = v.into();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SslConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ssl_mode,
            __ca_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sslMode" => Ok(__FieldTag::__ssl_mode),
                            "ssl_mode" => Ok(__FieldTag::__ssl_mode),
                            "caSource" => Ok(__FieldTag::__ca_source),
                            "ca_source" => Ok(__FieldTag::__ca_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ssl_mode => {
                            if !fields.insert(__FieldTag::__ssl_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_mode",
                                ));
                            }
                            result.ssl_mode = map.next_value::<std::option::Option<crate::model::ssl_config::SslMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ca_source => {
                            if !fields.insert(__FieldTag::__ca_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_source",
                                ));
                            }
                            result.ca_source = map.next_value::<std::option::Option<crate::model::ssl_config::CaSource>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ssl_mode) {
            state.serialize_entry("sslMode", &self.ssl_mode)?;
        }
        if !wkt::internal::is_default(&self.ca_source) {
            state.serialize_entry("caSource", &self.ca_source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SslConfig].
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// SSL mode options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslMode {
        /// SSL mode is not specified. Defaults to ENCRYPTED_ONLY.
        Unspecified,
        /// SSL connections are optional. CA verification not enforced.
        #[deprecated]
        Allow,
        /// SSL connections are required. CA verification not enforced.
        /// Clients may use locally self-signed certificates (default psql client
        /// behavior).
        #[deprecated]
        Require,
        /// SSL connections are required. CA verification enforced.
        /// Clients must have certificates signed by a Cluster CA, for example, using
        /// GenerateClientCertificate.
        #[deprecated]
        VerifyCa,
        /// SSL connections are optional. CA verification not enforced.
        AllowUnencryptedAndEncrypted,
        /// SSL connections are required. CA verification not enforced.
        EncryptedOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslMode::value] or
        /// [SslMode::name].
        UnknownValue(ssl_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Allow => std::option::Option::Some(1),
                Self::Require => std::option::Option::Some(2),
                Self::VerifyCa => std::option::Option::Some(3),
                Self::AllowUnencryptedAndEncrypted => std::option::Option::Some(4),
                Self::EncryptedOnly => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_MODE_UNSPECIFIED"),
                Self::Allow => std::option::Option::Some("SSL_MODE_ALLOW"),
                Self::Require => std::option::Option::Some("SSL_MODE_REQUIRE"),
                Self::VerifyCa => std::option::Option::Some("SSL_MODE_VERIFY_CA"),
                Self::AllowUnencryptedAndEncrypted => {
                    std::option::Option::Some("ALLOW_UNENCRYPTED_AND_ENCRYPTED")
                }
                Self::EncryptedOnly => std::option::Option::Some("ENCRYPTED_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Allow,
                2 => Self::Require,
                3 => Self::VerifyCa,
                4 => Self::AllowUnencryptedAndEncrypted,
                5 => Self::EncryptedOnly,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SslMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_MODE_UNSPECIFIED" => Self::Unspecified,
                "SSL_MODE_ALLOW" => Self::Allow,
                "SSL_MODE_REQUIRE" => Self::Require,
                "SSL_MODE_VERIFY_CA" => Self::VerifyCa,
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => Self::AllowUnencryptedAndEncrypted,
                "ENCRYPTED_ONLY" => Self::EncryptedOnly,
                _ => Self::UnknownValue(ssl_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SslMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Allow => serializer.serialize_i32(1),
                Self::Require => serializer.serialize_i32(2),
                Self::VerifyCa => serializer.serialize_i32(3),
                Self::AllowUnencryptedAndEncrypted => serializer.serialize_i32(4),
                Self::EncryptedOnly => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslMode>::new(
                ".google.cloud.alloydb.v1.SslConfig.SslMode",
            ))
        }
    }

    /// Certificate Authority (CA) source for SSL/TLS certificates.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CaSource {
        /// Certificate Authority (CA) source not specified. Defaults to
        /// CA_SOURCE_MANAGED.
        Unspecified,
        /// Certificate Authority (CA) managed by the AlloyDB Cluster.
        Managed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CaSource::value] or
        /// [CaSource::name].
        UnknownValue(ca_source::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ca_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CaSource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Managed => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CA_SOURCE_UNSPECIFIED"),
                Self::Managed => std::option::Option::Some("CA_SOURCE_MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CaSource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CaSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CaSource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Managed,
                _ => Self::UnknownValue(ca_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CaSource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CA_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "CA_SOURCE_MANAGED" => Self::Managed,
                _ => Self::UnknownValue(ca_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CaSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Managed => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CaSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CaSource>::new(
                ".google.cloud.alloydb.v1.SslConfig.CaSource",
            ))
        }
    }
}

/// Message describing the user-specified automated backup policy.
///
/// All fields in the automated backup policy are optional. Defaults for each
/// field are provided if they are not set.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomatedBackupPolicy {
    /// Whether automated automated backups are enabled. If not set, defaults to
    /// true.
    pub enabled: std::option::Option<bool>,

    /// The length of the time window during which a backup can be
    /// taken. If a backup does not succeed within this time window, it will be
    /// canceled and considered failed.
    ///
    /// The backup window must be at least 5 minutes long. There is no upper bound
    /// on the window. If not set, it defaults to 1 hour.
    pub backup_window: std::option::Option<wkt::Duration>,

    /// Optional. The encryption config can be specified to encrypt the
    /// backups with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will use the cluster's encryption config.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// The location where the backup will be stored. Currently, the only supported
    /// option is to store the backup in the same region as the cluster.
    ///
    /// If empty, defaults to the region of the cluster.
    pub location: std::string::String,

    /// Labels to apply to backups created using this configuration.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    pub schedule: std::option::Option<crate::model::automated_backup_policy::Schedule>,

    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    pub retention: std::option::Option<crate::model::automated_backup_policy::Retention>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomatedBackupPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::AutomatedBackupPolicy::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::AutomatedBackupPolicy::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_window][crate::model::AutomatedBackupPolicy::backup_window].
    pub fn set_backup_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.backup_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_window][crate::model::AutomatedBackupPolicy::backup_window].
    pub fn set_or_clear_backup_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.backup_window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_config][crate::model::AutomatedBackupPolicy::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::AutomatedBackupPolicy::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::AutomatedBackupPolicy::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AutomatedBackupPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupPolicy::schedule].
    ///
    /// Note that all the setters affecting `schedule` are mutually
    /// exclusive.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_policy::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::AutomatedBackupPolicy::schedule]
    /// if it holds a `WeeklySchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn weekly_schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>>
    {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Schedule::WeeklySchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupPolicy::schedule]
    /// to hold a `WeeklySchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_weekly_schedule<
        T: std::convert::Into<std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::automated_backup_policy::Schedule::WeeklySchedule(v.into()),
        );
        self
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention].
    ///
    /// Note that all the setters affecting `retention` are mutually
    /// exclusive.
    pub fn set_retention<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_policy::Retention>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = v.into();
        self
    }

    /// The value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// if it holds a `TimeBasedRetention`, `None` if the field is not set or
    /// holds a different branch.
    pub fn time_based_retention(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
    > {
        #[allow(unreachable_patterns)]
        self.retention.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Retention::TimeBasedRetention(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// to hold a `TimeBasedRetention`.
    ///
    /// Note that all the setters affecting `retention` are
    /// mutually exclusive.
    pub fn set_time_based_retention<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = std::option::Option::Some(
            crate::model::automated_backup_policy::Retention::TimeBasedRetention(v.into()),
        );
        self
    }

    /// The value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// if it holds a `QuantityBasedRetention`, `None` if the field is not set or
    /// holds a different branch.
    pub fn quantity_based_retention(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
    > {
        #[allow(unreachable_patterns)]
        self.retention.as_ref().and_then(|v| match v {
            crate::model::automated_backup_policy::Retention::QuantityBasedRetention(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupPolicy::retention]
    /// to hold a `QuantityBasedRetention`.
    ///
    /// Note that all the setters affecting `retention` are
    /// mutually exclusive.
    pub fn set_quantity_based_retention<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retention = std::option::Option::Some(
            crate::model::automated_backup_policy::Retention::QuantityBasedRetention(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomatedBackupPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomatedBackupPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __weekly_schedule,
            __time_based_retention,
            __quantity_based_retention,
            __enabled,
            __backup_window,
            __encryption_config,
            __location,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomatedBackupPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "weeklySchedule" => Ok(__FieldTag::__weekly_schedule),
                            "weekly_schedule" => Ok(__FieldTag::__weekly_schedule),
                            "timeBasedRetention" => Ok(__FieldTag::__time_based_retention),
                            "time_based_retention" => Ok(__FieldTag::__time_based_retention),
                            "quantityBasedRetention" => Ok(__FieldTag::__quantity_based_retention),
                            "quantity_based_retention" => {
                                Ok(__FieldTag::__quantity_based_retention)
                            }
                            "enabled" => Ok(__FieldTag::__enabled),
                            "backupWindow" => Ok(__FieldTag::__backup_window),
                            "backup_window" => Ok(__FieldTag::__backup_window),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            "location" => Ok(__FieldTag::__location),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomatedBackupPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomatedBackupPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__weekly_schedule => {
                            if !fields.insert(__FieldTag::__weekly_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.alloydb.v1.AutomatedBackupPolicy.weekly_schedule, latest field was weeklySchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::automated_backup_policy::Schedule::WeeklySchedule(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::automated_backup_policy::WeeklySchedule,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__time_based_retention => {
                            if !fields.insert(__FieldTag::__time_based_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_based_retention",
                                ));
                            }
                            if result.retention.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `retention`, a oneof with full ID .google.cloud.alloydb.v1.AutomatedBackupPolicy.time_based_retention, latest field was timeBasedRetention",
                                ));
                            }
                            result.retention = std::option::Option::Some(
                                crate::model::automated_backup_policy::Retention::TimeBasedRetention(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__quantity_based_retention => {
                            if !fields.insert(__FieldTag::__quantity_based_retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quantity_based_retention",
                                ));
                            }
                            if result.retention.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `retention`, a oneof with full ID .google.cloud.alloydb.v1.AutomatedBackupPolicy.quantity_based_retention, latest field was quantityBasedRetention",
                                ));
                            }
                            result.retention = std::option::Option::Some(
                                crate::model::automated_backup_policy::Retention::QuantityBasedRetention(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__backup_window => {
                            if !fields.insert(__FieldTag::__backup_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_window",
                                ));
                            }
                            result.backup_window =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomatedBackupPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.weekly_schedule() {
            state.serialize_entry("weeklySchedule", value)?;
        }
        if let Some(value) = self.time_based_retention() {
            state.serialize_entry("timeBasedRetention", value)?;
        }
        if let Some(value) = self.quantity_based_retention() {
            state.serialize_entry("quantityBasedRetention", value)?;
        }
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.backup_window.is_some() {
            state.serialize_entry("backupWindow", &self.backup_window)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AutomatedBackupPolicy].
pub mod automated_backup_policy {
    #[allow(unused_imports)]
    use super::*;

    /// A weekly schedule starts a backup at prescribed start times within a
    /// day, for the specified days of the week.
    ///
    /// The weekly schedule message is flexible and can be used to create many
    /// types of schedules. For example, to have a daily backup that starts at
    /// 22:00, configure the `start_times` field to have one element "22:00" and
    /// the `days_of_week` field to have all seven days of the week.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WeeklySchedule {
        /// The times during the day to start a backup. The start times are assumed
        /// to be in UTC and to be an exact hour (e.g., 04:00:00).
        ///
        /// If no start times are provided, a single fixed start time is chosen
        /// arbitrarily.
        pub start_times: std::vec::Vec<gtype::model::TimeOfDay>,

        /// The days of the week to perform a backup.
        ///
        /// If this field is left empty, the default of every day of the week is
        /// used.
        pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WeeklySchedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_times][crate::model::automated_backup_policy::WeeklySchedule::start_times].
        pub fn set_start_times<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<gtype::model::TimeOfDay>,
        {
            use std::iter::Iterator;
            self.start_times = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [days_of_week][crate::model::automated_backup_policy::WeeklySchedule::days_of_week].
        pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<gtype::model::DayOfWeek>,
        {
            use std::iter::Iterator;
            self.days_of_week = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WeeklySchedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.WeeklySchedule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WeeklySchedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_times,
                __days_of_week,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WeeklySchedule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTimes" => Ok(__FieldTag::__start_times),
                                "start_times" => Ok(__FieldTag::__start_times),
                                "daysOfWeek" => Ok(__FieldTag::__days_of_week),
                                "days_of_week" => Ok(__FieldTag::__days_of_week),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WeeklySchedule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WeeklySchedule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_times => {
                                if !fields.insert(__FieldTag::__start_times) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_times",
                                    ));
                                }
                                result.start_times = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::TimeOfDay>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__days_of_week => {
                                if !fields.insert(__FieldTag::__days_of_week) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for days_of_week",
                                    ));
                                }
                                result.days_of_week = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::DayOfWeek>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WeeklySchedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.start_times.is_empty() {
                state.serialize_entry("startTimes", &self.start_times)?;
            }
            if !self.days_of_week.is_empty() {
                state.serialize_entry("daysOfWeek", &self.days_of_week)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A time based retention policy specifies that all backups within a certain
    /// time period should be retained.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeBasedRetention {
        /// The retention period.
        pub retention_period: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeBasedRetention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_period][crate::model::automated_backup_policy::TimeBasedRetention::retention_period].
        pub fn set_retention_period<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_period = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [retention_period][crate::model::automated_backup_policy::TimeBasedRetention::retention_period].
        pub fn set_or_clear_retention_period<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_period = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TimeBasedRetention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.TimeBasedRetention"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeBasedRetention {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __retention_period,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeBasedRetention")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "retentionPeriod" => Ok(__FieldTag::__retention_period),
                                "retention_period" => Ok(__FieldTag::__retention_period),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeBasedRetention;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeBasedRetention")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__retention_period => {
                                if !fields.insert(__FieldTag::__retention_period) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for retention_period",
                                    ));
                                }
                                result.retention_period =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeBasedRetention {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.retention_period.is_some() {
                state.serialize_entry("retentionPeriod", &self.retention_period)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A quantity based policy specifies that a certain number of the most recent
    /// successful backups should be retained.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QuantityBasedRetention {
        /// The number of backups to retain.
        pub count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QuantityBasedRetention {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [count][crate::model::automated_backup_policy::QuantityBasedRetention::count].
        pub fn set_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.count = v.into();
            self
        }
    }

    impl wkt::message::Message for QuantityBasedRetention {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.AutomatedBackupPolicy.QuantityBasedRetention"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QuantityBasedRetention {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QuantityBasedRetention")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "count" => Ok(__FieldTag::__count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QuantityBasedRetention;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QuantityBasedRetention")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__count => {
                                if !fields.insert(__FieldTag::__count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QuantityBasedRetention {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("count", &__With(&self.count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The schedule for this automated backup policy.
    ///
    /// A schedule specifies times at which to start a backup. If a backup
    /// window is also provided, the backup is guaranteed to be started and
    /// completed within the start time plus the backup window. If the backup is
    /// not completed within the backup window it is marked as failed.
    ///
    /// If not set, the schedule defaults to a weekly schedule with one backup
    /// per day and a start time chosen arbitrarily.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schedule {
        /// Weekly schedule for the Backup.
        WeeklySchedule(std::boxed::Box<crate::model::automated_backup_policy::WeeklySchedule>),
    }

    /// The retention policy for automated backups.
    ///
    /// The retention policy for a backup is fixed at the time the backup is
    /// created. Changes to this field only apply to new backups taken with the
    /// policy; the retentions of existing backups remain unchanged.
    ///
    /// If no retention policy is set, a default of 14 days is used.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Retention {
        /// Time-based Backup retention policy.
        TimeBasedRetention(
            std::boxed::Box<crate::model::automated_backup_policy::TimeBasedRetention>,
        ),
        /// Quantity-based Backup retention policy to retain recent backups.
        QuantityBasedRetention(
            std::boxed::Box<crate::model::automated_backup_policy::QuantityBasedRetention>,
        ),
    }
}

/// ContinuousBackupConfig describes the continuous backups recovery
/// configurations of a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContinuousBackupConfig {
    /// Whether ContinuousBackup is enabled.
    pub enabled: std::option::Option<bool>,

    /// The number of days that are eligible to restore from using PITR. To support
    /// the entire recovery window, backups and logs are retained for one day more
    /// than the recovery window. If not set, defaults to 14 days.
    pub recovery_window_days: i32,

    /// The encryption config can be specified to encrypt the
    /// backups with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will use the cluster's encryption config.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContinuousBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ContinuousBackupConfig::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::ContinuousBackupConfig::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recovery_window_days][crate::model::ContinuousBackupConfig::recovery_window_days].
    pub fn set_recovery_window_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.recovery_window_days = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::ContinuousBackupConfig::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::ContinuousBackupConfig::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ContinuousBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContinuousBackupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __recovery_window_days,
            __encryption_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContinuousBackupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "recoveryWindowDays" => Ok(__FieldTag::__recovery_window_days),
                            "recovery_window_days" => Ok(__FieldTag::__recovery_window_days),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContinuousBackupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContinuousBackupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__recovery_window_days => {
                            if !fields.insert(__FieldTag::__recovery_window_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recovery_window_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.recovery_window_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContinuousBackupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.recovery_window_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("recoveryWindowDays", &__With(&self.recovery_window_days))?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ContinuousBackupInfo describes the continuous backup properties of a
/// cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContinuousBackupInfo {
    /// Output only. The encryption information for the WALs and backups required
    /// for ContinuousBackup.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Output only. When ContinuousBackup was most recently enabled. Set to null
    /// if ContinuousBackup is not enabled.
    pub enabled_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Days of the week on which a continuous backup is taken.
    pub schedule: std::vec::Vec<gtype::model::DayOfWeek>,

    /// Output only. The earliest restorable time that can be restored to. If
    /// continuous backups and recovery was recently enabled, the earliest
    /// restorable time is the creation time of the earliest eligible backup within
    /// this cluster's continuous backup recovery window. After a cluster has had
    /// continuous backups enabled for the duration of its recovery window, the
    /// earliest restorable time becomes "now minus the recovery window". For
    /// example, assuming a point in time recovery is attempted at 04/16/2025
    /// 3:23:00PM with a 14d recovery window, the earliest restorable time would be
    /// 04/02/2025 3:23:00PM. This field is only visible if the
    /// CLUSTER_VIEW_CONTINUOUS_BACKUP cluster view is provided.
    pub earliest_restorable_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContinuousBackupInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_info][crate::model::ContinuousBackupInfo::encryption_info].
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::ContinuousBackupInfo::encryption_info].
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enabled_time][crate::model::ContinuousBackupInfo::enabled_time].
    pub fn set_enabled_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enabled_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled_time][crate::model::ContinuousBackupInfo::enabled_time].
    pub fn set_or_clear_enabled_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.enabled_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule][crate::model::ContinuousBackupInfo::schedule].
    pub fn set_schedule<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<gtype::model::DayOfWeek>,
    {
        use std::iter::Iterator;
        self.schedule = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [earliest_restorable_time][crate::model::ContinuousBackupInfo::earliest_restorable_time].
    pub fn set_earliest_restorable_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.earliest_restorable_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [earliest_restorable_time][crate::model::ContinuousBackupInfo::earliest_restorable_time].
    pub fn set_or_clear_earliest_restorable_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.earliest_restorable_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ContinuousBackupInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContinuousBackupInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_info,
            __enabled_time,
            __schedule,
            __earliest_restorable_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContinuousBackupInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionInfo" => Ok(__FieldTag::__encryption_info),
                            "encryption_info" => Ok(__FieldTag::__encryption_info),
                            "enabledTime" => Ok(__FieldTag::__enabled_time),
                            "enabled_time" => Ok(__FieldTag::__enabled_time),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "earliestRestorableTime" => Ok(__FieldTag::__earliest_restorable_time),
                            "earliest_restorable_time" => {
                                Ok(__FieldTag::__earliest_restorable_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContinuousBackupInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContinuousBackupInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_info => {
                            if !fields.insert(__FieldTag::__encryption_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_info",
                                ));
                            }
                            result.encryption_info = map
                                .next_value::<std::option::Option<crate::model::EncryptionInfo>>(
                                )?;
                        }
                        __FieldTag::__enabled_time => {
                            if !fields.insert(__FieldTag::__enabled_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled_time",
                                ));
                            }
                            result.enabled_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::DayOfWeek>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__earliest_restorable_time => {
                            if !fields.insert(__FieldTag::__earliest_restorable_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for earliest_restorable_time",
                                ));
                            }
                            result.earliest_restorable_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContinuousBackupInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.encryption_info.is_some() {
            state.serialize_entry("encryptionInfo", &self.encryption_info)?;
        }
        if self.enabled_time.is_some() {
            state.serialize_entry("enabledTime", &self.enabled_time)?;
        }
        if !self.schedule.is_empty() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if self.earliest_restorable_time.is_some() {
            state.serialize_entry("earliestRestorableTime", &self.earliest_restorable_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing a BackupSource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupSource {
    /// Output only. The system-generated UID of the backup which was used to
    /// create this resource. The UID is generated when the backup is created, and
    /// it is retained until the backup is deleted.
    pub backup_uid: std::string::String,

    /// Required. The name of the backup resource with the format:
    ///
    /// * projects/{project}/locations/{region}/backups/{backup_id}
    pub backup_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_uid][crate::model::BackupSource::backup_uid].
    pub fn set_backup_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_uid = v.into();
        self
    }

    /// Sets the value of [backup_name][crate::model::BackupSource::backup_name].
    pub fn set_backup_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_name = v.into();
        self
    }
}

impl wkt::message::Message for BackupSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BackupSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_uid,
            __backup_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupUid" => Ok(__FieldTag::__backup_uid),
                            "backup_uid" => Ok(__FieldTag::__backup_uid),
                            "backupName" => Ok(__FieldTag::__backup_name),
                            "backup_name" => Ok(__FieldTag::__backup_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_uid => {
                            if !fields.insert(__FieldTag::__backup_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_uid",
                                ));
                            }
                            result.backup_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_name => {
                            if !fields.insert(__FieldTag::__backup_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_name",
                                ));
                            }
                            result.backup_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_uid.is_empty() {
            state.serialize_entry("backupUid", &self.backup_uid)?;
        }
        if !self.backup_name.is_empty() {
            state.serialize_entry("backupName", &self.backup_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing a ContinuousBackupSource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContinuousBackupSource {
    /// Required. The source cluster from which to restore. This cluster must have
    /// continuous backup enabled for this operation to succeed. For the required
    /// format, see the comment on the Cluster.name field.
    pub cluster: std::string::String,

    /// Required. The point in time to restore to.
    pub point_in_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContinuousBackupSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::ContinuousBackupSource::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [point_in_time][crate::model::ContinuousBackupSource::point_in_time].
    pub fn set_point_in_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.point_in_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [point_in_time][crate::model::ContinuousBackupSource::point_in_time].
    pub fn set_or_clear_point_in_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.point_in_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ContinuousBackupSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ContinuousBackupSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContinuousBackupSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            __point_in_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContinuousBackupSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            "pointInTime" => Ok(__FieldTag::__point_in_time),
                            "point_in_time" => Ok(__FieldTag::__point_in_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContinuousBackupSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContinuousBackupSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__point_in_time => {
                            if !fields.insert(__FieldTag::__point_in_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for point_in_time",
                                ));
                            }
                            result.point_in_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContinuousBackupSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.point_in_time.is_some() {
            state.serialize_entry("pointInTime", &self.point_in_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// MaintenanceUpdatePolicy defines the policy for system updates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceUpdatePolicy {
    /// Preferred windows to perform maintenance. Currently limited to 1.
    pub maintenance_windows:
        std::vec::Vec<crate::model::maintenance_update_policy::MaintenanceWindow>,

    /// Periods to deny maintenance. Currently limited to 1.
    pub deny_maintenance_periods:
        std::vec::Vec<crate::model::maintenance_update_policy::DenyMaintenancePeriod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceUpdatePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [maintenance_windows][crate::model::MaintenanceUpdatePolicy::maintenance_windows].
    pub fn set_maintenance_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::maintenance_update_policy::MaintenanceWindow>,
    {
        use std::iter::Iterator;
        self.maintenance_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [deny_maintenance_periods][crate::model::MaintenanceUpdatePolicy::deny_maintenance_periods].
    pub fn set_deny_maintenance_periods<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::maintenance_update_policy::DenyMaintenancePeriod>,
    {
        use std::iter::Iterator;
        self.deny_maintenance_periods = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenanceUpdatePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceUpdatePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __maintenance_windows,
            __deny_maintenance_periods,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceUpdatePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maintenanceWindows" => Ok(__FieldTag::__maintenance_windows),
                            "maintenance_windows" => Ok(__FieldTag::__maintenance_windows),
                            "denyMaintenancePeriods" => Ok(__FieldTag::__deny_maintenance_periods),
                            "deny_maintenance_periods" => {
                                Ok(__FieldTag::__deny_maintenance_periods)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceUpdatePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceUpdatePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__maintenance_windows => {
                            if !fields.insert(__FieldTag::__maintenance_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_windows",
                                ));
                            }
                            result.maintenance_windows = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::maintenance_update_policy::MaintenanceWindow,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deny_maintenance_periods => {
                            if !fields.insert(__FieldTag::__deny_maintenance_periods) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deny_maintenance_periods",
                                ));
                            }
                            result.deny_maintenance_periods = map.next_value::<std::option::Option<std::vec::Vec<crate::model::maintenance_update_policy::DenyMaintenancePeriod>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceUpdatePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.maintenance_windows.is_empty() {
            state.serialize_entry("maintenanceWindows", &self.maintenance_windows)?;
        }
        if !self.deny_maintenance_periods.is_empty() {
            state.serialize_entry("denyMaintenancePeriods", &self.deny_maintenance_periods)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MaintenanceUpdatePolicy].
pub mod maintenance_update_policy {
    #[allow(unused_imports)]
    use super::*;

    /// MaintenanceWindow specifies a preferred day and time for maintenance.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MaintenanceWindow {
        /// Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY, etc.
        pub day: gtype::model::DayOfWeek,

        /// Preferred time to start the maintenance operation on the specified day.
        /// Maintenance will start within 1 hour of this time.
        pub start_time: std::option::Option<gtype::model::TimeOfDay>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MaintenanceWindow {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [day][crate::model::maintenance_update_policy::MaintenanceWindow::day].
        pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
            self.day = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::maintenance_update_policy::MaintenanceWindow::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::maintenance_update_policy::MaintenanceWindow::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MaintenanceWindow {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy.MaintenanceWindow"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MaintenanceWindow {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __day,
                __start_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MaintenanceWindow")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "day" => Ok(__FieldTag::__day),
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MaintenanceWindow;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MaintenanceWindow")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__day => {
                                if !fields.insert(__FieldTag::__day) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for day",
                                    ));
                                }
                                result.day = map
                                    .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time = map
                                    .next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MaintenanceWindow {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.day) {
                state.serialize_entry("day", &self.day)?;
            }
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// DenyMaintenancePeriod definition. Excepting emergencies, maintenance
    /// will not be scheduled to start within this deny period. The start_date must
    /// be less than the end_date.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DenyMaintenancePeriod {
        /// Deny period start date.
        /// This can be:
        ///
        /// * A full date, with non-zero year, month and day values OR
        /// * A month and day value, with a zero year for recurring
        pub start_date: std::option::Option<gtype::model::Date>,

        /// Deny period end date.
        /// This can be:
        ///
        /// * A full date, with non-zero year, month and day values OR
        /// * A month and day value, with a zero year for recurring
        pub end_date: std::option::Option<gtype::model::Date>,

        /// Time in UTC when the deny period starts on start_date and ends on
        /// end_date. This can be:
        ///
        /// * Full time OR
        /// * All zeros for 00:00:00 UTC
        pub time: std::option::Option<gtype::model::TimeOfDay>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DenyMaintenancePeriod {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::start_date].
        pub fn set_start_date<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.start_date = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::start_date].
        pub fn set_or_clear_start_date<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.start_date = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::end_date].
        pub fn set_end_date<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.end_date = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_date][crate::model::maintenance_update_policy::DenyMaintenancePeriod::end_date].
        pub fn set_or_clear_end_date<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Date>,
        {
            self.end_date = v.map(|x| x.into());
            self
        }

        /// Sets the value of [time][crate::model::maintenance_update_policy::DenyMaintenancePeriod::time].
        pub fn set_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time][crate::model::maintenance_update_policy::DenyMaintenancePeriod::time].
        pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DenyMaintenancePeriod {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceUpdatePolicy.DenyMaintenancePeriod"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DenyMaintenancePeriod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_date,
                __end_date,
                __time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DenyMaintenancePeriod")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startDate" => Ok(__FieldTag::__start_date),
                                "start_date" => Ok(__FieldTag::__start_date),
                                "endDate" => Ok(__FieldTag::__end_date),
                                "end_date" => Ok(__FieldTag::__end_date),
                                "time" => Ok(__FieldTag::__time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DenyMaintenancePeriod;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DenyMaintenancePeriod")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_date => {
                                if !fields.insert(__FieldTag::__start_date) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_date",
                                    ));
                                }
                                result.start_date =
                                    map.next_value::<std::option::Option<gtype::model::Date>>()?;
                            }
                            __FieldTag::__end_date => {
                                if !fields.insert(__FieldTag::__end_date) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_date",
                                    ));
                                }
                                result.end_date =
                                    map.next_value::<std::option::Option<gtype::model::Date>>()?;
                            }
                            __FieldTag::__time => {
                                if !fields.insert(__FieldTag::__time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time",
                                    ));
                                }
                                result.time = map
                                    .next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DenyMaintenancePeriod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_date.is_some() {
                state.serialize_entry("startDate", &self.start_date)?;
            }
            if self.end_date.is_some() {
                state.serialize_entry("endDate", &self.end_date)?;
            }
            if self.time.is_some() {
                state.serialize_entry("time", &self.time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// MaintenanceSchedule stores the maintenance schedule generated from
/// the MaintenanceUpdatePolicy, once a maintenance rollout is triggered, if
/// MaintenanceWindow is set, and if there is no conflicting DenyPeriod.
/// The schedule is cleared once the update takes place. This field cannot be
/// manually changed; modify the MaintenanceUpdatePolicy instead.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceSchedule {
    /// Output only. The scheduled start time for the maintenance.
    pub start_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::MaintenanceSchedule::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::MaintenanceSchedule::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaintenanceSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.MaintenanceSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A cluster is a collection of regional AlloyDB resources. It can include a
/// primary instance and one or more read pool instances.
/// All cluster resources share a storage layer, which scales as needed.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// Output only. The name of the cluster resource with the format:
    ///
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}
    ///   where the cluster ID segment should satisfy the regex expression
    ///   `[a-z0-9-]+`. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the cluster resource name is the name of the parent resource:
    /// * projects/{project}/locations/{region}
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Cluster.
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    pub uid: std::string::String,

    /// Output only. Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current serving state of the cluster.
    pub state: crate::model::cluster::State,

    /// Output only. The type of the cluster. This is an output-only field and it's
    /// populated at the Cluster creation time or the Cluster promotion
    /// time. The cluster type is determined by which RPC was used to create
    /// the cluster (i.e. `CreateCluster` vs. `CreateSecondaryCluster`
    pub cluster_type: crate::model::cluster::ClusterType,

    /// Optional. The database engine major version. This is an optional field and
    /// it is populated at the Cluster creation time. If a database version is not
    /// supplied at cluster creation time, then a default database version will
    /// be used.
    pub database_version: crate::model::DatabaseVersion,

    pub network_config: std::option::Option<crate::model::cluster::NetworkConfig>,

    /// Required. The resource link for the VPC network in which cluster resources
    /// are created and from which they are accessible via Private IP. The network
    /// must belong to the same project as the cluster. It is specified in the
    /// form: `projects/{project}/global/networks/{network_id}`. This is required
    /// to create a cluster. Deprecated, use network_config.network instead.
    #[deprecated]
    pub network: std::string::String,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Cluster does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    pub reconciling: bool,

    /// Input only. Initial user to setup during cluster creation. Required.
    /// If used in `RestoreCluster` this is ignored.
    pub initial_user: std::option::Option<crate::model::UserPassword>,

    /// The automated backup policy for this cluster.
    ///
    /// If no policy is provided then the default policy will be used. If backups
    /// are supported for the cluster, the default policy takes one backup a day,
    /// has a backup window of 1 hour, and retains backups for 14 days.
    /// For more information on the defaults, consult the
    /// documentation for the message type.
    pub automated_backup_policy: std::option::Option<crate::model::AutomatedBackupPolicy>,

    /// SSL configuration for this AlloyDB cluster.
    #[deprecated]
    pub ssl_config: std::option::Option<crate::model::SslConfig>,

    /// Optional. The encryption config can be specified to encrypt the data disks
    /// and other persistent data resources of a cluster with a
    /// customer-managed encryption key (CMEK). When this field is not
    /// specified, the cluster will then use default encryption scheme to
    /// protect the user data.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Output only. The encryption information for the cluster.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Optional. Continuous backup configuration for this cluster.
    pub continuous_backup_config: std::option::Option<crate::model::ContinuousBackupConfig>,

    /// Output only. Continuous backup properties for this cluster.
    pub continuous_backup_info: std::option::Option<crate::model::ContinuousBackupInfo>,

    /// Cross Region replication config specific to SECONDARY cluster.
    pub secondary_config: std::option::Option<crate::model::cluster::SecondaryConfig>,

    /// Output only. Cross Region replication config specific to PRIMARY cluster.
    pub primary_config: std::option::Option<crate::model::cluster::PrimaryConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. The configuration for Private Service Connect (PSC) for the
    /// cluster.
    pub psc_config: std::option::Option<crate::model::cluster::PscConfig>,

    /// Optional. The maintenance update policy determines when to allow or deny
    /// updates.
    pub maintenance_update_policy: std::option::Option<crate::model::MaintenanceUpdatePolicy>,

    /// Output only. The maintenance schedule for the cluster, generated for a
    /// specific rollout if a maintenance window is set.
    pub maintenance_schedule: std::option::Option<crate::model::MaintenanceSchedule>,

    /// Optional. Subscription type of the cluster.
    pub subscription_type: crate::model::SubscriptionType,

    /// Output only. Metadata for free trial clusters
    pub trial_metadata: std::option::Option<crate::model::cluster::TrialMetadata>,

    /// Optional. Input only. Immutable. Tag keys/values directly bound to this
    /// resource. For example:
    ///
    /// ```norust
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    /// ```
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    pub source: std::option::Option<crate::model::cluster::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Cluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Cluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Cluster::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Cluster::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cluster_type][crate::model::Cluster::cluster_type].
    pub fn set_cluster_type<T: std::convert::Into<crate::model::cluster::ClusterType>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_type = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::Cluster::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [network_config][crate::model::Cluster::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::Cluster::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::Cluster::network].
    #[deprecated]
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Cluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Cluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [reconciling][crate::model::Cluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [initial_user][crate::model::Cluster::initial_user].
    pub fn set_initial_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserPassword>,
    {
        self.initial_user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_user][crate::model::Cluster::initial_user].
    pub fn set_or_clear_initial_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserPassword>,
    {
        self.initial_user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_backup_policy][crate::model::Cluster::automated_backup_policy].
    pub fn set_automated_backup_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupPolicy>,
    {
        self.automated_backup_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automated_backup_policy][crate::model::Cluster::automated_backup_policy].
    pub fn set_or_clear_automated_backup_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupPolicy>,
    {
        self.automated_backup_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_config][crate::model::Cluster::ssl_config].
    #[deprecated]
    pub fn set_ssl_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl_config][crate::model::Cluster::ssl_config].
    #[deprecated]
    pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_config][crate::model::Cluster::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::Cluster::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_info][crate::model::Cluster::encryption_info].
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::Cluster::encryption_info].
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [continuous_backup_config][crate::model::Cluster::continuous_backup_config].
    pub fn set_continuous_backup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupConfig>,
    {
        self.continuous_backup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [continuous_backup_config][crate::model::Cluster::continuous_backup_config].
    pub fn set_or_clear_continuous_backup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupConfig>,
    {
        self.continuous_backup_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [continuous_backup_info][crate::model::Cluster::continuous_backup_info].
    pub fn set_continuous_backup_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupInfo>,
    {
        self.continuous_backup_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [continuous_backup_info][crate::model::Cluster::continuous_backup_info].
    pub fn set_or_clear_continuous_backup_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousBackupInfo>,
    {
        self.continuous_backup_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_config][crate::model::Cluster::secondary_config].
    pub fn set_secondary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SecondaryConfig>,
    {
        self.secondary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_config][crate::model::Cluster::secondary_config].
    pub fn set_or_clear_secondary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SecondaryConfig>,
    {
        self.secondary_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [primary_config][crate::model::Cluster::primary_config].
    pub fn set_primary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PrimaryConfig>,
    {
        self.primary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_config][crate::model::Cluster::primary_config].
    pub fn set_or_clear_primary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PrimaryConfig>,
    {
        self.primary_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::Cluster::psc_config].
    pub fn set_psc_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PscConfig>,
    {
        self.psc_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_config][crate::model::Cluster::psc_config].
    pub fn set_or_clear_psc_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::PscConfig>,
    {
        self.psc_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_update_policy][crate::model::Cluster::maintenance_update_policy].
    pub fn set_maintenance_update_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceUpdatePolicy>,
    {
        self.maintenance_update_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_update_policy][crate::model::Cluster::maintenance_update_policy].
    pub fn set_or_clear_maintenance_update_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceUpdatePolicy>,
    {
        self.maintenance_update_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    pub fn set_maintenance_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceSchedule>,
    {
        self.maintenance_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    pub fn set_or_clear_maintenance_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceSchedule>,
    {
        self.maintenance_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subscription_type][crate::model::Cluster::subscription_type].
    pub fn set_subscription_type<T: std::convert::Into<crate::model::SubscriptionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.subscription_type = v.into();
        self
    }

    /// Sets the value of [trial_metadata][crate::model::Cluster::trial_metadata].
    pub fn set_trial_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::TrialMetadata>,
    {
        self.trial_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trial_metadata][crate::model::Cluster::trial_metadata].
    pub fn set_or_clear_trial_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::TrialMetadata>,
    {
        self.trial_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::Cluster::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source][crate::model::Cluster::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::cluster::Source>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `BackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::BackupSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `BackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_backup_source<T: std::convert::Into<std::boxed::Box<crate::model::BackupSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::cluster::Source::BackupSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `MigrationSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn migration_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MigrationSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::MigrationSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `MigrationSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_migration_source<
        T: std::convert::Into<std::boxed::Box<crate::model::MigrationSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::cluster::Source::MigrationSource(v.into()));
        self
    }

    /// The value of [source][crate::model::Cluster::source]
    /// if it holds a `CloudsqlBackupRunSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloudsql_backup_run_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSQLBackupRunSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::cluster::Source::CloudsqlBackupRunSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Cluster::source]
    /// to hold a `CloudsqlBackupRunSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloudsql_backup_run_source<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSQLBackupRunSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::cluster::Source::CloudsqlBackupRunSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Cluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_source,
            __migration_source,
            __cloudsql_backup_run_source,
            __name,
            __display_name,
            __uid,
            __create_time,
            __update_time,
            __delete_time,
            __labels,
            __state,
            __cluster_type,
            __database_version,
            __network_config,
            __network,
            __etag,
            __annotations,
            __reconciling,
            __initial_user,
            __automated_backup_policy,
            __ssl_config,
            __encryption_config,
            __encryption_info,
            __continuous_backup_config,
            __continuous_backup_info,
            __secondary_config,
            __primary_config,
            __satisfies_pzs,
            __psc_config,
            __maintenance_update_policy,
            __maintenance_schedule,
            __subscription_type,
            __trial_metadata,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupSource" => Ok(__FieldTag::__backup_source),
                            "backup_source" => Ok(__FieldTag::__backup_source),
                            "migrationSource" => Ok(__FieldTag::__migration_source),
                            "migration_source" => Ok(__FieldTag::__migration_source),
                            "cloudsqlBackupRunSource" => {
                                Ok(__FieldTag::__cloudsql_backup_run_source)
                            }
                            "cloudsql_backup_run_source" => {
                                Ok(__FieldTag::__cloudsql_backup_run_source)
                            }
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "clusterType" => Ok(__FieldTag::__cluster_type),
                            "cluster_type" => Ok(__FieldTag::__cluster_type),
                            "databaseVersion" => Ok(__FieldTag::__database_version),
                            "database_version" => Ok(__FieldTag::__database_version),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "network" => Ok(__FieldTag::__network),
                            "etag" => Ok(__FieldTag::__etag),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "initialUser" => Ok(__FieldTag::__initial_user),
                            "initial_user" => Ok(__FieldTag::__initial_user),
                            "automatedBackupPolicy" => Ok(__FieldTag::__automated_backup_policy),
                            "automated_backup_policy" => Ok(__FieldTag::__automated_backup_policy),
                            "sslConfig" => Ok(__FieldTag::__ssl_config),
                            "ssl_config" => Ok(__FieldTag::__ssl_config),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            "encryptionInfo" => Ok(__FieldTag::__encryption_info),
                            "encryption_info" => Ok(__FieldTag::__encryption_info),
                            "continuousBackupConfig" => Ok(__FieldTag::__continuous_backup_config),
                            "continuous_backup_config" => {
                                Ok(__FieldTag::__continuous_backup_config)
                            }
                            "continuousBackupInfo" => Ok(__FieldTag::__continuous_backup_info),
                            "continuous_backup_info" => Ok(__FieldTag::__continuous_backup_info),
                            "secondaryConfig" => Ok(__FieldTag::__secondary_config),
                            "secondary_config" => Ok(__FieldTag::__secondary_config),
                            "primaryConfig" => Ok(__FieldTag::__primary_config),
                            "primary_config" => Ok(__FieldTag::__primary_config),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "pscConfig" => Ok(__FieldTag::__psc_config),
                            "psc_config" => Ok(__FieldTag::__psc_config),
                            "maintenanceUpdatePolicy" => {
                                Ok(__FieldTag::__maintenance_update_policy)
                            }
                            "maintenance_update_policy" => {
                                Ok(__FieldTag::__maintenance_update_policy)
                            }
                            "maintenanceSchedule" => Ok(__FieldTag::__maintenance_schedule),
                            "maintenance_schedule" => Ok(__FieldTag::__maintenance_schedule),
                            "subscriptionType" => Ok(__FieldTag::__subscription_type),
                            "subscription_type" => Ok(__FieldTag::__subscription_type),
                            "trialMetadata" => Ok(__FieldTag::__trial_metadata),
                            "trial_metadata" => Ok(__FieldTag::__trial_metadata),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_source => {
                            if !fields.insert(__FieldTag::__backup_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.alloydb.v1.Cluster.backup_source, latest field was backupSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::cluster::Source::BackupSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BackupSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__migration_source => {
                            if !fields.insert(__FieldTag::__migration_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.alloydb.v1.Cluster.migration_source, latest field was migrationSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::cluster::Source::MigrationSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MigrationSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloudsql_backup_run_source => {
                            if !fields.insert(__FieldTag::__cloudsql_backup_run_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloudsql_backup_run_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.alloydb.v1.Cluster.cloudsql_backup_run_source, latest field was cloudsqlBackupRunSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::cluster::Source::CloudsqlBackupRunSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSQLBackupRunSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::cluster::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_type => {
                            if !fields.insert(__FieldTag::__cluster_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_type",
                                ));
                            }
                            result.cluster_type = map.next_value::<std::option::Option<crate::model::cluster::ClusterType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__database_version => {
                            if !fields.insert(__FieldTag::__database_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_version",
                                ));
                            }
                            result.database_version = map
                                .next_value::<std::option::Option<crate::model::DatabaseVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map.next_value::<std::option::Option<crate::model::cluster::NetworkConfig>>()?
                                ;
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__initial_user => {
                            if !fields.insert(__FieldTag::__initial_user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_user",
                                ));
                            }
                            result.initial_user = map
                                .next_value::<std::option::Option<crate::model::UserPassword>>()?;
                        }
                        __FieldTag::__automated_backup_policy => {
                            if !fields.insert(__FieldTag::__automated_backup_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_backup_policy",
                                ));
                            }
                            result.automated_backup_policy = map.next_value::<std::option::Option<crate::model::AutomatedBackupPolicy>>()?
                                ;
                        }
                        __FieldTag::__ssl_config => {
                            if !fields.insert(__FieldTag::__ssl_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl_config",
                                ));
                            }
                            result.ssl_config =
                                map.next_value::<std::option::Option<crate::model::SslConfig>>()?;
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::__encryption_info => {
                            if !fields.insert(__FieldTag::__encryption_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_info",
                                ));
                            }
                            result.encryption_info = map
                                .next_value::<std::option::Option<crate::model::EncryptionInfo>>(
                                )?;
                        }
                        __FieldTag::__continuous_backup_config => {
                            if !fields.insert(__FieldTag::__continuous_backup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous_backup_config",
                                ));
                            }
                            result.continuous_backup_config = map.next_value::<std::option::Option<crate::model::ContinuousBackupConfig>>()?
                                ;
                        }
                        __FieldTag::__continuous_backup_info => {
                            if !fields.insert(__FieldTag::__continuous_backup_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous_backup_info",
                                ));
                            }
                            result.continuous_backup_info = map.next_value::<std::option::Option<crate::model::ContinuousBackupInfo>>()?
                                ;
                        }
                        __FieldTag::__secondary_config => {
                            if !fields.insert(__FieldTag::__secondary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_config",
                                ));
                            }
                            result.secondary_config = map.next_value::<std::option::Option<crate::model::cluster::SecondaryConfig>>()?
                                ;
                        }
                        __FieldTag::__primary_config => {
                            if !fields.insert(__FieldTag::__primary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_config",
                                ));
                            }
                            result.primary_config = map.next_value::<std::option::Option<crate::model::cluster::PrimaryConfig>>()?
                                ;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_config => {
                            if !fields.insert(__FieldTag::__psc_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_config",
                                ));
                            }
                            result.psc_config = map.next_value::<std::option::Option<crate::model::cluster::PscConfig>>()?
                                ;
                        }
                        __FieldTag::__maintenance_update_policy => {
                            if !fields.insert(__FieldTag::__maintenance_update_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_update_policy",
                                ));
                            }
                            result.maintenance_update_policy = map.next_value::<std::option::Option<crate::model::MaintenanceUpdatePolicy>>()?
                                ;
                        }
                        __FieldTag::__maintenance_schedule => {
                            if !fields.insert(__FieldTag::__maintenance_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_schedule",
                                ));
                            }
                            result.maintenance_schedule = map.next_value::<std::option::Option<crate::model::MaintenanceSchedule>>()?
                                ;
                        }
                        __FieldTag::__subscription_type => {
                            if !fields.insert(__FieldTag::__subscription_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription_type",
                                ));
                            }
                            result.subscription_type = map
                                .next_value::<std::option::Option<crate::model::SubscriptionType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trial_metadata => {
                            if !fields.insert(__FieldTag::__trial_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trial_metadata",
                                ));
                            }
                            result.trial_metadata = map.next_value::<std::option::Option<crate::model::cluster::TrialMetadata>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.backup_source() {
            state.serialize_entry("backupSource", value)?;
        }
        if let Some(value) = self.migration_source() {
            state.serialize_entry("migrationSource", value)?;
        }
        if let Some(value) = self.cloudsql_backup_run_source() {
            state.serialize_entry("cloudsqlBackupRunSource", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.cluster_type) {
            state.serialize_entry("clusterType", &self.cluster_type)?;
        }
        if !wkt::internal::is_default(&self.database_version) {
            state.serialize_entry("databaseVersion", &self.database_version)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.initial_user.is_some() {
            state.serialize_entry("initialUser", &self.initial_user)?;
        }
        if self.automated_backup_policy.is_some() {
            state.serialize_entry("automatedBackupPolicy", &self.automated_backup_policy)?;
        }
        if self.ssl_config.is_some() {
            state.serialize_entry("sslConfig", &self.ssl_config)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if self.encryption_info.is_some() {
            state.serialize_entry("encryptionInfo", &self.encryption_info)?;
        }
        if self.continuous_backup_config.is_some() {
            state.serialize_entry("continuousBackupConfig", &self.continuous_backup_config)?;
        }
        if self.continuous_backup_info.is_some() {
            state.serialize_entry("continuousBackupInfo", &self.continuous_backup_info)?;
        }
        if self.secondary_config.is_some() {
            state.serialize_entry("secondaryConfig", &self.secondary_config)?;
        }
        if self.primary_config.is_some() {
            state.serialize_entry("primaryConfig", &self.primary_config)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.psc_config.is_some() {
            state.serialize_entry("pscConfig", &self.psc_config)?;
        }
        if self.maintenance_update_policy.is_some() {
            state.serialize_entry("maintenanceUpdatePolicy", &self.maintenance_update_policy)?;
        }
        if self.maintenance_schedule.is_some() {
            state.serialize_entry("maintenanceSchedule", &self.maintenance_schedule)?;
        }
        if !wkt::internal::is_default(&self.subscription_type) {
            state.serialize_entry("subscriptionType", &self.subscription_type)?;
        }
        if self.trial_metadata.is_some() {
            state.serialize_entry("trialMetadata", &self.trial_metadata)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata related to network configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkConfig {
        /// Optional. The resource link for the VPC network in which cluster
        /// resources are created and from which they are accessible via Private IP.
        /// The network must belong to the same project as the cluster. It is
        /// specified in the form:
        /// `projects/{project_number}/global/networks/{network_id}`. This is
        /// required to create a cluster.
        pub network: std::string::String,

        /// Optional. Name of the allocated IP range for the private IP AlloyDB
        /// cluster, for example: "google-managed-services-default". If set, the
        /// instance IPs for this cluster will be created in the allocated range. The
        /// range name must comply with RFC 1035. Specifically, the name must be 1-63
        /// characters long and match the regular expression
        /// `[a-z]([-a-z0-9]*[a-z0-9])?`.
        /// Field name is intended to be consistent with Cloud SQL.
        pub allocated_ip_range: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network][crate::model::cluster::NetworkConfig::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [allocated_ip_range][crate::model::cluster::NetworkConfig::allocated_ip_range].
        pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allocated_ip_range = v.into();
            self
        }
    }

    impl wkt::message::Message for NetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.NetworkConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network,
                __allocated_ip_range,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NetworkConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "network" => Ok(__FieldTag::__network),
                                "allocatedIpRange" => Ok(__FieldTag::__allocated_ip_range),
                                "allocated_ip_range" => Ok(__FieldTag::__allocated_ip_range),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NetworkConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NetworkConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network => {
                                if !fields.insert(__FieldTag::__network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network",
                                    ));
                                }
                                result.network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allocated_ip_range => {
                                if !fields.insert(__FieldTag::__allocated_ip_range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_ip_range",
                                    ));
                                }
                                result.allocated_ip_range = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NetworkConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network.is_empty() {
                state.serialize_entry("network", &self.network)?;
            }
            if !self.allocated_ip_range.is_empty() {
                state.serialize_entry("allocatedIpRange", &self.allocated_ip_range)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration information for the secondary cluster. This should be set
    /// if and only if the cluster is of type SECONDARY.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SecondaryConfig {
        /// The name of the primary cluster name with the format:
        ///
        /// * projects/{project}/locations/{region}/clusters/{cluster_id}
        pub primary_cluster_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SecondaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primary_cluster_name][crate::model::cluster::SecondaryConfig::primary_cluster_name].
        pub fn set_primary_cluster_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.primary_cluster_name = v.into();
            self
        }
    }

    impl wkt::message::Message for SecondaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.SecondaryConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SecondaryConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __primary_cluster_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SecondaryConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "primaryClusterName" => Ok(__FieldTag::__primary_cluster_name),
                                "primary_cluster_name" => Ok(__FieldTag::__primary_cluster_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SecondaryConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SecondaryConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__primary_cluster_name => {
                                if !fields.insert(__FieldTag::__primary_cluster_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for primary_cluster_name",
                                    ));
                                }
                                result.primary_cluster_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SecondaryConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.primary_cluster_name.is_empty() {
                state.serialize_entry("primaryClusterName", &self.primary_cluster_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for the primary cluster. It has the list of clusters that are
    /// replicating from this cluster. This should be set if and only if the
    /// cluster is of type PRIMARY.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PrimaryConfig {
        /// Output only. Names of the clusters that are replicating from this
        /// cluster.
        pub secondary_cluster_names: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrimaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [secondary_cluster_names][crate::model::cluster::PrimaryConfig::secondary_cluster_names].
        pub fn set_secondary_cluster_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.secondary_cluster_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PrimaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.PrimaryConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PrimaryConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __secondary_cluster_names,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PrimaryConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "secondaryClusterNames" => {
                                    Ok(__FieldTag::__secondary_cluster_names)
                                }
                                "secondary_cluster_names" => {
                                    Ok(__FieldTag::__secondary_cluster_names)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PrimaryConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PrimaryConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__secondary_cluster_names => {
                                if !fields.insert(__FieldTag::__secondary_cluster_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secondary_cluster_names",
                                    ));
                                }
                                result.secondary_cluster_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PrimaryConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.secondary_cluster_names.is_empty() {
                state.serialize_entry("secondaryClusterNames", &self.secondary_cluster_names)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// PscConfig contains PSC related configuration at a cluster level.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscConfig {
        /// Optional. Create an instance that allows connections from Private Service
        /// Connect endpoints to the instance.
        pub psc_enabled: bool,

        /// Output only. The project number that needs to be allowlisted on the
        /// network attachment to enable outbound connectivity.
        pub service_owned_project_number: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [psc_enabled][crate::model::cluster::PscConfig::psc_enabled].
        pub fn set_psc_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.psc_enabled = v.into();
            self
        }

        /// Sets the value of [service_owned_project_number][crate::model::cluster::PscConfig::service_owned_project_number].
        pub fn set_service_owned_project_number<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_owned_project_number = v.into();
            self
        }
    }

    impl wkt::message::Message for PscConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.PscConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PscConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __psc_enabled,
                __service_owned_project_number,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PscConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pscEnabled" => Ok(__FieldTag::__psc_enabled),
                                "psc_enabled" => Ok(__FieldTag::__psc_enabled),
                                "serviceOwnedProjectNumber" => {
                                    Ok(__FieldTag::__service_owned_project_number)
                                }
                                "service_owned_project_number" => {
                                    Ok(__FieldTag::__service_owned_project_number)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PscConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PscConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__psc_enabled => {
                                if !fields.insert(__FieldTag::__psc_enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for psc_enabled",
                                    ));
                                }
                                result.psc_enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_owned_project_number => {
                                if !fields.insert(__FieldTag::__service_owned_project_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_owned_project_number",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.service_owned_project_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PscConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.psc_enabled) {
                state.serialize_entry("pscEnabled", &self.psc_enabled)?;
            }
            if !wkt::internal::is_default(&self.service_owned_project_number) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "serviceOwnedProjectNumber",
                    &__With(&self.service_owned_project_number),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Contains information and all metadata related to TRIAL clusters.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TrialMetadata {
        /// start time of the trial cluster.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// End time of the trial cluster.
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Upgrade time of trial cluster to Standard cluster.
        pub upgrade_time: std::option::Option<wkt::Timestamp>,

        /// grace end time of the cluster.
        pub grace_end_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TrialMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::cluster::TrialMetadata::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::cluster::TrialMetadata::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::cluster::TrialMetadata::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::cluster::TrialMetadata::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [upgrade_time][crate::model::cluster::TrialMetadata::upgrade_time].
        pub fn set_upgrade_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.upgrade_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [upgrade_time][crate::model::cluster::TrialMetadata::upgrade_time].
        pub fn set_or_clear_upgrade_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.upgrade_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [grace_end_time][crate::model::cluster::TrialMetadata::grace_end_time].
        pub fn set_grace_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.grace_end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [grace_end_time][crate::model::cluster::TrialMetadata::grace_end_time].
        pub fn set_or_clear_grace_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.grace_end_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TrialMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Cluster.TrialMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TrialMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_time,
                __end_time,
                __upgrade_time,
                __grace_end_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TrialMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "endTime" => Ok(__FieldTag::__end_time),
                                "end_time" => Ok(__FieldTag::__end_time),
                                "upgradeTime" => Ok(__FieldTag::__upgrade_time),
                                "upgrade_time" => Ok(__FieldTag::__upgrade_time),
                                "graceEndTime" => Ok(__FieldTag::__grace_end_time),
                                "grace_end_time" => Ok(__FieldTag::__grace_end_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TrialMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TrialMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__end_time => {
                                if !fields.insert(__FieldTag::__end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_time",
                                    ));
                                }
                                result.end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__upgrade_time => {
                                if !fields.insert(__FieldTag::__upgrade_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for upgrade_time",
                                    ));
                                }
                                result.upgrade_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__grace_end_time => {
                                if !fields.insert(__FieldTag::__grace_end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for grace_end_time",
                                    ));
                                }
                                result.grace_end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TrialMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if self.end_time.is_some() {
                state.serialize_entry("endTime", &self.end_time)?;
            }
            if self.upgrade_time.is_some() {
                state.serialize_entry("upgradeTime", &self.upgrade_time)?;
            }
            if self.grace_end_time.is_some() {
                state.serialize_entry("graceEndTime", &self.grace_end_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Cluster State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the cluster is unknown.
        Unspecified,
        /// The cluster is active and running.
        Ready,
        /// The cluster is stopped. All instances in the cluster are stopped.
        /// Customers can start a stopped cluster at any point and all their
        /// instances will come back to life with same names and IP resources. In
        /// this state, customer pays for storage.
        /// Associated backups could also be present in a stopped cluster.
        Stopped,
        /// The cluster is empty and has no associated resources.
        /// All instances, associated storage and backups have been deleted.
        Empty,
        /// The cluster is being created.
        Creating,
        /// The cluster is being deleted.
        Deleting,
        /// The creation of the cluster failed.
        Failed,
        /// The cluster is bootstrapping with data from some other source.
        /// Direct mutations to the cluster (e.g. adding read pool) are not allowed.
        Bootstrapping,
        /// The cluster is under maintenance. AlloyDB regularly performs maintenance
        /// and upgrades on customer clusters. Updates on the cluster are
        /// not allowed while the cluster is in this state.
        Maintenance,
        /// The cluster is being promoted.
        Promoting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Stopped => std::option::Option::Some(2),
                Self::Empty => std::option::Option::Some(3),
                Self::Creating => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Bootstrapping => std::option::Option::Some(7),
                Self::Maintenance => std::option::Option::Some(8),
                Self::Promoting => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Empty => std::option::Option::Some("EMPTY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Bootstrapping => std::option::Option::Some("BOOTSTRAPPING"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Promoting => std::option::Option::Some("PROMOTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Stopped,
                3 => Self::Empty,
                4 => Self::Creating,
                5 => Self::Deleting,
                6 => Self::Failed,
                7 => Self::Bootstrapping,
                8 => Self::Maintenance,
                9 => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "STOPPED" => Self::Stopped,
                "EMPTY" => Self::Empty,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "BOOTSTRAPPING" => Self::Bootstrapping,
                "MAINTENANCE" => Self::Maintenance,
                "PROMOTING" => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Stopped => serializer.serialize_i32(2),
                Self::Empty => serializer.serialize_i32(3),
                Self::Creating => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Bootstrapping => serializer.serialize_i32(7),
                Self::Maintenance => serializer.serialize_i32(8),
                Self::Promoting => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.Cluster.State",
            ))
        }
    }

    /// Type of Cluster
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterType {
        /// The type of the cluster is unknown.
        Unspecified,
        /// Primary cluster that support read and write operations.
        Primary,
        /// Secondary cluster that is replicating from another region.
        /// This only supports read.
        Secondary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClusterType::value] or
        /// [ClusterType::name].
        UnknownValue(cluster_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClusterType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::Secondary => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_TYPE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Secondary => std::option::Option::Some("SECONDARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClusterType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClusterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClusterType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::Secondary,
                _ => Self::UnknownValue(cluster_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClusterType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "SECONDARY" => Self::Secondary,
                _ => Self::UnknownValue(cluster_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClusterType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::Secondary => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClusterType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterType>::new(
                ".google.cloud.alloydb.v1.Cluster.ClusterType",
            ))
        }
    }

    /// In case of an imported cluster, this field contains information about the
    /// source this cluster was imported from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Output only. Cluster created from backup.
        BackupSource(std::boxed::Box<crate::model::BackupSource>),
        /// Output only. Cluster created via DMS migration.
        MigrationSource(std::boxed::Box<crate::model::MigrationSource>),
        /// Output only. Cluster created from CloudSQL snapshot.
        CloudsqlBackupRunSource(std::boxed::Box<crate::model::CloudSQLBackupRunSource>),
    }
}

/// An Instance is a computing unit that an end customer can connect to.
/// It's the main unit of computing resources in AlloyDB.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The name of the instance resource with the format:
    ///
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}/instances/{instance_id}
    ///   where the cluster and instance ID segments should satisfy the regex
    ///   expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
    ///   lowercase letters, numbers, and dashes, starting with a letter, and ending
    ///   with a letter or number. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the instance resource name is the name of the parent
    ///   resource:
    /// * projects/{project}/locations/{region}/clusters/{cluster_id}
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Instance.
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    pub uid: std::string::String,

    /// Output only. Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current serving state of the instance.
    pub state: crate::model::instance::State,

    /// Required. The type of the instance. Specified at creation time.
    pub instance_type: crate::model::instance::InstanceType,

    /// Configurations for the machines that host the underlying
    /// database engine.
    pub machine_config: std::option::Option<crate::model::instance::MachineConfig>,

    /// Availability type of an Instance.
    /// If empty, defaults to REGIONAL for primary instances.
    /// For read pools, availability_type is always UNSPECIFIED. Instances in the
    /// read pools are evenly distributed across available zones within the region
    /// (i.e. read pools with more than one node will have a node in at
    /// least two zones).
    pub availability_type: crate::model::instance::AvailabilityType,

    /// The Compute Engine zone that the instance should serve from, per
    /// <https://cloud.google.com/compute/docs/regions-zones>
    /// This can ONLY be specified for ZONAL instances.
    /// If present for a REGIONAL instance, an error will be thrown.
    /// If this is absent for a ZONAL instance, instance is created in a random
    /// zone with available capacity.
    pub gce_zone: std::string::String,

    /// Database flags. Set at the instance level.
    /// They are copied from the primary instance on secondary instance creation.
    /// Flags that have restrictions default to the value at primary
    /// instance on read instances during creation. Read instances can set new
    /// flags or override existing flags that are relevant for reads, for example,
    /// for enabling columnar cache on a read instance. Flags set on read instance
    /// might or might not be present on the primary instance.
    ///
    /// This is a list of "key": "value" pairs.
    /// "key": The name of the flag. These flags are passed at instance setup time,
    /// so include both server options and system variables for Postgres. Flags are
    /// specified with underscores, not hyphens.
    /// "value": The value of the flag. Booleans are set to **on** for true
    /// and **off** for false. This field must be omitted if the flag
    /// doesn't take a value.
    pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. This is set for the read-write VM of the PRIMARY instance
    /// only.
    pub writable_node: std::option::Option<crate::model::instance::Node>,

    /// Output only. List of available read-only VMs in this instance, including
    /// the standby for a PRIMARY instance.
    pub nodes: std::vec::Vec<crate::model::instance::Node>,

    /// Configuration for query insights.
    pub query_insights_config:
        std::option::Option<crate::model::instance::QueryInsightsInstanceConfig>,

    /// Configuration for observability.
    pub observability_config:
        std::option::Option<crate::model::instance::ObservabilityInstanceConfig>,

    /// Read pool instance configuration.
    /// This is required if the value of instanceType is READ_POOL.
    pub read_pool_config: std::option::Option<crate::model::instance::ReadPoolConfig>,

    /// Output only. The IP address for the Instance.
    /// This is the connection endpoint for an end-user application.
    pub ip_address: std::string::String,

    /// Output only. The public IP addresses for the Instance. This is available
    /// ONLY when enable_public_ip is set. This is the connection endpoint for an
    /// end-user application.
    pub public_ip_address: std::string::String,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>).
    /// Set to true if the current state of Instance does not match the user's
    /// intended state, and the service is actively updating the resource to
    /// reconcile them. This can happen due to user-triggered updates or
    /// system actions like failover or maintenance.
    pub reconciling: bool,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Client connection specific configurations
    pub client_connection_config:
        std::option::Option<crate::model::instance::ClientConnectionConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Optional. The configuration for Private Service Connect (PSC) for the
    /// instance.
    pub psc_instance_config: std::option::Option<crate::model::instance::PscInstanceConfig>,

    /// Optional. Instance-level network configuration.
    pub network_config: std::option::Option<crate::model::instance::InstanceNetworkConfig>,

    /// Output only. All outbound public IP addresses configured for the instance.
    pub outbound_public_ip_addresses: std::vec::Vec<std::string::String>,

    /// Optional. Specifies whether an instance needs to spin up. Once the instance
    /// is active, the activation policy can be updated to the `NEVER` to stop the
    /// instance. Likewise, the activation policy can be updated to `ALWAYS` to
    /// start the instance.
    /// There are restrictions around when an instance can/cannot be activated (for
    /// example, a read pool instance should be stopped before stopping primary
    /// etc.). Please refer to the API documentation for more details.
    pub activation_policy: crate::model::instance::ActivationPolicy,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Instance::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Instance::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Instance::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::Instance::instance_type].
    pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [machine_config][crate::model::Instance::machine_config].
    pub fn set_machine_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::MachineConfig>,
    {
        self.machine_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_config][crate::model::Instance::machine_config].
    pub fn set_or_clear_machine_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::MachineConfig>,
    {
        self.machine_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [availability_type][crate::model::Instance::availability_type].
    pub fn set_availability_type<
        T: std::convert::Into<crate::model::instance::AvailabilityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [gce_zone][crate::model::Instance::gce_zone].
    pub fn set_gce_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gce_zone = v.into();
        self
    }

    /// Sets the value of [database_flags][crate::model::Instance::database_flags].
    pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [writable_node][crate::model::Instance::writable_node].
    pub fn set_writable_node<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::Node>,
    {
        self.writable_node = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [writable_node][crate::model::Instance::writable_node].
    pub fn set_or_clear_writable_node<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::Node>,
    {
        self.writable_node = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nodes][crate::model::Instance::nodes].
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance::Node>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [query_insights_config][crate::model::Instance::query_insights_config].
    pub fn set_query_insights_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::QueryInsightsInstanceConfig>,
    {
        self.query_insights_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_insights_config][crate::model::Instance::query_insights_config].
    pub fn set_or_clear_query_insights_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::QueryInsightsInstanceConfig>,
    {
        self.query_insights_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [observability_config][crate::model::Instance::observability_config].
    pub fn set_observability_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::ObservabilityInstanceConfig>,
    {
        self.observability_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [observability_config][crate::model::Instance::observability_config].
    pub fn set_or_clear_observability_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::ObservabilityInstanceConfig>,
    {
        self.observability_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [read_pool_config][crate::model::Instance::read_pool_config].
    pub fn set_read_pool_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::ReadPoolConfig>,
    {
        self.read_pool_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_pool_config][crate::model::Instance::read_pool_config].
    pub fn set_or_clear_read_pool_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::ReadPoolConfig>,
    {
        self.read_pool_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_address][crate::model::Instance::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::Instance::public_ip_address].
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Instance::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Instance::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Instance::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [client_connection_config][crate::model::Instance::client_connection_config].
    pub fn set_client_connection_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::ClientConnectionConfig>,
    {
        self.client_connection_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_connection_config][crate::model::Instance::client_connection_config].
    pub fn set_or_clear_client_connection_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::ClientConnectionConfig>,
    {
        self.client_connection_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [psc_instance_config][crate::model::Instance::psc_instance_config].
    pub fn set_psc_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::PscInstanceConfig>,
    {
        self.psc_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_instance_config][crate::model::Instance::psc_instance_config].
    pub fn set_or_clear_psc_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::PscInstanceConfig>,
    {
        self.psc_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_config][crate::model::Instance::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::InstanceNetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::Instance::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::InstanceNetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [outbound_public_ip_addresses][crate::model::Instance::outbound_public_ip_addresses].
    pub fn set_outbound_public_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.outbound_public_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [activation_policy][crate::model::Instance::activation_policy].
    pub fn set_activation_policy<
        T: std::convert::Into<crate::model::instance::ActivationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.activation_policy = v.into();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Instance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __create_time,
            __update_time,
            __delete_time,
            __labels,
            __state,
            __instance_type,
            __machine_config,
            __availability_type,
            __gce_zone,
            __database_flags,
            __writable_node,
            __nodes,
            __query_insights_config,
            __observability_config,
            __read_pool_config,
            __ip_address,
            __public_ip_address,
            __reconciling,
            __etag,
            __annotations,
            __client_connection_config,
            __satisfies_pzs,
            __psc_instance_config,
            __network_config,
            __outbound_public_ip_addresses,
            __activation_policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "machineConfig" => Ok(__FieldTag::__machine_config),
                            "machine_config" => Ok(__FieldTag::__machine_config),
                            "availabilityType" => Ok(__FieldTag::__availability_type),
                            "availability_type" => Ok(__FieldTag::__availability_type),
                            "gceZone" => Ok(__FieldTag::__gce_zone),
                            "gce_zone" => Ok(__FieldTag::__gce_zone),
                            "databaseFlags" => Ok(__FieldTag::__database_flags),
                            "database_flags" => Ok(__FieldTag::__database_flags),
                            "writableNode" => Ok(__FieldTag::__writable_node),
                            "writable_node" => Ok(__FieldTag::__writable_node),
                            "nodes" => Ok(__FieldTag::__nodes),
                            "queryInsightsConfig" => Ok(__FieldTag::__query_insights_config),
                            "query_insights_config" => Ok(__FieldTag::__query_insights_config),
                            "observabilityConfig" => Ok(__FieldTag::__observability_config),
                            "observability_config" => Ok(__FieldTag::__observability_config),
                            "readPoolConfig" => Ok(__FieldTag::__read_pool_config),
                            "read_pool_config" => Ok(__FieldTag::__read_pool_config),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "publicIpAddress" => Ok(__FieldTag::__public_ip_address),
                            "public_ip_address" => Ok(__FieldTag::__public_ip_address),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "etag" => Ok(__FieldTag::__etag),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "clientConnectionConfig" => Ok(__FieldTag::__client_connection_config),
                            "client_connection_config" => {
                                Ok(__FieldTag::__client_connection_config)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "pscInstanceConfig" => Ok(__FieldTag::__psc_instance_config),
                            "psc_instance_config" => Ok(__FieldTag::__psc_instance_config),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "outboundPublicIpAddresses" => {
                                Ok(__FieldTag::__outbound_public_ip_addresses)
                            }
                            "outbound_public_ip_addresses" => {
                                Ok(__FieldTag::__outbound_public_ip_addresses)
                            }
                            "activationPolicy" => Ok(__FieldTag::__activation_policy),
                            "activation_policy" => Ok(__FieldTag::__activation_policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::instance::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map.next_value::<std::option::Option<crate::model::instance::InstanceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__machine_config => {
                            if !fields.insert(__FieldTag::__machine_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_config",
                                ));
                            }
                            result.machine_config = map.next_value::<std::option::Option<crate::model::instance::MachineConfig>>()?
                                ;
                        }
                        __FieldTag::__availability_type => {
                            if !fields.insert(__FieldTag::__availability_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_type",
                                ));
                            }
                            result.availability_type = map.next_value::<std::option::Option<crate::model::instance::AvailabilityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__gce_zone => {
                            if !fields.insert(__FieldTag::__gce_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gce_zone",
                                ));
                            }
                            result.gce_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_flags => {
                            if !fields.insert(__FieldTag::__database_flags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_flags",
                                ));
                            }
                            result.database_flags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__writable_node => {
                            if !fields.insert(__FieldTag::__writable_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for writable_node",
                                ));
                            }
                            result.writable_node = map
                                .next_value::<std::option::Option<crate::model::instance::Node>>(
                                )?;
                        }
                        __FieldTag::__nodes => {
                            if !fields.insert(__FieldTag::__nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodes",
                                ));
                            }
                            result.nodes =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::instance::Node>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_insights_config => {
                            if !fields.insert(__FieldTag::__query_insights_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_insights_config",
                                ));
                            }
                            result.query_insights_config = map.next_value::<std::option::Option<
                                crate::model::instance::QueryInsightsInstanceConfig,
                            >>()?;
                        }
                        __FieldTag::__observability_config => {
                            if !fields.insert(__FieldTag::__observability_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for observability_config",
                                ));
                            }
                            result.observability_config = map.next_value::<std::option::Option<
                                crate::model::instance::ObservabilityInstanceConfig,
                            >>()?;
                        }
                        __FieldTag::__read_pool_config => {
                            if !fields.insert(__FieldTag::__read_pool_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_pool_config",
                                ));
                            }
                            result.read_pool_config = map.next_value::<std::option::Option<crate::model::instance::ReadPoolConfig>>()?
                                ;
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ip_address => {
                            if !fields.insert(__FieldTag::__public_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ip_address",
                                ));
                            }
                            result.public_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_connection_config => {
                            if !fields.insert(__FieldTag::__client_connection_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_connection_config",
                                ));
                            }
                            result.client_connection_config = map
                                .next_value::<std::option::Option<
                                    crate::model::instance::ClientConnectionConfig,
                                >>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_instance_config => {
                            if !fields.insert(__FieldTag::__psc_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_instance_config",
                                ));
                            }
                            result.psc_instance_config = map.next_value::<std::option::Option<crate::model::instance::PscInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map.next_value::<std::option::Option<
                                crate::model::instance::InstanceNetworkConfig,
                            >>()?;
                        }
                        __FieldTag::__outbound_public_ip_addresses => {
                            if !fields.insert(__FieldTag::__outbound_public_ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for outbound_public_ip_addresses",
                                ));
                            }
                            result.outbound_public_ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__activation_policy => {
                            if !fields.insert(__FieldTag::__activation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_policy",
                                ));
                            }
                            result.activation_policy = map.next_value::<std::option::Option<crate::model::instance::ActivationPolicy>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.instance_type) {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if self.machine_config.is_some() {
            state.serialize_entry("machineConfig", &self.machine_config)?;
        }
        if !wkt::internal::is_default(&self.availability_type) {
            state.serialize_entry("availabilityType", &self.availability_type)?;
        }
        if !self.gce_zone.is_empty() {
            state.serialize_entry("gceZone", &self.gce_zone)?;
        }
        if !self.database_flags.is_empty() {
            state.serialize_entry("databaseFlags", &self.database_flags)?;
        }
        if self.writable_node.is_some() {
            state.serialize_entry("writableNode", &self.writable_node)?;
        }
        if !self.nodes.is_empty() {
            state.serialize_entry("nodes", &self.nodes)?;
        }
        if self.query_insights_config.is_some() {
            state.serialize_entry("queryInsightsConfig", &self.query_insights_config)?;
        }
        if self.observability_config.is_some() {
            state.serialize_entry("observabilityConfig", &self.observability_config)?;
        }
        if self.read_pool_config.is_some() {
            state.serialize_entry("readPoolConfig", &self.read_pool_config)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.public_ip_address.is_empty() {
            state.serialize_entry("publicIpAddress", &self.public_ip_address)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.client_connection_config.is_some() {
            state.serialize_entry("clientConnectionConfig", &self.client_connection_config)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.psc_instance_config.is_some() {
            state.serialize_entry("pscInstanceConfig", &self.psc_instance_config)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if !self.outbound_public_ip_addresses.is_empty() {
            state.serialize_entry(
                "outboundPublicIpAddresses",
                &self.outbound_public_ip_addresses,
            )?;
        }
        if !wkt::internal::is_default(&self.activation_policy) {
            state.serialize_entry("activationPolicy", &self.activation_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// MachineConfig describes the configuration of a machine.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MachineConfig {
        /// The number of CPU's in the VM instance.
        pub cpu_count: i32,

        /// Machine type of the VM instance. E.g. "n2-highmem-4",
        /// "n2-highmem-8", "c4a-highmem-4-lssd".
        /// cpu_count must match the number of vCPUs in the machine type.
        pub machine_type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MachineConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cpu_count][crate::model::instance::MachineConfig::cpu_count].
        pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.cpu_count = v.into();
            self
        }

        /// Sets the value of [machine_type][crate::model::instance::MachineConfig::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }
    }

    impl wkt::message::Message for MachineConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.MachineConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MachineConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cpu_count,
                __machine_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MachineConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cpuCount" => Ok(__FieldTag::__cpu_count),
                                "cpu_count" => Ok(__FieldTag::__cpu_count),
                                "machineType" => Ok(__FieldTag::__machine_type),
                                "machine_type" => Ok(__FieldTag::__machine_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MachineConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MachineConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cpu_count => {
                                if !fields.insert(__FieldTag::__cpu_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cpu_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.cpu_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__machine_type => {
                                if !fields.insert(__FieldTag::__machine_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_type",
                                    ));
                                }
                                result.machine_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MachineConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.cpu_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
            }
            if !self.machine_type.is_empty() {
                state.serialize_entry("machineType", &self.machine_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details of a single node in the instance.
    /// Nodes in an AlloyDB instance are ephemeral, they can change during
    /// update, failover, autohealing and resize operations.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Node {
        /// Output only. The Compute Engine zone of the VM e.g. "us-central1-b".
        pub zone_id: std::string::String,

        /// Output only. The identifier of the VM e.g.
        /// "test-read-0601-407e52be-ms3l".
        pub id: std::string::String,

        /// Output only. The private IP address of the VM e.g. "10.57.0.34".
        pub ip: std::string::String,

        /// Output only. Determined by state of the compute VM and postgres-service
        /// health. Compute VM state can have values listed in
        /// <https://cloud.google.com/compute/docs/instances/instance-life-cycle> and
        /// postgres-service health can have values: HEALTHY and UNHEALTHY.
        pub state: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Node {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [zone_id][crate::model::instance::Node::zone_id].
        pub fn set_zone_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone_id = v.into();
            self
        }

        /// Sets the value of [id][crate::model::instance::Node::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [ip][crate::model::instance::Node::ip].
        pub fn set_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip = v.into();
            self
        }

        /// Sets the value of [state][crate::model::instance::Node::state].
        pub fn set_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for Node {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.Node"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Node {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __zone_id,
                __id,
                __ip,
                __state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Node")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "zoneId" => Ok(__FieldTag::__zone_id),
                                "zone_id" => Ok(__FieldTag::__zone_id),
                                "id" => Ok(__FieldTag::__id),
                                "ip" => Ok(__FieldTag::__ip),
                                "state" => Ok(__FieldTag::__state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Node;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Node")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__zone_id => {
                                if !fields.insert(__FieldTag::__zone_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for zone_id",
                                    ));
                                }
                                result.zone_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ip => {
                                if !fields.insert(__FieldTag::__ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ip",
                                    ));
                                }
                                result.ip = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Node {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.zone_id.is_empty() {
                state.serialize_entry("zoneId", &self.zone_id)?;
            }
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.ip.is_empty() {
                state.serialize_entry("ip", &self.ip)?;
            }
            if !self.state.is_empty() {
                state.serialize_entry("state", &self.state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// QueryInsights Instance specific configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryInsightsInstanceConfig {
        /// Record application tags for an instance.
        /// This flag is turned "on" by default.
        pub record_application_tags: std::option::Option<bool>,

        /// Record client address for an instance. Client address is PII information.
        /// This flag is turned "on" by default.
        pub record_client_address: std::option::Option<bool>,

        /// Query string length. The default value is 1024.
        /// Any integer between 256 and 4500 is considered valid.
        pub query_string_length: u32,

        /// Number of query execution plans captured by Insights per minute
        /// for all queries combined. The default value is 5.
        /// Any integer between 0 and 20 is considered valid.
        pub query_plans_per_minute: std::option::Option<u32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryInsightsInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [record_application_tags][crate::model::instance::QueryInsightsInstanceConfig::record_application_tags].
        pub fn set_record_application_tags<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [record_application_tags][crate::model::instance::QueryInsightsInstanceConfig::record_application_tags].
        pub fn set_or_clear_record_application_tags<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = v.map(|x| x.into());
            self
        }

        /// Sets the value of [record_client_address][crate::model::instance::QueryInsightsInstanceConfig::record_client_address].
        pub fn set_record_client_address<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_client_address = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [record_client_address][crate::model::instance::QueryInsightsInstanceConfig::record_client_address].
        pub fn set_or_clear_record_client_address<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_client_address = v.map(|x| x.into());
            self
        }

        /// Sets the value of [query_string_length][crate::model::instance::QueryInsightsInstanceConfig::query_string_length].
        pub fn set_query_string_length<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
            self.query_string_length = v.into();
            self
        }

        /// Sets the value of [query_plans_per_minute][crate::model::instance::QueryInsightsInstanceConfig::query_plans_per_minute].
        pub fn set_query_plans_per_minute<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.query_plans_per_minute = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_plans_per_minute][crate::model::instance::QueryInsightsInstanceConfig::query_plans_per_minute].
        pub fn set_or_clear_query_plans_per_minute<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.query_plans_per_minute = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for QueryInsightsInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.QueryInsightsInstanceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueryInsightsInstanceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __record_application_tags,
                __record_client_address,
                __query_string_length,
                __query_plans_per_minute,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueryInsightsInstanceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "recordApplicationTags" => {
                                    Ok(__FieldTag::__record_application_tags)
                                }
                                "record_application_tags" => {
                                    Ok(__FieldTag::__record_application_tags)
                                }
                                "recordClientAddress" => Ok(__FieldTag::__record_client_address),
                                "record_client_address" => Ok(__FieldTag::__record_client_address),
                                "queryStringLength" => Ok(__FieldTag::__query_string_length),
                                "query_string_length" => Ok(__FieldTag::__query_string_length),
                                "queryPlansPerMinute" => Ok(__FieldTag::__query_plans_per_minute),
                                "query_plans_per_minute" => {
                                    Ok(__FieldTag::__query_plans_per_minute)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueryInsightsInstanceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueryInsightsInstanceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__record_application_tags => {
                                if !fields.insert(__FieldTag::__record_application_tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for record_application_tags",
                                    ));
                                }
                                result.record_application_tags =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__record_client_address => {
                                if !fields.insert(__FieldTag::__record_client_address) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for record_client_address",
                                    ));
                                }
                                result.record_client_address =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__query_string_length => {
                                if !fields.insert(__FieldTag::__query_string_length) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_string_length",
                                    ));
                                }
                                struct __With(std::option::Option<u32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.query_string_length =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__query_plans_per_minute => {
                                if !fields.insert(__FieldTag::__query_plans_per_minute) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_plans_per_minute",
                                    ));
                                }
                                struct __With(std::option::Option<u32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.query_plans_per_minute = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueryInsightsInstanceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.record_application_tags.is_some() {
                state.serialize_entry("recordApplicationTags", &self.record_application_tags)?;
            }
            if self.record_client_address.is_some() {
                state.serialize_entry("recordClientAddress", &self.record_client_address)?;
            }
            if !wkt::internal::is_default(&self.query_string_length) {
                struct __With<'a>(&'a u32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("queryStringLength", &__With(&self.query_string_length))?;
            }
            if self.query_plans_per_minute.is_some() {
                struct __With<'a>(&'a std::option::Option<u32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "queryPlansPerMinute",
                    &__With(&self.query_plans_per_minute),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Observability Instance specific configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ObservabilityInstanceConfig {
        /// Observability feature status for an instance.
        /// This flag is turned "off" by default.
        pub enabled: std::option::Option<bool>,

        /// Preserve comments in query string for an instance.
        /// This flag is turned "off" by default.
        pub preserve_comments: std::option::Option<bool>,

        /// Track wait events during query execution for an instance.
        /// This flag is turned "on" by default but tracking is enabled only after
        /// observability enabled flag is also turned on.
        pub track_wait_events: std::option::Option<bool>,

        /// Output only. Track wait event types during query execution for an
        /// instance. This flag is turned "on" by default but tracking is enabled
        /// only after observability enabled flag is also turned on. This is
        /// read-only flag and only modifiable by internal API.
        pub track_wait_event_types: std::option::Option<bool>,

        /// Query string length. The default value is 10k.
        pub max_query_string_length: std::option::Option<i32>,

        /// Record application tags for an instance.
        /// This flag is turned "off" by default.
        pub record_application_tags: std::option::Option<bool>,

        /// Number of query execution plans captured by Insights per minute
        /// for all queries combined. The default value is 200.
        /// Any integer between 0 to 200 is considered valid.
        pub query_plans_per_minute: std::option::Option<i32>,

        /// Track actively running queries on the instance.
        /// If not set, this flag is "off" by default.
        pub track_active_queries: std::option::Option<bool>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ObservabilityInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::instance::ObservabilityInstanceConfig::enabled].
        pub fn set_enabled<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enabled = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [enabled][crate::model::instance::ObservabilityInstanceConfig::enabled].
        pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enabled = v.map(|x| x.into());
            self
        }

        /// Sets the value of [preserve_comments][crate::model::instance::ObservabilityInstanceConfig::preserve_comments].
        pub fn set_preserve_comments<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.preserve_comments = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [preserve_comments][crate::model::instance::ObservabilityInstanceConfig::preserve_comments].
        pub fn set_or_clear_preserve_comments<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.preserve_comments = v.map(|x| x.into());
            self
        }

        /// Sets the value of [track_wait_events][crate::model::instance::ObservabilityInstanceConfig::track_wait_events].
        pub fn set_track_wait_events<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_events = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [track_wait_events][crate::model::instance::ObservabilityInstanceConfig::track_wait_events].
        pub fn set_or_clear_track_wait_events<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_events = v.map(|x| x.into());
            self
        }

        /// Sets the value of [track_wait_event_types][crate::model::instance::ObservabilityInstanceConfig::track_wait_event_types].
        pub fn set_track_wait_event_types<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_event_types = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [track_wait_event_types][crate::model::instance::ObservabilityInstanceConfig::track_wait_event_types].
        pub fn set_or_clear_track_wait_event_types<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_wait_event_types = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_query_string_length][crate::model::instance::ObservabilityInstanceConfig::max_query_string_length].
        pub fn set_max_query_string_length<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_query_string_length = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_query_string_length][crate::model::instance::ObservabilityInstanceConfig::max_query_string_length].
        pub fn set_or_clear_max_query_string_length<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_query_string_length = v.map(|x| x.into());
            self
        }

        /// Sets the value of [record_application_tags][crate::model::instance::ObservabilityInstanceConfig::record_application_tags].
        pub fn set_record_application_tags<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [record_application_tags][crate::model::instance::ObservabilityInstanceConfig::record_application_tags].
        pub fn set_or_clear_record_application_tags<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.record_application_tags = v.map(|x| x.into());
            self
        }

        /// Sets the value of [query_plans_per_minute][crate::model::instance::ObservabilityInstanceConfig::query_plans_per_minute].
        pub fn set_query_plans_per_minute<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.query_plans_per_minute = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_plans_per_minute][crate::model::instance::ObservabilityInstanceConfig::query_plans_per_minute].
        pub fn set_or_clear_query_plans_per_minute<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.query_plans_per_minute = v.map(|x| x.into());
            self
        }

        /// Sets the value of [track_active_queries][crate::model::instance::ObservabilityInstanceConfig::track_active_queries].
        pub fn set_track_active_queries<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_active_queries = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [track_active_queries][crate::model::instance::ObservabilityInstanceConfig::track_active_queries].
        pub fn set_or_clear_track_active_queries<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.track_active_queries = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ObservabilityInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ObservabilityInstanceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ObservabilityInstanceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __preserve_comments,
                __track_wait_events,
                __track_wait_event_types,
                __max_query_string_length,
                __record_application_tags,
                __query_plans_per_minute,
                __track_active_queries,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ObservabilityInstanceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "preserveComments" => Ok(__FieldTag::__preserve_comments),
                                "preserve_comments" => Ok(__FieldTag::__preserve_comments),
                                "trackWaitEvents" => Ok(__FieldTag::__track_wait_events),
                                "track_wait_events" => Ok(__FieldTag::__track_wait_events),
                                "trackWaitEventTypes" => Ok(__FieldTag::__track_wait_event_types),
                                "track_wait_event_types" => {
                                    Ok(__FieldTag::__track_wait_event_types)
                                }
                                "maxQueryStringLength" => Ok(__FieldTag::__max_query_string_length),
                                "max_query_string_length" => {
                                    Ok(__FieldTag::__max_query_string_length)
                                }
                                "recordApplicationTags" => {
                                    Ok(__FieldTag::__record_application_tags)
                                }
                                "record_application_tags" => {
                                    Ok(__FieldTag::__record_application_tags)
                                }
                                "queryPlansPerMinute" => Ok(__FieldTag::__query_plans_per_minute),
                                "query_plans_per_minute" => {
                                    Ok(__FieldTag::__query_plans_per_minute)
                                }
                                "trackActiveQueries" => Ok(__FieldTag::__track_active_queries),
                                "track_active_queries" => Ok(__FieldTag::__track_active_queries),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ObservabilityInstanceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ObservabilityInstanceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__preserve_comments => {
                                if !fields.insert(__FieldTag::__preserve_comments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for preserve_comments",
                                    ));
                                }
                                result.preserve_comments =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__track_wait_events => {
                                if !fields.insert(__FieldTag::__track_wait_events) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for track_wait_events",
                                    ));
                                }
                                result.track_wait_events =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__track_wait_event_types => {
                                if !fields.insert(__FieldTag::__track_wait_event_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for track_wait_event_types",
                                    ));
                                }
                                result.track_wait_event_types =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__max_query_string_length => {
                                if !fields.insert(__FieldTag::__max_query_string_length) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_query_string_length",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_query_string_length = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__record_application_tags => {
                                if !fields.insert(__FieldTag::__record_application_tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for record_application_tags",
                                    ));
                                }
                                result.record_application_tags =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__query_plans_per_minute => {
                                if !fields.insert(__FieldTag::__query_plans_per_minute) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_plans_per_minute",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.query_plans_per_minute = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__track_active_queries => {
                                if !fields.insert(__FieldTag::__track_active_queries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for track_active_queries",
                                    ));
                                }
                                result.track_active_queries =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ObservabilityInstanceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.enabled.is_some() {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if self.preserve_comments.is_some() {
                state.serialize_entry("preserveComments", &self.preserve_comments)?;
            }
            if self.track_wait_events.is_some() {
                state.serialize_entry("trackWaitEvents", &self.track_wait_events)?;
            }
            if self.track_wait_event_types.is_some() {
                state.serialize_entry("trackWaitEventTypes", &self.track_wait_event_types)?;
            }
            if self.max_query_string_length.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "maxQueryStringLength",
                    &__With(&self.max_query_string_length),
                )?;
            }
            if self.record_application_tags.is_some() {
                state.serialize_entry("recordApplicationTags", &self.record_application_tags)?;
            }
            if self.query_plans_per_minute.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "queryPlansPerMinute",
                    &__With(&self.query_plans_per_minute),
                )?;
            }
            if self.track_active_queries.is_some() {
                state.serialize_entry("trackActiveQueries", &self.track_active_queries)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for a read pool instance.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReadPoolConfig {
        /// Read capacity, i.e. number of nodes in a read pool instance.
        pub node_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReadPoolConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node_count][crate::model::instance::ReadPoolConfig::node_count].
        pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.node_count = v.into();
            self
        }
    }

    impl wkt::message::Message for ReadPoolConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ReadPoolConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReadPoolConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __node_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReadPoolConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "nodeCount" => Ok(__FieldTag::__node_count),
                                "node_count" => Ok(__FieldTag::__node_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReadPoolConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReadPoolConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__node_count => {
                                if !fields.insert(__FieldTag::__node_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.node_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReadPoolConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.node_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("nodeCount", &__With(&self.node_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Client connection configuration
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClientConnectionConfig {
        /// Optional. Configuration to enforce connectors only (ex: AuthProxy)
        /// connections to the database.
        pub require_connectors: bool,

        /// Optional. SSL configuration option for this instance.
        pub ssl_config: std::option::Option<crate::model::SslConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClientConnectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [require_connectors][crate::model::instance::ClientConnectionConfig::require_connectors].
        pub fn set_require_connectors<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.require_connectors = v.into();
            self
        }

        /// Sets the value of [ssl_config][crate::model::instance::ClientConnectionConfig::ssl_config].
        pub fn set_ssl_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::SslConfig>,
        {
            self.ssl_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ssl_config][crate::model::instance::ClientConnectionConfig::ssl_config].
        pub fn set_or_clear_ssl_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::SslConfig>,
        {
            self.ssl_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ClientConnectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.ClientConnectionConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClientConnectionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __require_connectors,
                __ssl_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClientConnectionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "requireConnectors" => Ok(__FieldTag::__require_connectors),
                                "require_connectors" => Ok(__FieldTag::__require_connectors),
                                "sslConfig" => Ok(__FieldTag::__ssl_config),
                                "ssl_config" => Ok(__FieldTag::__ssl_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClientConnectionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClientConnectionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__require_connectors => {
                                if !fields.insert(__FieldTag::__require_connectors) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for require_connectors",
                                    ));
                                }
                                result.require_connectors = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ssl_config => {
                                if !fields.insert(__FieldTag::__ssl_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ssl_config",
                                    ));
                                }
                                result.ssl_config = map
                                    .next_value::<std::option::Option<crate::model::SslConfig>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClientConnectionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.require_connectors) {
                state.serialize_entry("requireConnectors", &self.require_connectors)?;
            }
            if self.ssl_config.is_some() {
                state.serialize_entry("sslConfig", &self.ssl_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for setting up a PSC interface to enable outbound
    /// connectivity.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscInterfaceConfig {
        /// The network attachment resource created in the consumer network to which
        /// the PSC interface will be linked. This is of the format:
        /// "projects/${CONSUMER_PROJECT}/regions/${REGION}/networkAttachments/${NETWORK_ATTACHMENT_NAME}".
        /// The network attachment must be in the same region as the instance.
        pub network_attachment_resource: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscInterfaceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [network_attachment_resource][crate::model::instance::PscInterfaceConfig::network_attachment_resource].
        pub fn set_network_attachment_resource<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_attachment_resource = v.into();
            self
        }
    }

    impl wkt::message::Message for PscInterfaceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.PscInterfaceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PscInterfaceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __network_attachment_resource,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PscInterfaceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "networkAttachmentResource" => {
                                    Ok(__FieldTag::__network_attachment_resource)
                                }
                                "network_attachment_resource" => {
                                    Ok(__FieldTag::__network_attachment_resource)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PscInterfaceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PscInterfaceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__network_attachment_resource => {
                                if !fields.insert(__FieldTag::__network_attachment_resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network_attachment_resource",
                                    ));
                                }
                                result.network_attachment_resource = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PscInterfaceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.network_attachment_resource.is_empty() {
                state.serialize_entry(
                    "networkAttachmentResource",
                    &self.network_attachment_resource,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for setting up PSC service automation. Consumer projects in
    /// the configs will be allowlisted automatically for the instance.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscAutoConnectionConfig {
        /// The consumer project to which the PSC service automation endpoint will
        /// be created.
        pub consumer_project: std::string::String,

        /// The consumer network for the PSC service automation, example:
        /// "projects/vpc-host-project/global/networks/default".
        /// The consumer network might be hosted a different project than the
        /// consumer project.
        pub consumer_network: std::string::String,

        /// Output only. The IP address of the PSC service automation endpoint.
        pub ip_address: std::string::String,

        /// Output only. The status of the PSC service automation connection.
        /// Possible values:
        /// "STATE_UNSPECIFIED" - An invalid state as the default case.
        /// "ACTIVE" - The connection has been created successfully.
        /// "FAILED" - The connection is not functional since some resources on the
        /// connection fail to be created.
        /// "CREATING" - The connection is being created.
        /// "DELETING" - The connection is being deleted.
        /// "CREATE_REPAIRING" - The connection is being repaired to complete
        /// creation.
        /// "DELETE_REPAIRING" - The connection is being repaired to complete
        /// deletion.
        pub status: std::string::String,

        /// Output only. The status of the service connection policy.
        /// Possible values:
        /// "STATE_UNSPECIFIED" - Default state, when Connection Map is created
        /// initially.
        /// "VALID" - Set when policy and map configuration is valid, and their
        /// matching can lead to allowing creation of PSC Connections subject to
        /// other constraints like connections limit.
        /// "CONNECTION_POLICY_MISSING" - No Service Connection Policy found for
        /// this network and Service Class
        /// "POLICY_LIMIT_REACHED" - Service Connection Policy limit reached for
        /// this network and Service Class
        /// "CONSUMER_INSTANCE_PROJECT_NOT_ALLOWLISTED" - The consumer instance
        /// project is not in AllowedGoogleProducersResourceHierarchyLevels of the
        /// matching ServiceConnectionPolicy.
        pub consumer_network_status: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscAutoConnectionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [consumer_project][crate::model::instance::PscAutoConnectionConfig::consumer_project].
        pub fn set_consumer_project<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_project = v.into();
            self
        }

        /// Sets the value of [consumer_network][crate::model::instance::PscAutoConnectionConfig::consumer_network].
        pub fn set_consumer_network<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_network = v.into();
            self
        }

        /// Sets the value of [ip_address][crate::model::instance::PscAutoConnectionConfig::ip_address].
        pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.ip_address = v.into();
            self
        }

        /// Sets the value of [status][crate::model::instance::PscAutoConnectionConfig::status].
        pub fn set_status<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [consumer_network_status][crate::model::instance::PscAutoConnectionConfig::consumer_network_status].
        pub fn set_consumer_network_status<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_network_status = v.into();
            self
        }
    }

    impl wkt::message::Message for PscAutoConnectionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.PscAutoConnectionConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PscAutoConnectionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __consumer_project,
                __consumer_network,
                __ip_address,
                __status,
                __consumer_network_status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PscAutoConnectionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "consumerProject" => Ok(__FieldTag::__consumer_project),
                                "consumer_project" => Ok(__FieldTag::__consumer_project),
                                "consumerNetwork" => Ok(__FieldTag::__consumer_network),
                                "consumer_network" => Ok(__FieldTag::__consumer_network),
                                "ipAddress" => Ok(__FieldTag::__ip_address),
                                "ip_address" => Ok(__FieldTag::__ip_address),
                                "status" => Ok(__FieldTag::__status),
                                "consumerNetworkStatus" => {
                                    Ok(__FieldTag::__consumer_network_status)
                                }
                                "consumer_network_status" => {
                                    Ok(__FieldTag::__consumer_network_status)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PscAutoConnectionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PscAutoConnectionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__consumer_project => {
                                if !fields.insert(__FieldTag::__consumer_project) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consumer_project",
                                    ));
                                }
                                result.consumer_project = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__consumer_network => {
                                if !fields.insert(__FieldTag::__consumer_network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consumer_network",
                                    ));
                                }
                                result.consumer_network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ip_address => {
                                if !fields.insert(__FieldTag::__ip_address) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ip_address",
                                    ));
                                }
                                result.ip_address = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__consumer_network_status => {
                                if !fields.insert(__FieldTag::__consumer_network_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consumer_network_status",
                                    ));
                                }
                                result.consumer_network_status = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PscAutoConnectionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.consumer_project.is_empty() {
                state.serialize_entry("consumerProject", &self.consumer_project)?;
            }
            if !self.consumer_network.is_empty() {
                state.serialize_entry("consumerNetwork", &self.consumer_network)?;
            }
            if !self.ip_address.is_empty() {
                state.serialize_entry("ipAddress", &self.ip_address)?;
            }
            if !self.status.is_empty() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self.consumer_network_status.is_empty() {
                state.serialize_entry("consumerNetworkStatus", &self.consumer_network_status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// PscInstanceConfig contains PSC related configuration at an
    /// instance level.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PscInstanceConfig {
        /// Output only. The service attachment created when Private
        /// Service Connect (PSC) is enabled for the instance.
        /// The name of the resource will be in the format of
        /// `projects/<alloydb-tenant-project-number>/regions/<region-name>/serviceAttachments/<service-attachment-name>`
        pub service_attachment_link: std::string::String,

        /// Optional. List of consumer projects that are allowed to create
        /// PSC endpoints to service-attachments to this instance.
        pub allowed_consumer_projects: std::vec::Vec<std::string::String>,

        /// Output only. The DNS name of the instance for PSC connectivity.
        /// Name convention: \<uid\>.\<uid\>.\<region\>.alloydb-psc.goog
        pub psc_dns_name: std::string::String,

        /// Optional. Configurations for setting up PSC interfaces attached to the
        /// instance which are used for outbound connectivity. Only primary instances
        /// can have PSC interface attached. Currently we only support 0 or 1 PSC
        /// interface.
        pub psc_interface_configs: std::vec::Vec<crate::model::instance::PscInterfaceConfig>,

        /// Optional. Configurations for setting up PSC service automation.
        pub psc_auto_connections: std::vec::Vec<crate::model::instance::PscAutoConnectionConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PscInstanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_attachment_link][crate::model::instance::PscInstanceConfig::service_attachment_link].
        pub fn set_service_attachment_link<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_attachment_link = v.into();
            self
        }

        /// Sets the value of [allowed_consumer_projects][crate::model::instance::PscInstanceConfig::allowed_consumer_projects].
        pub fn set_allowed_consumer_projects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_consumer_projects = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [psc_dns_name][crate::model::instance::PscInstanceConfig::psc_dns_name].
        pub fn set_psc_dns_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.psc_dns_name = v.into();
            self
        }

        /// Sets the value of [psc_interface_configs][crate::model::instance::PscInstanceConfig::psc_interface_configs].
        pub fn set_psc_interface_configs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance::PscInterfaceConfig>,
        {
            use std::iter::Iterator;
            self.psc_interface_configs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [psc_auto_connections][crate::model::instance::PscInstanceConfig::psc_auto_connections].
        pub fn set_psc_auto_connections<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance::PscAutoConnectionConfig>,
        {
            use std::iter::Iterator;
            self.psc_auto_connections = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PscInstanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.PscInstanceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PscInstanceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service_attachment_link,
                __allowed_consumer_projects,
                __psc_dns_name,
                __psc_interface_configs,
                __psc_auto_connections,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PscInstanceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serviceAttachmentLink" => {
                                    Ok(__FieldTag::__service_attachment_link)
                                }
                                "service_attachment_link" => {
                                    Ok(__FieldTag::__service_attachment_link)
                                }
                                "allowedConsumerProjects" => {
                                    Ok(__FieldTag::__allowed_consumer_projects)
                                }
                                "allowed_consumer_projects" => {
                                    Ok(__FieldTag::__allowed_consumer_projects)
                                }
                                "pscDnsName" => Ok(__FieldTag::__psc_dns_name),
                                "psc_dns_name" => Ok(__FieldTag::__psc_dns_name),
                                "pscInterfaceConfigs" => Ok(__FieldTag::__psc_interface_configs),
                                "psc_interface_configs" => Ok(__FieldTag::__psc_interface_configs),
                                "pscAutoConnections" => Ok(__FieldTag::__psc_auto_connections),
                                "psc_auto_connections" => Ok(__FieldTag::__psc_auto_connections),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PscInstanceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PscInstanceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service_attachment_link => {
                                if !fields.insert(__FieldTag::__service_attachment_link) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_attachment_link",
                                    ));
                                }
                                result.service_attachment_link = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allowed_consumer_projects => {
                                if !fields.insert(__FieldTag::__allowed_consumer_projects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_consumer_projects",
                                    ));
                                }
                                result.allowed_consumer_projects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__psc_dns_name => {
                                if !fields.insert(__FieldTag::__psc_dns_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for psc_dns_name",
                                    ));
                                }
                                result.psc_dns_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__psc_interface_configs => {
                                if !fields.insert(__FieldTag::__psc_interface_configs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for psc_interface_configs",
                                    ));
                                }
                                result.psc_interface_configs = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::instance::PscInterfaceConfig>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__psc_auto_connections => {
                                if !fields.insert(__FieldTag::__psc_auto_connections) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for psc_auto_connections",
                                    ));
                                }
                                result.psc_auto_connections = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::instance::PscAutoConnectionConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PscInstanceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service_attachment_link.is_empty() {
                state.serialize_entry("serviceAttachmentLink", &self.service_attachment_link)?;
            }
            if !self.allowed_consumer_projects.is_empty() {
                state
                    .serialize_entry("allowedConsumerProjects", &self.allowed_consumer_projects)?;
            }
            if !self.psc_dns_name.is_empty() {
                state.serialize_entry("pscDnsName", &self.psc_dns_name)?;
            }
            if !self.psc_interface_configs.is_empty() {
                state.serialize_entry("pscInterfaceConfigs", &self.psc_interface_configs)?;
            }
            if !self.psc_auto_connections.is_empty() {
                state.serialize_entry("pscAutoConnections", &self.psc_auto_connections)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Metadata related to instance-level network configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceNetworkConfig {
        /// Optional. A list of external network authorized to access this instance.
        pub authorized_external_networks:
            std::vec::Vec<crate::model::instance::instance_network_config::AuthorizedNetwork>,

        /// Optional. Enabling public ip for the instance.
        pub enable_public_ip: bool,

        /// Optional. Enabling an outbound public IP address to support a database
        /// server sending requests out into the internet.
        pub enable_outbound_public_ip: bool,

        /// Output only. The resource link for the VPC network in which instance
        /// resources are created and from which they are accessible via Private IP.
        /// This will be the same value as the parent cluster's network. It is
        /// specified in the form: //
        /// `projects/{project_number}/global/networks/{network_id}`.
        pub network: std::string::String,

        /// Optional. Name of the allocated IP range for the private IP AlloyDB
        /// instance, for example: "google-managed-services-default". If set, the
        /// instance IPs will be created from this allocated range and will override
        /// the IP range used by the parent cluster. The range name must comply with
        /// [RFC 1035](http://datatracker.ietf.org/doc/html/rfc1035). Specifically,
        /// the name must be 1-63 characters long and match the regular expression
        /// [a-z]([-a-z0-9]*[a-z0-9])?.
        pub allocated_ip_range_override: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceNetworkConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [authorized_external_networks][crate::model::instance::InstanceNetworkConfig::authorized_external_networks].
        pub fn set_authorized_external_networks<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::instance::instance_network_config::AuthorizedNetwork,
                >,
        {
            use std::iter::Iterator;
            self.authorized_external_networks = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [enable_public_ip][crate::model::instance::InstanceNetworkConfig::enable_public_ip].
        pub fn set_enable_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_public_ip = v.into();
            self
        }

        /// Sets the value of [enable_outbound_public_ip][crate::model::instance::InstanceNetworkConfig::enable_outbound_public_ip].
        pub fn set_enable_outbound_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_outbound_public_ip = v.into();
            self
        }

        /// Sets the value of [network][crate::model::instance::InstanceNetworkConfig::network].
        pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.network = v.into();
            self
        }

        /// Sets the value of [allocated_ip_range_override][crate::model::instance::InstanceNetworkConfig::allocated_ip_range_override].
        pub fn set_allocated_ip_range_override<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allocated_ip_range_override = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceNetworkConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Instance.InstanceNetworkConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InstanceNetworkConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __authorized_external_networks,
                __enable_public_ip,
                __enable_outbound_public_ip,
                __network,
                __allocated_ip_range_override,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InstanceNetworkConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "authorizedExternalNetworks" => {
                                    Ok(__FieldTag::__authorized_external_networks)
                                }
                                "authorized_external_networks" => {
                                    Ok(__FieldTag::__authorized_external_networks)
                                }
                                "enablePublicIp" => Ok(__FieldTag::__enable_public_ip),
                                "enable_public_ip" => Ok(__FieldTag::__enable_public_ip),
                                "enableOutboundPublicIp" => {
                                    Ok(__FieldTag::__enable_outbound_public_ip)
                                }
                                "enable_outbound_public_ip" => {
                                    Ok(__FieldTag::__enable_outbound_public_ip)
                                }
                                "network" => Ok(__FieldTag::__network),
                                "allocatedIpRangeOverride" => {
                                    Ok(__FieldTag::__allocated_ip_range_override)
                                }
                                "allocated_ip_range_override" => {
                                    Ok(__FieldTag::__allocated_ip_range_override)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InstanceNetworkConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InstanceNetworkConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__authorized_external_networks => {
                                if !fields.insert(__FieldTag::__authorized_external_networks) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for authorized_external_networks",
                                    ));
                                }
                                result.authorized_external_networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::instance::instance_network_config::AuthorizedNetwork>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__enable_public_ip => {
                                if !fields.insert(__FieldTag::__enable_public_ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_public_ip",
                                    ));
                                }
                                result.enable_public_ip = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_outbound_public_ip => {
                                if !fields.insert(__FieldTag::__enable_outbound_public_ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_outbound_public_ip",
                                    ));
                                }
                                result.enable_outbound_public_ip = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__network => {
                                if !fields.insert(__FieldTag::__network) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for network",
                                    ));
                                }
                                result.network = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allocated_ip_range_override => {
                                if !fields.insert(__FieldTag::__allocated_ip_range_override) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allocated_ip_range_override",
                                    ));
                                }
                                result.allocated_ip_range_override = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InstanceNetworkConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.authorized_external_networks.is_empty() {
                state.serialize_entry(
                    "authorizedExternalNetworks",
                    &self.authorized_external_networks,
                )?;
            }
            if !wkt::internal::is_default(&self.enable_public_ip) {
                state.serialize_entry("enablePublicIp", &self.enable_public_ip)?;
            }
            if !wkt::internal::is_default(&self.enable_outbound_public_ip) {
                state.serialize_entry("enableOutboundPublicIp", &self.enable_outbound_public_ip)?;
            }
            if !self.network.is_empty() {
                state.serialize_entry("network", &self.network)?;
            }
            if !self.allocated_ip_range_override.is_empty() {
                state.serialize_entry(
                    "allocatedIpRangeOverride",
                    &self.allocated_ip_range_override,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [InstanceNetworkConfig].
    pub mod instance_network_config {
        #[allow(unused_imports)]
        use super::*;

        /// AuthorizedNetwork contains metadata for an authorized network.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AuthorizedNetwork {
            /// CIDR range for one authorzied network of the instance.
            pub cidr_range: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AuthorizedNetwork {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cidr_range][crate::model::instance::instance_network_config::AuthorizedNetwork::cidr_range].
            pub fn set_cidr_range<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.cidr_range = v.into();
                self
            }
        }

        impl wkt::message::Message for AuthorizedNetwork {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.alloydb.v1.Instance.InstanceNetworkConfig.AuthorizedNetwork"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AuthorizedNetwork {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __cidr_range,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AuthorizedNetwork")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "cidrRange" => Ok(__FieldTag::__cidr_range),
                                    "cidr_range" => Ok(__FieldTag::__cidr_range),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AuthorizedNetwork;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AuthorizedNetwork")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__cidr_range => {
                                    if !fields.insert(__FieldTag::__cidr_range) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for cidr_range",
                                            ),
                                        );
                                    }
                                    result.cidr_range = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AuthorizedNetwork {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.cidr_range.is_empty() {
                    state.serialize_entry("cidrRange", &self.cidr_range)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Instance State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the instance is unknown.
        Unspecified,
        /// The instance is active and running.
        Ready,
        /// The instance is stopped. Instance name and IP resources are preserved.
        Stopped,
        /// The instance is being created.
        Creating,
        /// The instance is being deleted.
        Deleting,
        /// The instance is down for maintenance.
        Maintenance,
        /// The creation of the instance failed or a fatal error occurred during
        /// an operation on the instance.
        /// Note: Instances in this state would tried to be auto-repaired. And
        /// Customers should be able to restart, update or delete these instances.
        Failed,
        /// Index 7 is used in the producer apis for ROLLED_BACK state. Keeping that
        /// index unused in case that state also needs to exposed via consumer apis
        /// in future.
        /// The instance has been configured to sync data from some other source.
        Bootstrapping,
        /// The instance is being promoted.
        Promoting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Stopped => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Maintenance => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Bootstrapping => std::option::Option::Some(8),
                Self::Promoting => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Bootstrapping => std::option::Option::Some("BOOTSTRAPPING"),
                Self::Promoting => std::option::Option::Some("PROMOTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Stopped,
                3 => Self::Creating,
                4 => Self::Deleting,
                5 => Self::Maintenance,
                6 => Self::Failed,
                8 => Self::Bootstrapping,
                9 => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "STOPPED" => Self::Stopped,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "MAINTENANCE" => Self::Maintenance,
                "FAILED" => Self::Failed,
                "BOOTSTRAPPING" => Self::Bootstrapping,
                "PROMOTING" => Self::Promoting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Stopped => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Maintenance => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Bootstrapping => serializer.serialize_i32(8),
                Self::Promoting => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.Instance.State",
            ))
        }
    }

    /// Type of an Instance
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceType {
        /// The type of the instance is unknown.
        Unspecified,
        /// PRIMARY instances support read and write operations.
        Primary,
        /// READ POOL instances support read operations only. Each read pool instance
        /// consists of one or more homogeneous nodes.
        ///
        /// * Read pool of size 1 can only have zonal availability.
        /// * Read pools with node count of 2 or more can have regional
        ///   availability (nodes are present in 2 or more zones in a region).
        ReadPool,
        /// SECONDARY instances support read operations only. SECONDARY instance
        /// is a cross-region read replica
        Secondary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceType::value] or
        /// [InstanceType::name].
        UnknownValue(instance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl InstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::ReadPool => std::option::Option::Some(2),
                Self::Secondary => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INSTANCE_TYPE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::ReadPool => std::option::Option::Some("READ_POOL"),
                Self::Secondary => std::option::Option::Some("SECONDARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for InstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for InstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for InstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::ReadPool,
                3 => Self::Secondary,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for InstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "READ_POOL" => Self::ReadPool,
                "SECONDARY" => Self::Secondary,
                _ => Self::UnknownValue(instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for InstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::ReadPool => serializer.serialize_i32(2),
                Self::Secondary => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for InstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceType>::new(
                ".google.cloud.alloydb.v1.Instance.InstanceType",
            ))
        }
    }

    /// The Availability type of an instance. Potential values:
    ///
    /// - ZONAL: The instance serves data from only one zone. Outages in that
    ///   zone affect instance availability.
    /// - REGIONAL: The instance can serve data from more than one zone in a
    ///   region (it is highly available).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AvailabilityType {
        /// This is an unknown Availability type.
        Unspecified,
        /// Zonal available instance.
        Zonal,
        /// Regional (or Highly) available instance.
        Regional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AvailabilityType::value] or
        /// [AvailabilityType::name].
        UnknownValue(availability_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod availability_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AvailabilityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Zonal => std::option::Option::Some(1),
                Self::Regional => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AVAILABILITY_TYPE_UNSPECIFIED"),
                Self::Zonal => std::option::Option::Some("ZONAL"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AvailabilityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AvailabilityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AvailabilityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Zonal,
                2 => Self::Regional,
                _ => Self::UnknownValue(availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AvailabilityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AVAILABILITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ZONAL" => Self::Zonal,
                "REGIONAL" => Self::Regional,
                _ => Self::UnknownValue(availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AvailabilityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Zonal => serializer.serialize_i32(1),
                Self::Regional => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AvailabilityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AvailabilityType>::new(
                ".google.cloud.alloydb.v1.Instance.AvailabilityType",
            ))
        }
    }

    /// Specifies whether an instance needs to spin up.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ActivationPolicy {
        /// The policy is not specified.
        Unspecified,
        /// The instance is running.
        Always,
        /// The instance is not running.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ActivationPolicy::value] or
        /// [ActivationPolicy::name].
        UnknownValue(activation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod activation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ActivationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTIVATION_POLICY_UNSPECIFIED"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ActivationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ActivationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ActivationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Never,
                _ => Self::UnknownValue(activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ActivationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTIVATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                _ => Self::UnknownValue(activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ActivationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ActivationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ActivationPolicy>::new(
                ".google.cloud.alloydb.v1.Instance.ActivationPolicy",
            ))
        }
    }
}

/// ConnectionInfo singleton resource.
/// <https://google.aip.dev/156>
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectionInfo {
    /// The name of the ConnectionInfo singleton resource, e.g.:
    /// projects/{project}/locations/{location}/clusters/*/instances/*/connectionInfo
    /// This field currently has no semantic meaning.
    pub name: std::string::String,

    /// Output only. The private network IP address for the Instance. This is the
    /// default IP for the instance and is always created (even if enable_public_ip
    /// is set). This is the connection endpoint for an end-user application.
    pub ip_address: std::string::String,

    /// Output only. The public IP addresses for the Instance. This is available
    /// ONLY when enable_public_ip is set. This is the connection endpoint for an
    /// end-user application.
    pub public_ip_address: std::string::String,

    /// Output only. The unique ID of the Instance.
    pub instance_uid: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::ConnectionInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [public_ip_address][crate::model::ConnectionInfo::public_ip_address].
    pub fn set_public_ip_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ip_address = v.into();
        self
    }

    /// Sets the value of [instance_uid][crate::model::ConnectionInfo::instance_uid].
    pub fn set_instance_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_uid = v.into();
        self
    }
}

impl wkt::message::Message for ConnectionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ConnectionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ip_address,
            __public_ip_address,
            __instance_uid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "publicIpAddress" => Ok(__FieldTag::__public_ip_address),
                            "public_ip_address" => Ok(__FieldTag::__public_ip_address),
                            "instanceUid" => Ok(__FieldTag::__instance_uid),
                            "instance_uid" => Ok(__FieldTag::__instance_uid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ip_address => {
                            if !fields.insert(__FieldTag::__public_ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ip_address",
                                ));
                            }
                            result.public_ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_uid => {
                            if !fields.insert(__FieldTag::__instance_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_uid",
                                ));
                            }
                            result.instance_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.public_ip_address.is_empty() {
            state.serialize_entry("publicIpAddress", &self.public_ip_address)?;
        }
        if !self.instance_uid.is_empty() {
            state.serialize_entry("instanceUid", &self.instance_uid)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message describing Backup object
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The name of the backup resource with the format:
    ///
    /// * projects/{project}/locations/{region}/backups/{backup_id}
    ///   where the cluster and backup ID segments should satisfy the regex
    ///   expression `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`, e.g. 1-63 characters of
    ///   lowercase letters, numbers, and dashes, starting with a letter, and ending
    ///   with a letter or number. For more details see <https://google.aip.dev/122>.
    ///   The prefix of the backup resource name is the name of the parent
    ///   resource:
    /// * projects/{project}/locations/{region}
    pub name: std::string::String,

    /// User-settable and human-readable display name for the Backup.
    pub display_name: std::string::String,

    /// Output only. The system-generated UID of the resource. The UID is assigned
    /// when the resource is created, and it is retained until it is deleted.
    pub uid: std::string::String,

    /// Output only. Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    ///
    /// Users should not infer any meaning from this field. Its value is generally
    /// unrelated to the timing of the backup creation operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Delete time stamp
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when the resource finished being created.
    pub create_completion_time: std::option::Option<wkt::Timestamp>,

    /// Labels as key value pairs
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,

    /// The backup type, which suggests the trigger for the backup.
    pub r#type: crate::model::backup::Type,

    /// User-provided description of the backup.
    pub description: std::string::String,

    /// Output only. The system-generated UID of the cluster which was used to
    /// create this resource.
    pub cluster_uid: std::string::String,

    /// Required. The full resource name of the backup source cluster
    /// (e.g., projects/{project}/locations/{region}/clusters/{cluster_id}).
    pub cluster_name: std::string::String,

    /// Output only. Reconciling (<https://google.aip.dev/128#reconciliation>), if
    /// true, indicates that the service is actively updating the resource. This
    /// can happen due to user-triggered updates or system actions like failover or
    /// maintenance.
    pub reconciling: bool,

    /// Optional. The encryption config can be specified to encrypt the
    /// backup with a customer-managed encryption key (CMEK). When this field is
    /// not specified, the backup will then use default encryption scheme to
    /// protect the user data.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Output only. The encryption information for the backup.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// For Resource freshness validation (<https://google.aip.dev/154>)
    pub etag: std::string::String,

    /// Annotations to allow client tools to store small amount of arbitrary data.
    /// This is distinct from labels.
    /// <https://google.aip.dev/128>
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The size of the backup in bytes.
    pub size_bytes: i64,

    /// Output only. The time at which after the backup is eligible to be garbage
    /// collected. It is the duration specified by the backup's retention policy,
    /// added to the backup's create_time.
    pub expiry_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The QuantityBasedExpiry of the backup, specified by the
    /// backup's retention policy. Once the expiry quantity is over retention, the
    /// backup is eligible to be garbage collected.
    pub expiry_quantity: std::option::Option<crate::model::backup::QuantityBasedExpiry>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. The database engine major version of the cluster this backup
    /// was created from. Any restored cluster created from this backup will have
    /// the same database version.
    pub database_version: crate::model::DatabaseVersion,

    /// Optional. Input only. Immutable. Tag keys/values directly bound to this
    /// resource. For example:
    ///
    /// ```norust
    /// "123/environment": "production",
    /// "123/costCenter": "marketing"
    /// ```
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Backup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Backup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Backup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Backup::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Backup::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Backup::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Backup::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_completion_time][crate::model::Backup::create_completion_time].
    pub fn set_create_completion_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_completion_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_completion_time][crate::model::Backup::create_completion_time].
    pub fn set_or_clear_create_completion_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_completion_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Backup::type].
    pub fn set_type<T: std::convert::Into<crate::model::backup::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [cluster_uid][crate::model::Backup::cluster_uid].
    pub fn set_cluster_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uid = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::Backup::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Backup::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::Backup::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::Backup::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Backup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Backup::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Backup::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [expiry_time][crate::model::Backup::expiry_time].
    pub fn set_expiry_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiry_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiry_time][crate::model::Backup::expiry_time].
    pub fn set_or_clear_expiry_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiry_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expiry_quantity][crate::model::Backup::expiry_quantity].
    pub fn set_expiry_quantity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup::QuantityBasedExpiry>,
    {
        self.expiry_quantity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiry_quantity][crate::model::Backup::expiry_quantity].
    pub fn set_or_clear_expiry_quantity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup::QuantityBasedExpiry>,
    {
        self.expiry_quantity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [database_version][crate::model::Backup::database_version].
    pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::Backup::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Backup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Backup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __create_time,
            __update_time,
            __delete_time,
            __create_completion_time,
            __labels,
            __state,
            __type,
            __description,
            __cluster_uid,
            __cluster_name,
            __reconciling,
            __encryption_config,
            __encryption_info,
            __etag,
            __annotations,
            __size_bytes,
            __expiry_time,
            __expiry_quantity,
            __satisfies_pzs,
            __database_version,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Backup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "createCompletionTime" => Ok(__FieldTag::__create_completion_time),
                            "create_completion_time" => Ok(__FieldTag::__create_completion_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            "clusterUid" => Ok(__FieldTag::__cluster_uid),
                            "cluster_uid" => Ok(__FieldTag::__cluster_uid),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            "encryptionInfo" => Ok(__FieldTag::__encryption_info),
                            "encryption_info" => Ok(__FieldTag::__encryption_info),
                            "etag" => Ok(__FieldTag::__etag),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "sizeBytes" => Ok(__FieldTag::__size_bytes),
                            "size_bytes" => Ok(__FieldTag::__size_bytes),
                            "expiryTime" => Ok(__FieldTag::__expiry_time),
                            "expiry_time" => Ok(__FieldTag::__expiry_time),
                            "expiryQuantity" => Ok(__FieldTag::__expiry_quantity),
                            "expiry_quantity" => Ok(__FieldTag::__expiry_quantity),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "databaseVersion" => Ok(__FieldTag::__database_version),
                            "database_version" => Ok(__FieldTag::__database_version),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Backup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Backup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_completion_time => {
                            if !fields.insert(__FieldTag::__create_completion_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_completion_time",
                                ));
                            }
                            result.create_completion_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::backup::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::backup::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uid => {
                            if !fields.insert(__FieldTag::__cluster_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uid",
                                ));
                            }
                            result.cluster_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::__encryption_info => {
                            if !fields.insert(__FieldTag::__encryption_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_info",
                                ));
                            }
                            result.encryption_info = map
                                .next_value::<std::option::Option<crate::model::EncryptionInfo>>(
                                )?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_bytes => {
                            if !fields.insert(__FieldTag::__size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expiry_time => {
                            if !fields.insert(__FieldTag::__expiry_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiry_time",
                                ));
                            }
                            result.expiry_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expiry_quantity => {
                            if !fields.insert(__FieldTag::__expiry_quantity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiry_quantity",
                                ));
                            }
                            result.expiry_quantity = map.next_value::<std::option::Option<crate::model::backup::QuantityBasedExpiry>>()?
                                ;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_version => {
                            if !fields.insert(__FieldTag::__database_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_version",
                                ));
                            }
                            result.database_version = map
                                .next_value::<std::option::Option<crate::model::DatabaseVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Backup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.create_completion_time.is_some() {
            state.serialize_entry("createCompletionTime", &self.create_completion_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.cluster_uid.is_empty() {
            state.serialize_entry("clusterUid", &self.cluster_uid)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if self.encryption_info.is_some() {
            state.serialize_entry("encryptionInfo", &self.encryption_info)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !wkt::internal::is_default(&self.size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeBytes", &__With(&self.size_bytes))?;
        }
        if self.expiry_time.is_some() {
            state.serialize_entry("expiryTime", &self.expiry_time)?;
        }
        if self.expiry_quantity.is_some() {
            state.serialize_entry("expiryQuantity", &self.expiry_quantity)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.database_version) {
            state.serialize_entry("databaseVersion", &self.database_version)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// A backup's position in a quantity-based retention queue, of backups with
    /// the same source cluster and type, with length, retention, specified by the
    /// backup's retention policy.
    /// Once the position is greater than the retention, the backup is eligible to
    /// be garbage collected.
    ///
    /// Example: 5 backups from the same source cluster and type with a
    /// quantity-based retention of 3 and denoted by backup_id (position,
    /// retention).
    ///
    /// Safe: backup_5 (1, 3), backup_4, (2, 3), backup_3 (3, 3).
    /// Awaiting garbage collection: backup_2 (4, 3), backup_1 (5, 3)
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QuantityBasedExpiry {
        /// Output only. The backup's position among its backups with the same source
        /// cluster and type, by descending chronological order create time(i.e.
        /// newest first).
        pub retention_count: i32,

        /// Output only. The length of the quantity-based queue, specified by the
        /// backup's retention policy.
        pub total_retention_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QuantityBasedExpiry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_count][crate::model::backup::QuantityBasedExpiry::retention_count].
        pub fn set_retention_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.retention_count = v.into();
            self
        }

        /// Sets the value of [total_retention_count][crate::model::backup::QuantityBasedExpiry::total_retention_count].
        pub fn set_total_retention_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.total_retention_count = v.into();
            self
        }
    }

    impl wkt::message::Message for QuantityBasedExpiry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.Backup.QuantityBasedExpiry"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QuantityBasedExpiry {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __retention_count,
                __total_retention_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QuantityBasedExpiry")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "retentionCount" => Ok(__FieldTag::__retention_count),
                                "retention_count" => Ok(__FieldTag::__retention_count),
                                "totalRetentionCount" => Ok(__FieldTag::__total_retention_count),
                                "total_retention_count" => Ok(__FieldTag::__total_retention_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QuantityBasedExpiry;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QuantityBasedExpiry")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__retention_count => {
                                if !fields.insert(__FieldTag::__retention_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for retention_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.retention_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__total_retention_count => {
                                if !fields.insert(__FieldTag::__total_retention_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_retention_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.total_retention_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QuantityBasedExpiry {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.retention_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("retentionCount", &__With(&self.retention_count))?;
            }
            if !wkt::internal::is_default(&self.total_retention_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("totalRetentionCount", &__With(&self.total_retention_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Backup State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the backup is unknown.
        Unspecified,
        /// The backup is ready.
        Ready,
        /// The backup is creating.
        Creating,
        /// The backup failed.
        Failed,
        /// The backup is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Failed,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.Backup.State",
            ))
        }
    }

    /// Backup Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Backup Type is unknown.
        Unspecified,
        /// ON_DEMAND backups that were triggered by the customer (e.g., not
        /// AUTOMATED).
        OnDemand,
        /// AUTOMATED backups triggered by the automated backups scheduler pursuant
        /// to an automated backup policy.
        Automated,
        /// CONTINUOUS backups triggered by the automated backups scheduler
        /// due to a continuous backup policy.
        Continuous,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Automated => std::option::Option::Some(2),
                Self::Continuous => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Automated => std::option::Option::Some("AUTOMATED"),
                Self::Continuous => std::option::Option::Some("CONTINUOUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Automated,
                3 => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "AUTOMATED" => Self::Automated,
                "CONTINUOUS" => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Automated => serializer.serialize_i32(2),
                Self::Continuous => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.alloydb.v1.Backup.Type",
            ))
        }
    }
}

/// SupportedDatabaseFlag gives general information about a database flag,
/// like type and allowed values. This is a static value that is defined
/// on the server side, and it cannot be modified by callers.
/// To set the Database flags on a particular Instance, a caller should modify
/// the Instance.database_flags field.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SupportedDatabaseFlag {
    /// The name of the flag resource, following Google Cloud conventions, e.g.:
    ///
    /// * projects/{project}/locations/{location}/flags/{flag}
    ///   This field currently has no semantic meaning.
    pub name: std::string::String,

    /// The name of the database flag, e.g. "max_allowed_packets".
    /// The is a possibly key for the Instance.database_flags map field.
    pub flag_name: std::string::String,

    pub value_type: crate::model::supported_database_flag::ValueType,

    /// Whether the database flag accepts multiple values. If true,
    /// a comma-separated list of stringified values may be specified.
    pub accepts_multiple_values: bool,

    /// Major database engine versions for which this flag is supported.
    pub supported_db_versions: std::vec::Vec<crate::model::DatabaseVersion>,

    /// Whether setting or updating this flag on an Instance requires a database
    /// restart. If a flag that requires database restart is set, the backend
    /// will automatically restart the database (making sure to satisfy any
    /// availability SLO's).
    pub requires_db_restart: bool,

    /// The scope of the flag.
    pub scope: crate::model::supported_database_flag::Scope,

    /// The restrictions on the flag value per type.
    pub restrictions: std::option::Option<crate::model::supported_database_flag::Restrictions>,

    /// The recommended value for the flag by type, if applicable.
    pub recommended_value:
        std::option::Option<crate::model::supported_database_flag::RecommendedValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SupportedDatabaseFlag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SupportedDatabaseFlag::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [flag_name][crate::model::SupportedDatabaseFlag::flag_name].
    pub fn set_flag_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flag_name = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::SupportedDatabaseFlag::value_type].
    pub fn set_value_type<
        T: std::convert::Into<crate::model::supported_database_flag::ValueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }

    /// Sets the value of [accepts_multiple_values][crate::model::SupportedDatabaseFlag::accepts_multiple_values].
    pub fn set_accepts_multiple_values<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.accepts_multiple_values = v.into();
        self
    }

    /// Sets the value of [supported_db_versions][crate::model::SupportedDatabaseFlag::supported_db_versions].
    pub fn set_supported_db_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseVersion>,
    {
        use std::iter::Iterator;
        self.supported_db_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [requires_db_restart][crate::model::SupportedDatabaseFlag::requires_db_restart].
    pub fn set_requires_db_restart<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requires_db_restart = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::SupportedDatabaseFlag::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::supported_database_flag::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions].
    ///
    /// Note that all the setters affecting `restrictions` are mutually
    /// exclusive.
    pub fn set_restrictions<
        T: std::convert::Into<
                std::option::Option<crate::model::supported_database_flag::Restrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = v.into();
        self
    }

    /// The value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// if it holds a `StringRestrictions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_restrictions(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
    > {
        #[allow(unreachable_patterns)]
        self.restrictions.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::Restrictions::StringRestrictions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// to hold a `StringRestrictions`.
    ///
    /// Note that all the setters affecting `restrictions` are
    /// mutually exclusive.
    pub fn set_string_restrictions<
        T: std::convert::Into<
                std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = std::option::Option::Some(
            crate::model::supported_database_flag::Restrictions::StringRestrictions(v.into()),
        );
        self
    }

    /// The value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// if it holds a `IntegerRestrictions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn integer_restrictions(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
    > {
        #[allow(unreachable_patterns)]
        self.restrictions.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::Restrictions::IntegerRestrictions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [restrictions][crate::model::SupportedDatabaseFlag::restrictions]
    /// to hold a `IntegerRestrictions`.
    ///
    /// Note that all the setters affecting `restrictions` are
    /// mutually exclusive.
    pub fn set_integer_restrictions<
        T: std::convert::Into<
                std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restrictions = std::option::Option::Some(
            crate::model::supported_database_flag::Restrictions::IntegerRestrictions(v.into()),
        );
        self
    }

    /// Sets the value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value].
    ///
    /// Note that all the setters affecting `recommended_value` are mutually
    /// exclusive.
    pub fn set_recommended_value<
        T: std::convert::Into<
                std::option::Option<crate::model::supported_database_flag::RecommendedValue>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_value = v.into();
        self
    }

    /// The value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// if it holds a `RecommendedStringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recommended_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.recommended_value.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::RecommendedValue::RecommendedStringValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// to hold a `RecommendedStringValue`.
    ///
    /// Note that all the setters affecting `recommended_value` are
    /// mutually exclusive.
    pub fn set_recommended_string_value<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_value = std::option::Option::Some(
            crate::model::supported_database_flag::RecommendedValue::RecommendedStringValue(
                v.into(),
            ),
        );
        self
    }

    /// The value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// if it holds a `RecommendedIntegerValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recommended_integer_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<wkt::Int64Value>> {
        #[allow(unreachable_patterns)]
        self.recommended_value.as_ref().and_then(|v| match v {
            crate::model::supported_database_flag::RecommendedValue::RecommendedIntegerValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recommended_value][crate::model::SupportedDatabaseFlag::recommended_value]
    /// to hold a `RecommendedIntegerValue`.
    ///
    /// Note that all the setters affecting `recommended_value` are
    /// mutually exclusive.
    pub fn set_recommended_integer_value<
        T: std::convert::Into<std::boxed::Box<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recommended_value = std::option::Option::Some(
            crate::model::supported_database_flag::RecommendedValue::RecommendedIntegerValue(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SupportedDatabaseFlag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SupportedDatabaseFlag {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __string_restrictions,
            __integer_restrictions,
            __recommended_string_value,
            __recommended_integer_value,
            __name,
            __flag_name,
            __value_type,
            __accepts_multiple_values,
            __supported_db_versions,
            __requires_db_restart,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SupportedDatabaseFlag")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stringRestrictions" => Ok(__FieldTag::__string_restrictions),
                            "string_restrictions" => Ok(__FieldTag::__string_restrictions),
                            "integerRestrictions" => Ok(__FieldTag::__integer_restrictions),
                            "integer_restrictions" => Ok(__FieldTag::__integer_restrictions),
                            "recommendedStringValue" => Ok(__FieldTag::__recommended_string_value),
                            "recommended_string_value" => {
                                Ok(__FieldTag::__recommended_string_value)
                            }
                            "recommendedIntegerValue" => {
                                Ok(__FieldTag::__recommended_integer_value)
                            }
                            "recommended_integer_value" => {
                                Ok(__FieldTag::__recommended_integer_value)
                            }
                            "name" => Ok(__FieldTag::__name),
                            "flagName" => Ok(__FieldTag::__flag_name),
                            "flag_name" => Ok(__FieldTag::__flag_name),
                            "valueType" => Ok(__FieldTag::__value_type),
                            "value_type" => Ok(__FieldTag::__value_type),
                            "acceptsMultipleValues" => Ok(__FieldTag::__accepts_multiple_values),
                            "accepts_multiple_values" => Ok(__FieldTag::__accepts_multiple_values),
                            "supportedDbVersions" => Ok(__FieldTag::__supported_db_versions),
                            "supported_db_versions" => Ok(__FieldTag::__supported_db_versions),
                            "requiresDbRestart" => Ok(__FieldTag::__requires_db_restart),
                            "requires_db_restart" => Ok(__FieldTag::__requires_db_restart),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SupportedDatabaseFlag;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SupportedDatabaseFlag")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__string_restrictions => {
                            if !fields.insert(__FieldTag::__string_restrictions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_restrictions",
                                ));
                            }
                            if result.restrictions.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `restrictions`, a oneof with full ID .google.cloud.alloydb.v1.SupportedDatabaseFlag.string_restrictions, latest field was stringRestrictions",
                                ));
                            }
                            result.restrictions = std::option::Option::Some(
                                crate::model::supported_database_flag::Restrictions::StringRestrictions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__integer_restrictions => {
                            if !fields.insert(__FieldTag::__integer_restrictions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for integer_restrictions",
                                ));
                            }
                            if result.restrictions.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `restrictions`, a oneof with full ID .google.cloud.alloydb.v1.SupportedDatabaseFlag.integer_restrictions, latest field was integerRestrictions",
                                ));
                            }
                            result.restrictions = std::option::Option::Some(
                                crate::model::supported_database_flag::Restrictions::IntegerRestrictions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__recommended_string_value => {
                            if !fields.insert(__FieldTag::__recommended_string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recommended_string_value",
                                ));
                            }
                            if result.recommended_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `recommended_value`, a oneof with full ID .google.cloud.alloydb.v1.SupportedDatabaseFlag.recommended_string_value, latest field was recommendedStringValue",
                                ));
                            }
                            result.recommended_value = std::option::Option::Some(
                                crate::model::supported_database_flag::RecommendedValue::RecommendedStringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__recommended_integer_value => {
                            if !fields.insert(__FieldTag::__recommended_integer_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recommended_integer_value",
                                ));
                            }
                            struct __With(std::option::Option<std::boxed::Box<wkt::Int64Value>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::boxed::Box<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            if result.recommended_value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `recommended_value`, a oneof with full ID .google.cloud.alloydb.v1.SupportedDatabaseFlag.recommended_integer_value, latest field was recommendedIntegerValue",
                                ));
                            }
                            result.recommended_value = std::option::Option::Some(
                                crate::model::supported_database_flag::RecommendedValue::RecommendedIntegerValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flag_name => {
                            if !fields.insert(__FieldTag::__flag_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flag_name",
                                ));
                            }
                            result.flag_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value_type => {
                            if !fields.insert(__FieldTag::__value_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_type",
                                ));
                            }
                            result.value_type = map
                                .next_value::<std::option::Option<
                                    crate::model::supported_database_flag::ValueType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__accepts_multiple_values => {
                            if !fields.insert(__FieldTag::__accepts_multiple_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accepts_multiple_values",
                                ));
                            }
                            result.accepts_multiple_values = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_db_versions => {
                            if !fields.insert(__FieldTag::__supported_db_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_db_versions",
                                ));
                            }
                            result.supported_db_versions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatabaseVersion>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requires_db_restart => {
                            if !fields.insert(__FieldTag::__requires_db_restart) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requires_db_restart",
                                ));
                            }
                            result.requires_db_restart = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope =
                                map.next_value::<std::option::Option<
                                    crate::model::supported_database_flag::Scope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SupportedDatabaseFlag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.string_restrictions() {
            state.serialize_entry("stringRestrictions", value)?;
        }
        if let Some(value) = self.integer_restrictions() {
            state.serialize_entry("integerRestrictions", value)?;
        }
        if let Some(value) = self.recommended_string_value() {
            state.serialize_entry("recommendedStringValue", value)?;
        }
        if let Some(value) = self.recommended_integer_value() {
            struct __With<'a>(&'a std::boxed::Box<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("recommendedIntegerValue", &__With(value))?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.flag_name.is_empty() {
            state.serialize_entry("flagName", &self.flag_name)?;
        }
        if !wkt::internal::is_default(&self.value_type) {
            state.serialize_entry("valueType", &self.value_type)?;
        }
        if !wkt::internal::is_default(&self.accepts_multiple_values) {
            state.serialize_entry("acceptsMultipleValues", &self.accepts_multiple_values)?;
        }
        if !self.supported_db_versions.is_empty() {
            state.serialize_entry("supportedDbVersions", &self.supported_db_versions)?;
        }
        if !wkt::internal::is_default(&self.requires_db_restart) {
            state.serialize_entry("requiresDbRestart", &self.requires_db_restart)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SupportedDatabaseFlag].
pub mod supported_database_flag {
    #[allow(unused_imports)]
    use super::*;

    /// Restrictions on STRING type values
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StringRestrictions {
        /// The list of allowed values, if bounded. This field will be empty
        /// if there is a unbounded number of allowed values.
        pub allowed_values: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StringRestrictions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_values][crate::model::supported_database_flag::StringRestrictions::allowed_values].
        pub fn set_allowed_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for StringRestrictions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag.StringRestrictions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StringRestrictions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allowed_values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StringRestrictions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allowedValues" => Ok(__FieldTag::__allowed_values),
                                "allowed_values" => Ok(__FieldTag::__allowed_values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StringRestrictions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StringRestrictions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allowed_values => {
                                if !fields.insert(__FieldTag::__allowed_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_values",
                                    ));
                                }
                                result.allowed_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StringRestrictions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allowed_values.is_empty() {
                state.serialize_entry("allowedValues", &self.allowed_values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Restrictions on INTEGER type values.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IntegerRestrictions {
        /// The minimum value that can be specified, if applicable.
        pub min_value: std::option::Option<wkt::Int64Value>,

        /// The maximum value that can be specified, if applicable.
        pub max_value: std::option::Option<wkt::Int64Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IntegerRestrictions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::supported_database_flag::IntegerRestrictions::min_value].
        pub fn set_min_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.min_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_value][crate::model::supported_database_flag::IntegerRestrictions::min_value].
        pub fn set_or_clear_min_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.min_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_value][crate::model::supported_database_flag::IntegerRestrictions::max_value].
        pub fn set_max_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.max_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_value][crate::model::supported_database_flag::IntegerRestrictions::max_value].
        pub fn set_or_clear_max_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Int64Value>,
        {
            self.max_value = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for IntegerRestrictions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.SupportedDatabaseFlag.IntegerRestrictions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IntegerRestrictions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min_value,
                __max_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IntegerRestrictions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "minValue" => Ok(__FieldTag::__min_value),
                                "min_value" => Ok(__FieldTag::__min_value),
                                "maxValue" => Ok(__FieldTag::__max_value),
                                "max_value" => Ok(__FieldTag::__max_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IntegerRestrictions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IntegerRestrictions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min_value => {
                                if !fields.insert(__FieldTag::__min_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_value",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int64Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.min_value = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__max_value => {
                                if !fields.insert(__FieldTag::__max_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_value",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::Int64Value>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_value = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IntegerRestrictions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.min_value.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("minValue", &__With(&self.min_value))?;
            }
            if self.max_value.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("maxValue", &__With(&self.max_value))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// ValueType describes the semantic type of the value that the flag accepts.
    /// Regardless of the ValueType, the Instance.database_flags field accepts the
    /// stringified version of the value, i.e. "20" or "3.14".
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValueType {
        /// This is an unknown flag type.
        Unspecified,
        /// String type flag.
        String,
        /// Integer type flag.
        Integer,
        /// Float type flag.
        Float,
        /// Denotes that the flag does not accept any values.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ValueType::value] or
        /// [ValueType::name].
        UnknownValue(value_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod value_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ValueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::String => std::option::Option::Some(1),
                Self::Integer => std::option::Option::Some(2),
                Self::Float => std::option::Option::Some(3),
                Self::None => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VALUE_TYPE_UNSPECIFIED"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Integer => std::option::Option::Some("INTEGER"),
                Self::Float => std::option::Option::Some("FLOAT"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ValueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ValueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ValueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::String,
                2 => Self::Integer,
                3 => Self::Float,
                4 => Self::None,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ValueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STRING" => Self::String,
                "INTEGER" => Self::Integer,
                "FLOAT" => Self::Float,
                "NONE" => Self::None,
                _ => Self::UnknownValue(value_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ValueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::String => serializer.serialize_i32(1),
                Self::Integer => serializer.serialize_i32(2),
                Self::Float => serializer.serialize_i32(3),
                Self::None => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ValueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueType>::new(
                ".google.cloud.alloydb.v1.SupportedDatabaseFlag.ValueType",
            ))
        }
    }

    /// The scope of the flag.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// The scope of the flag is not specified. Default is DATABASE.
        Unspecified,
        /// The flag is a database flag.
        Database,
        /// The flag is a connection pool flag.
        ConnectionPool,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Database => std::option::Option::Some(1),
                Self::ConnectionPool => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Database => std::option::Option::Some("DATABASE"),
                Self::ConnectionPool => std::option::Option::Some("CONNECTION_POOL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Database,
                2 => Self::ConnectionPool,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "DATABASE" => Self::Database,
                "CONNECTION_POOL" => Self::ConnectionPool,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Database => serializer.serialize_i32(1),
                Self::ConnectionPool => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.alloydb.v1.SupportedDatabaseFlag.Scope",
            ))
        }
    }

    /// The restrictions on the flag value per type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Restrictions {
        /// Restriction on STRING type value.
        StringRestrictions(
            std::boxed::Box<crate::model::supported_database_flag::StringRestrictions>,
        ),
        /// Restriction on INTEGER type value.
        IntegerRestrictions(
            std::boxed::Box<crate::model::supported_database_flag::IntegerRestrictions>,
        ),
    }

    /// The recommended value for the flag by type, if applicable.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RecommendedValue {
        /// The recommended value for a STRING flag.
        RecommendedStringValue(std::string::String),
        /// The recommended value for an INTEGER flag.
        RecommendedIntegerValue(std::boxed::Box<wkt::Int64Value>),
    }
}

/// Message describing User object.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct User {
    /// Output only. Name of the resource in the form of
    /// projects/{project}/locations/{location}/cluster/{cluster}/users/{user}.
    pub name: std::string::String,

    /// Input only. Password for the user.
    pub password: std::string::String,

    /// Optional. List of database roles this user has.
    /// The database role strings are subject to the PostgreSQL naming conventions.
    pub database_roles: std::vec::Vec<std::string::String>,

    /// Optional. Type of this user.
    pub user_type: crate::model::user::UserType,

    /// Input only. If the user already exists and it has additional roles, keep
    /// them granted.
    pub keep_extra_roles: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [password][crate::model::User::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [database_roles][crate::model::User::database_roles].
    pub fn set_database_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_type][crate::model::User::user_type].
    pub fn set_user_type<T: std::convert::Into<crate::model::user::UserType>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_type = v.into();
        self
    }

    /// Sets the value of [keep_extra_roles][crate::model::User::keep_extra_roles].
    pub fn set_keep_extra_roles<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.keep_extra_roles = v.into();
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.User"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for User {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __password,
            __database_roles,
            __user_type,
            __keep_extra_roles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for User")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "password" => Ok(__FieldTag::__password),
                            "databaseRoles" => Ok(__FieldTag::__database_roles),
                            "database_roles" => Ok(__FieldTag::__database_roles),
                            "userType" => Ok(__FieldTag::__user_type),
                            "user_type" => Ok(__FieldTag::__user_type),
                            "keepExtraRoles" => Ok(__FieldTag::__keep_extra_roles),
                            "keep_extra_roles" => Ok(__FieldTag::__keep_extra_roles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = User;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct User")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_roles => {
                            if !fields.insert(__FieldTag::__database_roles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_roles",
                                ));
                            }
                            result.database_roles = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_type => {
                            if !fields.insert(__FieldTag::__user_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_type",
                                ));
                            }
                            result.user_type = map
                                .next_value::<std::option::Option<crate::model::user::UserType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__keep_extra_roles => {
                            if !fields.insert(__FieldTag::__keep_extra_roles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keep_extra_roles",
                                ));
                            }
                            result.keep_extra_roles = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for User {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.database_roles.is_empty() {
            state.serialize_entry("databaseRoles", &self.database_roles)?;
        }
        if !wkt::internal::is_default(&self.user_type) {
            state.serialize_entry("userType", &self.user_type)?;
        }
        if !wkt::internal::is_default(&self.keep_extra_roles) {
            state.serialize_entry("keepExtraRoles", &self.keep_extra_roles)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [User].
pub mod user {
    #[allow(unused_imports)]
    use super::*;

    /// Enum that details the user type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserType {
        /// Unspecified user type.
        Unspecified,
        /// The default user type that authenticates via password-based
        /// authentication.
        AlloydbBuiltIn,
        /// Database user that can authenticate via IAM-Based authentication.
        AlloydbIamUser,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserType::value] or
        /// [UserType::name].
        UnknownValue(user_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AlloydbBuiltIn => std::option::Option::Some(1),
                Self::AlloydbIamUser => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("USER_TYPE_UNSPECIFIED"),
                Self::AlloydbBuiltIn => std::option::Option::Some("ALLOYDB_BUILT_IN"),
                Self::AlloydbIamUser => std::option::Option::Some("ALLOYDB_IAM_USER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AlloydbBuiltIn,
                2 => Self::AlloydbIamUser,
                _ => Self::UnknownValue(user_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ALLOYDB_BUILT_IN" => Self::AlloydbBuiltIn,
                "ALLOYDB_IAM_USER" => Self::AlloydbIamUser,
                _ => Self::UnknownValue(user_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AlloydbBuiltIn => serializer.serialize_i32(1),
                Self::AlloydbIamUser => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserType>::new(
                ".google.cloud.alloydb.v1.User.UserType",
            ))
        }
    }
}

/// Message describing Database object.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Database {
    /// Identifier. Name of the resource in the form of
    /// `projects/{project}/locations/{location}/clusters/{cluster}/databases/{database}`.
    pub name: std::string::String,

    /// Optional. Charset for the database.
    /// This field can contain any PostgreSQL supported charset name.
    /// Example values include "UTF8", "SQL_ASCII", etc.
    pub charset: std::string::String,

    /// Optional. Collation for the database.
    /// Name of the custom or native collation for postgres.
    /// Example values include "C", "POSIX", etc
    pub collation: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Database {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Database::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::Database::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::Database::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }
}

impl wkt::message::Message for Database {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.Database"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Database {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __charset,
            __collation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Database")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "charset" => Ok(__FieldTag::__charset),
                            "collation" => Ok(__FieldTag::__collation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Database;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Database")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__charset => {
                            if !fields.insert(__FieldTag::__charset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for charset",
                                ));
                            }
                            result.charset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Database {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.charset.is_empty() {
            state.serialize_entry("charset", &self.charset)?;
        }
        if !self.collation.is_empty() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting list of Clusters
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Cluster.name field. Additionally, you can perform an
    /// aggregated list operation by specifying a value with the following format:
    ///
    /// * projects/{project}/locations/-
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing Clusters
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// The list of Cluster
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clusters,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusters" => Ok(__FieldTag::__clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a Cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field.
    pub name: std::string::String,

    /// Optional. The view of the cluster to return. Returns all default fields if
    /// not set.
    pub view: crate::model::ClusterView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetClusterRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::ClusterView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::ClusterView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSecondaryClusterRequest {
    /// Required. The location of the new cluster. For the required
    /// format, see the comment on the Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object (the secondary cluster).
    pub cluster_id: std::string::String,

    /// Required. Configuration of the requesting object (the secondary cluster).
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSecondaryClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecondaryClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateSecondaryClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateSecondaryClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateSecondaryClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSecondaryClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateSecondaryClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateSecondaryClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateSecondaryClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSecondaryClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cluster_id,
            __cluster,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSecondaryClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSecondaryClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSecondaryClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSecondaryClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a Cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The location of the new cluster. For the required format, see the
    /// comment on the Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cluster_id,
            __cluster,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a Cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Cluster resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if cluster is not found. In
    /// that case, a new cluster is created and `update_mask` is ignored.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __cluster,
            __request_id,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Destination for Export. Export will be done to cloud storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required. The path to the file in Google Cloud Storage where the export
    /// will be stored. The URI is in the form `gs://bucketName/fileName`.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsDestination::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GcsDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Export cluster request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. Name of the database where the export command will be executed.
    /// Note - Value provided should be the same as expected from
    /// `SELECT current_database();` and NOT as a resource reference.
    pub database: std::string::String,

    /// Oneof field to support other destinations in future.
    pub destination: std::option::Option<crate::model::export_cluster_request::Destination>,

    /// Required field to specify export file type and options.
    pub export_options: std::option::Option<crate::model::export_cluster_request::ExportOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ExportClusterRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportClusterRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_cluster_request::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportClusterRequest::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_cluster_request::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportClusterRequest::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_cluster_request::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options].
    ///
    /// Note that all the setters affecting `export_options` are mutually
    /// exclusive.
    pub fn set_export_options<
        T: std::convert::Into<
                std::option::Option<crate::model::export_cluster_request::ExportOptions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_options = v.into();
        self
    }

    /// The value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// if it holds a `CsvExportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_export_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.export_options.as_ref().and_then(|v| match v {
            crate::model::export_cluster_request::ExportOptions::CsvExportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// to hold a `CsvExportOptions`.
    ///
    /// Note that all the setters affecting `export_options` are
    /// mutually exclusive.
    pub fn set_csv_export_options<
        T: std::convert::Into<std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_options = std::option::Option::Some(
            crate::model::export_cluster_request::ExportOptions::CsvExportOptions(v.into()),
        );
        self
    }

    /// The value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// if it holds a `SqlExportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_export_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.export_options.as_ref().and_then(|v| match v {
            crate::model::export_cluster_request::ExportOptions::SqlExportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options]
    /// to hold a `SqlExportOptions`.
    ///
    /// Note that all the setters affecting `export_options` are
    /// mutually exclusive.
    pub fn set_sql_export_options<
        T: std::convert::Into<std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.export_options = std::option::Option::Some(
            crate::model::export_cluster_request::ExportOptions::SqlExportOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __csv_export_options,
            __sql_export_options,
            __name,
            __database,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "csvExportOptions" => Ok(__FieldTag::__csv_export_options),
                            "csv_export_options" => Ok(__FieldTag::__csv_export_options),
                            "sqlExportOptions" => Ok(__FieldTag::__sql_export_options),
                            "sql_export_options" => Ok(__FieldTag::__sql_export_options),
                            "name" => Ok(__FieldTag::__name),
                            "database" => Ok(__FieldTag::__database),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.alloydb.v1.ExportClusterRequest.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_cluster_request::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__csv_export_options => {
                            if !fields.insert(__FieldTag::__csv_export_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_export_options",
                                ));
                            }
                            if result.export_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `export_options`, a oneof with full ID .google.cloud.alloydb.v1.ExportClusterRequest.csv_export_options, latest field was csvExportOptions",
                                ));
                            }
                            result.export_options = std::option::Option::Some(
                                crate::model::export_cluster_request::ExportOptions::CsvExportOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__sql_export_options => {
                            if !fields.insert(__FieldTag::__sql_export_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_export_options",
                                ));
                            }
                            if result.export_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `export_options`, a oneof with full ID .google.cloud.alloydb.v1.ExportClusterRequest.sql_export_options, latest field was sqlExportOptions",
                                ));
                            }
                            result.export_options = std::option::Option::Some(
                                crate::model::export_cluster_request::ExportOptions::SqlExportOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if let Some(value) = self.csv_export_options() {
            state.serialize_entry("csvExportOptions", value)?;
        }
        if let Some(value) = self.sql_export_options() {
            state.serialize_entry("sqlExportOptions", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportClusterRequest].
pub mod export_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Options for exporting data in CSV format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CsvExportOptions {
        /// Required. The SELECT query used to extract the data.
        pub select_query: std::string::String,

        /// Optional. Specifies the character that separates columns within each row
        /// (line) of the file. The default is comma. The value of this argument has
        /// to be a character in Hex ASCII Code.
        pub field_delimiter: std::string::String,

        /// Optional. Specifies the quoting character to be used when a data value is
        /// quoted. The default is double-quote. The value of this argument has to be
        /// a character in Hex ASCII Code.
        pub quote_character: std::string::String,

        /// Optional. Specifies the character that should appear before a data
        /// character that needs to be escaped. The default is the same as quote
        /// character. The value of this argument has to be a character in Hex ASCII
        /// Code.
        pub escape_character: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [select_query][crate::model::export_cluster_request::CsvExportOptions::select_query].
        pub fn set_select_query<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.select_query = v.into();
            self
        }

        /// Sets the value of [field_delimiter][crate::model::export_cluster_request::CsvExportOptions::field_delimiter].
        pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.field_delimiter = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::export_cluster_request::CsvExportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::export_cluster_request::CsvExportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.escape_character = v.into();
            self
        }
    }

    impl wkt::message::Message for CsvExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterRequest.CsvExportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CsvExportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __select_query,
                __field_delimiter,
                __quote_character,
                __escape_character,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CsvExportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "selectQuery" => Ok(__FieldTag::__select_query),
                                "select_query" => Ok(__FieldTag::__select_query),
                                "fieldDelimiter" => Ok(__FieldTag::__field_delimiter),
                                "field_delimiter" => Ok(__FieldTag::__field_delimiter),
                                "quoteCharacter" => Ok(__FieldTag::__quote_character),
                                "quote_character" => Ok(__FieldTag::__quote_character),
                                "escapeCharacter" => Ok(__FieldTag::__escape_character),
                                "escape_character" => Ok(__FieldTag::__escape_character),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CsvExportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CsvExportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__select_query => {
                                if !fields.insert(__FieldTag::__select_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for select_query",
                                    ));
                                }
                                result.select_query = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__field_delimiter => {
                                if !fields.insert(__FieldTag::__field_delimiter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field_delimiter",
                                    ));
                                }
                                result.field_delimiter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__quote_character => {
                                if !fields.insert(__FieldTag::__quote_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quote_character",
                                    ));
                                }
                                result.quote_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__escape_character => {
                                if !fields.insert(__FieldTag::__escape_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for escape_character",
                                    ));
                                }
                                result.escape_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CsvExportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.select_query.is_empty() {
                state.serialize_entry("selectQuery", &self.select_query)?;
            }
            if !self.field_delimiter.is_empty() {
                state.serialize_entry("fieldDelimiter", &self.field_delimiter)?;
            }
            if !self.quote_character.is_empty() {
                state.serialize_entry("quoteCharacter", &self.quote_character)?;
            }
            if !self.escape_character.is_empty() {
                state.serialize_entry("escapeCharacter", &self.escape_character)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Options for exporting data in SQL format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlExportOptions {
        /// Optional. Tables to export from.
        pub tables: std::vec::Vec<std::string::String>,

        /// Optional. If true, only export the schema.
        pub schema_only: std::option::Option<bool>,

        /// Optional. If true, output commands to DROP all the dumped database
        /// objects prior to outputting the commands for creating them.
        pub clean_target_objects: std::option::Option<bool>,

        /// Optional. If true, use DROP ... IF EXISTS commands to check for the
        /// object's existence before dropping it in clean_target_objects mode.
        pub if_exist_target_objects: std::option::Option<bool>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlExportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tables][crate::model::export_cluster_request::SqlExportOptions::tables].
        pub fn set_tables<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tables = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [schema_only][crate::model::export_cluster_request::SqlExportOptions::schema_only].
        pub fn set_schema_only<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.schema_only = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [schema_only][crate::model::export_cluster_request::SqlExportOptions::schema_only].
        pub fn set_or_clear_schema_only<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.schema_only = v.map(|x| x.into());
            self
        }

        /// Sets the value of [clean_target_objects][crate::model::export_cluster_request::SqlExportOptions::clean_target_objects].
        pub fn set_clean_target_objects<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.clean_target_objects = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [clean_target_objects][crate::model::export_cluster_request::SqlExportOptions::clean_target_objects].
        pub fn set_or_clear_clean_target_objects<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.clean_target_objects = v.map(|x| x.into());
            self
        }

        /// Sets the value of [if_exist_target_objects][crate::model::export_cluster_request::SqlExportOptions::if_exist_target_objects].
        pub fn set_if_exist_target_objects<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.if_exist_target_objects = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [if_exist_target_objects][crate::model::export_cluster_request::SqlExportOptions::if_exist_target_objects].
        pub fn set_or_clear_if_exist_target_objects<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.if_exist_target_objects = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SqlExportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterRequest.SqlExportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlExportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tables,
                __schema_only,
                __clean_target_objects,
                __if_exist_target_objects,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlExportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tables" => Ok(__FieldTag::__tables),
                                "schemaOnly" => Ok(__FieldTag::__schema_only),
                                "schema_only" => Ok(__FieldTag::__schema_only),
                                "cleanTargetObjects" => Ok(__FieldTag::__clean_target_objects),
                                "clean_target_objects" => Ok(__FieldTag::__clean_target_objects),
                                "ifExistTargetObjects" => Ok(__FieldTag::__if_exist_target_objects),
                                "if_exist_target_objects" => {
                                    Ok(__FieldTag::__if_exist_target_objects)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlExportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlExportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tables => {
                                if !fields.insert(__FieldTag::__tables) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tables",
                                    ));
                                }
                                result.tables = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__schema_only => {
                                if !fields.insert(__FieldTag::__schema_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schema_only",
                                    ));
                                }
                                result.schema_only =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__clean_target_objects => {
                                if !fields.insert(__FieldTag::__clean_target_objects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for clean_target_objects",
                                    ));
                                }
                                result.clean_target_objects =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__if_exist_target_objects => {
                                if !fields.insert(__FieldTag::__if_exist_target_objects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for if_exist_target_objects",
                                    ));
                                }
                                result.if_exist_target_objects =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlExportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tables.is_empty() {
                state.serialize_entry("tables", &self.tables)?;
            }
            if self.schema_only.is_some() {
                state.serialize_entry("schemaOnly", &self.schema_only)?;
            }
            if self.clean_target_objects.is_some() {
                state.serialize_entry("cleanTargetObjects", &self.clean_target_objects)?;
            }
            if self.if_exist_target_objects.is_some() {
                state.serialize_entry("ifExistTargetObjects", &self.if_exist_target_objects)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Oneof field to support other destinations in future.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Required. Option to export data to cloud storage.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }

    /// Required field to specify export file type and options.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExportOptions {
        /// Options for exporting data in CSV format. Required field to be set for
        /// CSV file type.
        CsvExportOptions(std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>),
        /// Options for exporting data in SQL format. Required field to be set for
        /// SQL file type.
        SqlExportOptions(std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>),
    }
}

/// Response of export cluster rpc.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportClusterResponse {
    /// Oneof field to support other destinations in future.
    pub destination: std::option::Option<crate::model::export_cluster_response::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportClusterResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ExportClusterResponse::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_cluster_response::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportClusterResponse::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_cluster_response::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportClusterResponse::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_cluster_response::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportClusterResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExportClusterResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportClusterResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportClusterResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportClusterResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportClusterResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.alloydb.v1.ExportClusterResponse.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_cluster_response::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportClusterResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportClusterResponse].
pub mod export_cluster_response {
    #[allow(unused_imports)]
    use super::*;

    /// Oneof field to support other destinations in future.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Required. Option to export data to cloud storage.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// Import cluster request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. The path to the file in Google Cloud Storage where the source
    /// file for import will be stored. The URI is in the form
    /// `gs://bucketName/fileName`.
    pub gcs_uri: std::string::String,

    /// Optional. Name of the database to which the import will be done.
    /// For import from SQL file, this is required only if the file does not
    /// specify a database.
    /// Note - Value provided should be the same as expected from `SELECT
    /// current_database();` and NOT as a resource reference.
    pub database: std::string::String,

    /// Optional. Database user to be used for importing the data.
    /// Note - Value provided should be the same as expected from
    /// `SELECT current_user;` and NOT as a resource reference.
    pub user: std::string::String,

    /// oneof field to support various import formats like SQL and CSV.
    pub import_options: std::option::Option<crate::model::import_cluster_request::ImportOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [gcs_uri][crate::model::ImportClusterRequest::gcs_uri].
    pub fn set_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_uri = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ImportClusterRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [user][crate::model::ImportClusterRequest::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options].
    ///
    /// Note that all the setters affecting `import_options` are mutually
    /// exclusive.
    pub fn set_import_options<
        T: std::convert::Into<
                std::option::Option<crate::model::import_cluster_request::ImportOptions>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_options = v.into();
        self
    }

    /// The value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// if it holds a `SqlImportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_import_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.import_options.as_ref().and_then(|v| match v {
            crate::model::import_cluster_request::ImportOptions::SqlImportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// to hold a `SqlImportOptions`.
    ///
    /// Note that all the setters affecting `import_options` are
    /// mutually exclusive.
    pub fn set_sql_import_options<
        T: std::convert::Into<std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_options = std::option::Option::Some(
            crate::model::import_cluster_request::ImportOptions::SqlImportOptions(v.into()),
        );
        self
    }

    /// The value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// if it holds a `CsvImportOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv_import_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>>
    {
        #[allow(unreachable_patterns)]
        self.import_options.as_ref().and_then(|v| match v {
            crate::model::import_cluster_request::ImportOptions::CsvImportOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options]
    /// to hold a `CsvImportOptions`.
    ///
    /// Note that all the setters affecting `import_options` are
    /// mutually exclusive.
    pub fn set_csv_import_options<
        T: std::convert::Into<std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_options = std::option::Option::Some(
            crate::model::import_cluster_request::ImportOptions::CsvImportOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_import_options,
            __csv_import_options,
            __name,
            __gcs_uri,
            __database,
            __user,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlImportOptions" => Ok(__FieldTag::__sql_import_options),
                            "sql_import_options" => Ok(__FieldTag::__sql_import_options),
                            "csvImportOptions" => Ok(__FieldTag::__csv_import_options),
                            "csv_import_options" => Ok(__FieldTag::__csv_import_options),
                            "name" => Ok(__FieldTag::__name),
                            "gcsUri" => Ok(__FieldTag::__gcs_uri),
                            "gcs_uri" => Ok(__FieldTag::__gcs_uri),
                            "database" => Ok(__FieldTag::__database),
                            "user" => Ok(__FieldTag::__user),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_import_options => {
                            if !fields.insert(__FieldTag::__sql_import_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_import_options",
                                ));
                            }
                            if result.import_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `import_options`, a oneof with full ID .google.cloud.alloydb.v1.ImportClusterRequest.sql_import_options, latest field was sqlImportOptions",
                                ));
                            }
                            result.import_options = std::option::Option::Some(
                                crate::model::import_cluster_request::ImportOptions::SqlImportOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__csv_import_options => {
                            if !fields.insert(__FieldTag::__csv_import_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_import_options",
                                ));
                            }
                            if result.import_options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `import_options`, a oneof with full ID .google.cloud.alloydb.v1.ImportClusterRequest.csv_import_options, latest field was csvImportOptions",
                                ));
                            }
                            result.import_options = std::option::Option::Some(
                                crate::model::import_cluster_request::ImportOptions::CsvImportOptions(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_uri => {
                            if !fields.insert(__FieldTag::__gcs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_uri",
                                ));
                            }
                            result.gcs_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.sql_import_options() {
            state.serialize_entry("sqlImportOptions", value)?;
        }
        if let Some(value) = self.csv_import_options() {
            state.serialize_entry("csvImportOptions", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.gcs_uri.is_empty() {
            state.serialize_entry("gcsUri", &self.gcs_uri)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportClusterRequest].
pub mod import_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Options for importing data in SQL format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SqlImportOptions {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SqlImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterRequest.SqlImportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SqlImportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SqlImportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SqlImportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SqlImportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SqlImportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Options for importing data in CSV format.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CsvImportOptions {
        /// Required. The database table to import CSV file into.
        pub table: std::string::String,

        /// Optional. The columns to which CSV data is imported. If not specified,
        /// all columns of the database table are loaded with CSV data.
        pub columns: std::vec::Vec<std::string::String>,

        /// Optional. Specifies the character that separates columns within each row
        /// (line) of the file. The default is comma. The value of this argument has
        /// to be a character in Hex ASCII Code.
        pub field_delimiter: std::string::String,

        /// Optional. Specifies the quoting character to be used when a data value is
        /// quoted. The default is double-quote. The value of this argument has to be
        /// a character in Hex ASCII Code.
        pub quote_character: std::string::String,

        /// Optional. Specifies the character that should appear before a data
        /// character that needs to be escaped. The default is same as quote
        /// character. The value of this argument has to be a character in Hex ASCII
        /// Code.
        pub escape_character: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvImportOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::import_cluster_request::CsvImportOptions::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [columns][crate::model::import_cluster_request::CsvImportOptions::columns].
        pub fn set_columns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.columns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [field_delimiter][crate::model::import_cluster_request::CsvImportOptions::field_delimiter].
        pub fn set_field_delimiter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.field_delimiter = v.into();
            self
        }

        /// Sets the value of [quote_character][crate::model::import_cluster_request::CsvImportOptions::quote_character].
        pub fn set_quote_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.quote_character = v.into();
            self
        }

        /// Sets the value of [escape_character][crate::model::import_cluster_request::CsvImportOptions::escape_character].
        pub fn set_escape_character<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.escape_character = v.into();
            self
        }
    }

    impl wkt::message::Message for CsvImportOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterRequest.CsvImportOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CsvImportOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __table,
                __columns,
                __field_delimiter,
                __quote_character,
                __escape_character,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CsvImportOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "table" => Ok(__FieldTag::__table),
                                "columns" => Ok(__FieldTag::__columns),
                                "fieldDelimiter" => Ok(__FieldTag::__field_delimiter),
                                "field_delimiter" => Ok(__FieldTag::__field_delimiter),
                                "quoteCharacter" => Ok(__FieldTag::__quote_character),
                                "quote_character" => Ok(__FieldTag::__quote_character),
                                "escapeCharacter" => Ok(__FieldTag::__escape_character),
                                "escape_character" => Ok(__FieldTag::__escape_character),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CsvImportOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CsvImportOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__table => {
                                if !fields.insert(__FieldTag::__table) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table",
                                    ));
                                }
                                result.table = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__columns => {
                                if !fields.insert(__FieldTag::__columns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for columns",
                                    ));
                                }
                                result.columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__field_delimiter => {
                                if !fields.insert(__FieldTag::__field_delimiter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field_delimiter",
                                    ));
                                }
                                result.field_delimiter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__quote_character => {
                                if !fields.insert(__FieldTag::__quote_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quote_character",
                                    ));
                                }
                                result.quote_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__escape_character => {
                                if !fields.insert(__FieldTag::__escape_character) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for escape_character",
                                    ));
                                }
                                result.escape_character = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CsvImportOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.table.is_empty() {
                state.serialize_entry("table", &self.table)?;
            }
            if !self.columns.is_empty() {
                state.serialize_entry("columns", &self.columns)?;
            }
            if !self.field_delimiter.is_empty() {
                state.serialize_entry("fieldDelimiter", &self.field_delimiter)?;
            }
            if !self.quote_character.is_empty() {
                state.serialize_entry("quoteCharacter", &self.quote_character)?;
            }
            if !self.escape_character.is_empty() {
                state.serialize_entry("escapeCharacter", &self.escape_character)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// oneof field to support various import formats like SQL and CSV.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportOptions {
        /// Options for importing data in SQL format.
        SqlImportOptions(std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>),
        /// Options for importing data in CSV format.
        CsvImportOptions(std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>),
    }
}

/// Response of import rpc.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportClusterResponse {
    /// Required. Size of the object downloaded from Google Cloud Storage in bytes.
    pub bytes_downloaded: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportClusterResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bytes_downloaded][crate::model::ImportClusterResponse::bytes_downloaded].
    pub fn set_bytes_downloaded<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.bytes_downloaded = v.into();
        self
    }
}

impl wkt::message::Message for ImportClusterResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ImportClusterResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportClusterResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bytes_downloaded,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportClusterResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bytesDownloaded" => Ok(__FieldTag::__bytes_downloaded),
                            "bytes_downloaded" => Ok(__FieldTag::__bytes_downloaded),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportClusterResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportClusterResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bytes_downloaded => {
                            if !fields.insert(__FieldTag::__bytes_downloaded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_downloaded",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.bytes_downloaded =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportClusterResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.bytes_downloaded) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("bytesDownloaded", &__With(&self.bytes_downloaded))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Upgrades a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. The version the cluster is going to be upgraded to.
    pub version: crate::model::DatabaseVersion,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// upgrade will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpgradeClusterRequest::version].
    pub fn set_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpgradeClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UpgradeClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __request_id,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<crate::model::DatabaseVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.version) {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// UpgradeClusterResponse contains the response for upgrade cluster operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterResponse {
    /// Status of upgrade operation.
    pub status: crate::model::upgrade_cluster_response::Status,

    /// A user friendly message summarising the upgrade operation details and the
    /// next steps for the user if there is any.
    pub message: std::string::String,

    /// Array of upgrade details for the current cluster and all the secondary
    /// clusters associated with this cluster.
    pub cluster_upgrade_details:
        std::vec::Vec<crate::model::upgrade_cluster_response::ClusterUpgradeDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [status][crate::model::UpgradeClusterResponse::status].
    pub fn set_status<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [message][crate::model::UpgradeClusterResponse::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [cluster_upgrade_details][crate::model::UpgradeClusterResponse::cluster_upgrade_details].
    pub fn set_cluster_upgrade_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::upgrade_cluster_response::ClusterUpgradeDetails>,
    {
        use std::iter::Iterator;
        self.cluster_upgrade_details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpgradeClusterResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeClusterResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __status,
            __message,
            __cluster_upgrade_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeClusterResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "status" => Ok(__FieldTag::__status),
                            "message" => Ok(__FieldTag::__message),
                            "clusterUpgradeDetails" => Ok(__FieldTag::__cluster_upgrade_details),
                            "cluster_upgrade_details" => Ok(__FieldTag::__cluster_upgrade_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeClusterResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeClusterResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<
                                    crate::model::upgrade_cluster_response::Status,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_upgrade_details => {
                            if !fields.insert(__FieldTag::__cluster_upgrade_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_upgrade_details",
                                ));
                            }
                            result.cluster_upgrade_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::upgrade_cluster_response::ClusterUpgradeDetails>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeClusterResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.cluster_upgrade_details.is_empty() {
            state.serialize_entry("clusterUpgradeDetails", &self.cluster_upgrade_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UpgradeClusterResponse].
pub mod upgrade_cluster_response {
    #[allow(unused_imports)]
    use super::*;

    /// Stage information for different stages in the upgrade process.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StageInfo {
        /// The stage.
        pub stage: crate::model::upgrade_cluster_response::Stage,

        /// Status of the stage.
        pub status: crate::model::upgrade_cluster_response::Status,

        /// logs_url is the URL for the logs associated with a stage if that stage
        /// has logs. Right now, only three stages have logs: ALLOYDB_PRECHECK,
        /// PG_UPGRADE_CHECK, PRIMARY_INSTANCE_UPGRADE.
        pub logs_url: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StageInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [stage][crate::model::upgrade_cluster_response::StageInfo::stage].
        pub fn set_stage<T: std::convert::Into<crate::model::upgrade_cluster_response::Stage>>(
            mut self,
            v: T,
        ) -> Self {
            self.stage = v.into();
            self
        }

        /// Sets the value of [status][crate::model::upgrade_cluster_response::StageInfo::status].
        pub fn set_status<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [logs_url][crate::model::upgrade_cluster_response::StageInfo::logs_url].
        pub fn set_logs_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.logs_url = v.into();
            self
        }
    }

    impl wkt::message::Message for StageInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse.StageInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StageInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __stage,
                __status,
                __logs_url,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StageInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "stage" => Ok(__FieldTag::__stage),
                                "status" => Ok(__FieldTag::__status),
                                "logsUrl" => Ok(__FieldTag::__logs_url),
                                "logs_url" => Ok(__FieldTag::__logs_url),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StageInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StageInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__stage => {
                                if !fields.insert(__FieldTag::__stage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stage",
                                    ));
                                }
                                result.stage = map
                                    .next_value::<std::option::Option<
                                        crate::model::upgrade_cluster_response::Stage,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map
                                    .next_value::<std::option::Option<
                                        crate::model::upgrade_cluster_response::Status,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__logs_url => {
                                if !fields.insert(__FieldTag::__logs_url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for logs_url",
                                    ));
                                }
                                result.logs_url = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StageInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.stage) {
                state.serialize_entry("stage", &self.stage)?;
            }
            if !wkt::internal::is_default(&self.status) {
                state.serialize_entry("status", &self.status)?;
            }
            if !self.logs_url.is_empty() {
                state.serialize_entry("logsUrl", &self.logs_url)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Details regarding the upgrade of instances associated with a cluster.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceUpgradeDetails {
        /// Normalized name of the instance.
        pub name: std::string::String,

        /// Upgrade status of the instance.
        pub upgrade_status: crate::model::upgrade_cluster_response::Status,

        /// Instance type.
        pub instance_type: crate::model::instance::InstanceType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceUpgradeDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::upgrade_cluster_response::InstanceUpgradeDetails::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [upgrade_status][crate::model::upgrade_cluster_response::InstanceUpgradeDetails::upgrade_status].
        pub fn set_upgrade_status<
            T: std::convert::Into<crate::model::upgrade_cluster_response::Status>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upgrade_status = v.into();
            self
        }

        /// Sets the value of [instance_type][crate::model::upgrade_cluster_response::InstanceUpgradeDetails::instance_type].
        pub fn set_instance_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_type = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceUpgradeDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse.InstanceUpgradeDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InstanceUpgradeDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __upgrade_status,
                __instance_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InstanceUpgradeDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "upgradeStatus" => Ok(__FieldTag::__upgrade_status),
                                "upgrade_status" => Ok(__FieldTag::__upgrade_status),
                                "instanceType" => Ok(__FieldTag::__instance_type),
                                "instance_type" => Ok(__FieldTag::__instance_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InstanceUpgradeDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InstanceUpgradeDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__upgrade_status => {
                                if !fields.insert(__FieldTag::__upgrade_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for upgrade_status",
                                    ));
                                }
                                result.upgrade_status = map
                                    .next_value::<std::option::Option<
                                        crate::model::upgrade_cluster_response::Status,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__instance_type => {
                                if !fields.insert(__FieldTag::__instance_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for instance_type",
                                    ));
                                }
                                result.instance_type = map.next_value::<std::option::Option<crate::model::instance::InstanceType>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InstanceUpgradeDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.upgrade_status) {
                state.serialize_entry("upgradeStatus", &self.upgrade_status)?;
            }
            if !wkt::internal::is_default(&self.instance_type) {
                state.serialize_entry("instanceType", &self.instance_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Upgrade details of a cluster. This cluster can be primary or secondary.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterUpgradeDetails {
        /// Normalized name of the cluster
        pub name: std::string::String,

        /// Upgrade status of the cluster.
        pub upgrade_status: crate::model::upgrade_cluster_response::Status,

        /// Cluster type which can either be primary or secondary.
        pub cluster_type: crate::model::cluster::ClusterType,

        /// Database version of the cluster after the upgrade operation. This will be
        /// the target version if the upgrade was successful otherwise it remains the
        /// same as that before the upgrade operation.
        pub database_version: crate::model::DatabaseVersion,

        /// Array containing stage info associated with this cluster.
        pub stage_info: std::vec::Vec<crate::model::upgrade_cluster_response::StageInfo>,

        /// Upgrade details of the instances directly associated with this cluster.
        pub instance_upgrade_details:
            std::vec::Vec<crate::model::upgrade_cluster_response::InstanceUpgradeDetails>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterUpgradeDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [upgrade_status][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::upgrade_status].
        pub fn set_upgrade_status<
            T: std::convert::Into<crate::model::upgrade_cluster_response::Status>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.upgrade_status = v.into();
            self
        }

        /// Sets the value of [cluster_type][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::cluster_type].
        pub fn set_cluster_type<T: std::convert::Into<crate::model::cluster::ClusterType>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_type = v.into();
            self
        }

        /// Sets the value of [database_version][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::database_version].
        pub fn set_database_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
            mut self,
            v: T,
        ) -> Self {
            self.database_version = v.into();
            self
        }

        /// Sets the value of [stage_info][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::stage_info].
        pub fn set_stage_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::upgrade_cluster_response::StageInfo>,
        {
            use std::iter::Iterator;
            self.stage_info = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [instance_upgrade_details][crate::model::upgrade_cluster_response::ClusterUpgradeDetails::instance_upgrade_details].
        pub fn set_instance_upgrade_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::upgrade_cluster_response::InstanceUpgradeDetails>,
        {
            use std::iter::Iterator;
            self.instance_upgrade_details = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ClusterUpgradeDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterResponse.ClusterUpgradeDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterUpgradeDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __upgrade_status,
                __cluster_type,
                __database_version,
                __stage_info,
                __instance_upgrade_details,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterUpgradeDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "upgradeStatus" => Ok(__FieldTag::__upgrade_status),
                                "upgrade_status" => Ok(__FieldTag::__upgrade_status),
                                "clusterType" => Ok(__FieldTag::__cluster_type),
                                "cluster_type" => Ok(__FieldTag::__cluster_type),
                                "databaseVersion" => Ok(__FieldTag::__database_version),
                                "database_version" => Ok(__FieldTag::__database_version),
                                "stageInfo" => Ok(__FieldTag::__stage_info),
                                "stage_info" => Ok(__FieldTag::__stage_info),
                                "instanceUpgradeDetails" => {
                                    Ok(__FieldTag::__instance_upgrade_details)
                                }
                                "instance_upgrade_details" => {
                                    Ok(__FieldTag::__instance_upgrade_details)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterUpgradeDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterUpgradeDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__upgrade_status => {
                                if !fields.insert(__FieldTag::__upgrade_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for upgrade_status",
                                    ));
                                }
                                result.upgrade_status = map
                                    .next_value::<std::option::Option<
                                        crate::model::upgrade_cluster_response::Status,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_type => {
                                if !fields.insert(__FieldTag::__cluster_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_type",
                                    ));
                                }
                                result.cluster_type = map.next_value::<std::option::Option<crate::model::cluster::ClusterType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__database_version => {
                                if !fields.insert(__FieldTag::__database_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for database_version",
                                    ));
                                }
                                result.database_version = map.next_value::<std::option::Option<crate::model::DatabaseVersion>>()?.unwrap_or_default();
                            }
                            __FieldTag::__stage_info => {
                                if !fields.insert(__FieldTag::__stage_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stage_info",
                                    ));
                                }
                                result.stage_info = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::upgrade_cluster_response::StageInfo,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__instance_upgrade_details => {
                                if !fields.insert(__FieldTag::__instance_upgrade_details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for instance_upgrade_details",
                                    ));
                                }
                                result.instance_upgrade_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::upgrade_cluster_response::InstanceUpgradeDetails>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterUpgradeDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.upgrade_status) {
                state.serialize_entry("upgradeStatus", &self.upgrade_status)?;
            }
            if !wkt::internal::is_default(&self.cluster_type) {
                state.serialize_entry("clusterType", &self.cluster_type)?;
            }
            if !wkt::internal::is_default(&self.database_version) {
                state.serialize_entry("databaseVersion", &self.database_version)?;
            }
            if !self.stage_info.is_empty() {
                state.serialize_entry("stageInfo", &self.stage_info)?;
            }
            if !self.instance_upgrade_details.is_empty() {
                state.serialize_entry("instanceUpgradeDetails", &self.instance_upgrade_details)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Status of upgrade operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unspecified status.
        Unspecified,
        /// Not started.
        NotStarted,
        /// In progress.
        InProgress,
        /// Operation succeeded.
        Success,
        /// Operation failed.
        Failed,
        /// Operation partially succeeded.
        PartialSuccess,
        /// Cancel is in progress.
        CancelInProgress,
        /// Cancellation complete.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotStarted => std::option::Option::Some(4),
                Self::InProgress => std::option::Option::Some(5),
                Self::Success => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::PartialSuccess => std::option::Option::Some(3),
                Self::CancelInProgress => std::option::Option::Some(6),
                Self::Cancelled => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                Self::CancelInProgress => std::option::Option::Some("CANCEL_IN_PROGRESS"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Success,
                2 => Self::Failed,
                3 => Self::PartialSuccess,
                4 => Self::NotStarted,
                5 => Self::InProgress,
                6 => Self::CancelInProgress,
                7 => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "NOT_STARTED" => Self::NotStarted,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCESS" => Self::Success,
                "FAILED" => Self::Failed,
                "PARTIAL_SUCCESS" => Self::PartialSuccess,
                "CANCEL_IN_PROGRESS" => Self::CancelInProgress,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotStarted => serializer.serialize_i32(4),
                Self::InProgress => serializer.serialize_i32(5),
                Self::Success => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::PartialSuccess => serializer.serialize_i32(3),
                Self::CancelInProgress => serializer.serialize_i32(6),
                Self::Cancelled => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.alloydb.v1.UpgradeClusterResponse.Status",
            ))
        }
    }

    /// Stage in the upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Stage {
        /// Unspecified stage.
        Unspecified,
        /// Pre-upgrade custom checks, not covered by pg_upgrade.
        AlloydbPrecheck,
        /// Pre-upgrade pg_upgrade checks.
        PgUpgradeCheck,
        /// Clone the original cluster.
        PrepareForUpgrade,
        /// Upgrade the primary instance(downtime).
        PrimaryInstanceUpgrade,
        /// This stage is read pool upgrade.
        ReadPoolInstancesUpgrade,
        /// Rollback in case of critical failures.
        Rollback,
        /// Cleanup.
        Cleanup,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Stage::value] or
        /// [Stage::name].
        UnknownValue(stage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Stage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AlloydbPrecheck => std::option::Option::Some(1),
                Self::PgUpgradeCheck => std::option::Option::Some(2),
                Self::PrepareForUpgrade => std::option::Option::Some(5),
                Self::PrimaryInstanceUpgrade => std::option::Option::Some(3),
                Self::ReadPoolInstancesUpgrade => std::option::Option::Some(4),
                Self::Rollback => std::option::Option::Some(6),
                Self::Cleanup => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STAGE_UNSPECIFIED"),
                Self::AlloydbPrecheck => std::option::Option::Some("ALLOYDB_PRECHECK"),
                Self::PgUpgradeCheck => std::option::Option::Some("PG_UPGRADE_CHECK"),
                Self::PrepareForUpgrade => std::option::Option::Some("PREPARE_FOR_UPGRADE"),
                Self::PrimaryInstanceUpgrade => {
                    std::option::Option::Some("PRIMARY_INSTANCE_UPGRADE")
                }
                Self::ReadPoolInstancesUpgrade => {
                    std::option::Option::Some("READ_POOL_INSTANCES_UPGRADE")
                }
                Self::Rollback => std::option::Option::Some("ROLLBACK"),
                Self::Cleanup => std::option::Option::Some("CLEANUP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Stage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Stage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Stage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AlloydbPrecheck,
                2 => Self::PgUpgradeCheck,
                3 => Self::PrimaryInstanceUpgrade,
                4 => Self::ReadPoolInstancesUpgrade,
                5 => Self::PrepareForUpgrade,
                6 => Self::Rollback,
                7 => Self::Cleanup,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Stage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STAGE_UNSPECIFIED" => Self::Unspecified,
                "ALLOYDB_PRECHECK" => Self::AlloydbPrecheck,
                "PG_UPGRADE_CHECK" => Self::PgUpgradeCheck,
                "PREPARE_FOR_UPGRADE" => Self::PrepareForUpgrade,
                "PRIMARY_INSTANCE_UPGRADE" => Self::PrimaryInstanceUpgrade,
                "READ_POOL_INSTANCES_UPGRADE" => Self::ReadPoolInstancesUpgrade,
                "ROLLBACK" => Self::Rollback,
                "CLEANUP" => Self::Cleanup,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Stage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AlloydbPrecheck => serializer.serialize_i32(1),
                Self::PgUpgradeCheck => serializer.serialize_i32(2),
                Self::PrepareForUpgrade => serializer.serialize_i32(5),
                Self::PrimaryInstanceUpgrade => serializer.serialize_i32(3),
                Self::ReadPoolInstancesUpgrade => serializer.serialize_i32(4),
                Self::Rollback => serializer.serialize_i32(6),
                Self::Cleanup => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Stage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Stage>::new(
                ".google.cloud.alloydb.v1.UpgradeClusterResponse.Stage",
            ))
        }
    }
}

/// Message for deleting a Cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. Whether to cascade delete child instances for given cluster.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __etag,
            __validate_only,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for switching over to a cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SwitchoverClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SwitchoverClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SwitchoverClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::SwitchoverClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::SwitchoverClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for SwitchoverClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.SwitchoverClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SwitchoverClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SwitchoverClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SwitchoverClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SwitchoverClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SwitchoverClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for promoting a Cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PromoteClusterRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Cluster.name field
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. The current etag of the Cluster.
    /// If an etag is provided and does not match the current etag of the Cluster,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PromoteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::PromoteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::PromoteClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::PromoteClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for PromoteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.PromoteClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PromoteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __etag,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PromoteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PromoteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PromoteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PromoteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for restoring a Cluster from a backup or another cluster at a given
/// point in time.
/// NEXT_ID: 11
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreClusterRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Cluster.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub cluster_id: std::string::String,

    /// Required. The resource being created
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Required.
    /// The source to import from.
    pub source: std::option::Option<crate::model::restore_cluster_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::RestoreClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::RestoreClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::RestoreClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::RestoreClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RestoreClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_cluster_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreClusterRequest::source]
    /// if it holds a `BackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_cluster_request::Source::BackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
    /// to hold a `BackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_backup_source<T: std::convert::Into<std::boxed::Box<crate::model::BackupSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_cluster_request::Source::BackupSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::RestoreClusterRequest::source]
    /// if it holds a `ContinuousBackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn continuous_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ContinuousBackupSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_cluster_request::Source::ContinuousBackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
    /// to hold a `ContinuousBackupSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_continuous_backup_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ContinuousBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_cluster_request::Source::ContinuousBackupSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestoreClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_source,
            __continuous_backup_source,
            __parent,
            __cluster_id,
            __cluster,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupSource" => Ok(__FieldTag::__backup_source),
                            "backup_source" => Ok(__FieldTag::__backup_source),
                            "continuousBackupSource" => Ok(__FieldTag::__continuous_backup_source),
                            "continuous_backup_source" => {
                                Ok(__FieldTag::__continuous_backup_source)
                            }
                            "parent" => Ok(__FieldTag::__parent),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_source => {
                            if !fields.insert(__FieldTag::__backup_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.alloydb.v1.RestoreClusterRequest.backup_source, latest field was backupSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::restore_cluster_request::Source::BackupSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BackupSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__continuous_backup_source => {
                            if !fields.insert(__FieldTag::__continuous_backup_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous_backup_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.alloydb.v1.RestoreClusterRequest.continuous_backup_source, latest field was continuousBackupSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::restore_cluster_request::Source::ContinuousBackupSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ContinuousBackupSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.backup_source() {
            state.serialize_entry("backupSource", value)?;
        }
        if let Some(value) = self.continuous_backup_source() {
            state.serialize_entry("continuousBackupSource", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreClusterRequest].
pub mod restore_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required.
    /// The source to import from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Backup source.
        BackupSource(std::boxed::Box<crate::model::BackupSource>),
        /// ContinuousBackup source. Continuous backup needs to be enabled in the
        /// source cluster for this operation to succeed.
        ContinuousBackupSource(std::boxed::Box<crate::model::ContinuousBackupSource>),
    }
}

/// Message for requesting list of Instances
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field. Additionally, you can perform an
    /// aggregated list operation by specifying a value with one of the following
    /// formats:
    ///
    /// * projects/{project}/locations/-/clusters/-
    /// * projects/{project}/locations/{region}/clusters/-
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing Instances
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of Instance
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Instance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a Instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// The view of the instance to return.
    pub view: crate::model::InstanceView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetInstanceRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::InstanceView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::InstanceView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a Instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub instance_id: std::string::String,

    /// Required. The resource being created
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __instance_id,
            __instance,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a Secondary Instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSecondaryInstanceRequest {
    /// Required. The name of the parent resource. For the required format, see the
    /// comment on the Instance.name field.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub instance_id: std::string::String,

    /// Required. The resource being created
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSecondaryInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecondaryInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateSecondaryInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateSecondaryInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateSecondaryInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSecondaryInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateSecondaryInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateSecondaryInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateSecondaryInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSecondaryInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __instance_id,
            __instance,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSecondaryInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSecondaryInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSecondaryInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSecondaryInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// See usage below for notes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequests {
    /// Required. Primary and read replica instances to be created. This list
    /// should not be empty.
    pub create_instance_requests: std::vec::Vec<crate::model::CreateInstanceRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequests {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_instance_requests][crate::model::CreateInstanceRequests::create_instance_requests].
    pub fn set_create_instance_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CreateInstanceRequest>,
    {
        use std::iter::Iterator;
        self.create_instance_requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequests {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateInstanceRequests"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceRequests {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_instance_requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceRequests")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createInstanceRequests" => Ok(__FieldTag::__create_instance_requests),
                            "create_instance_requests" => {
                                Ok(__FieldTag::__create_instance_requests)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceRequests;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceRequests")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_instance_requests => {
                            if !fields.insert(__FieldTag::__create_instance_requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_instance_requests",
                                ));
                            }
                            result.create_instance_requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CreateInstanceRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceRequests {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.create_instance_requests.is_empty() {
            state.serialize_entry("createInstanceRequests", &self.create_instance_requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a batch of instances under the specified cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstancesRequest {
    /// Required. The name of the parent resource.
    pub parent: std::string::String,

    /// Required. Resources being created.
    pub requests: std::option::Option<crate::model::CreateInstanceRequests>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchCreateInstancesRequest::requests].
    pub fn set_requests<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateInstanceRequests>,
    {
        self.requests = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requests][crate::model::BatchCreateInstancesRequest::requests].
    pub fn set_or_clear_requests<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateInstanceRequests>,
    {
        self.requests = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::BatchCreateInstancesRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __requests,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requests" => Ok(__FieldTag::__requests),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map.next_value::<std::option::Option<crate::model::CreateInstanceRequests>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.requests.is_some() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating batches of instances in a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstancesResponse {
    /// Created instances.
    pub instances: std::vec::Vec<crate::model::Instance>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::BatchCreateInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Instance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for metadata that is specific to BatchCreateInstances API.
/// NEXT_ID: 3
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstancesMetadata {
    /// The instances being created in the API call. Each string in this list
    /// is the server defined resource path for target instances in the request
    /// and for the format of each string, see the comment on the Instance.name
    /// field.
    pub instance_targets: std::vec::Vec<std::string::String>,

    /// A map representing state of the instances involved in the
    /// BatchCreateInstances operation during the operation execution.
    /// The instance state will be in STATE_UNSPECIFIED state if the instance has
    /// not yet been picked up for processing.
    /// The key of the map is the name of the instance resource.
    /// For the format, see the comment on the Instance.name field.
    pub instance_statuses:
        std::collections::HashMap<std::string::String, crate::model::BatchCreateInstanceStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstancesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_targets][crate::model::BatchCreateInstancesMetadata::instance_targets].
    pub fn set_instance_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_statuses][crate::model::BatchCreateInstancesMetadata::instance_statuses].
    pub fn set_instance_statuses<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BatchCreateInstanceStatus>,
    {
        use std::iter::Iterator;
        self.instance_statuses = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateInstancesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstancesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateInstancesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_targets,
            __instance_statuses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateInstancesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceTargets" => Ok(__FieldTag::__instance_targets),
                            "instance_targets" => Ok(__FieldTag::__instance_targets),
                            "instanceStatuses" => Ok(__FieldTag::__instance_statuses),
                            "instance_statuses" => Ok(__FieldTag::__instance_statuses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateInstancesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateInstancesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_targets => {
                            if !fields.insert(__FieldTag::__instance_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_targets",
                                ));
                            }
                            result.instance_targets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_statuses => {
                            if !fields.insert(__FieldTag::__instance_statuses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_statuses",
                                ));
                            }
                            result.instance_statuses = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::BatchCreateInstanceStatus,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateInstancesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_targets.is_empty() {
            state.serialize_entry("instanceTargets", &self.instance_targets)?;
        }
        if !self.instance_statuses.is_empty() {
            state.serialize_entry("instanceStatuses", &self.instance_statuses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for current status of an instance in the BatchCreateInstances
/// operation.
/// For example, lets say a BatchCreateInstances workflow has 4 instances,
/// Instance1 through Instance4. Lets also assume that 2 instances succeeded
/// but the third failed to create and the 4th was never picked up for creation
/// because of failure of the previous one. Then, resulting states would look
/// something like:
///
/// 1. Instance1 = ROLLED_BACK
/// 1. Instance2 = ROLLED_BACK
/// 1. Instance3 = FAILED
/// 1. Instance4 = FAILED
///
/// However, while the operation is running, the instance might be in other
/// states including PENDING_CREATE, ACTIVE, DELETING and CREATING. The states
/// / do not get further updated once the operation is done.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateInstanceStatus {
    /// The current state of an instance involved in the batch create operation.
    /// Once the operation is complete, the final state of the instances in the
    /// LRO can be one of:
    ///
    /// 1. ACTIVE, indicating that instances were created successfully
    /// 1. FAILED, indicating that a particular instance failed creation
    /// 1. ROLLED_BACK indicating that although the instance was created
    ///    successfully, it had to be rolled back and deleted due to failure in
    ///    other steps of the workflow.
    pub state: crate::model::batch_create_instance_status::State,

    /// DEPRECATED - Use the error field instead.
    /// Error, if any error occurred and is available, during instance creation.
    pub error_msg: std::string::String,

    /// The RPC status of the instance creation operation. This field will be
    /// present if an error happened during the instance creation.
    pub error: std::option::Option<rpc::model::Status>,

    pub r#type: crate::model::instance::InstanceType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateInstanceStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchCreateInstanceStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_create_instance_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error_msg][crate::model::BatchCreateInstanceStatus::error_msg].
    pub fn set_error_msg<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_msg = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BatchCreateInstanceStatus::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::BatchCreateInstanceStatus::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::BatchCreateInstanceStatus::type].
    pub fn set_type<T: std::convert::Into<crate::model::instance::InstanceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for BatchCreateInstanceStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.BatchCreateInstanceStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateInstanceStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __error_msg,
            __error,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateInstanceStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "errorMsg" => Ok(__FieldTag::__error_msg),
                            "error_msg" => Ok(__FieldTag::__error_msg),
                            "error" => Ok(__FieldTag::__error),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateInstanceStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateInstanceStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::batch_create_instance_status::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_msg => {
                            if !fields.insert(__FieldTag::__error_msg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_msg",
                                ));
                            }
                            result.error_msg = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::instance::InstanceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateInstanceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.error_msg.is_empty() {
            state.serialize_entry("errorMsg", &self.error_msg)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchCreateInstanceStatus].
pub mod batch_create_instance_status {
    #[allow(unused_imports)]
    use super::*;

    /// State contains all valid instance states for the BatchCreateInstances
    /// operation. This is mainly used for status reporting through the LRO
    /// metadata.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the instance is unknown.
        Unspecified,
        /// Instance is pending creation and has not yet been picked up for
        /// processing in the backend.
        PendingCreate,
        /// The instance is active and running.
        Ready,
        /// The instance is being created.
        Creating,
        /// The instance is being deleted.
        Deleting,
        /// The creation of the instance failed or a fatal error occurred during
        /// an operation on the instance or a batch of instances.
        Failed,
        /// The instance was created successfully, but was rolled back and deleted
        /// due to some other failure during BatchCreateInstances operation.
        RolledBack,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PendingCreate => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::RolledBack => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::PendingCreate => std::option::Option::Some("PENDING_CREATE"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::RolledBack => std::option::Option::Some("ROLLED_BACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PendingCreate,
                2 => Self::Ready,
                3 => Self::Creating,
                4 => Self::Deleting,
                5 => Self::Failed,
                6 => Self::RolledBack,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING_CREATE" => Self::PendingCreate,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "ROLLED_BACK" => Self::RolledBack,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PendingCreate => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::RolledBack => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.alloydb.v1.BatchCreateInstanceStatus.State",
            ))
        }
    }
}

/// Message for updating a Instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Instance resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if instance is not found. In
    /// that case, a new instance is created and `update_mask` is ignored.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateInstanceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __instance,
            __request_id,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "instance" => Ok(__FieldTag::__instance),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a Instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. The current etag of the Instance.
    /// If an etag is provided and does not match the current etag of the Instance,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteInstanceRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __etag,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "etag" => Ok(__FieldTag::__etag),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for triggering failover on an Instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FailoverInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailoverInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FailoverInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::FailoverInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::FailoverInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for FailoverInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.FailoverInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FailoverInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailoverInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FailoverInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailoverInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FailoverInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for triggering fault injection on an instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InjectFaultRequest {
    /// Required. The type of fault to be injected in an instance.
    pub fault_type: crate::model::inject_fault_request::FaultType,

    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InjectFaultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fault_type][crate::model::InjectFaultRequest::fault_type].
    pub fn set_fault_type<T: std::convert::Into<crate::model::inject_fault_request::FaultType>>(
        mut self,
        v: T,
    ) -> Self {
        self.fault_type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::InjectFaultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InjectFaultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::InjectFaultRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for InjectFaultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.InjectFaultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InjectFaultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fault_type,
            __name,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InjectFaultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "faultType" => Ok(__FieldTag::__fault_type),
                            "fault_type" => Ok(__FieldTag::__fault_type),
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InjectFaultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InjectFaultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fault_type => {
                            if !fields.insert(__FieldTag::__fault_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fault_type",
                                ));
                            }
                            result.fault_type =
                                map.next_value::<std::option::Option<
                                    crate::model::inject_fault_request::FaultType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InjectFaultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.fault_type) {
            state.serialize_entry("faultType", &self.fault_type)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InjectFaultRequest].
pub mod inject_fault_request {
    #[allow(unused_imports)]
    use super::*;

    /// FaultType contains all valid types of faults that can be injected to an
    /// instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FaultType {
        /// The fault type is unknown.
        Unspecified,
        /// Stop the VM
        StopVm,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FaultType::value] or
        /// [FaultType::name].
        UnknownValue(fault_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod fault_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FaultType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StopVm => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FAULT_TYPE_UNSPECIFIED"),
                Self::StopVm => std::option::Option::Some("STOP_VM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FaultType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FaultType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FaultType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StopVm,
                _ => Self::UnknownValue(fault_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FaultType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAULT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STOP_VM" => Self::StopVm,
                _ => Self::UnknownValue(fault_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FaultType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StopVm => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FaultType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FaultType>::new(
                ".google.cloud.alloydb.v1.InjectFaultRequest.FaultType",
            ))
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestartInstanceRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the Instance.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, performs request validation, for example, permission
    /// checks and any other type of validation, but does not actually execute the
    /// create request.
    pub validate_only: bool,

    /// Optional. Full name of the nodes as obtained from INSTANCE_VIEW_FULL to
    /// restart upon. Applicable only to read instances.
    pub node_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RestartInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::RestartInstanceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [node_ids][crate::model::RestartInstanceRequest::node_ids].
    pub fn set_node_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.node_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RestartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.RestartInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestartInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            __node_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestartInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "nodeIds" => Ok(__FieldTag::__node_ids),
                            "node_ids" => Ok(__FieldTag::__node_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestartInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestartInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_ids => {
                            if !fields.insert(__FieldTag::__node_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_ids",
                                ));
                            }
                            result.node_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestartInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.node_ids.is_empty() {
            state.serialize_entry("nodeIds", &self.node_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for ExecuteSql rpc.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteSqlRequest {
    /// Required. The instance where the SQL will be executed. For the required
    /// format, see the comment on the Instance.name field.
    pub instance: std::string::String,

    /// Required. Name of the database where the query will be executed.
    /// Note - Value provided should be the same as expected from `SELECT
    /// current_database();` and NOT as a resource reference.
    pub database: std::string::String,

    /// Required. Database user to be used for executing the SQL.
    /// Note - Value provided should be the same as expected from
    /// `SELECT current_user;` and NOT as a resource reference.
    pub user: std::string::String,

    /// Required. SQL statement to execute on database. Any valid statement is
    /// permitted, including DDL, DML, DQL statements.
    pub sql_statement: std::string::String,

    /// Oneof field to support other credential mechanisms in future like
    /// SecretManager etc.
    pub user_credential: std::option::Option<crate::model::execute_sql_request::UserCredential>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteSqlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::ExecuteSqlRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [database][crate::model::ExecuteSqlRequest::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [user][crate::model::ExecuteSqlRequest::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [sql_statement][crate::model::ExecuteSqlRequest::sql_statement].
    pub fn set_sql_statement<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_statement = v.into();
        self
    }

    /// Sets the value of [user_credential][crate::model::ExecuteSqlRequest::user_credential].
    ///
    /// Note that all the setters affecting `user_credential` are mutually
    /// exclusive.
    pub fn set_user_credential<
        T: std::convert::Into<std::option::Option<crate::model::execute_sql_request::UserCredential>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_credential = v.into();
        self
    }

    /// The value of [user_credential][crate::model::ExecuteSqlRequest::user_credential]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.user_credential.as_ref().and_then(|v| match v {
            crate::model::execute_sql_request::UserCredential::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [user_credential][crate::model::ExecuteSqlRequest::user_credential]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `user_credential` are
    /// mutually exclusive.
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_credential = std::option::Option::Some(
            crate::model::execute_sql_request::UserCredential::Password(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecuteSqlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecuteSqlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __password,
            __instance,
            __database,
            __user,
            __sql_statement,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecuteSqlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "password" => Ok(__FieldTag::__password),
                            "instance" => Ok(__FieldTag::__instance),
                            "database" => Ok(__FieldTag::__database),
                            "user" => Ok(__FieldTag::__user),
                            "sqlStatement" => Ok(__FieldTag::__sql_statement),
                            "sql_statement" => Ok(__FieldTag::__sql_statement),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecuteSqlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecuteSqlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            if result.user_credential.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `user_credential`, a oneof with full ID .google.cloud.alloydb.v1.ExecuteSqlRequest.password, latest field was password",
                                ));
                            }
                            result.user_credential = std::option::Option::Some(
                                crate::model::execute_sql_request::UserCredential::Password(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_statement => {
                            if !fields.insert(__FieldTag::__sql_statement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_statement",
                                ));
                            }
                            result.sql_statement = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecuteSqlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.password() {
            state.serialize_entry("password", value)?;
        }
        if !self.instance.is_empty() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.sql_statement.is_empty() {
            state.serialize_entry("sqlStatement", &self.sql_statement)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExecuteSqlRequest].
pub mod execute_sql_request {
    #[allow(unused_imports)]
    use super::*;

    /// Oneof field to support other credential mechanisms in future like
    /// SecretManager etc.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserCredential {
        /// Optional. The database native user’s password.
        Password(std::string::String),
    }
}

/// Execute a SQL statement response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteSqlResponse {
    /// SqlResult represents the results for the execution of sql statements.
    pub sql_results: std::vec::Vec<crate::model::SqlResult>,

    /// Any additional metadata information regarding the execution of the sql
    /// statement.
    pub metadata: std::option::Option<crate::model::ExecuteSqlMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteSqlResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_results][crate::model::ExecuteSqlResponse::sql_results].
    pub fn set_sql_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlResult>,
    {
        use std::iter::Iterator;
        self.sql_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::ExecuteSqlResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecuteSqlMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::ExecuteSqlResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecuteSqlMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExecuteSqlResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecuteSqlResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_results,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecuteSqlResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlResults" => Ok(__FieldTag::__sql_results),
                            "sql_results" => Ok(__FieldTag::__sql_results),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecuteSqlResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecuteSqlResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_results => {
                            if !fields.insert(__FieldTag::__sql_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_results",
                                ));
                            }
                            result.sql_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SqlResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::ExecuteSqlMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecuteSqlResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sql_results.is_empty() {
            state.serialize_entry("sqlResults", &self.sql_results)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Any additional metadata information regarding the execution of the SQL
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecuteSqlMetadata {
    /// Message related to SQL execution. Marked as core content since it
    /// can potentially contain details related to the query or result set. This
    /// field can be used to convey messages such as "when the SQL result set
    /// exceeds the acceptable response size limits."
    pub message: std::string::String,

    /// Set to true if SQL returned a result set larger than the acceptable
    /// response size limits and the result was truncated.
    pub partial_result: bool,

    /// The time duration taken to execute the sql statement.
    pub sql_statement_execution_duration: std::option::Option<wkt::Duration>,

    /// Status of SQL execution.
    pub status: crate::model::execute_sql_metadata::Status,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecuteSqlMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::ExecuteSqlMetadata::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [partial_result][crate::model::ExecuteSqlMetadata::partial_result].
    pub fn set_partial_result<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.partial_result = v.into();
        self
    }

    /// Sets the value of [sql_statement_execution_duration][crate::model::ExecuteSqlMetadata::sql_statement_execution_duration].
    pub fn set_sql_statement_execution_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.sql_statement_execution_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sql_statement_execution_duration][crate::model::ExecuteSqlMetadata::sql_statement_execution_duration].
    pub fn set_or_clear_sql_statement_execution_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.sql_statement_execution_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::ExecuteSqlMetadata::status].
    pub fn set_status<T: std::convert::Into<crate::model::execute_sql_metadata::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for ExecuteSqlMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ExecuteSqlMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecuteSqlMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            __partial_result,
            __sql_statement_execution_duration,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecuteSqlMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            "partialResult" => Ok(__FieldTag::__partial_result),
                            "partial_result" => Ok(__FieldTag::__partial_result),
                            "sqlStatementExecutionDuration" => {
                                Ok(__FieldTag::__sql_statement_execution_duration)
                            }
                            "sql_statement_execution_duration" => {
                                Ok(__FieldTag::__sql_statement_execution_duration)
                            }
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecuteSqlMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecuteSqlMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partial_result => {
                            if !fields.insert(__FieldTag::__partial_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_result",
                                ));
                            }
                            result.partial_result = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_statement_execution_duration => {
                            if !fields.insert(__FieldTag::__sql_statement_execution_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_statement_execution_duration",
                                ));
                            }
                            result.sql_statement_execution_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::execute_sql_metadata::Status>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecuteSqlMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.partial_result) {
            state.serialize_entry("partialResult", &self.partial_result)?;
        }
        if self.sql_statement_execution_duration.is_some() {
            state.serialize_entry(
                "sqlStatementExecutionDuration",
                &self.sql_statement_execution_duration,
            )?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExecuteSqlMetadata].
pub mod execute_sql_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Status contains all valid Status a SQL execution can end up in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// The status is unknown.
        Unspecified,
        /// No error during SQL execution i.e. All SQL statements ran to completion.
        /// The "message" will be empty.
        Ok,
        /// Same as OK, except indicates that only partial results were
        /// returned. The "message" field will contain details on why results were
        /// truncated.
        Partial,
        /// Error during SQL execution. Atleast 1 SQL statement execution resulted in
        /// a error. Side effects of other statements are rolled back.  The "message"
        /// field will contain human readable error given by Postgres of the first
        /// bad SQL statement. SQL execution errors don't constitute API errors as
        /// defined in <https://google.aip.dev/193> but will be returned as part of
        /// this message.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ok => std::option::Option::Some(1),
                Self::Partial => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Ok => std::option::Option::Some("OK"),
                Self::Partial => std::option::Option::Some("PARTIAL"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ok,
                2 => Self::Partial,
                3 => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "OK" => Self::Ok,
                "PARTIAL" => Self::Partial,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ok => serializer.serialize_i32(1),
                Self::Partial => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.alloydb.v1.ExecuteSqlMetadata.Status",
            ))
        }
    }
}

/// Message for requesting list of Backups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. Parent value for ListBackupsRequest
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Filtering results
    pub filter: std::string::String,

    /// Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing Backups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of Backup
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backups" => Ok(__FieldTag::__backups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backups => {
                            if !fields.insert(__FieldTag::__backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backups",
                                ));
                            }
                            result.backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Backup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backups.is_empty() {
            state.serialize_entry("backups", &self.backups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a Backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the resource
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a Backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub backup_id: std::string::String,

    /// Required. The resource being created
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateBackupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_id,
            __backup,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupId" => Ok(__FieldTag::__backup_id),
                            "backup_id" => Ok(__FieldTag::__backup_id),
                            "backup" => Ok(__FieldTag::__backup),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_id => {
                            if !fields.insert(__FieldTag::__backup_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_id",
                                ));
                            }
                            result.backup_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_id.is_empty() {
            state.serialize_entry("backupId", &self.backup_id)?;
        }
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a Backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Backup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. If set to true, update succeeds even if instance is not found. In
    /// that case, a new backup is created and `update_mask` is ignored.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateBackupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateBackupRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __backup,
            __request_id,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "backup" => Ok(__FieldTag::__backup),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a Backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the resource. For the required format, see the comment on
    /// the Backup.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. The current etag of the Backup.
    /// If an etag is provided and does not match the current etag of the Backup,
    /// deletion will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteBackupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for listing the information about the supported Database flags.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSupportedDatabaseFlagsRequest {
    /// Required. The name of the parent resource. The required format is:
    ///
    /// * projects/{project}/locations/{location}
    ///
    /// Regardless of the parent specified here, as long it is contains a valid
    /// project and location, the service will return a static list of supported
    /// flags resources. Note that we do not yet support region-specific
    /// flags.
    pub parent: std::string::String,

    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. The scope for which supported flags are requested. If not
    /// specified, default is DATABASE.
    pub scope: crate::model::supported_database_flag::Scope,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSupportedDatabaseFlagsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSupportedDatabaseFlagsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSupportedDatabaseFlagsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSupportedDatabaseFlagsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::ListSupportedDatabaseFlagsRequest::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::supported_database_flag::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for ListSupportedDatabaseFlagsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListSupportedDatabaseFlagsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSupportedDatabaseFlagsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSupportedDatabaseFlagsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSupportedDatabaseFlagsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSupportedDatabaseFlagsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope =
                                map.next_value::<std::option::Option<
                                    crate::model::supported_database_flag::Scope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSupportedDatabaseFlagsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing SupportedDatabaseFlags.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSupportedDatabaseFlagsResponse {
    /// The list of SupportedDatabaseFlags.
    pub supported_database_flags: std::vec::Vec<crate::model::SupportedDatabaseFlag>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSupportedDatabaseFlagsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [supported_database_flags][crate::model::ListSupportedDatabaseFlagsResponse::supported_database_flags].
    pub fn set_supported_database_flags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SupportedDatabaseFlag>,
    {
        use std::iter::Iterator;
        self.supported_database_flags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSupportedDatabaseFlagsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSupportedDatabaseFlagsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListSupportedDatabaseFlagsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSupportedDatabaseFlagsResponse {
    type PageItem = crate::model::SupportedDatabaseFlag;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.supported_database_flags
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSupportedDatabaseFlagsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __supported_database_flags,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSupportedDatabaseFlagsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "supportedDatabaseFlags" => Ok(__FieldTag::__supported_database_flags),
                            "supported_database_flags" => {
                                Ok(__FieldTag::__supported_database_flags)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSupportedDatabaseFlagsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSupportedDatabaseFlagsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__supported_database_flags => {
                            if !fields.insert(__FieldTag::__supported_database_flags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_database_flags",
                                ));
                            }
                            result.supported_database_flags = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SupportedDatabaseFlag>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSupportedDatabaseFlagsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.supported_database_flags.is_empty() {
            state.serialize_entry("supportedDatabaseFlags", &self.supported_database_flags)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requests to generate a client certificate signed by the Cluster
/// CA.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateClientCertificateRequest {
    /// Required. The name of the parent resource. The required format is:
    ///
    /// * projects/{project}/locations/{location}/clusters/{cluster}
    pub parent: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. An optional hint to the endpoint to generate the client
    /// certificate with the requested duration. The duration can be from 1 hour to
    /// 24 hours. The endpoint may or may not honor the hint. If the hint is left
    /// unspecified or is not honored, then the endpoint will pick an appropriate
    /// default duration.
    pub cert_duration: std::option::Option<wkt::Duration>,

    /// Optional. The public key from the client.
    pub public_key: std::string::String,

    /// Optional. An optional hint to the endpoint to generate a client certificate
    /// that can be used by AlloyDB connectors to exchange additional metadata with
    /// the server after TLS handshake.
    pub use_metadata_exchange: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateClientCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GenerateClientCertificateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::GenerateClientCertificateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [cert_duration][crate::model::GenerateClientCertificateRequest::cert_duration].
    pub fn set_cert_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cert_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cert_duration][crate::model::GenerateClientCertificateRequest::cert_duration].
    pub fn set_or_clear_cert_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cert_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [public_key][crate::model::GenerateClientCertificateRequest::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [use_metadata_exchange][crate::model::GenerateClientCertificateRequest::use_metadata_exchange].
    pub fn set_use_metadata_exchange<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_metadata_exchange = v.into();
        self
    }
}

impl wkt::message::Message for GenerateClientCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GenerateClientCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateClientCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __request_id,
            __cert_duration,
            __public_key,
            __use_metadata_exchange,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateClientCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "certDuration" => Ok(__FieldTag::__cert_duration),
                            "cert_duration" => Ok(__FieldTag::__cert_duration),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "useMetadataExchange" => Ok(__FieldTag::__use_metadata_exchange),
                            "use_metadata_exchange" => Ok(__FieldTag::__use_metadata_exchange),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateClientCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateClientCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cert_duration => {
                            if !fields.insert(__FieldTag::__cert_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_duration",
                                ));
                            }
                            result.cert_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_metadata_exchange => {
                            if !fields.insert(__FieldTag::__use_metadata_exchange) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_metadata_exchange",
                                ));
                            }
                            result.use_metadata_exchange = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateClientCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if self.cert_duration.is_some() {
            state.serialize_entry("certDuration", &self.cert_duration)?;
        }
        if !self.public_key.is_empty() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if !wkt::internal::is_default(&self.use_metadata_exchange) {
            state.serialize_entry("useMetadataExchange", &self.use_metadata_exchange)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message returned by a GenerateClientCertificate operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateClientCertificateResponse {
    /// Output only. The pem-encoded chain that may be used to verify the X.509
    /// certificate. Expected to be in issuer-to-root order according to RFC 5246.
    pub pem_certificate_chain: std::vec::Vec<std::string::String>,

    /// Optional. The pem-encoded cluster ca X.509 certificate.
    pub ca_cert: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateClientCertificateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pem_certificate_chain][crate::model::GenerateClientCertificateResponse::pem_certificate_chain].
    pub fn set_pem_certificate_chain<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pem_certificate_chain = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ca_cert][crate::model::GenerateClientCertificateResponse::ca_cert].
    pub fn set_ca_cert<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_cert = v.into();
        self
    }
}

impl wkt::message::Message for GenerateClientCertificateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GenerateClientCertificateResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateClientCertificateResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pem_certificate_chain,
            __ca_cert,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateClientCertificateResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pemCertificateChain" => Ok(__FieldTag::__pem_certificate_chain),
                            "pem_certificate_chain" => Ok(__FieldTag::__pem_certificate_chain),
                            "caCert" => Ok(__FieldTag::__ca_cert),
                            "ca_cert" => Ok(__FieldTag::__ca_cert),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateClientCertificateResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateClientCertificateResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pem_certificate_chain => {
                            if !fields.insert(__FieldTag::__pem_certificate_chain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_certificate_chain",
                                ));
                            }
                            result.pem_certificate_chain = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ca_cert => {
                            if !fields.insert(__FieldTag::__ca_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_cert",
                                ));
                            }
                            result.ca_cert = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateClientCertificateResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pem_certificate_chain.is_empty() {
            state.serialize_entry("pemCertificateChain", &self.pem_certificate_chain)?;
        }
        if !self.ca_cert.is_empty() {
            state.serialize_entry("caCert", &self.ca_cert)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetConnectionInfo.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionInfoRequest {
    /// Required. The name of the parent resource. The required format is:
    /// projects/{project}/locations/{location}/clusters/{cluster}/instances/{instance}
    pub parent: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetConnectionInfoRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::GetConnectionInfoRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetConnectionInfoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    /// Request specific metadata, if any.
    pub request_specific: std::option::Option<crate::model::operation_metadata::RequestSpecific>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [request_specific][crate::model::OperationMetadata::request_specific].
    ///
    /// Note that all the setters affecting `request_specific` are mutually
    /// exclusive.
    pub fn set_request_specific<
        T: std::convert::Into<std::option::Option<crate::model::operation_metadata::RequestSpecific>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = v.into();
        self
    }

    /// The value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// if it holds a `BatchCreateInstancesMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn batch_create_instances_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BatchCreateInstancesMetadata>> {
        #[allow(unreachable_patterns)]
        self.request_specific.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// to hold a `BatchCreateInstancesMetadata`.
    ///
    /// Note that all the setters affecting `request_specific` are
    /// mutually exclusive.
    pub fn set_batch_create_instances_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::BatchCreateInstancesMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = std::option::Option::Some(
            crate::model::operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(
                v.into(),
            ),
        );
        self
    }

    /// The value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// if it holds a `UpgradeClusterStatus`, `None` if the field is not set or
    /// holds a different branch.
    pub fn upgrade_cluster_status(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpgradeClusterStatus>> {
        #[allow(unreachable_patterns)]
        self.request_specific.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::RequestSpecific::UpgradeClusterStatus(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request_specific][crate::model::OperationMetadata::request_specific]
    /// to hold a `UpgradeClusterStatus`.
    ///
    /// Note that all the setters affecting `request_specific` are
    /// mutually exclusive.
    pub fn set_upgrade_cluster_status<
        T: std::convert::Into<std::boxed::Box<crate::model::UpgradeClusterStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request_specific = std::option::Option::Some(
            crate::model::operation_metadata::RequestSpecific::UpgradeClusterStatus(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __batch_create_instances_metadata,
            __upgrade_cluster_status,
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "batchCreateInstancesMetadata" => {
                                Ok(__FieldTag::__batch_create_instances_metadata)
                            }
                            "batch_create_instances_metadata" => {
                                Ok(__FieldTag::__batch_create_instances_metadata)
                            }
                            "upgradeClusterStatus" => Ok(__FieldTag::__upgrade_cluster_status),
                            "upgrade_cluster_status" => Ok(__FieldTag::__upgrade_cluster_status),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__batch_create_instances_metadata => {
                            if !fields.insert(__FieldTag::__batch_create_instances_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_create_instances_metadata",
                                ));
                            }
                            if result.request_specific.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request_specific`, a oneof with full ID .google.cloud.alloydb.v1.OperationMetadata.batch_create_instances_metadata, latest field was batchCreateInstancesMetadata",
                                ));
                            }
                            result.request_specific = std::option::Option::Some(
                                crate::model::operation_metadata::RequestSpecific::BatchCreateInstancesMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::BatchCreateInstancesMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__upgrade_cluster_status => {
                            if !fields.insert(__FieldTag::__upgrade_cluster_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_cluster_status",
                                ));
                            }
                            if result.request_specific.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request_specific`, a oneof with full ID .google.cloud.alloydb.v1.OperationMetadata.upgrade_cluster_status, latest field was upgradeClusterStatus",
                                ));
                            }
                            result.request_specific = std::option::Option::Some(
                                crate::model::operation_metadata::RequestSpecific::UpgradeClusterStatus(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::UpgradeClusterStatus>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.batch_create_instances_metadata() {
            state.serialize_entry("batchCreateInstancesMetadata", value)?;
        }
        if let Some(value) = self.upgrade_cluster_status() {
            state.serialize_entry("upgradeClusterStatus", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Request specific metadata, if any.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RequestSpecific {
        /// Output only. BatchCreateInstances related metadata.
        BatchCreateInstancesMetadata(std::boxed::Box<crate::model::BatchCreateInstancesMetadata>),
        /// Output only. UpgradeClusterStatus related metadata.
        UpgradeClusterStatus(std::boxed::Box<crate::model::UpgradeClusterStatus>),
    }
}

/// Message for current status of the Major Version Upgrade operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterStatus {
    /// Cluster Major Version Upgrade state.
    pub state: crate::model::upgrade_cluster_response::Status,

    /// Whether the operation is cancellable.
    pub cancellable: bool,

    /// Source database major version.
    pub source_version: crate::model::DatabaseVersion,

    /// Target database major version.
    pub target_version: crate::model::DatabaseVersion,

    /// Status of all upgrade stages.
    pub stages: std::vec::Vec<crate::model::upgrade_cluster_status::StageStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::UpgradeClusterStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cancellable][crate::model::UpgradeClusterStatus::cancellable].
    pub fn set_cancellable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancellable = v.into();
        self
    }

    /// Sets the value of [source_version][crate::model::UpgradeClusterStatus::source_version].
    pub fn set_source_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeClusterStatus::target_version].
    pub fn set_target_version<T: std::convert::Into<crate::model::DatabaseVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [stages][crate::model::UpgradeClusterStatus::stages].
    pub fn set_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::upgrade_cluster_status::StageStatus>,
    {
        use std::iter::Iterator;
        self.stages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpgradeClusterStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeClusterStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __cancellable,
            __source_version,
            __target_version,
            __stages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeClusterStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "cancellable" => Ok(__FieldTag::__cancellable),
                            "sourceVersion" => Ok(__FieldTag::__source_version),
                            "source_version" => Ok(__FieldTag::__source_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "stages" => Ok(__FieldTag::__stages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeClusterStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeClusterStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::upgrade_cluster_response::Status,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cancellable => {
                            if !fields.insert(__FieldTag::__cancellable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancellable",
                                ));
                            }
                            result.cancellable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_version => {
                            if !fields.insert(__FieldTag::__source_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_version",
                                ));
                            }
                            result.source_version = map
                                .next_value::<std::option::Option<crate::model::DatabaseVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<crate::model::DatabaseVersion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stages => {
                            if !fields.insert(__FieldTag::__stages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stages",
                                ));
                            }
                            result.stages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::upgrade_cluster_status::StageStatus,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeClusterStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.cancellable) {
            state.serialize_entry("cancellable", &self.cancellable)?;
        }
        if !wkt::internal::is_default(&self.source_version) {
            state.serialize_entry("sourceVersion", &self.source_version)?;
        }
        if !wkt::internal::is_default(&self.target_version) {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self.stages.is_empty() {
            state.serialize_entry("stages", &self.stages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UpgradeClusterStatus].
pub mod upgrade_cluster_status {
    #[allow(unused_imports)]
    use super::*;

    /// Status of an upgrade stage.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StageStatus {
        /// Upgrade stage.
        pub stage: crate::model::upgrade_cluster_response::Stage,

        /// State of this stage.
        pub state: crate::model::upgrade_cluster_response::Status,

        /// Stage specific status information, if any.
        pub stage_specific_status: std::option::Option<
            crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StageStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [stage][crate::model::upgrade_cluster_status::StageStatus::stage].
        pub fn set_stage<T: std::convert::Into<crate::model::upgrade_cluster_response::Stage>>(
            mut self,
            v: T,
        ) -> Self {
            self.stage = v.into();
            self
        }

        /// Sets the value of [state][crate::model::upgrade_cluster_status::StageStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::upgrade_cluster_response::Status>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [stage_specific_status][crate::model::upgrade_cluster_status::StageStatus::stage_specific_status].
        ///
        /// Note that all the setters affecting `stage_specific_status` are mutually
        /// exclusive.
        pub fn set_stage_specific_status<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.stage_specific_status = v.into();
            self
        }

        /// The value of [stage_specific_status][crate::model::upgrade_cluster_status::StageStatus::stage_specific_status]
        /// if it holds a `ReadPoolInstancesUpgrade`, `None` if the field is not set or
        /// holds a different branch.
        pub fn read_pool_instances_upgrade(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.stage_specific_status.as_ref().and_then(|v| match v {
                crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus::ReadPoolInstancesUpgrade(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [stage_specific_status][crate::model::upgrade_cluster_status::StageStatus::stage_specific_status]
        /// to hold a `ReadPoolInstancesUpgrade`.
        ///
        /// Note that all the setters affecting `stage_specific_status` are
        /// mutually exclusive.
        pub fn set_read_pool_instances_upgrade<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.stage_specific_status = std::option::Option::Some(
                crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus::ReadPoolInstancesUpgrade(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for StageStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus.StageStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StageStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __read_pool_instances_upgrade,
                __stage,
                __state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StageStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "readPoolInstancesUpgrade" => {
                                    Ok(__FieldTag::__read_pool_instances_upgrade)
                                }
                                "read_pool_instances_upgrade" => {
                                    Ok(__FieldTag::__read_pool_instances_upgrade)
                                }
                                "stage" => Ok(__FieldTag::__stage),
                                "state" => Ok(__FieldTag::__state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StageStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StageStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__read_pool_instances_upgrade => {
                                if !fields.insert(__FieldTag::__read_pool_instances_upgrade) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for read_pool_instances_upgrade",
                                    ));
                                }
                                if result.stage_specific_status.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `stage_specific_status`, a oneof with full ID .google.cloud.alloydb.v1.UpgradeClusterStatus.StageStatus.read_pool_instances_upgrade, latest field was readPoolInstancesUpgrade",
                                    ));
                                }
                                result.stage_specific_status = std::option::Option::Some(
                                    crate::model::upgrade_cluster_status::stage_status::StageSpecificStatus::ReadPoolInstancesUpgrade(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__stage => {
                                if !fields.insert(__FieldTag::__stage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stage",
                                    ));
                                }
                                result.stage = map
                                    .next_value::<std::option::Option<
                                        crate::model::upgrade_cluster_response::Stage,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::upgrade_cluster_response::Status,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StageStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.read_pool_instances_upgrade() {
                state.serialize_entry("readPoolInstancesUpgrade", value)?;
            }
            if !wkt::internal::is_default(&self.stage) {
                state.serialize_entry("stage", &self.stage)?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [StageStatus].
    pub mod stage_status {
        #[allow(unused_imports)]
        use super::*;

        /// Stage specific status information, if any.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum StageSpecificStatus {
            /// Read pool instances upgrade metadata.
            ReadPoolInstancesUpgrade(
                std::boxed::Box<
                    crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus,
                >,
            ),
        }
    }

    /// Read pool instances upgrade specific status.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReadPoolInstancesUpgradeStageStatus {
        /// Read pool instances upgrade statistics.
        pub upgrade_stats: std::option::Option<
            crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReadPoolInstancesUpgradeStageStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [upgrade_stats][crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus::upgrade_stats].
        pub fn set_upgrade_stats<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats>
        {
            self.upgrade_stats = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [upgrade_stats][crate::model::upgrade_cluster_status::ReadPoolInstancesUpgradeStageStatus::upgrade_stats].
        pub fn set_or_clear_upgrade_stats<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats>
        {
            self.upgrade_stats = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ReadPoolInstancesUpgradeStageStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus.ReadPoolInstancesUpgradeStageStatus"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReadPoolInstancesUpgradeStageStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __upgrade_stats,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter
                                .write_str("a field name for ReadPoolInstancesUpgradeStageStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "upgradeStats" => Ok(__FieldTag::__upgrade_stats),
                                "upgrade_stats" => Ok(__FieldTag::__upgrade_stats),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReadPoolInstancesUpgradeStageStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReadPoolInstancesUpgradeStageStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__upgrade_stats => {
                                if !fields.insert(__FieldTag::__upgrade_stats) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for upgrade_stats",
                                    ));
                                }
                                result.upgrade_stats = map.next_value::<std::option::Option<crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReadPoolInstancesUpgradeStageStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.upgrade_stats.is_some() {
                state.serialize_entry("upgradeStats", &self.upgrade_stats)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ReadPoolInstancesUpgradeStageStatus].
    pub mod read_pool_instances_upgrade_stage_status {
        #[allow(unused_imports)]
        use super::*;

        /// Upgrade stats for read pool instances.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Stats {
            /// Number of read pool instances for which upgrade has not started.
            pub not_started: i32,

            /// Number of read pool instances undergoing upgrade.
            pub ongoing: i32,

            /// Number of read pool instances successfully upgraded.
            pub success: i32,

            /// Number of read pool instances which failed to upgrade.
            pub failed: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Stats {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [not_started][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::not_started].
            pub fn set_not_started<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.not_started = v.into();
                self
            }

            /// Sets the value of [ongoing][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::ongoing].
            pub fn set_ongoing<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.ongoing = v.into();
                self
            }

            /// Sets the value of [success][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::success].
            pub fn set_success<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.success = v.into();
                self
            }

            /// Sets the value of [failed][crate::model::upgrade_cluster_status::read_pool_instances_upgrade_stage_status::Stats::failed].
            pub fn set_failed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.failed = v.into();
                self
            }
        }

        impl wkt::message::Message for Stats {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.alloydb.v1.UpgradeClusterStatus.ReadPoolInstancesUpgradeStageStatus.Stats"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Stats {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __not_started,
                    __ongoing,
                    __success,
                    __failed,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Stats")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "notStarted" => Ok(__FieldTag::__not_started),
                                    "not_started" => Ok(__FieldTag::__not_started),
                                    "ongoing" => Ok(__FieldTag::__ongoing),
                                    "success" => Ok(__FieldTag::__success),
                                    "failed" => Ok(__FieldTag::__failed),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Stats;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Stats")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__not_started => {
                                    if !fields.insert(__FieldTag::__not_started) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for not_started",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.not_started =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__ongoing => {
                                    if !fields.insert(__FieldTag::__ongoing) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for ongoing",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.ongoing =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__success => {
                                    if !fields.insert(__FieldTag::__success) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for success",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.success =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__failed => {
                                    if !fields.insert(__FieldTag::__failed) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for failed"),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.failed =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Stats {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.not_started) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("notStarted", &__With(&self.not_started))?;
                }
                if !wkt::internal::is_default(&self.ongoing) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("ongoing", &__With(&self.ongoing))?;
                }
                if !wkt::internal::is_default(&self.success) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("success", &__With(&self.success))?;
                }
                if !wkt::internal::is_default(&self.failed) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("failed", &__With(&self.failed))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// Message for requesting list of Users
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersRequest {
    /// Required. Parent value for ListUsersRequest
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUsersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListUsersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListUsersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing Users
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersResponse {
    /// The list of User
    pub users: std::vec::Vec<crate::model::User>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [users][crate::model::ListUsersResponse::users].
    pub fn set_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>,
    {
        use std::iter::Iterator;
        self.users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsersResponse {
    type PageItem = crate::model::User;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __users,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "users" => Ok(__FieldTag::__users),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__users => {
                            if !fields.insert(__FieldTag::__users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for users",
                                ));
                            }
                            result.users = map.next_value::<std::option::Option<std::vec::Vec<crate::model::User>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.users.is_empty() {
            state.serialize_entry("users", &self.users)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a User
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUserRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the User.name field.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.GetUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a User
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUserRequest {
    /// Required. Value for parent.
    pub parent: std::string::String,

    /// Required. ID of the requesting object.
    pub user_id: std::string::String,

    /// Required. The resource being created
    pub user: std::option::Option<crate::model::User>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUserRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::CreateUserRequest::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [user][crate::model::CreateUserRequest::user].
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::CreateUserRequest::user].
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateUserRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateUserRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.CreateUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __user_id,
            __user,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "user" => Ok(__FieldTag::__user),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            result.user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user =
                                map.next_value::<std::option::Option<crate::model::User>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.user_id.is_empty() {
            state.serialize_entry("userId", &self.user_id)?;
        }
        if self.user.is_some() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a User
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateUserRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// User resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub user: std::option::Option<crate::model::User>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    /// Optional. Allow missing fields in the update mask.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::UpdateUserRequest::user].
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::UpdateUserRequest::user].
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateUserRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateUserRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateUserRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.UpdateUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __user,
            __request_id,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "user" => Ok(__FieldTag::__user),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user =
                                map.next_value::<std::option::Option<crate::model::User>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.user.is_some() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a User
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUserRequest {
    /// Required. The name of the resource. For the required format, see the
    /// comment on the User.name field.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server ignores the
    /// request if it has already been completed. The server guarantees that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if the original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set, the backend validates the request, but doesn't actually
    /// execute it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteUserRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteUserRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.DeleteUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting list of Databases.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesRequest {
    /// Required. Parent value for ListDatabasesRequest.
    pub parent: std::string::String,

    /// Optional. The maximum number of databases to return. The service may return
    /// fewer than this value. If unspecified, 2000 is the default page_size. The
    /// max value of page_size will be 4000, values above max will be coerced to
    /// max.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListDatabases` call.
    /// This should be provided to retrieve the subsequent page.
    /// This field is currently not supported, its value will be ignored if passed.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    /// This field is currently not supported, its value will be ignored if passed.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatabasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatabasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatabasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListDatabasesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatabasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatabasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatabasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatabasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatabasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing Databases.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatabasesResponse {
    /// The list of databases
    pub databases: std::vec::Vec<crate::model::Database>,

    /// A token identifying the next page of results the server should return.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatabasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [databases][crate::model::ListDatabasesResponse::databases].
    pub fn set_databases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Database>,
    {
        use std::iter::Iterator;
        self.databases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatabasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDatabasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.alloydb.v1.ListDatabasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatabasesResponse {
    type PageItem = crate::model::Database;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.databases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatabasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __databases,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatabasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "databases" => Ok(__FieldTag::__databases),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatabasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatabasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__databases => {
                            if !fields.insert(__FieldTag::__databases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for databases",
                                ));
                            }
                            result.databases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Database>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatabasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.databases.is_empty() {
            state.serialize_entry("databases", &self.databases)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// View on Instance. Pass this enum to rpcs that returns an Instance message to
/// control which subsets of fields to get.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InstanceView {
    /// INSTANCE_VIEW_UNSPECIFIED Not specified, equivalent to BASIC.
    Unspecified,
    /// BASIC server responses for a primary or read instance include all the
    /// relevant instance details, excluding the details of each node in the
    /// instance. The default value.
    Basic,
    /// FULL response is equivalent to BASIC for primary instance (for now).
    /// For read pool instance, this includes details of each node in the pool.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InstanceView::value] or
    /// [InstanceView::name].
    UnknownValue(instance_view::UnknownValue),
}

#[doc(hidden)]
pub mod instance_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InstanceView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INSTANCE_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("INSTANCE_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("INSTANCE_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InstanceView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InstanceView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InstanceView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(instance_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InstanceView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INSTANCE_VIEW_UNSPECIFIED" => Self::Unspecified,
            "INSTANCE_VIEW_BASIC" => Self::Basic,
            "INSTANCE_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(instance_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InstanceView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InstanceView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceView>::new(
            ".google.cloud.alloydb.v1.InstanceView",
        ))
    }
}

/// View on Cluster. Pass this enum to rpcs that returns a cluster message to
/// control which subsets of fields to get.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ClusterView {
    /// CLUSTER_VIEW_UNSPECIFIED Not specified, equivalent to BASIC.
    Unspecified,
    /// BASIC server responses include all the relevant cluster details, excluding
    /// Cluster.ContinuousBackupInfo.EarliestRestorableTime and other view-specific
    /// fields. The default value.
    Basic,
    /// CONTINUOUS_BACKUP response returns all the fields from BASIC plus
    /// the earliest restorable time if continuous backups are enabled.
    /// May increase latency.
    ContinuousBackup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ClusterView::value] or
    /// [ClusterView::name].
    UnknownValue(cluster_view::UnknownValue),
}

#[doc(hidden)]
pub mod cluster_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ClusterView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::ContinuousBackup => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CLUSTER_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("CLUSTER_VIEW_BASIC"),
            Self::ContinuousBackup => std::option::Option::Some("CLUSTER_VIEW_CONTINUOUS_BACKUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ClusterView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ClusterView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ClusterView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::ContinuousBackup,
            _ => Self::UnknownValue(cluster_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ClusterView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CLUSTER_VIEW_UNSPECIFIED" => Self::Unspecified,
            "CLUSTER_VIEW_BASIC" => Self::Basic,
            "CLUSTER_VIEW_CONTINUOUS_BACKUP" => Self::ContinuousBackup,
            _ => Self::UnknownValue(cluster_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ClusterView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::ContinuousBackup => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ClusterView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterView>::new(
            ".google.cloud.alloydb.v1.ClusterView",
        ))
    }
}

/// The supported database engine versions.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseVersion {
    /// This is an unknown database version.
    Unspecified,
    /// DEPRECATED - The database version is Postgres 13.
    #[deprecated]
    Postgres13,
    /// The database version is Postgres 14.
    Postgres14,
    /// The database version is Postgres 15.
    Postgres15,
    /// The database version is Postgres 16.
    Postgres16,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseVersion::value] or
    /// [DatabaseVersion::name].
    UnknownValue(database_version::UnknownValue),
}

#[doc(hidden)]
pub mod database_version {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseVersion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Postgres13 => std::option::Option::Some(1),
            Self::Postgres14 => std::option::Option::Some(2),
            Self::Postgres15 => std::option::Option::Some(3),
            Self::Postgres16 => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_VERSION_UNSPECIFIED"),
            Self::Postgres13 => std::option::Option::Some("POSTGRES_13"),
            Self::Postgres14 => std::option::Option::Some("POSTGRES_14"),
            Self::Postgres15 => std::option::Option::Some("POSTGRES_15"),
            Self::Postgres16 => std::option::Option::Some("POSTGRES_16"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseVersion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseVersion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Postgres13,
            2 => Self::Postgres14,
            3 => Self::Postgres15,
            4 => Self::Postgres16,
            _ => Self::UnknownValue(database_version::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseVersion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_VERSION_UNSPECIFIED" => Self::Unspecified,
            "POSTGRES_13" => Self::Postgres13,
            "POSTGRES_14" => Self::Postgres14,
            "POSTGRES_15" => Self::Postgres15,
            "POSTGRES_16" => Self::Postgres16,
            _ => Self::UnknownValue(database_version::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Postgres13 => serializer.serialize_i32(1),
            Self::Postgres14 => serializer.serialize_i32(2),
            Self::Postgres15 => serializer.serialize_i32(3),
            Self::Postgres16 => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseVersion>::new(
            ".google.cloud.alloydb.v1.DatabaseVersion",
        ))
    }
}

/// Subscription_type added to distinguish between Standard and Trial
/// subscriptions. By default, a subscription type is considered STANDARD unless
/// explicitly specified.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SubscriptionType {
    /// This is an unknown subscription type. By default, the subscription type is
    /// STANDARD.
    Unspecified,
    /// Standard subscription.
    Standard,
    /// Trial subscription.
    Trial,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SubscriptionType::value] or
    /// [SubscriptionType::name].
    UnknownValue(subscription_type::UnknownValue),
}

#[doc(hidden)]
pub mod subscription_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SubscriptionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Trial => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SUBSCRIPTION_TYPE_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("STANDARD"),
            Self::Trial => std::option::Option::Some("TRIAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SubscriptionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SubscriptionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SubscriptionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Trial,
            _ => Self::UnknownValue(subscription_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SubscriptionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SUBSCRIPTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "STANDARD" => Self::Standard,
            "TRIAL" => Self::Trial,
            _ => Self::UnknownValue(subscription_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SubscriptionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Trial => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SubscriptionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SubscriptionType>::new(
            ".google.cloud.alloydb.v1.SubscriptionType",
        ))
    }
}
