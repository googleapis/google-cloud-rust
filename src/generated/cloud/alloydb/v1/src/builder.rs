// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

pub mod alloy_dbcsql_admin {
    use crate::Result;

    /// A builder for [AlloyDBCSQLAdmin][crate::client::AlloyDBCSQLAdmin].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_alloydb_v1::*;
    /// # use builder::alloy_dbcsql_admin::ClientBuilder;
    /// # use client::AlloyDBCSQLAdmin;
    /// let builder : ClientBuilder = AlloyDBCSQLAdmin::builder();
    /// let client = builder
    ///     .with_endpoint("https://alloydb.googleapis.com")
    ///     .build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub type ClientBuilder =
        gax::client_builder::ClientBuilder<client::Factory, gaxi::options::Credentials>;

    pub(crate) mod client {
        use super::super::super::client::AlloyDBCSQLAdmin;
        pub struct Factory;
        impl gax::client_builder::internal::ClientFactory for Factory {
            type Client = AlloyDBCSQLAdmin;
            type Credentials = gaxi::options::Credentials;
            async fn build(
                self,
                config: gaxi::options::ClientConfig,
            ) -> gax::client_builder::Result<Self::Client> {
                Self::Client::new(config).await
            }
        }
    }

    /// Common implementation for [crate::client::AlloyDBCSQLAdmin] request builders.
    #[derive(Clone, Debug)]
    pub(crate) struct RequestBuilder<R: std::default::Default> {
        stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        request: R,
        options: gax::options::RequestOptions,
    }

    impl<R> RequestBuilder<R>
    where
        R: std::default::Default,
    {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self {
                stub,
                request: R::default(),
                options: gax::options::RequestOptions::default(),
            }
        }
    }

    /// The request builder for [AlloyDBCSQLAdmin::restore_from_cloud_sql][crate::client::AlloyDBCSQLAdmin::restore_from_cloud_sql] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_dbcsql_admin::RestoreFromCloudSQL;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> RestoreFromCloudSQL {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct RestoreFromCloudSQL(RequestBuilder<crate::model::RestoreFromCloudSQLRequest>);

    impl RestoreFromCloudSQL {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::RestoreFromCloudSQLRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [restore_from_cloud_sql][crate::client::AlloyDBCSQLAdmin::restore_from_cloud_sql].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .restore_from_cloud_sql(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `restore_from_cloud_sql`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Cluster, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Cluster, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::RestoreFromCloudSQLRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [cluster_id][crate::model::RestoreFromCloudSQLRequest::cluster_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.cluster_id = v.into();
            self
        }

        /// Sets the value of [cluster][crate::model::RestoreFromCloudSQLRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cluster][crate::model::RestoreFromCloudSQLRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source][crate::model::RestoreFromCloudSQLRequest::source].
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_source<T: Into<Option<crate::model::restore_from_cloud_sql_request::Source>>>(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.source = v.into();
            self
        }

        /// Sets the value of [source][crate::model::RestoreFromCloudSQLRequest::source]
        /// to hold a `CloudsqlBackupRunSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_cloudsql_backup_run_source<
            T: std::convert::Into<std::boxed::Box<crate::model::CloudSQLBackupRunSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_cloudsql_backup_run_source(v);
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for RestoreFromCloudSQL {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBCSQLAdmin::list_locations][crate::client::AlloyDBCSQLAdmin::list_locations] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_dbcsql_admin::ListLocations;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListLocations {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListLocations(RequestBuilder<location::model::ListLocationsRequest>);

    impl ListLocations {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<location::model::ListLocationsRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<location::model::ListLocationsResponse> {
            (*self.0.stub)
                .list_locations(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<location::model::ListLocationsResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<location::model::ListLocationsResponse, gax::error::Error>
        {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [name][location::model::ListLocationsRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [filter][location::model::ListLocationsRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [page_size][location::model::ListLocationsRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][location::model::ListLocationsRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListLocations {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBCSQLAdmin::get_location][crate::client::AlloyDBCSQLAdmin::get_location] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_dbcsql_admin::GetLocation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetLocation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetLocation(RequestBuilder<location::model::GetLocationRequest>);

    impl GetLocation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<location::model::GetLocationRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<location::model::Location> {
            (*self.0.stub)
                .get_location(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][location::model::GetLocationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetLocation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBCSQLAdmin::list_operations][crate::client::AlloyDBCSQLAdmin::list_operations] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_dbcsql_admin::ListOperations;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListOperations {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListOperations(RequestBuilder<longrunning::model::ListOperationsRequest>);

    impl ListOperations {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::ListOperationsRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<longrunning::model::ListOperationsResponse> {
            (*self.0.stub)
                .list_operations(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<longrunning::model::ListOperationsResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<
            longrunning::model::ListOperationsResponse,
            gax::error::Error,
        > {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [name][longrunning::model::ListOperationsRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [filter][longrunning::model::ListOperationsRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [page_size][longrunning::model::ListOperationsRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][longrunning::model::ListOperationsRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [return_partial_success][longrunning::model::ListOperationsRequest::return_partial_success].
        pub fn set_return_partial_success<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.return_partial_success = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListOperations {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBCSQLAdmin::get_operation][crate::client::AlloyDBCSQLAdmin::get_operation] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_dbcsql_admin::GetOperation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetOperation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetOperation(RequestBuilder<longrunning::model::GetOperationRequest>);

    impl GetOperation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::GetOperationRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .get_operation(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][longrunning::model::GetOperationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetOperation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBCSQLAdmin::delete_operation][crate::client::AlloyDBCSQLAdmin::delete_operation] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_dbcsql_admin::DeleteOperation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> DeleteOperation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct DeleteOperation(RequestBuilder<longrunning::model::DeleteOperationRequest>);

    impl DeleteOperation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::DeleteOperationRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<()> {
            (*self.0.stub)
                .delete_operation(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][longrunning::model::DeleteOperationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for DeleteOperation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBCSQLAdmin::cancel_operation][crate::client::AlloyDBCSQLAdmin::cancel_operation] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_dbcsql_admin::CancelOperation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CancelOperation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CancelOperation(RequestBuilder<longrunning::model::CancelOperationRequest>);

    impl CancelOperation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBCSQLAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::CancelOperationRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<()> {
            (*self.0.stub)
                .cancel_operation(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][longrunning::model::CancelOperationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CancelOperation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }
}

pub mod alloy_db_admin {
    use crate::Result;

    /// A builder for [AlloyDBAdmin][crate::client::AlloyDBAdmin].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_alloydb_v1::*;
    /// # use builder::alloy_db_admin::ClientBuilder;
    /// # use client::AlloyDBAdmin;
    /// let builder : ClientBuilder = AlloyDBAdmin::builder();
    /// let client = builder
    ///     .with_endpoint("https://alloydb.googleapis.com")
    ///     .build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub type ClientBuilder =
        gax::client_builder::ClientBuilder<client::Factory, gaxi::options::Credentials>;

    pub(crate) mod client {
        use super::super::super::client::AlloyDBAdmin;
        pub struct Factory;
        impl gax::client_builder::internal::ClientFactory for Factory {
            type Client = AlloyDBAdmin;
            type Credentials = gaxi::options::Credentials;
            async fn build(
                self,
                config: gaxi::options::ClientConfig,
            ) -> gax::client_builder::Result<Self::Client> {
                Self::Client::new(config).await
            }
        }
    }

    /// Common implementation for [crate::client::AlloyDBAdmin] request builders.
    #[derive(Clone, Debug)]
    pub(crate) struct RequestBuilder<R: std::default::Default> {
        stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        request: R,
        options: gax::options::RequestOptions,
    }

    impl<R> RequestBuilder<R>
    where
        R: std::default::Default,
    {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self {
                stub,
                request: R::default(),
                options: gax::options::RequestOptions::default(),
            }
        }
    }

    /// The request builder for [AlloyDBAdmin::list_clusters][crate::client::AlloyDBAdmin::list_clusters] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListClusters;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListClusters {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListClusters(RequestBuilder<crate::model::ListClustersRequest>);

    impl ListClusters {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ListClustersRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ListClustersResponse> {
            (*self.0.stub)
                .list_clusters(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<crate::model::ListClustersResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<crate::model::ListClustersResponse, gax::error::Error>
        {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
        pub fn set_order_by<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.order_by = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListClusters {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::get_cluster][crate::client::AlloyDBAdmin::get_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GetCluster;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetCluster(RequestBuilder<crate::model::GetClusterRequest>);

    impl GetCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::GetClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::Cluster> {
            (*self.0.stub)
                .get_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][crate::model::GetClusterRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [view][crate::model::GetClusterRequest::view].
        pub fn set_view<T: Into<crate::model::ClusterView>>(mut self, v: T) -> Self {
            self.0.request.view = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::create_cluster][crate::client::AlloyDBAdmin::create_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::CreateCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CreateCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CreateCluster(RequestBuilder<crate::model::CreateClusterRequest>);

    impl CreateCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::CreateClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [create_cluster][crate::client::AlloyDBAdmin::create_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .create_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `create_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Cluster, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Cluster, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.cluster_id = v.into();
            self
        }

        /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::CreateClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CreateCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::update_cluster][crate::client::AlloyDBAdmin::update_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::UpdateCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> UpdateCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct UpdateCluster(RequestBuilder<crate::model::UpdateClusterRequest>);

    impl UpdateCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::UpdateClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [update_cluster][crate::client::AlloyDBAdmin::update_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .update_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `update_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Cluster, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Cluster, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
        pub fn set_update_mask<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
        pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = v.map(|x| x.into());
            self
        }

        /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::UpdateClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [allow_missing][crate::model::UpdateClusterRequest::allow_missing].
        pub fn set_allow_missing<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.allow_missing = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for UpdateCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::export_cluster][crate::client::AlloyDBAdmin::export_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ExportCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ExportCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ExportCluster(RequestBuilder<crate::model::ExportClusterRequest>);

    impl ExportCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ExportClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [export_cluster][crate::client::AlloyDBAdmin::export_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .export_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `export_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::ExportClusterResponse, crate::model::OperationMetadata>
        {
            type Operation = lro::internal::Operation<
                crate::model::ExportClusterResponse,
                crate::model::OperationMetadata,
            >;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [name][crate::model::ExportClusterRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [database][crate::model::ExportClusterRequest::database].
        ///
        /// This is a **required** field for requests.
        pub fn set_database<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.database = v.into();
            self
        }

        /// Sets the value of [destination][crate::model::ExportClusterRequest::destination].
        ///
        /// Note that all the setters affecting `destination` are
        /// mutually exclusive.
        pub fn set_destination<
            T: Into<Option<crate::model::export_cluster_request::Destination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.destination = v.into();
            self
        }

        /// Sets the value of [destination][crate::model::ExportClusterRequest::destination]
        /// to hold a `GcsDestination`.
        ///
        /// Note that all the setters affecting `destination` are
        /// mutually exclusive.
        pub fn set_gcs_destination<
            T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_gcs_destination(v);
            self
        }

        /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options].
        ///
        /// Note that all the setters affecting `export_options` are
        /// mutually exclusive.
        pub fn set_export_options<
            T: Into<Option<crate::model::export_cluster_request::ExportOptions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.export_options = v.into();
            self
        }

        /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options]
        /// to hold a `CsvExportOptions`.
        ///
        /// Note that all the setters affecting `export_options` are
        /// mutually exclusive.
        pub fn set_csv_export_options<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::export_cluster_request::CsvExportOptions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_csv_export_options(v);
            self
        }

        /// Sets the value of [export_options][crate::model::ExportClusterRequest::export_options]
        /// to hold a `SqlExportOptions`.
        ///
        /// Note that all the setters affecting `export_options` are
        /// mutually exclusive.
        pub fn set_sql_export_options<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::export_cluster_request::SqlExportOptions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_sql_export_options(v);
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ExportCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::import_cluster][crate::client::AlloyDBAdmin::import_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ImportCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ImportCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ImportCluster(RequestBuilder<crate::model::ImportClusterRequest>);

    impl ImportCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ImportClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [import_cluster][crate::client::AlloyDBAdmin::import_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .import_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `import_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::ImportClusterResponse, crate::model::OperationMetadata>
        {
            type Operation = lro::internal::Operation<
                crate::model::ImportClusterResponse,
                crate::model::OperationMetadata,
            >;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [name][crate::model::ImportClusterRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [gcs_uri][crate::model::ImportClusterRequest::gcs_uri].
        ///
        /// This is a **required** field for requests.
        pub fn set_gcs_uri<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.gcs_uri = v.into();
            self
        }

        /// Sets the value of [database][crate::model::ImportClusterRequest::database].
        pub fn set_database<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.database = v.into();
            self
        }

        /// Sets the value of [user][crate::model::ImportClusterRequest::user].
        pub fn set_user<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.user = v.into();
            self
        }

        /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options].
        ///
        /// Note that all the setters affecting `import_options` are
        /// mutually exclusive.
        pub fn set_import_options<
            T: Into<Option<crate::model::import_cluster_request::ImportOptions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.import_options = v.into();
            self
        }

        /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options]
        /// to hold a `SqlImportOptions`.
        ///
        /// Note that all the setters affecting `import_options` are
        /// mutually exclusive.
        pub fn set_sql_import_options<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::import_cluster_request::SqlImportOptions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_sql_import_options(v);
            self
        }

        /// Sets the value of [import_options][crate::model::ImportClusterRequest::import_options]
        /// to hold a `CsvImportOptions`.
        ///
        /// Note that all the setters affecting `import_options` are
        /// mutually exclusive.
        pub fn set_csv_import_options<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::import_cluster_request::CsvImportOptions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_csv_import_options(v);
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ImportCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::upgrade_cluster][crate::client::AlloyDBAdmin::upgrade_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::UpgradeCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> UpgradeCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct UpgradeCluster(RequestBuilder<crate::model::UpgradeClusterRequest>);

    impl UpgradeCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::UpgradeClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [upgrade_cluster][crate::client::AlloyDBAdmin::upgrade_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .upgrade_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `upgrade_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::UpgradeClusterResponse, crate::model::OperationMetadata>
        {
            type Operation = lro::internal::Operation<
                crate::model::UpgradeClusterResponse,
                crate::model::OperationMetadata,
            >;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [name][crate::model::UpgradeClusterRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [version][crate::model::UpgradeClusterRequest::version].
        ///
        /// This is a **required** field for requests.
        pub fn set_version<T: Into<crate::model::DatabaseVersion>>(mut self, v: T) -> Self {
            self.0.request.version = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::UpgradeClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::UpgradeClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [etag][crate::model::UpgradeClusterRequest::etag].
        pub fn set_etag<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.etag = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for UpgradeCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::delete_cluster][crate::client::AlloyDBAdmin::delete_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::DeleteCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> DeleteCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct DeleteCluster(RequestBuilder<crate::model::DeleteClusterRequest>);

    impl DeleteCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::DeleteClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [delete_cluster][crate::client::AlloyDBAdmin::delete_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .delete_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `delete_cluster`.
        pub fn poller(self) -> impl lro::Poller<(), crate::model::OperationMetadata> {
            type Operation = lro::internal::Operation<wkt::Empty, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_unit_response_poller(
                polling_error_policy,
                polling_backoff_policy,
                start,
                query,
            )
        }

        /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [etag][crate::model::DeleteClusterRequest::etag].
        pub fn set_etag<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.etag = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::DeleteClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [force][crate::model::DeleteClusterRequest::force].
        pub fn set_force<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.force = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for DeleteCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::promote_cluster][crate::client::AlloyDBAdmin::promote_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::PromoteCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> PromoteCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct PromoteCluster(RequestBuilder<crate::model::PromoteClusterRequest>);

    impl PromoteCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::PromoteClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [promote_cluster][crate::client::AlloyDBAdmin::promote_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .promote_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `promote_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Cluster, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Cluster, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [name][crate::model::PromoteClusterRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::PromoteClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [etag][crate::model::PromoteClusterRequest::etag].
        pub fn set_etag<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.etag = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::PromoteClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for PromoteCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::switchover_cluster][crate::client::AlloyDBAdmin::switchover_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::SwitchoverCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> SwitchoverCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct SwitchoverCluster(RequestBuilder<crate::model::SwitchoverClusterRequest>);

    impl SwitchoverCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::SwitchoverClusterRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [switchover_cluster][crate::client::AlloyDBAdmin::switchover_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .switchover_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `switchover_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Cluster, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Cluster, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [name][crate::model::SwitchoverClusterRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::SwitchoverClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::SwitchoverClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for SwitchoverCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::restore_cluster][crate::client::AlloyDBAdmin::restore_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::RestoreCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> RestoreCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct RestoreCluster(RequestBuilder<crate::model::RestoreClusterRequest>);

    impl RestoreCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::RestoreClusterRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [restore_cluster][crate::client::AlloyDBAdmin::restore_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .restore_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `restore_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Cluster, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Cluster, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::RestoreClusterRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [cluster_id][crate::model::RestoreClusterRequest::cluster_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.cluster_id = v.into();
            self
        }

        /// Sets the value of [cluster][crate::model::RestoreClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cluster][crate::model::RestoreClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::RestoreClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::RestoreClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [source][crate::model::RestoreClusterRequest::source].
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_source<T: Into<Option<crate::model::restore_cluster_request::Source>>>(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.source = v.into();
            self
        }

        /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
        /// to hold a `BackupSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_backup_source<
            T: std::convert::Into<std::boxed::Box<crate::model::BackupSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_backup_source(v);
            self
        }

        /// Sets the value of [source][crate::model::RestoreClusterRequest::source]
        /// to hold a `ContinuousBackupSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_continuous_backup_source<
            T: std::convert::Into<std::boxed::Box<crate::model::ContinuousBackupSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request = self.0.request.set_continuous_backup_source(v);
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for RestoreCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::create_secondary_cluster][crate::client::AlloyDBAdmin::create_secondary_cluster] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::CreateSecondaryCluster;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CreateSecondaryCluster {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CreateSecondaryCluster(RequestBuilder<crate::model::CreateSecondaryClusterRequest>);

    impl CreateSecondaryCluster {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::CreateSecondaryClusterRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [create_secondary_cluster][crate::client::AlloyDBAdmin::create_secondary_cluster].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .create_secondary_cluster(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `create_secondary_cluster`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Cluster, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Cluster, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::CreateSecondaryClusterRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [cluster_id][crate::model::CreateSecondaryClusterRequest::cluster_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.cluster_id = v.into();
            self
        }

        /// Sets the value of [cluster][crate::model::CreateSecondaryClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_cluster<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cluster][crate::model::CreateSecondaryClusterRequest::cluster].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Cluster>,
        {
            self.0.request.cluster = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::CreateSecondaryClusterRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::CreateSecondaryClusterRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CreateSecondaryCluster {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::list_instances][crate::client::AlloyDBAdmin::list_instances] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListInstances;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListInstances {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListInstances(RequestBuilder<crate::model::ListInstancesRequest>);

    impl ListInstances {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ListInstancesRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ListInstancesResponse> {
            (*self.0.stub)
                .list_instances(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<crate::model::ListInstancesResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<crate::model::ListInstancesResponse, gax::error::Error>
        {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
        pub fn set_order_by<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.order_by = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListInstances {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::get_instance][crate::client::AlloyDBAdmin::get_instance] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GetInstance;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetInstance {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetInstance(RequestBuilder<crate::model::GetInstanceRequest>);

    impl GetInstance {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::GetInstanceRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::Instance> {
            (*self.0.stub)
                .get_instance(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][crate::model::GetInstanceRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [view][crate::model::GetInstanceRequest::view].
        pub fn set_view<T: Into<crate::model::InstanceView>>(mut self, v: T) -> Self {
            self.0.request.view = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetInstance {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::create_instance][crate::client::AlloyDBAdmin::create_instance] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::CreateInstance;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CreateInstance {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CreateInstance(RequestBuilder<crate::model::CreateInstanceRequest>);

    impl CreateInstance {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::CreateInstanceRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [create_instance][crate::client::AlloyDBAdmin::create_instance].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .create_instance(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `create_instance`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Instance, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Instance, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_instance_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.instance_id = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
        ///
        /// This is a **required** field for requests.
        pub fn set_instance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.0.request.instance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.0.request.instance = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::CreateInstanceRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CreateInstance {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::create_secondary_instance][crate::client::AlloyDBAdmin::create_secondary_instance] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::CreateSecondaryInstance;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CreateSecondaryInstance {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CreateSecondaryInstance(
        RequestBuilder<crate::model::CreateSecondaryInstanceRequest>,
    );

    impl CreateSecondaryInstance {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::CreateSecondaryInstanceRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [create_secondary_instance][crate::client::AlloyDBAdmin::create_secondary_instance].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .create_secondary_instance(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `create_secondary_instance`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Instance, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Instance, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::CreateSecondaryInstanceRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [instance_id][crate::model::CreateSecondaryInstanceRequest::instance_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_instance_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.instance_id = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::CreateSecondaryInstanceRequest::instance].
        ///
        /// This is a **required** field for requests.
        pub fn set_instance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.0.request.instance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [instance][crate::model::CreateSecondaryInstanceRequest::instance].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.0.request.instance = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::CreateSecondaryInstanceRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::CreateSecondaryInstanceRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CreateSecondaryInstance {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::batch_create_instances][crate::client::AlloyDBAdmin::batch_create_instances] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::BatchCreateInstances;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> BatchCreateInstances {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct BatchCreateInstances(RequestBuilder<crate::model::BatchCreateInstancesRequest>);

    impl BatchCreateInstances {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::BatchCreateInstancesRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [batch_create_instances][crate::client::AlloyDBAdmin::batch_create_instances].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .batch_create_instances(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `batch_create_instances`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::BatchCreateInstancesResponse, crate::model::OperationMetadata>
        {
            type Operation = lro::internal::Operation<
                crate::model::BatchCreateInstancesResponse,
                crate::model::OperationMetadata,
            >;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::BatchCreateInstancesRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [requests][crate::model::BatchCreateInstancesRequest::requests].
        ///
        /// This is a **required** field for requests.
        pub fn set_requests<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::CreateInstanceRequests>,
        {
            self.0.request.requests = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [requests][crate::model::BatchCreateInstancesRequest::requests].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_requests<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::CreateInstanceRequests>,
        {
            self.0.request.requests = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::BatchCreateInstancesRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for BatchCreateInstances {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::update_instance][crate::client::AlloyDBAdmin::update_instance] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::UpdateInstance;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> UpdateInstance {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct UpdateInstance(RequestBuilder<crate::model::UpdateInstanceRequest>);

    impl UpdateInstance {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::UpdateInstanceRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [update_instance][crate::client::AlloyDBAdmin::update_instance].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .update_instance(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `update_instance`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Instance, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Instance, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
        pub fn set_update_mask<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
        pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
        ///
        /// This is a **required** field for requests.
        pub fn set_instance<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.0.request.instance = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.0.request.instance = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::UpdateInstanceRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [allow_missing][crate::model::UpdateInstanceRequest::allow_missing].
        pub fn set_allow_missing<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.allow_missing = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for UpdateInstance {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::delete_instance][crate::client::AlloyDBAdmin::delete_instance] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::DeleteInstance;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> DeleteInstance {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct DeleteInstance(RequestBuilder<crate::model::DeleteInstanceRequest>);

    impl DeleteInstance {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::DeleteInstanceRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [delete_instance][crate::client::AlloyDBAdmin::delete_instance].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .delete_instance(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `delete_instance`.
        pub fn poller(self) -> impl lro::Poller<(), crate::model::OperationMetadata> {
            type Operation = lro::internal::Operation<wkt::Empty, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_unit_response_poller(
                polling_error_policy,
                polling_backoff_policy,
                start,
                query,
            )
        }

        /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [etag][crate::model::DeleteInstanceRequest::etag].
        pub fn set_etag<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.etag = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::DeleteInstanceRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for DeleteInstance {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::failover_instance][crate::client::AlloyDBAdmin::failover_instance] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::FailoverInstance;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> FailoverInstance {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct FailoverInstance(RequestBuilder<crate::model::FailoverInstanceRequest>);

    impl FailoverInstance {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::FailoverInstanceRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [failover_instance][crate::client::AlloyDBAdmin::failover_instance].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .failover_instance(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `failover_instance`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Instance, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Instance, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [name][crate::model::FailoverInstanceRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::FailoverInstanceRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::FailoverInstanceRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for FailoverInstance {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::inject_fault][crate::client::AlloyDBAdmin::inject_fault] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::InjectFault;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> InjectFault {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct InjectFault(RequestBuilder<crate::model::InjectFaultRequest>);

    impl InjectFault {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::InjectFaultRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [inject_fault][crate::client::AlloyDBAdmin::inject_fault].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .inject_fault(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `inject_fault`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Instance, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Instance, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [fault_type][crate::model::InjectFaultRequest::fault_type].
        ///
        /// This is a **required** field for requests.
        pub fn set_fault_type<T: Into<crate::model::inject_fault_request::FaultType>>(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.fault_type = v.into();
            self
        }

        /// Sets the value of [name][crate::model::InjectFaultRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::InjectFaultRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::InjectFaultRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for InjectFault {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::restart_instance][crate::client::AlloyDBAdmin::restart_instance] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::RestartInstance;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> RestartInstance {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct RestartInstance(RequestBuilder<crate::model::RestartInstanceRequest>);

    impl RestartInstance {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::RestartInstanceRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [restart_instance][crate::client::AlloyDBAdmin::restart_instance].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .restart_instance(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `restart_instance`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Instance, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Instance, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [name][crate::model::RestartInstanceRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::RestartInstanceRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::RestartInstanceRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [node_ids][crate::model::RestartInstanceRequest::node_ids].
        pub fn set_node_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.0.request.node_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for RestartInstance {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::execute_sql][crate::client::AlloyDBAdmin::execute_sql] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ExecuteSql;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ExecuteSql {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ExecuteSql(RequestBuilder<crate::model::ExecuteSqlRequest>);

    impl ExecuteSql {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ExecuteSqlRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ExecuteSqlResponse> {
            (*self.0.stub)
                .execute_sql(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [instance][crate::model::ExecuteSqlRequest::instance].
        ///
        /// This is a **required** field for requests.
        pub fn set_instance<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.instance = v.into();
            self
        }

        /// Sets the value of [database][crate::model::ExecuteSqlRequest::database].
        ///
        /// This is a **required** field for requests.
        pub fn set_database<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.database = v.into();
            self
        }

        /// Sets the value of [user][crate::model::ExecuteSqlRequest::user].
        pub fn set_user<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.user = v.into();
            self
        }

        /// Sets the value of [sql_statement][crate::model::ExecuteSqlRequest::sql_statement].
        ///
        /// This is a **required** field for requests.
        pub fn set_sql_statement<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.sql_statement = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::ExecuteSqlRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [user_credential][crate::model::ExecuteSqlRequest::user_credential].
        ///
        /// Note that all the setters affecting `user_credential` are
        /// mutually exclusive.
        pub fn set_user_credential<
            T: Into<Option<crate::model::execute_sql_request::UserCredential>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.user_credential = v.into();
            self
        }

        /// Sets the value of [user_credential][crate::model::ExecuteSqlRequest::user_credential]
        /// to hold a `Password`.
        ///
        /// Note that all the setters affecting `user_credential` are
        /// mutually exclusive.
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request = self.0.request.set_password(v);
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ExecuteSql {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::list_backups][crate::client::AlloyDBAdmin::list_backups] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListBackups;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListBackups {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListBackups(RequestBuilder<crate::model::ListBackupsRequest>);

    impl ListBackups {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ListBackupsRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ListBackupsResponse> {
            (*self.0.stub)
                .list_backups(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<crate::model::ListBackupsResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<crate::model::ListBackupsResponse, gax::error::Error>
        {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
        pub fn set_order_by<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.order_by = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListBackups {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::get_backup][crate::client::AlloyDBAdmin::get_backup] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GetBackup;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetBackup {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetBackup(RequestBuilder<crate::model::GetBackupRequest>);

    impl GetBackup {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::GetBackupRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::Backup> {
            (*self.0.stub)
                .get_backup(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][crate::model::GetBackupRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetBackup {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::create_backup][crate::client::AlloyDBAdmin::create_backup] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::CreateBackup;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CreateBackup {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CreateBackup(RequestBuilder<crate::model::CreateBackupRequest>);

    impl CreateBackup {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::CreateBackupRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [create_backup][crate::client::AlloyDBAdmin::create_backup].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .create_backup(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `create_backup`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Backup, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Backup, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_backup_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.backup_id = v.into();
            self
        }

        /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
        ///
        /// This is a **required** field for requests.
        pub fn set_backup<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Backup>,
        {
            self.0.request.backup = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [backup][crate::model::CreateBackupRequest::backup].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Backup>,
        {
            self.0.request.backup = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::CreateBackupRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::CreateBackupRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CreateBackup {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::update_backup][crate::client::AlloyDBAdmin::update_backup] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::UpdateBackup;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> UpdateBackup {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct UpdateBackup(RequestBuilder<crate::model::UpdateBackupRequest>);

    impl UpdateBackup {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::UpdateBackupRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [update_backup][crate::client::AlloyDBAdmin::update_backup].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .update_backup(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `update_backup`.
        pub fn poller(
            self,
        ) -> impl lro::Poller<crate::model::Backup, crate::model::OperationMetadata> {
            type Operation =
                lro::internal::Operation<crate::model::Backup, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_poller(polling_error_policy, polling_backoff_policy, start, query)
        }

        /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
        pub fn set_update_mask<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
        pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = v.map(|x| x.into());
            self
        }

        /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
        ///
        /// This is a **required** field for requests.
        pub fn set_backup<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Backup>,
        {
            self.0.request.backup = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [backup][crate::model::UpdateBackupRequest::backup].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Backup>,
        {
            self.0.request.backup = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::UpdateBackupRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::UpdateBackupRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [allow_missing][crate::model::UpdateBackupRequest::allow_missing].
        pub fn set_allow_missing<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.allow_missing = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for UpdateBackup {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::delete_backup][crate::client::AlloyDBAdmin::delete_backup] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::DeleteBackup;
    /// # tokio_test::block_on(async {
    /// use lro::Poller;
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.poller().until_done().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> DeleteBackup {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct DeleteBackup(RequestBuilder<crate::model::DeleteBackupRequest>);

    impl DeleteBackup {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::DeleteBackupRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        ///
        /// # Long running operations
        ///
        /// This starts, but does not poll, a longrunning operation. More information
        /// on [delete_backup][crate::client::AlloyDBAdmin::delete_backup].
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .delete_backup(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Creates a [Poller][lro::Poller] to work with `delete_backup`.
        pub fn poller(self) -> impl lro::Poller<(), crate::model::OperationMetadata> {
            type Operation = lro::internal::Operation<wkt::Empty, crate::model::OperationMetadata>;
            let polling_error_policy = self.0.stub.get_polling_error_policy(&self.0.options);
            let polling_backoff_policy = self.0.stub.get_polling_backoff_policy(&self.0.options);

            let stub = self.0.stub.clone();
            let mut options = self.0.options.clone();
            options.set_retry_policy(gax::retry_policy::NeverRetry);
            let query = move |name| {
                let stub = stub.clone();
                let options = options.clone();
                async {
                    let op = GetOperation::new(stub)
                        .set_name(name)
                        .with_options(options)
                        .send()
                        .await?;
                    Ok(Operation::new(op))
                }
            };

            let start = move || async {
                let op = self.send().await?;
                Ok(Operation::new(op))
            };

            lro::internal::new_unit_response_poller(
                polling_error_policy,
                polling_backoff_policy,
                start,
                query,
            )
        }

        /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::DeleteBackupRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [etag][crate::model::DeleteBackupRequest::etag].
        pub fn set_etag<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.etag = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for DeleteBackup {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::list_supported_database_flags][crate::client::AlloyDBAdmin::list_supported_database_flags] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListSupportedDatabaseFlags;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListSupportedDatabaseFlags {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListSupportedDatabaseFlags(
        RequestBuilder<crate::model::ListSupportedDatabaseFlagsRequest>,
    );

    impl ListSupportedDatabaseFlags {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ListSupportedDatabaseFlagsRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ListSupportedDatabaseFlagsResponse> {
            (*self.0.stub)
                .list_supported_database_flags(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<
            crate::model::ListSupportedDatabaseFlagsResponse,
            gax::error::Error,
        > {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<
            crate::model::ListSupportedDatabaseFlagsResponse,
            gax::error::Error,
        > {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [parent][crate::model::ListSupportedDatabaseFlagsRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [page_size][crate::model::ListSupportedDatabaseFlagsRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][crate::model::ListSupportedDatabaseFlagsRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [scope][crate::model::ListSupportedDatabaseFlagsRequest::scope].
        pub fn set_scope<T: Into<crate::model::supported_database_flag::Scope>>(
            mut self,
            v: T,
        ) -> Self {
            self.0.request.scope = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListSupportedDatabaseFlags {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::generate_client_certificate][crate::client::AlloyDBAdmin::generate_client_certificate] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GenerateClientCertificate;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GenerateClientCertificate {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GenerateClientCertificate(
        RequestBuilder<crate::model::GenerateClientCertificateRequest>,
    );

    impl GenerateClientCertificate {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::GenerateClientCertificateRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::GenerateClientCertificateResponse> {
            (*self.0.stub)
                .generate_client_certificate(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [parent][crate::model::GenerateClientCertificateRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::GenerateClientCertificateRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [cert_duration][crate::model::GenerateClientCertificateRequest::cert_duration].
        pub fn set_cert_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.0.request.cert_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cert_duration][crate::model::GenerateClientCertificateRequest::cert_duration].
        pub fn set_or_clear_cert_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.0.request.cert_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [public_key][crate::model::GenerateClientCertificateRequest::public_key].
        pub fn set_public_key<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.public_key = v.into();
            self
        }

        /// Sets the value of [use_metadata_exchange][crate::model::GenerateClientCertificateRequest::use_metadata_exchange].
        pub fn set_use_metadata_exchange<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.use_metadata_exchange = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GenerateClientCertificate {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::get_connection_info][crate::client::AlloyDBAdmin::get_connection_info] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GetConnectionInfo;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetConnectionInfo {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetConnectionInfo(RequestBuilder<crate::model::GetConnectionInfoRequest>);

    impl GetConnectionInfo {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::GetConnectionInfoRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ConnectionInfo> {
            (*self.0.stub)
                .get_connection_info(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [parent][crate::model::GetConnectionInfoRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::GetConnectionInfoRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetConnectionInfo {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::list_users][crate::client::AlloyDBAdmin::list_users] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListUsers;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListUsers {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListUsers(RequestBuilder<crate::model::ListUsersRequest>);

    impl ListUsers {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ListUsersRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ListUsersResponse> {
            (*self.0.stub)
                .list_users(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<crate::model::ListUsersResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<crate::model::ListUsersResponse, gax::error::Error>
        {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [parent][crate::model::ListUsersRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [page_size][crate::model::ListUsersRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][crate::model::ListUsersRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::ListUsersRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [order_by][crate::model::ListUsersRequest::order_by].
        pub fn set_order_by<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.order_by = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListUsers {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::get_user][crate::client::AlloyDBAdmin::get_user] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GetUser;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetUser {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetUser(RequestBuilder<crate::model::GetUserRequest>);

    impl GetUser {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::GetUserRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::User> {
            (*self.0.stub)
                .get_user(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][crate::model::GetUserRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetUser {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::create_user][crate::client::AlloyDBAdmin::create_user] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::CreateUser;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CreateUser {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CreateUser(RequestBuilder<crate::model::CreateUserRequest>);

    impl CreateUser {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::CreateUserRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::User> {
            (*self.0.stub)
                .create_user(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [parent][crate::model::CreateUserRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [user_id][crate::model::CreateUserRequest::user_id].
        ///
        /// This is a **required** field for requests.
        pub fn set_user_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.user_id = v.into();
            self
        }

        /// Sets the value of [user][crate::model::CreateUserRequest::user].
        ///
        /// This is a **required** field for requests.
        pub fn set_user<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::User>,
        {
            self.0.request.user = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [user][crate::model::CreateUserRequest::user].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::User>,
        {
            self.0.request.user = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::CreateUserRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::CreateUserRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CreateUser {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::update_user][crate::client::AlloyDBAdmin::update_user] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::UpdateUser;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> UpdateUser {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct UpdateUser(RequestBuilder<crate::model::UpdateUserRequest>);

    impl UpdateUser {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::UpdateUserRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::User> {
            (*self.0.stub)
                .update_user(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
        pub fn set_update_mask<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
        pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.0.request.update_mask = v.map(|x| x.into());
            self
        }

        /// Sets the value of [user][crate::model::UpdateUserRequest::user].
        ///
        /// This is a **required** field for requests.
        pub fn set_user<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::User>,
        {
            self.0.request.user = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [user][crate::model::UpdateUserRequest::user].
        ///
        /// This is a **required** field for requests.
        pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::User>,
        {
            self.0.request.user = v.map(|x| x.into());
            self
        }

        /// Sets the value of [request_id][crate::model::UpdateUserRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::UpdateUserRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }

        /// Sets the value of [allow_missing][crate::model::UpdateUserRequest::allow_missing].
        pub fn set_allow_missing<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.allow_missing = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for UpdateUser {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::delete_user][crate::client::AlloyDBAdmin::delete_user] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::DeleteUser;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> DeleteUser {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct DeleteUser(RequestBuilder<crate::model::DeleteUserRequest>);

    impl DeleteUser {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::DeleteUserRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<()> {
            (*self.0.stub)
                .delete_user(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][crate::model::DeleteUserRequest::name].
        ///
        /// This is a **required** field for requests.
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::DeleteUserRequest::request_id].
        pub fn set_request_id<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.request_id = v.into();
            self
        }

        /// Sets the value of [validate_only][crate::model::DeleteUserRequest::validate_only].
        pub fn set_validate_only<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.validate_only = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for DeleteUser {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::list_databases][crate::client::AlloyDBAdmin::list_databases] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListDatabases;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListDatabases {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListDatabases(RequestBuilder<crate::model::ListDatabasesRequest>);

    impl ListDatabases {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<crate::model::ListDatabasesRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<crate::model::ListDatabasesResponse> {
            (*self.0.stub)
                .list_databases(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<crate::model::ListDatabasesResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<crate::model::ListDatabasesResponse, gax::error::Error>
        {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [parent][crate::model::ListDatabasesRequest::parent].
        ///
        /// This is a **required** field for requests.
        pub fn set_parent<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.parent = v.into();
            self
        }

        /// Sets the value of [page_size][crate::model::ListDatabasesRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][crate::model::ListDatabasesRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::ListDatabasesRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListDatabases {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::list_locations][crate::client::AlloyDBAdmin::list_locations] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListLocations;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListLocations {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListLocations(RequestBuilder<location::model::ListLocationsRequest>);

    impl ListLocations {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<location::model::ListLocationsRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<location::model::ListLocationsResponse> {
            (*self.0.stub)
                .list_locations(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<location::model::ListLocationsResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<location::model::ListLocationsResponse, gax::error::Error>
        {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [name][location::model::ListLocationsRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [filter][location::model::ListLocationsRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [page_size][location::model::ListLocationsRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][location::model::ListLocationsRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListLocations {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::get_location][crate::client::AlloyDBAdmin::get_location] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GetLocation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetLocation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetLocation(RequestBuilder<location::model::GetLocationRequest>);

    impl GetLocation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<location::model::GetLocationRequest>>(mut self, v: V) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<location::model::Location> {
            (*self.0.stub)
                .get_location(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][location::model::GetLocationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetLocation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::list_operations][crate::client::AlloyDBAdmin::list_operations] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::ListOperations;
    /// # tokio_test::block_on(async {
    /// use gax::paginator::ItemPaginator;
    ///
    /// let builder = prepare_request_builder();
    /// let mut items = builder.by_item();
    /// while let Some(result) = items.next().await {
    ///   let item = result?;
    /// }
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> ListOperations {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct ListOperations(RequestBuilder<longrunning::model::ListOperationsRequest>);

    impl ListOperations {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::ListOperationsRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<longrunning::model::ListOperationsResponse> {
            (*self.0.stub)
                .list_operations(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Streams each page in the collection.
        pub fn by_page(
            self,
        ) -> impl gax::paginator::Paginator<longrunning::model::ListOperationsResponse, gax::error::Error>
        {
            use std::clone::Clone;
            let token = self.0.request.page_token.clone();
            let execute = move |token: String| {
                let mut builder = self.clone();
                builder.0.request = builder.0.request.set_page_token(token);
                builder.send()
            };
            gax::paginator::internal::new_paginator(token, execute)
        }

        /// Streams each item in the collection.
        pub fn by_item(
            self,
        ) -> impl gax::paginator::ItemPaginator<
            longrunning::model::ListOperationsResponse,
            gax::error::Error,
        > {
            use gax::paginator::Paginator;
            self.by_page().items()
        }

        /// Sets the value of [name][longrunning::model::ListOperationsRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }

        /// Sets the value of [filter][longrunning::model::ListOperationsRequest::filter].
        pub fn set_filter<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.filter = v.into();
            self
        }

        /// Sets the value of [page_size][longrunning::model::ListOperationsRequest::page_size].
        pub fn set_page_size<T: Into<i32>>(mut self, v: T) -> Self {
            self.0.request.page_size = v.into();
            self
        }

        /// Sets the value of [page_token][longrunning::model::ListOperationsRequest::page_token].
        pub fn set_page_token<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.page_token = v.into();
            self
        }

        /// Sets the value of [return_partial_success][longrunning::model::ListOperationsRequest::return_partial_success].
        pub fn set_return_partial_success<T: Into<bool>>(mut self, v: T) -> Self {
            self.0.request.return_partial_success = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for ListOperations {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::get_operation][crate::client::AlloyDBAdmin::get_operation] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::GetOperation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> GetOperation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct GetOperation(RequestBuilder<longrunning::model::GetOperationRequest>);

    impl GetOperation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::GetOperationRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<longrunning::model::Operation> {
            (*self.0.stub)
                .get_operation(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][longrunning::model::GetOperationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for GetOperation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::delete_operation][crate::client::AlloyDBAdmin::delete_operation] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::DeleteOperation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> DeleteOperation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct DeleteOperation(RequestBuilder<longrunning::model::DeleteOperationRequest>);

    impl DeleteOperation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::DeleteOperationRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<()> {
            (*self.0.stub)
                .delete_operation(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][longrunning::model::DeleteOperationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for DeleteOperation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }

    /// The request builder for [AlloyDBAdmin::cancel_operation][crate::client::AlloyDBAdmin::cancel_operation] calls.
    ///
    /// # Example
    /// ```no_run
    /// # use google_cloud_alloydb_v1::builder;
    /// use builder::alloy_db_admin::CancelOperation;
    /// # tokio_test::block_on(async {
    ///
    /// let builder = prepare_request_builder();
    /// let response = builder.send().await?;
    /// # gax::Result::<()>::Ok(()) });
    ///
    /// fn prepare_request_builder() -> CancelOperation {
    ///   # panic!();
    ///   // ... details omitted ...
    /// }
    /// ```
    #[derive(Clone, Debug)]
    pub struct CancelOperation(RequestBuilder<longrunning::model::CancelOperationRequest>);

    impl CancelOperation {
        pub(crate) fn new(
            stub: std::sync::Arc<dyn super::super::stub::dynamic::AlloyDBAdmin>,
        ) -> Self {
            Self(RequestBuilder::new(stub))
        }

        /// Sets the full request, replacing any prior values.
        pub fn with_request<V: Into<longrunning::model::CancelOperationRequest>>(
            mut self,
            v: V,
        ) -> Self {
            self.0.request = v.into();
            self
        }

        /// Sets all the options, replacing any prior values.
        pub fn with_options<V: Into<gax::options::RequestOptions>>(mut self, v: V) -> Self {
            self.0.options = v.into();
            self
        }

        /// Sends the request.
        pub async fn send(self) -> Result<()> {
            (*self.0.stub)
                .cancel_operation(self.0.request, self.0.options)
                .await
                .map(gax::response::Response::into_body)
        }

        /// Sets the value of [name][longrunning::model::CancelOperationRequest::name].
        pub fn set_name<T: Into<std::string::String>>(mut self, v: T) -> Self {
            self.0.request.name = v.into();
            self
        }
    }

    #[doc(hidden)]
    impl gax::options::internal::RequestBuilder for CancelOperation {
        fn request_options(&mut self) -> &mut gax::options::RequestOptions {
            &mut self.0.options
        }
    }
}
