// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message representing a period of time between two timestamps.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimestampRange {
    /// Begin of the period (inclusive).
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End of the period (exclusive).
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimestampRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimestampRange::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimestampRange::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimestampRange::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimestampRange::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimestampRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.TimestampRange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimestampRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimestampRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimestampRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimestampRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimestampRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimestampRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimestampRange");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A resource that represents a location with full geographic information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Location {
    /// The type of a location, which corresponds to the address lines field of
    /// [google.type.PostalAddress][google.type.PostalAddress]. For example,
    /// "Downtown, Atlanta, GA, USA" has a type of
    /// [LocationType.NEIGHBORHOOD][google.cloud.talent.v4.Location.LocationType.NEIGHBORHOOD],
    /// and "Kansas City, KS, USA" has a type of
    /// [LocationType.LOCALITY][google.cloud.talent.v4.Location.LocationType.LOCALITY].
    ///
    /// [google.cloud.talent.v4.Location.LocationType.LOCALITY]: crate::model::location::LocationType::Locality
    /// [google.cloud.talent.v4.Location.LocationType.NEIGHBORHOOD]: crate::model::location::LocationType::Neighborhood
    /// [google.type.PostalAddress]: gtype::model::PostalAddress
    pub location_type: crate::model::location::LocationType,

    /// Postal address of the location that includes human readable information,
    /// such as postal delivery and payments addresses. Given a postal address,
    /// a postal service can deliver items to a premises, P.O. Box, or other
    /// delivery location.
    pub postal_address: std::option::Option<gtype::model::PostalAddress>,

    /// An object representing a latitude/longitude pair.
    pub lat_lng: std::option::Option<gtype::model::LatLng>,

    /// Radius in miles of the job location. This value is derived from the
    /// location bounding box in which a circle with the specified radius
    /// centered from [google.type.LatLng][google.type.LatLng] covers the area
    /// associated with the job location. For example, currently, "Mountain View,
    /// CA, USA" has a radius of 6.17 miles.
    ///
    /// [google.type.LatLng]: gtype::model::LatLng
    pub radius_miles: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location_type][crate::model::Location::location_type].
    pub fn set_location_type<T: std::convert::Into<crate::model::location::LocationType>>(
        mut self,
        v: T,
    ) -> Self {
        self.location_type = v.into();
        self
    }

    /// Sets the value of [postal_address][crate::model::Location::postal_address].
    pub fn set_postal_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::PostalAddress>,
    {
        self.postal_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [postal_address][crate::model::Location::postal_address].
    pub fn set_or_clear_postal_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::PostalAddress>,
    {
        self.postal_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lat_lng][crate::model::Location::lat_lng].
    pub fn set_lat_lng<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.lat_lng = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lat_lng][crate::model::Location::lat_lng].
    pub fn set_or_clear_lat_lng<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.lat_lng = v.map(|x| x.into());
        self
    }

    /// Sets the value of [radius_miles][crate::model::Location::radius_miles].
    pub fn set_radius_miles<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.radius_miles = v.into();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.Location"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Location {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location_type,
            __postal_address,
            __lat_lng,
            __radius_miles,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Location")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "locationType" => Ok(__FieldTag::__location_type),
                            "location_type" => Ok(__FieldTag::__location_type),
                            "postalAddress" => Ok(__FieldTag::__postal_address),
                            "postal_address" => Ok(__FieldTag::__postal_address),
                            "latLng" => Ok(__FieldTag::__lat_lng),
                            "lat_lng" => Ok(__FieldTag::__lat_lng),
                            "radiusMiles" => Ok(__FieldTag::__radius_miles),
                            "radius_miles" => Ok(__FieldTag::__radius_miles),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Location;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Location")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location_type => {
                            if !fields.insert(__FieldTag::__location_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_type",
                                ));
                            }
                            result.location_type = map.next_value::<std::option::Option<crate::model::location::LocationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__postal_address => {
                            if !fields.insert(__FieldTag::__postal_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postal_address",
                                ));
                            }
                            result.postal_address = map
                                .next_value::<std::option::Option<gtype::model::PostalAddress>>()?;
                        }
                        __FieldTag::__lat_lng => {
                            if !fields.insert(__FieldTag::__lat_lng) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lat_lng",
                                ));
                            }
                            result.lat_lng =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__radius_miles => {
                            if !fields.insert(__FieldTag::__radius_miles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for radius_miles",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.radius_miles = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Location {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.location_type) {
            state.serialize_entry("locationType", &self.location_type)?;
        }
        if self.postal_address.is_some() {
            state.serialize_entry("postalAddress", &self.postal_address)?;
        }
        if self.lat_lng.is_some() {
            state.serialize_entry("latLng", &self.lat_lng)?;
        }
        if !wkt::internal::is_default(&self.radius_miles) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("radiusMiles", &__With(&self.radius_miles))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Location {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Location");
        debug_struct.field("location_type", &self.location_type);
        debug_struct.field("postal_address", &self.postal_address);
        debug_struct.field("lat_lng", &self.lat_lng);
        debug_struct.field("radius_miles", &self.radius_miles);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Location].
pub mod location {
    #[allow(unused_imports)]
    use super::*;

    /// An enum which represents the type of a location.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocationType {
        /// Default value if the type isn't specified.
        Unspecified,
        /// A country level location.
        Country,
        /// A state or equivalent level location.
        AdministrativeArea,
        /// A county or equivalent level location.
        SubAdministrativeArea,
        /// A city or equivalent level location.
        Locality,
        /// A postal code level location.
        PostalCode,
        /// A sublocality is a subdivision of a locality, for example a city borough,
        /// ward, or arrondissement. Sublocalities are usually recognized by a local
        /// political authority. For example, Manhattan and Brooklyn are recognized
        /// as boroughs by the City of New York, and are therefore modeled as
        /// sublocalities.
        SubLocality,
        /// A district or equivalent level location.
        SubLocality1,
        /// A smaller district or equivalent level display.
        SubLocality2,
        /// A neighborhood level location.
        Neighborhood,
        /// A street address level location.
        StreetAddress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocationType::value] or
        /// [LocationType::name].
        UnknownValue(location_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod location_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Country => std::option::Option::Some(1),
                Self::AdministrativeArea => std::option::Option::Some(2),
                Self::SubAdministrativeArea => std::option::Option::Some(3),
                Self::Locality => std::option::Option::Some(4),
                Self::PostalCode => std::option::Option::Some(5),
                Self::SubLocality => std::option::Option::Some(6),
                Self::SubLocality1 => std::option::Option::Some(7),
                Self::SubLocality2 => std::option::Option::Some(8),
                Self::Neighborhood => std::option::Option::Some(9),
                Self::StreetAddress => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOCATION_TYPE_UNSPECIFIED"),
                Self::Country => std::option::Option::Some("COUNTRY"),
                Self::AdministrativeArea => std::option::Option::Some("ADMINISTRATIVE_AREA"),
                Self::SubAdministrativeArea => std::option::Option::Some("SUB_ADMINISTRATIVE_AREA"),
                Self::Locality => std::option::Option::Some("LOCALITY"),
                Self::PostalCode => std::option::Option::Some("POSTAL_CODE"),
                Self::SubLocality => std::option::Option::Some("SUB_LOCALITY"),
                Self::SubLocality1 => std::option::Option::Some("SUB_LOCALITY_1"),
                Self::SubLocality2 => std::option::Option::Some("SUB_LOCALITY_2"),
                Self::Neighborhood => std::option::Option::Some("NEIGHBORHOOD"),
                Self::StreetAddress => std::option::Option::Some("STREET_ADDRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Country,
                2 => Self::AdministrativeArea,
                3 => Self::SubAdministrativeArea,
                4 => Self::Locality,
                5 => Self::PostalCode,
                6 => Self::SubLocality,
                7 => Self::SubLocality1,
                8 => Self::SubLocality2,
                9 => Self::Neighborhood,
                10 => Self::StreetAddress,
                _ => Self::UnknownValue(location_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "COUNTRY" => Self::Country,
                "ADMINISTRATIVE_AREA" => Self::AdministrativeArea,
                "SUB_ADMINISTRATIVE_AREA" => Self::SubAdministrativeArea,
                "LOCALITY" => Self::Locality,
                "POSTAL_CODE" => Self::PostalCode,
                "SUB_LOCALITY" => Self::SubLocality,
                "SUB_LOCALITY_1" => Self::SubLocality1,
                "SUB_LOCALITY_2" => Self::SubLocality2,
                "NEIGHBORHOOD" => Self::Neighborhood,
                "STREET_ADDRESS" => Self::StreetAddress,
                _ => Self::UnknownValue(location_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Country => serializer.serialize_i32(1),
                Self::AdministrativeArea => serializer.serialize_i32(2),
                Self::SubAdministrativeArea => serializer.serialize_i32(3),
                Self::Locality => serializer.serialize_i32(4),
                Self::PostalCode => serializer.serialize_i32(5),
                Self::SubLocality => serializer.serialize_i32(6),
                Self::SubLocality1 => serializer.serialize_i32(7),
                Self::SubLocality2 => serializer.serialize_i32(8),
                Self::Neighborhood => serializer.serialize_i32(9),
                Self::StreetAddress => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocationType>::new(
                ".google.cloud.talent.v4.Location.LocationType",
            ))
        }
    }
}

/// Meta information related to the job searcher or entity
/// conducting the job search. This information is used to improve the
/// performance of the service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RequestMetadata {
    /// Required if
    /// [allow_missing_ids][google.cloud.talent.v4.RequestMetadata.allow_missing_ids]
    /// is unset or `false`.
    ///
    /// The client-defined scope or source of the service call, which typically
    /// is the domain on
    /// which the service has been implemented and is currently being run.
    ///
    /// For example, if the service is being run by client \<em\>Foo, Inc.\</em\>, on
    /// job board www.foo.com and career site www.bar.com, then this field is
    /// set to "foo.com" for use on the job board, and "bar.com" for use on the
    /// career site.
    ///
    /// Note that any improvements to the model for a particular tenant site rely
    /// on this field being set correctly to a unique domain.
    ///
    /// The maximum number of allowed characters is 255.
    ///
    /// [google.cloud.talent.v4.RequestMetadata.allow_missing_ids]: crate::model::RequestMetadata::allow_missing_ids
    pub domain: std::string::String,

    /// Required if
    /// [allow_missing_ids][google.cloud.talent.v4.RequestMetadata.allow_missing_ids]
    /// is unset or `false`.
    ///
    /// A unique session identification string. A session is defined as the
    /// duration of an end user's interaction with the service over a certain
    /// period.
    /// Obfuscate this field for privacy concerns before
    /// providing it to the service.
    ///
    /// Note that any improvements to the model for a particular tenant site rely
    /// on this field being set correctly to a unique session ID.
    ///
    /// The maximum number of allowed characters is 255.
    ///
    /// [google.cloud.talent.v4.RequestMetadata.allow_missing_ids]: crate::model::RequestMetadata::allow_missing_ids
    pub session_id: std::string::String,

    /// Required if
    /// [allow_missing_ids][google.cloud.talent.v4.RequestMetadata.allow_missing_ids]
    /// is unset or `false`.
    ///
    /// A unique user identification string, as determined by the client.
    /// To have the strongest positive impact on search quality
    /// make sure the client-level is unique.
    /// Obfuscate this field for privacy concerns before
    /// providing it to the service.
    ///
    /// Note that any improvements to the model for a particular tenant site rely
    /// on this field being set correctly to a unique user ID.
    ///
    /// The maximum number of allowed characters is 255.
    ///
    /// [google.cloud.talent.v4.RequestMetadata.allow_missing_ids]: crate::model::RequestMetadata::allow_missing_ids
    pub user_id: std::string::String,

    /// Only set when any of
    /// [domain][google.cloud.talent.v4.RequestMetadata.domain],
    /// [session_id][google.cloud.talent.v4.RequestMetadata.session_id] and
    /// [user_id][google.cloud.talent.v4.RequestMetadata.user_id] isn't available
    /// for some reason. It is highly recommended not to set this field and provide
    /// accurate [domain][google.cloud.talent.v4.RequestMetadata.domain],
    /// [session_id][google.cloud.talent.v4.RequestMetadata.session_id] and
    /// [user_id][google.cloud.talent.v4.RequestMetadata.user_id] for the best
    /// service experience.
    ///
    /// [google.cloud.talent.v4.RequestMetadata.domain]: crate::model::RequestMetadata::domain
    /// [google.cloud.talent.v4.RequestMetadata.session_id]: crate::model::RequestMetadata::session_id
    /// [google.cloud.talent.v4.RequestMetadata.user_id]: crate::model::RequestMetadata::user_id
    pub allow_missing_ids: bool,

    /// The type of device used by the job seeker at the time of the call to the
    /// service.
    pub device_info: std::option::Option<crate::model::DeviceInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RequestMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::RequestMetadata::domain].
    pub fn set_domain<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain = v.into();
        self
    }

    /// Sets the value of [session_id][crate::model::RequestMetadata::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::RequestMetadata::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [allow_missing_ids][crate::model::RequestMetadata::allow_missing_ids].
    pub fn set_allow_missing_ids<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing_ids = v.into();
        self
    }

    /// Sets the value of [device_info][crate::model::RequestMetadata::device_info].
    pub fn set_device_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeviceInfo>,
    {
        self.device_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [device_info][crate::model::RequestMetadata::device_info].
    pub fn set_or_clear_device_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeviceInfo>,
    {
        self.device_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RequestMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.RequestMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RequestMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __domain,
            __session_id,
            __user_id,
            __allow_missing_ids,
            __device_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RequestMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "domain" => Ok(__FieldTag::__domain),
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "allowMissingIds" => Ok(__FieldTag::__allow_missing_ids),
                            "allow_missing_ids" => Ok(__FieldTag::__allow_missing_ids),
                            "deviceInfo" => Ok(__FieldTag::__device_info),
                            "device_info" => Ok(__FieldTag::__device_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RequestMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RequestMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_id",
                                ));
                            }
                            result.session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            result.user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing_ids => {
                            if !fields.insert(__FieldTag::__allow_missing_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing_ids",
                                ));
                            }
                            result.allow_missing_ids = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__device_info => {
                            if !fields.insert(__FieldTag::__device_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_info",
                                ));
                            }
                            result.device_info =
                                map.next_value::<std::option::Option<crate::model::DeviceInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RequestMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.domain.is_empty() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.session_id.is_empty() {
            state.serialize_entry("sessionId", &self.session_id)?;
        }
        if !self.user_id.is_empty() {
            state.serialize_entry("userId", &self.user_id)?;
        }
        if !wkt::internal::is_default(&self.allow_missing_ids) {
            state.serialize_entry("allowMissingIds", &self.allow_missing_ids)?;
        }
        if self.device_info.is_some() {
            state.serialize_entry("deviceInfo", &self.device_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RequestMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RequestMetadata");
        debug_struct.field("domain", &self.domain);
        debug_struct.field("session_id", &self.session_id);
        debug_struct.field("user_id", &self.user_id);
        debug_struct.field("allow_missing_ids", &self.allow_missing_ids);
        debug_struct.field("device_info", &self.device_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Additional information returned to client, such as debugging information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResponseMetadata {
    /// A unique id associated with this call.
    /// This id is logged for tracking purposes.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResponseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_id][crate::model::ResponseMetadata::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for ResponseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ResponseMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResponseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResponseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResponseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResponseMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResponseMetadata");
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Device information collected from the job seeker, candidate, or
/// other entity conducting the job search. Providing this information improves
/// the quality of the search results across devices.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeviceInfo {
    /// Type of the device.
    pub device_type: crate::model::device_info::DeviceType,

    /// A device-specific ID. The ID must be a unique identifier that
    /// distinguishes the device from other devices.
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeviceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [device_type][crate::model::DeviceInfo::device_type].
    pub fn set_device_type<T: std::convert::Into<crate::model::device_info::DeviceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.device_type = v.into();
        self
    }

    /// Sets the value of [id][crate::model::DeviceInfo::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for DeviceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.DeviceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeviceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __device_type,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeviceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deviceType" => Ok(__FieldTag::__device_type),
                            "device_type" => Ok(__FieldTag::__device_type),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeviceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeviceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__device_type => {
                            if !fields.insert(__FieldTag::__device_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_type",
                                ));
                            }
                            result.device_type = map.next_value::<std::option::Option<crate::model::device_info::DeviceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeviceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.device_type) {
            state.serialize_entry("deviceType", &self.device_type)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeviceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeviceInfo");
        debug_struct.field("device_type", &self.device_type);
        debug_struct.field("id", &self.id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DeviceInfo].
pub mod device_info {
    #[allow(unused_imports)]
    use super::*;

    /// An enumeration describing an API access portal and exposure mechanism.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DeviceType {
        /// The device type isn't specified.
        Unspecified,
        /// A desktop web browser, such as, Chrome, Firefox, Safari, or Internet
        /// Explorer)
        Web,
        /// A mobile device web browser, such as a phone or tablet with a Chrome
        /// browser.
        MobileWeb,
        /// An Android device native application.
        Android,
        /// An iOS device native application.
        Ios,
        /// A bot, as opposed to a device operated by human beings, such as a web
        /// crawler.
        Bot,
        /// Other devices types.
        Other,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DeviceType::value] or
        /// [DeviceType::name].
        UnknownValue(device_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod device_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DeviceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Web => std::option::Option::Some(1),
                Self::MobileWeb => std::option::Option::Some(2),
                Self::Android => std::option::Option::Some(3),
                Self::Ios => std::option::Option::Some(4),
                Self::Bot => std::option::Option::Some(5),
                Self::Other => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DEVICE_TYPE_UNSPECIFIED"),
                Self::Web => std::option::Option::Some("WEB"),
                Self::MobileWeb => std::option::Option::Some("MOBILE_WEB"),
                Self::Android => std::option::Option::Some("ANDROID"),
                Self::Ios => std::option::Option::Some("IOS"),
                Self::Bot => std::option::Option::Some("BOT"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DeviceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DeviceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DeviceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Web,
                2 => Self::MobileWeb,
                3 => Self::Android,
                4 => Self::Ios,
                5 => Self::Bot,
                6 => Self::Other,
                _ => Self::UnknownValue(device_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DeviceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEVICE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "WEB" => Self::Web,
                "MOBILE_WEB" => Self::MobileWeb,
                "ANDROID" => Self::Android,
                "IOS" => Self::Ios,
                "BOT" => Self::Bot,
                "OTHER" => Self::Other,
                _ => Self::UnknownValue(device_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DeviceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Web => serializer.serialize_i32(1),
                Self::MobileWeb => serializer.serialize_i32(2),
                Self::Android => serializer.serialize_i32(3),
                Self::Ios => serializer.serialize_i32(4),
                Self::Bot => serializer.serialize_i32(5),
                Self::Other => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DeviceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DeviceType>::new(
                ".google.cloud.talent.v4.DeviceInfo.DeviceType",
            ))
        }
    }
}

/// Custom attribute values that are either filterable or non-filterable.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomAttribute {
    /// Exactly one of
    /// [string_values][google.cloud.talent.v4.CustomAttribute.string_values] or
    /// [long_values][google.cloud.talent.v4.CustomAttribute.long_values] must be
    /// specified.
    ///
    /// This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or
    /// `CASE_INSENSITIVE_MATCH`) search.
    /// For filterable `string_value`s, a maximum total number of 200 values
    /// is allowed, with each `string_value` has a byte size of no more than
    /// 500B. For unfilterable `string_values`, the maximum total byte size of
    /// unfilterable `string_values` is 50KB.
    ///
    /// Empty string isn't allowed.
    ///
    /// [google.cloud.talent.v4.CustomAttribute.long_values]: crate::model::CustomAttribute::long_values
    /// [google.cloud.talent.v4.CustomAttribute.string_values]: crate::model::CustomAttribute::string_values
    pub string_values: std::vec::Vec<std::string::String>,

    /// Exactly one of
    /// [string_values][google.cloud.talent.v4.CustomAttribute.string_values] or
    /// [long_values][google.cloud.talent.v4.CustomAttribute.long_values] must be
    /// specified.
    ///
    /// This field is used to perform number range search.
    /// (`EQ`, `GT`, `GE`, `LE`, `LT`) over filterable `long_value`.
    ///
    /// Currently at most 1
    /// [long_values][google.cloud.talent.v4.CustomAttribute.long_values] is
    /// supported.
    ///
    /// [google.cloud.talent.v4.CustomAttribute.long_values]: crate::model::CustomAttribute::long_values
    /// [google.cloud.talent.v4.CustomAttribute.string_values]: crate::model::CustomAttribute::string_values
    pub long_values: std::vec::Vec<i64>,

    /// If the `filterable` flag is true, the custom field values may be used for
    /// custom attribute filters
    /// [JobQuery.custom_attribute_filter][google.cloud.talent.v4.JobQuery.custom_attribute_filter].
    /// If false, these values may not be used for custom attribute filters.
    ///
    /// Default is false.
    ///
    /// [google.cloud.talent.v4.JobQuery.custom_attribute_filter]: crate::model::JobQuery::custom_attribute_filter
    pub filterable: bool,

    /// If the `keyword_searchable` flag is true, the keywords in custom fields are
    /// searchable by keyword match.
    /// If false, the values are not searchable by keyword match.
    ///
    /// Default is false.
    pub keyword_searchable: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [string_values][crate::model::CustomAttribute::string_values].
    pub fn set_string_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.string_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [long_values][crate::model::CustomAttribute::long_values].
    pub fn set_long_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.long_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filterable][crate::model::CustomAttribute::filterable].
    pub fn set_filterable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.filterable = v.into();
        self
    }

    /// Sets the value of [keyword_searchable][crate::model::CustomAttribute::keyword_searchable].
    pub fn set_keyword_searchable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.keyword_searchable = v.into();
        self
    }
}

impl wkt::message::Message for CustomAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CustomAttribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomAttribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __string_values,
            __long_values,
            __filterable,
            __keyword_searchable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomAttribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stringValues" => Ok(__FieldTag::__string_values),
                            "string_values" => Ok(__FieldTag::__string_values),
                            "longValues" => Ok(__FieldTag::__long_values),
                            "long_values" => Ok(__FieldTag::__long_values),
                            "filterable" => Ok(__FieldTag::__filterable),
                            "keywordSearchable" => Ok(__FieldTag::__keyword_searchable),
                            "keyword_searchable" => Ok(__FieldTag::__keyword_searchable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomAttribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomAttribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__string_values => {
                            if !fields.insert(__FieldTag::__string_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_values",
                                ));
                            }
                            result.string_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__long_values => {
                            if !fields.insert(__FieldTag::__long_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for long_values",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.long_values = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__filterable => {
                            if !fields.insert(__FieldTag::__filterable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filterable",
                                ));
                            }
                            result.filterable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__keyword_searchable => {
                            if !fields.insert(__FieldTag::__keyword_searchable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keyword_searchable",
                                ));
                            }
                            result.keyword_searchable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.string_values.is_empty() {
            state.serialize_entry("stringValues", &self.string_values)?;
        }
        if !self.long_values.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("longValues", &__With(&self.long_values))?;
        }
        if !wkt::internal::is_default(&self.filterable) {
            state.serialize_entry("filterable", &self.filterable)?;
        }
        if !wkt::internal::is_default(&self.keyword_searchable) {
            state.serialize_entry("keywordSearchable", &self.keyword_searchable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomAttribute");
        debug_struct.field("string_values", &self.string_values);
        debug_struct.field("long_values", &self.long_values);
        debug_struct.field("filterable", &self.filterable);
        debug_struct.field("keyword_searchable", &self.keyword_searchable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Spell check result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SpellingCorrection {
    /// Indicates if the query was corrected by the spell checker.
    pub corrected: bool,

    /// Correction output consisting of the corrected keyword string.
    pub corrected_text: std::string::String,

    /// Corrected output with html tags to highlight the corrected words.
    /// Corrected words are called out with the "\<b\>\<i\>...\</i\>\</b\>" html tags.
    ///
    /// For example, the user input query is "software enginear", where the second
    /// word, "enginear," is incorrect. It should be "engineer". When spelling
    /// correction is enabled, this value is
    /// "software \<b\>\<i\>engineer\</i\>\</b\>".
    pub corrected_html: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpellingCorrection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [corrected][crate::model::SpellingCorrection::corrected].
    pub fn set_corrected<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.corrected = v.into();
        self
    }

    /// Sets the value of [corrected_text][crate::model::SpellingCorrection::corrected_text].
    pub fn set_corrected_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.corrected_text = v.into();
        self
    }

    /// Sets the value of [corrected_html][crate::model::SpellingCorrection::corrected_html].
    pub fn set_corrected_html<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.corrected_html = v.into();
        self
    }
}

impl wkt::message::Message for SpellingCorrection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.SpellingCorrection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpellingCorrection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __corrected,
            __corrected_text,
            __corrected_html,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpellingCorrection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "corrected" => Ok(__FieldTag::__corrected),
                            "correctedText" => Ok(__FieldTag::__corrected_text),
                            "corrected_text" => Ok(__FieldTag::__corrected_text),
                            "correctedHtml" => Ok(__FieldTag::__corrected_html),
                            "corrected_html" => Ok(__FieldTag::__corrected_html),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpellingCorrection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpellingCorrection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__corrected => {
                            if !fields.insert(__FieldTag::__corrected) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for corrected",
                                ));
                            }
                            result.corrected = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__corrected_text => {
                            if !fields.insert(__FieldTag::__corrected_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for corrected_text",
                                ));
                            }
                            result.corrected_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__corrected_html => {
                            if !fields.insert(__FieldTag::__corrected_html) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for corrected_html",
                                ));
                            }
                            result.corrected_html = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpellingCorrection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.corrected) {
            state.serialize_entry("corrected", &self.corrected)?;
        }
        if !self.corrected_text.is_empty() {
            state.serialize_entry("correctedText", &self.corrected_text)?;
        }
        if !self.corrected_html.is_empty() {
            state.serialize_entry("correctedHtml", &self.corrected_html)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SpellingCorrection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpellingCorrection");
        debug_struct.field("corrected", &self.corrected);
        debug_struct.field("corrected_text", &self.corrected_text);
        debug_struct.field("corrected_html", &self.corrected_html);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Job compensation details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompensationInfo {
    /// Job compensation information.
    ///
    /// At most one entry can be of type
    /// [CompensationInfo.CompensationType.BASE][google.cloud.talent.v4.CompensationInfo.CompensationType.BASE],
    /// which is referred as **base compensation entry** for the job.
    ///
    /// [google.cloud.talent.v4.CompensationInfo.CompensationType.BASE]: crate::model::compensation_info::CompensationType::Base
    pub entries: std::vec::Vec<crate::model::compensation_info::CompensationEntry>,

    /// Output only. Annualized base compensation range. Computed as base
    /// compensation entry's
    /// [CompensationEntry.amount][google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]
    /// times
    /// [CompensationEntry.expected_units_per_year][google.cloud.talent.v4.CompensationInfo.CompensationEntry.expected_units_per_year].
    ///
    /// See
    /// [CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry]
    /// for explanation on compensation annualization.
    ///
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry]: crate::model::compensation_info::CompensationEntry
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]: crate::model::compensation_info::CompensationEntry::compensation_amount
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.expected_units_per_year]: crate::model::compensation_info::CompensationEntry::expected_units_per_year
    pub annualized_base_compensation_range:
        std::option::Option<crate::model::compensation_info::CompensationRange>,

    /// Output only. Annualized total compensation range. Computed as all
    /// compensation entries'
    /// [CompensationEntry.amount][google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]
    /// times
    /// [CompensationEntry.expected_units_per_year][google.cloud.talent.v4.CompensationInfo.CompensationEntry.expected_units_per_year].
    ///
    /// See
    /// [CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry]
    /// for explanation on compensation annualization.
    ///
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry]: crate::model::compensation_info::CompensationEntry
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]: crate::model::compensation_info::CompensationEntry::compensation_amount
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.expected_units_per_year]: crate::model::compensation_info::CompensationEntry::expected_units_per_year
    pub annualized_total_compensation_range:
        std::option::Option<crate::model::compensation_info::CompensationRange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompensationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::CompensationInfo::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::compensation_info::CompensationEntry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annualized_base_compensation_range][crate::model::CompensationInfo::annualized_base_compensation_range].
    pub fn set_annualized_base_compensation_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compensation_info::CompensationRange>,
    {
        self.annualized_base_compensation_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annualized_base_compensation_range][crate::model::CompensationInfo::annualized_base_compensation_range].
    pub fn set_or_clear_annualized_base_compensation_range<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::compensation_info::CompensationRange>,
    {
        self.annualized_base_compensation_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annualized_total_compensation_range][crate::model::CompensationInfo::annualized_total_compensation_range].
    pub fn set_annualized_total_compensation_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compensation_info::CompensationRange>,
    {
        self.annualized_total_compensation_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [annualized_total_compensation_range][crate::model::CompensationInfo::annualized_total_compensation_range].
    pub fn set_or_clear_annualized_total_compensation_range<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::compensation_info::CompensationRange>,
    {
        self.annualized_total_compensation_range = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CompensationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CompensationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompensationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            __annualized_base_compensation_range,
            __annualized_total_compensation_range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompensationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            "annualizedBaseCompensationRange" => {
                                Ok(__FieldTag::__annualized_base_compensation_range)
                            }
                            "annualized_base_compensation_range" => {
                                Ok(__FieldTag::__annualized_base_compensation_range)
                            }
                            "annualizedTotalCompensationRange" => {
                                Ok(__FieldTag::__annualized_total_compensation_range)
                            }
                            "annualized_total_compensation_range" => {
                                Ok(__FieldTag::__annualized_total_compensation_range)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompensationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompensationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::compensation_info::CompensationEntry,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annualized_base_compensation_range => {
                            if !fields.insert(__FieldTag::__annualized_base_compensation_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annualized_base_compensation_range",
                                ));
                            }
                            result.annualized_base_compensation_range = map
                                .next_value::<std::option::Option<
                                    crate::model::compensation_info::CompensationRange,
                                >>()?;
                        }
                        __FieldTag::__annualized_total_compensation_range => {
                            if !fields.insert(__FieldTag::__annualized_total_compensation_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annualized_total_compensation_range",
                                ));
                            }
                            result.annualized_total_compensation_range = map
                                .next_value::<std::option::Option<
                                    crate::model::compensation_info::CompensationRange,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompensationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if self.annualized_base_compensation_range.is_some() {
            state.serialize_entry(
                "annualizedBaseCompensationRange",
                &self.annualized_base_compensation_range,
            )?;
        }
        if self.annualized_total_compensation_range.is_some() {
            state.serialize_entry(
                "annualizedTotalCompensationRange",
                &self.annualized_total_compensation_range,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompensationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompensationInfo");
        debug_struct.field("entries", &self.entries);
        debug_struct.field(
            "annualized_base_compensation_range",
            &self.annualized_base_compensation_range,
        );
        debug_struct.field(
            "annualized_total_compensation_range",
            &self.annualized_total_compensation_range,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CompensationInfo].
pub mod compensation_info {
    #[allow(unused_imports)]
    use super::*;

    /// A compensation entry that represents one component of compensation, such
    /// as base pay, bonus, or other compensation type.
    ///
    /// Annualization: One compensation entry can be annualized if
    ///
    /// - it contains valid
    ///   [amount][google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]
    ///   or
    ///   [range][google.cloud.talent.v4.CompensationInfo.CompensationEntry.range].
    /// - and its
    ///   [expected_units_per_year][google.cloud.talent.v4.CompensationInfo.CompensationEntry.expected_units_per_year]
    ///   is set or can be derived. Its annualized range is determined as
    ///   ([amount][google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]
    ///   or
    ///   [range][google.cloud.talent.v4.CompensationInfo.CompensationEntry.range])
    ///   times
    ///   [expected_units_per_year][google.cloud.talent.v4.CompensationInfo.CompensationEntry.expected_units_per_year].
    ///
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]: crate::model::compensation_info::CompensationEntry::compensation_amount
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.expected_units_per_year]: crate::model::compensation_info::CompensationEntry::expected_units_per_year
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.range]: crate::model::compensation_info::CompensationEntry::compensation_amount
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CompensationEntry {
        /// Compensation type.
        ///
        /// Default is
        /// [CompensationType.COMPENSATION_TYPE_UNSPECIFIED][google.cloud.talent.v4.CompensationInfo.CompensationType.COMPENSATION_TYPE_UNSPECIFIED].
        ///
        /// [google.cloud.talent.v4.CompensationInfo.CompensationType.COMPENSATION_TYPE_UNSPECIFIED]: crate::model::compensation_info::CompensationType::Unspecified
        pub r#type: crate::model::compensation_info::CompensationType,

        /// Frequency of the specified amount.
        ///
        /// Default is
        /// [CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED][google.cloud.talent.v4.CompensationInfo.CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED].
        ///
        /// [google.cloud.talent.v4.CompensationInfo.CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED]: crate::model::compensation_info::CompensationUnit::Unspecified
        pub unit: crate::model::compensation_info::CompensationUnit,

        /// Compensation description.  For example, could
        /// indicate equity terms or provide additional context to an estimated
        /// bonus.
        pub description: std::string::String,

        /// Expected number of units paid each year. If not specified, when
        /// [Job.employment_types][google.cloud.talent.v4.Job.employment_types] is
        /// FULLTIME, a default value is inferred based on
        /// [unit][google.cloud.talent.v4.CompensationInfo.CompensationEntry.unit].
        /// Default values:
        ///
        /// - HOURLY: 2080
        /// - DAILY: 260
        /// - WEEKLY: 52
        /// - MONTHLY: 12
        /// - ANNUAL: 1
        ///
        /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.unit]: crate::model::compensation_info::CompensationEntry::unit
        /// [google.cloud.talent.v4.Job.employment_types]: crate::model::Job::employment_types
        pub expected_units_per_year: std::option::Option<wkt::DoubleValue>,

        /// Compensation amount. It could be a fixed amount or a floating range.
        pub compensation_amount: std::option::Option<
            crate::model::compensation_info::compensation_entry::CompensationAmount,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CompensationEntry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::compensation_info::CompensationEntry::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::compensation_info::CompensationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [unit][crate::model::compensation_info::CompensationEntry::unit].
        pub fn set_unit<
            T: std::convert::Into<crate::model::compensation_info::CompensationUnit>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.unit = v.into();
            self
        }

        /// Sets the value of [description][crate::model::compensation_info::CompensationEntry::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [expected_units_per_year][crate::model::compensation_info::CompensationEntry::expected_units_per_year].
        pub fn set_expected_units_per_year<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.expected_units_per_year = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expected_units_per_year][crate::model::compensation_info::CompensationEntry::expected_units_per_year].
        pub fn set_or_clear_expected_units_per_year<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::DoubleValue>,
        {
            self.expected_units_per_year = v.map(|x| x.into());
            self
        }

        /// Sets the value of [compensation_amount][crate::model::compensation_info::CompensationEntry::compensation_amount].
        ///
        /// Note that all the setters affecting `compensation_amount` are mutually
        /// exclusive.
        pub fn set_compensation_amount<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::compensation_info::compensation_entry::CompensationAmount,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.compensation_amount = v.into();
            self
        }

        /// The value of [compensation_amount][crate::model::compensation_info::CompensationEntry::compensation_amount]
        /// if it holds a `Amount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn amount(&self) -> std::option::Option<&std::boxed::Box<gtype::model::Money>> {
            #[allow(unreachable_patterns)]
            self.compensation_amount.as_ref().and_then(|v| match v {
                crate::model::compensation_info::compensation_entry::CompensationAmount::Amount(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [compensation_amount][crate::model::compensation_info::CompensationEntry::compensation_amount]
        /// to hold a `Amount`.
        ///
        /// Note that all the setters affecting `compensation_amount` are
        /// mutually exclusive.
        pub fn set_amount<T: std::convert::Into<std::boxed::Box<gtype::model::Money>>>(
            mut self,
            v: T,
        ) -> Self {
            self.compensation_amount = std::option::Option::Some(
                crate::model::compensation_info::compensation_entry::CompensationAmount::Amount(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [compensation_amount][crate::model::compensation_info::CompensationEntry::compensation_amount]
        /// if it holds a `Range`, `None` if the field is not set or
        /// holds a different branch.
        pub fn range(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::compensation_info::CompensationRange>>
        {
            #[allow(unreachable_patterns)]
            self.compensation_amount.as_ref().and_then(|v| match v {
                crate::model::compensation_info::compensation_entry::CompensationAmount::Range(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [compensation_amount][crate::model::compensation_info::CompensationEntry::compensation_amount]
        /// to hold a `Range`.
        ///
        /// Note that all the setters affecting `compensation_amount` are
        /// mutually exclusive.
        pub fn set_range<
            T: std::convert::Into<std::boxed::Box<crate::model::compensation_info::CompensationRange>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.compensation_amount = std::option::Option::Some(
                crate::model::compensation_info::compensation_entry::CompensationAmount::Range(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for CompensationEntry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.CompensationInfo.CompensationEntry"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CompensationEntry {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __unit,
                __amount,
                __range,
                __description,
                __expected_units_per_year,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CompensationEntry")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "unit" => Ok(__FieldTag::__unit),
                                "amount" => Ok(__FieldTag::__amount),
                                "range" => Ok(__FieldTag::__range),
                                "description" => Ok(__FieldTag::__description),
                                "expectedUnitsPerYear" => Ok(__FieldTag::__expected_units_per_year),
                                "expected_units_per_year" => {
                                    Ok(__FieldTag::__expected_units_per_year)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CompensationEntry;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CompensationEntry")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::compensation_info::CompensationType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__unit => {
                                if !fields.insert(__FieldTag::__unit) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for unit",
                                    ));
                                }
                                result.unit = map
                                    .next_value::<std::option::Option<
                                        crate::model::compensation_info::CompensationUnit,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__amount => {
                                if !fields.insert(__FieldTag::__amount) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for amount",
                                    ));
                                }
                                if result.compensation_amount.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `compensation_amount`, a oneof with full ID .google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount, latest field was amount",
                                    ));
                                }
                                result.compensation_amount = std::option::Option::Some(
                                    crate::model::compensation_info::compensation_entry::CompensationAmount::Amount(
                                        map.next_value::<std::option::Option<std::boxed::Box<gtype::model::Money>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__range => {
                                if !fields.insert(__FieldTag::__range) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for range",
                                    ));
                                }
                                if result.compensation_amount.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `compensation_amount`, a oneof with full ID .google.cloud.talent.v4.CompensationInfo.CompensationEntry.range, latest field was range",
                                    ));
                                }
                                result.compensation_amount = std::option::Option::Some(
                                    crate::model::compensation_info::compensation_entry::CompensationAmount::Range(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::compensation_info::CompensationRange>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__expected_units_per_year => {
                                if !fields.insert(__FieldTag::__expected_units_per_year) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expected_units_per_year",
                                    ));
                                }
                                struct __With(std::option::Option<wkt::DoubleValue>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.expected_units_per_year = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CompensationEntry {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.unit) {
                state.serialize_entry("unit", &self.unit)?;
            }
            if let Some(value) = self.amount() {
                state.serialize_entry("amount", value)?;
            }
            if let Some(value) = self.range() {
                state.serialize_entry("range", value)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if self.expected_units_per_year.is_some() {
                struct __With<'a>(&'a std::option::Option<wkt::DoubleValue>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "expectedUnitsPerYear",
                    &__With(&self.expected_units_per_year),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CompensationEntry {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CompensationEntry");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("unit", &self.unit);
            debug_struct.field("description", &self.description);
            debug_struct.field("expected_units_per_year", &self.expected_units_per_year);
            debug_struct.field("compensation_amount", &self.compensation_amount);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [CompensationEntry].
    pub mod compensation_entry {
        #[allow(unused_imports)]
        use super::*;

        /// Compensation amount. It could be a fixed amount or a floating range.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum CompensationAmount {
            /// Compensation amount.
            Amount(std::boxed::Box<gtype::model::Money>),
            /// Compensation range.
            Range(std::boxed::Box<crate::model::compensation_info::CompensationRange>),
        }
    }

    /// Compensation range.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CompensationRange {
        /// The maximum amount of compensation. If left empty, the value is set
        /// to a maximal compensation value and the currency code is set to
        /// match the [currency code][google.type.Money.currency_code] of
        /// min_compensation.
        ///
        /// [google.type.Money.currency_code]: gtype::model::Money::currency_code
        pub max_compensation: std::option::Option<gtype::model::Money>,

        /// The minimum amount of compensation. If left empty, the value is set
        /// to zero and the currency code is set to match the
        /// [currency code][google.type.Money.currency_code] of max_compensation.
        ///
        /// [google.type.Money.currency_code]: gtype::model::Money::currency_code
        pub min_compensation: std::option::Option<gtype::model::Money>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CompensationRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_compensation][crate::model::compensation_info::CompensationRange::max_compensation].
        pub fn set_max_compensation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.max_compensation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_compensation][crate::model::compensation_info::CompensationRange::max_compensation].
        pub fn set_or_clear_max_compensation<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.max_compensation = v.map(|x| x.into());
            self
        }

        /// Sets the value of [min_compensation][crate::model::compensation_info::CompensationRange::min_compensation].
        pub fn set_min_compensation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.min_compensation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_compensation][crate::model::compensation_info::CompensationRange::min_compensation].
        pub fn set_or_clear_min_compensation<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::Money>,
        {
            self.min_compensation = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for CompensationRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.CompensationInfo.CompensationRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CompensationRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __max_compensation,
                __min_compensation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CompensationRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "maxCompensation" => Ok(__FieldTag::__max_compensation),
                                "max_compensation" => Ok(__FieldTag::__max_compensation),
                                "minCompensation" => Ok(__FieldTag::__min_compensation),
                                "min_compensation" => Ok(__FieldTag::__min_compensation),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CompensationRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CompensationRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__max_compensation => {
                                if !fields.insert(__FieldTag::__max_compensation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_compensation",
                                    ));
                                }
                                result.max_compensation =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::__min_compensation => {
                                if !fields.insert(__FieldTag::__min_compensation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_compensation",
                                    ));
                                }
                                result.min_compensation =
                                    map.next_value::<std::option::Option<gtype::model::Money>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CompensationRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.max_compensation.is_some() {
                state.serialize_entry("maxCompensation", &self.max_compensation)?;
            }
            if self.min_compensation.is_some() {
                state.serialize_entry("minCompensation", &self.min_compensation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CompensationRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CompensationRange");
            debug_struct.field("max_compensation", &self.max_compensation);
            debug_struct.field("min_compensation", &self.min_compensation);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The type of compensation.
    ///
    /// For compensation amounts specified in non-monetary amounts,
    /// describe the compensation scheme in the
    /// [CompensationEntry.description][google.cloud.talent.v4.CompensationInfo.CompensationEntry.description].
    ///
    /// For example, tipping format is described in
    /// [CompensationEntry.description][google.cloud.talent.v4.CompensationInfo.CompensationEntry.description]
    /// (for example, "expect 15-20% tips based on customer bill.") and an estimate
    /// of the tips provided in
    /// [CompensationEntry.amount][google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]
    /// or
    /// [CompensationEntry.range][google.cloud.talent.v4.CompensationInfo.CompensationEntry.range]
    /// ($10 per hour).
    ///
    /// For example, equity is described in
    /// [CompensationEntry.description][google.cloud.talent.v4.CompensationInfo.CompensationEntry.description]
    /// (for example, "1% - 2% equity vesting over 4 years, 1 year cliff") and
    /// value estimated in
    /// [CompensationEntry.amount][google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]
    /// or
    /// [CompensationEntry.range][google.cloud.talent.v4.CompensationInfo.CompensationEntry.range].
    /// If no value estimate is possible, units are
    /// [CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED][google.cloud.talent.v4.CompensationInfo.CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED]
    /// and then further clarified in
    /// [CompensationEntry.description][google.cloud.talent.v4.CompensationInfo.CompensationEntry.description]
    /// field.
    ///
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.amount]: crate::model::compensation_info::CompensationEntry::compensation_amount
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.description]: crate::model::compensation_info::CompensationEntry::description
    /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry.range]: crate::model::compensation_info::CompensationEntry::compensation_amount
    /// [google.cloud.talent.v4.CompensationInfo.CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED]: crate::model::compensation_info::CompensationUnit::Unspecified
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompensationType {
        /// Default value.
        Unspecified,
        /// Base compensation: Refers to the fixed amount of money paid to an
        /// employee by an employer in return for work performed. Base compensation
        /// does not include benefits, bonuses or any other potential compensation
        /// from an employer.
        Base,
        /// Bonus.
        Bonus,
        /// Signing bonus.
        SigningBonus,
        /// Equity.
        Equity,
        /// Profit sharing.
        ProfitSharing,
        /// Commission.
        Commissions,
        /// Tips.
        Tips,
        /// Other compensation type.
        OtherCompensationType,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompensationType::value] or
        /// [CompensationType::name].
        UnknownValue(compensation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod compensation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompensationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Base => std::option::Option::Some(1),
                Self::Bonus => std::option::Option::Some(2),
                Self::SigningBonus => std::option::Option::Some(3),
                Self::Equity => std::option::Option::Some(4),
                Self::ProfitSharing => std::option::Option::Some(5),
                Self::Commissions => std::option::Option::Some(6),
                Self::Tips => std::option::Option::Some(7),
                Self::OtherCompensationType => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPENSATION_TYPE_UNSPECIFIED"),
                Self::Base => std::option::Option::Some("BASE"),
                Self::Bonus => std::option::Option::Some("BONUS"),
                Self::SigningBonus => std::option::Option::Some("SIGNING_BONUS"),
                Self::Equity => std::option::Option::Some("EQUITY"),
                Self::ProfitSharing => std::option::Option::Some("PROFIT_SHARING"),
                Self::Commissions => std::option::Option::Some("COMMISSIONS"),
                Self::Tips => std::option::Option::Some("TIPS"),
                Self::OtherCompensationType => std::option::Option::Some("OTHER_COMPENSATION_TYPE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompensationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompensationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompensationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Base,
                2 => Self::Bonus,
                3 => Self::SigningBonus,
                4 => Self::Equity,
                5 => Self::ProfitSharing,
                6 => Self::Commissions,
                7 => Self::Tips,
                8 => Self::OtherCompensationType,
                _ => Self::UnknownValue(compensation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompensationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPENSATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BASE" => Self::Base,
                "BONUS" => Self::Bonus,
                "SIGNING_BONUS" => Self::SigningBonus,
                "EQUITY" => Self::Equity,
                "PROFIT_SHARING" => Self::ProfitSharing,
                "COMMISSIONS" => Self::Commissions,
                "TIPS" => Self::Tips,
                "OTHER_COMPENSATION_TYPE" => Self::OtherCompensationType,
                _ => Self::UnknownValue(compensation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompensationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Base => serializer.serialize_i32(1),
                Self::Bonus => serializer.serialize_i32(2),
                Self::SigningBonus => serializer.serialize_i32(3),
                Self::Equity => serializer.serialize_i32(4),
                Self::ProfitSharing => serializer.serialize_i32(5),
                Self::Commissions => serializer.serialize_i32(6),
                Self::Tips => serializer.serialize_i32(7),
                Self::OtherCompensationType => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompensationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompensationType>::new(
                ".google.cloud.talent.v4.CompensationInfo.CompensationType",
            ))
        }
    }

    /// Pay frequency.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompensationUnit {
        /// Default value.
        Unspecified,
        /// Hourly.
        Hourly,
        /// Daily.
        Daily,
        /// Weekly
        Weekly,
        /// Monthly.
        Monthly,
        /// Yearly.
        Yearly,
        /// One time.
        OneTime,
        /// Other compensation units.
        OtherCompensationUnit,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompensationUnit::value] or
        /// [CompensationUnit::name].
        UnknownValue(compensation_unit::UnknownValue),
    }

    #[doc(hidden)]
    pub mod compensation_unit {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompensationUnit {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hourly => std::option::Option::Some(1),
                Self::Daily => std::option::Option::Some(2),
                Self::Weekly => std::option::Option::Some(3),
                Self::Monthly => std::option::Option::Some(4),
                Self::Yearly => std::option::Option::Some(5),
                Self::OneTime => std::option::Option::Some(6),
                Self::OtherCompensationUnit => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPENSATION_UNIT_UNSPECIFIED"),
                Self::Hourly => std::option::Option::Some("HOURLY"),
                Self::Daily => std::option::Option::Some("DAILY"),
                Self::Weekly => std::option::Option::Some("WEEKLY"),
                Self::Monthly => std::option::Option::Some("MONTHLY"),
                Self::Yearly => std::option::Option::Some("YEARLY"),
                Self::OneTime => std::option::Option::Some("ONE_TIME"),
                Self::OtherCompensationUnit => std::option::Option::Some("OTHER_COMPENSATION_UNIT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompensationUnit {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompensationUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompensationUnit {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hourly,
                2 => Self::Daily,
                3 => Self::Weekly,
                4 => Self::Monthly,
                5 => Self::Yearly,
                6 => Self::OneTime,
                7 => Self::OtherCompensationUnit,
                _ => Self::UnknownValue(compensation_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompensationUnit {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPENSATION_UNIT_UNSPECIFIED" => Self::Unspecified,
                "HOURLY" => Self::Hourly,
                "DAILY" => Self::Daily,
                "WEEKLY" => Self::Weekly,
                "MONTHLY" => Self::Monthly,
                "YEARLY" => Self::Yearly,
                "ONE_TIME" => Self::OneTime,
                "OTHER_COMPENSATION_UNIT" => Self::OtherCompensationUnit,
                _ => Self::UnknownValue(compensation_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompensationUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hourly => serializer.serialize_i32(1),
                Self::Daily => serializer.serialize_i32(2),
                Self::Weekly => serializer.serialize_i32(3),
                Self::Monthly => serializer.serialize_i32(4),
                Self::Yearly => serializer.serialize_i32(5),
                Self::OneTime => serializer.serialize_i32(6),
                Self::OtherCompensationUnit => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompensationUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompensationUnit>::new(
                ".google.cloud.talent.v4.CompensationInfo.CompensationUnit",
            ))
        }
    }
}

/// Metadata used for long running operations returned by CTS batch APIs.
/// It's used to replace
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata].
///
/// [google.longrunning.Operation.metadata]: longrunning::model::Operation::metadata
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchOperationMetadata {
    /// The state of a long running operation.
    pub state: crate::model::batch_operation_metadata::State,

    /// More detailed information about operation state.
    pub state_description: std::string::String,

    /// Count of successful item(s) inside an operation.
    pub success_count: i32,

    /// Count of failed item(s) inside an operation.
    pub failure_count: i32,

    /// Count of total item(s) inside an operation.
    pub total_count: i32,

    /// The time when the batch operation is created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the batch operation status is updated. The metadata and the
    /// [update_time][google.cloud.talent.v4.BatchOperationMetadata.update_time] is
    /// refreshed every minute otherwise cached data is returned.
    ///
    /// [google.cloud.talent.v4.BatchOperationMetadata.update_time]: crate::model::BatchOperationMetadata::update_time
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The time when the batch operation is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to `true`.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_description][crate::model::BatchOperationMetadata::state_description].
    pub fn set_state_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_description = v.into();
        self
    }

    /// Sets the value of [success_count][crate::model::BatchOperationMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::BatchOperationMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }

    /// Sets the value of [total_count][crate::model::BatchOperationMetadata::total_count].
    pub fn set_total_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BatchOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BatchOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BatchOperationMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BatchOperationMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BatchOperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BatchOperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.BatchOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __state_description,
            __success_count,
            __failure_count,
            __total_count,
            __create_time,
            __update_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "stateDescription" => Ok(__FieldTag::__state_description),
                            "state_description" => Ok(__FieldTag::__state_description),
                            "successCount" => Ok(__FieldTag::__success_count),
                            "success_count" => Ok(__FieldTag::__success_count),
                            "failureCount" => Ok(__FieldTag::__failure_count),
                            "failure_count" => Ok(__FieldTag::__failure_count),
                            "totalCount" => Ok(__FieldTag::__total_count),
                            "total_count" => Ok(__FieldTag::__total_count),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::batch_operation_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_description => {
                            if !fields.insert(__FieldTag::__state_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_description",
                                ));
                            }
                            result.state_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__success_count => {
                            if !fields.insert(__FieldTag::__success_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.success_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failure_count => {
                            if !fields.insert(__FieldTag::__failure_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failure_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_count => {
                            if !fields.insert(__FieldTag::__total_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_description.is_empty() {
            state.serialize_entry("stateDescription", &self.state_description)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !wkt::internal::is_default(&self.total_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCount", &__With(&self.total_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchOperationMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_description", &self.state_description);
        debug_struct.field("success_count", &self.success_count);
        debug_struct.field("failure_count", &self.failure_count);
        debug_struct.field("total_count", &self.total_count);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("end_time", &self.end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BatchOperationMetadata].
pub mod batch_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value.
        Unspecified,
        /// The batch operation is being prepared for processing.
        Initializing,
        /// The batch operation is actively being processed.
        Processing,
        /// The batch operation is processed, and at least one item has been
        /// successfully processed.
        Succeeded,
        /// The batch operation is done and no item has been successfully processed.
        Failed,
        /// The batch operation is in the process of cancelling after
        /// [google.longrunning.Operations.CancelOperation][google.longrunning.Operations.CancelOperation]
        /// is called.
        Cancelling,
        /// The batch operation is done after
        /// [google.longrunning.Operations.CancelOperation][google.longrunning.Operations.CancelOperation]
        /// is called. Any items processed before cancelling are returned in the
        /// response.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Initializing => std::option::Option::Some(1),
                Self::Processing => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Cancelled => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Initializing => std::option::Option::Some("INITIALIZING"),
                Self::Processing => std::option::Option::Some("PROCESSING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Initializing,
                2 => Self::Processing,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Cancelling,
                6 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INITIALIZING" => Self::Initializing,
                "PROCESSING" => Self::Processing,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Initializing => serializer.serialize_i32(1),
                Self::Processing => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Cancelled => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.talent.v4.BatchOperationMetadata.State",
            ))
        }
    }
}

/// A Company resource represents a company in the service. A company is the
/// entity that owns job postings, that is, the hiring entity responsible for
/// employing applicants for the job position.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Company {
    /// Required during company update.
    ///
    /// The resource name for a company. This is generated by the service when a
    /// company is created.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}", for
    /// example, "projects/foo/tenants/bar/companies/baz".
    pub name: std::string::String,

    /// Required. The display name of the company, for example, "Google LLC".
    pub display_name: std::string::String,

    /// Required. Client side company identifier, used to uniquely identify the
    /// company.
    ///
    /// The maximum number of allowed characters is 255.
    pub external_id: std::string::String,

    /// The employer's company size.
    pub size: crate::model::CompanySize,

    /// The street address of the company's main headquarters, which may be
    /// different from the job location. The service attempts
    /// to geolocate the provided address, and populates a more specific
    /// location wherever possible in
    /// [DerivedInfo.headquarters_location][google.cloud.talent.v4.Company.DerivedInfo.headquarters_location].
    ///
    /// [google.cloud.talent.v4.Company.DerivedInfo.headquarters_location]: crate::model::company::DerivedInfo::headquarters_location
    pub headquarters_address: std::string::String,

    /// Set to true if it is the hiring agency that post jobs for other
    /// employers.
    ///
    /// Defaults to false if not provided.
    pub hiring_agency: bool,

    /// Equal Employment Opportunity legal disclaimer text to be
    /// associated with all jobs, and typically to be displayed in all
    /// roles.
    ///
    /// The maximum number of allowed characters is 500.
    pub eeo_text: std::string::String,

    /// The URI representing the company's primary web site or home page,
    /// for example, `https://www.google.com`.
    ///
    /// The maximum number of allowed characters is 255.
    pub website_uri: std::string::String,

    /// The URI to employer's career site or careers page on the employer's web
    /// site, for example, `https://careers.google.com`.
    pub career_site_uri: std::string::String,

    /// A URI that hosts the employer's company logo.
    pub image_uri: std::string::String,

    /// This field is deprecated. Please set the searchability of the custom
    /// attribute in the
    /// [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes] going
    /// forward.
    ///
    /// A list of keys of filterable
    /// [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes],
    /// whose corresponding `string_values` are used in keyword searches. Jobs with
    /// `string_values` under these specified field keys are returned if any
    /// of the values match the search keyword. Custom field values with
    /// parenthesis, brackets and special symbols are not searchable as-is,
    /// and those keyword queries must be surrounded by quotes.
    ///
    /// [google.cloud.talent.v4.Job.custom_attributes]: crate::model::Job::custom_attributes
    #[deprecated]
    pub keyword_searchable_job_custom_attributes: std::vec::Vec<std::string::String>,

    /// Output only. Derived details about the company.
    pub derived_info: std::option::Option<crate::model::company::DerivedInfo>,

    /// Output only. Indicates whether a company is flagged to be suspended from
    /// public availability by the service when job content appears suspicious,
    /// abusive, or spammy.
    pub suspended: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Company {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Company::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Company::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [external_id][crate::model::Company::external_id].
    pub fn set_external_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_id = v.into();
        self
    }

    /// Sets the value of [size][crate::model::Company::size].
    pub fn set_size<T: std::convert::Into<crate::model::CompanySize>>(mut self, v: T) -> Self {
        self.size = v.into();
        self
    }

    /// Sets the value of [headquarters_address][crate::model::Company::headquarters_address].
    pub fn set_headquarters_address<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.headquarters_address = v.into();
        self
    }

    /// Sets the value of [hiring_agency][crate::model::Company::hiring_agency].
    pub fn set_hiring_agency<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.hiring_agency = v.into();
        self
    }

    /// Sets the value of [eeo_text][crate::model::Company::eeo_text].
    pub fn set_eeo_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.eeo_text = v.into();
        self
    }

    /// Sets the value of [website_uri][crate::model::Company::website_uri].
    pub fn set_website_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.website_uri = v.into();
        self
    }

    /// Sets the value of [career_site_uri][crate::model::Company::career_site_uri].
    pub fn set_career_site_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.career_site_uri = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::Company::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [keyword_searchable_job_custom_attributes][crate::model::Company::keyword_searchable_job_custom_attributes].
    #[deprecated]
    pub fn set_keyword_searchable_job_custom_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.keyword_searchable_job_custom_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [derived_info][crate::model::Company::derived_info].
    pub fn set_derived_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::company::DerivedInfo>,
    {
        self.derived_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [derived_info][crate::model::Company::derived_info].
    pub fn set_or_clear_derived_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::company::DerivedInfo>,
    {
        self.derived_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [suspended][crate::model::Company::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }
}

impl wkt::message::Message for Company {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.Company"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Company {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __external_id,
            __size,
            __headquarters_address,
            __hiring_agency,
            __eeo_text,
            __website_uri,
            __career_site_uri,
            __image_uri,
            __keyword_searchable_job_custom_attributes,
            __derived_info,
            __suspended,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Company")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "externalId" => Ok(__FieldTag::__external_id),
                            "external_id" => Ok(__FieldTag::__external_id),
                            "size" => Ok(__FieldTag::__size),
                            "headquartersAddress" => Ok(__FieldTag::__headquarters_address),
                            "headquarters_address" => Ok(__FieldTag::__headquarters_address),
                            "hiringAgency" => Ok(__FieldTag::__hiring_agency),
                            "hiring_agency" => Ok(__FieldTag::__hiring_agency),
                            "eeoText" => Ok(__FieldTag::__eeo_text),
                            "eeo_text" => Ok(__FieldTag::__eeo_text),
                            "websiteUri" => Ok(__FieldTag::__website_uri),
                            "website_uri" => Ok(__FieldTag::__website_uri),
                            "careerSiteUri" => Ok(__FieldTag::__career_site_uri),
                            "career_site_uri" => Ok(__FieldTag::__career_site_uri),
                            "imageUri" => Ok(__FieldTag::__image_uri),
                            "image_uri" => Ok(__FieldTag::__image_uri),
                            "keywordSearchableJobCustomAttributes" => {
                                Ok(__FieldTag::__keyword_searchable_job_custom_attributes)
                            }
                            "keyword_searchable_job_custom_attributes" => {
                                Ok(__FieldTag::__keyword_searchable_job_custom_attributes)
                            }
                            "derivedInfo" => Ok(__FieldTag::__derived_info),
                            "derived_info" => Ok(__FieldTag::__derived_info),
                            "suspended" => Ok(__FieldTag::__suspended),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Company;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Company")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_id => {
                            if !fields.insert(__FieldTag::__external_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_id",
                                ));
                            }
                            result.external_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size => {
                            if !fields.insert(__FieldTag::__size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size",
                                ));
                            }
                            result.size = map
                                .next_value::<std::option::Option<crate::model::CompanySize>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headquarters_address => {
                            if !fields.insert(__FieldTag::__headquarters_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headquarters_address",
                                ));
                            }
                            result.headquarters_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hiring_agency => {
                            if !fields.insert(__FieldTag::__hiring_agency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hiring_agency",
                                ));
                            }
                            result.hiring_agency = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__eeo_text => {
                            if !fields.insert(__FieldTag::__eeo_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eeo_text",
                                ));
                            }
                            result.eeo_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__website_uri => {
                            if !fields.insert(__FieldTag::__website_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for website_uri",
                                ));
                            }
                            result.website_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__career_site_uri => {
                            if !fields.insert(__FieldTag::__career_site_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for career_site_uri",
                                ));
                            }
                            result.career_site_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_uri => {
                            if !fields.insert(__FieldTag::__image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_uri",
                                ));
                            }
                            result.image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__keyword_searchable_job_custom_attributes => {
                            if !fields
                                .insert(__FieldTag::__keyword_searchable_job_custom_attributes)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keyword_searchable_job_custom_attributes",
                                ));
                            }
                            result.keyword_searchable_job_custom_attributes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__derived_info => {
                            if !fields.insert(__FieldTag::__derived_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for derived_info",
                                ));
                            }
                            result.derived_info = map.next_value::<std::option::Option<crate::model::company::DerivedInfo>>()?
                                ;
                        }
                        __FieldTag::__suspended => {
                            if !fields.insert(__FieldTag::__suspended) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suspended",
                                ));
                            }
                            result.suspended = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Company {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.external_id.is_empty() {
            state.serialize_entry("externalId", &self.external_id)?;
        }
        if !wkt::internal::is_default(&self.size) {
            state.serialize_entry("size", &self.size)?;
        }
        if !self.headquarters_address.is_empty() {
            state.serialize_entry("headquartersAddress", &self.headquarters_address)?;
        }
        if !wkt::internal::is_default(&self.hiring_agency) {
            state.serialize_entry("hiringAgency", &self.hiring_agency)?;
        }
        if !self.eeo_text.is_empty() {
            state.serialize_entry("eeoText", &self.eeo_text)?;
        }
        if !self.website_uri.is_empty() {
            state.serialize_entry("websiteUri", &self.website_uri)?;
        }
        if !self.career_site_uri.is_empty() {
            state.serialize_entry("careerSiteUri", &self.career_site_uri)?;
        }
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if !self.keyword_searchable_job_custom_attributes.is_empty() {
            state.serialize_entry(
                "keywordSearchableJobCustomAttributes",
                &self.keyword_searchable_job_custom_attributes,
            )?;
        }
        if self.derived_info.is_some() {
            state.serialize_entry("derivedInfo", &self.derived_info)?;
        }
        if !wkt::internal::is_default(&self.suspended) {
            state.serialize_entry("suspended", &self.suspended)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Company {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Company");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("external_id", &self.external_id);
        debug_struct.field("size", &self.size);
        debug_struct.field("headquarters_address", &self.headquarters_address);
        debug_struct.field("hiring_agency", &self.hiring_agency);
        debug_struct.field("eeo_text", &self.eeo_text);
        debug_struct.field("website_uri", &self.website_uri);
        debug_struct.field("career_site_uri", &self.career_site_uri);
        debug_struct.field("image_uri", &self.image_uri);
        debug_struct.field(
            "keyword_searchable_job_custom_attributes",
            &self.keyword_searchable_job_custom_attributes,
        );
        debug_struct.field("derived_info", &self.derived_info);
        debug_struct.field("suspended", &self.suspended);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Company].
pub mod company {
    #[allow(unused_imports)]
    use super::*;

    /// Derived details about the company.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DerivedInfo {
        /// A structured headquarters location of the company, resolved from
        /// [Company.headquarters_address][google.cloud.talent.v4.Company.headquarters_address]
        /// if provided.
        ///
        /// [google.cloud.talent.v4.Company.headquarters_address]: crate::model::Company::headquarters_address
        pub headquarters_location: std::option::Option<crate::model::Location>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DerivedInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [headquarters_location][crate::model::company::DerivedInfo::headquarters_location].
        pub fn set_headquarters_location<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Location>,
        {
            self.headquarters_location = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [headquarters_location][crate::model::company::DerivedInfo::headquarters_location].
        pub fn set_or_clear_headquarters_location<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Location>,
        {
            self.headquarters_location = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DerivedInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.Company.DerivedInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DerivedInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __headquarters_location,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DerivedInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "headquartersLocation" => Ok(__FieldTag::__headquarters_location),
                                "headquarters_location" => Ok(__FieldTag::__headquarters_location),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DerivedInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DerivedInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__headquarters_location => {
                                if !fields.insert(__FieldTag::__headquarters_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for headquarters_location",
                                    ));
                                }
                                result.headquarters_location = map
                                    .next_value::<std::option::Option<crate::model::Location>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DerivedInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.headquarters_location.is_some() {
                state.serialize_entry("headquartersLocation", &self.headquarters_location)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DerivedInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DerivedInfo");
            debug_struct.field("headquarters_location", &self.headquarters_location);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The Request of the CreateCompany method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCompanyRequest {
    /// Required. Resource name of the tenant under which the company is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}", for example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// Required. The company to be created.
    pub company: std::option::Option<crate::model::Company>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCompanyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCompanyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [company][crate::model::CreateCompanyRequest::company].
    pub fn set_company<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Company>,
    {
        self.company = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [company][crate::model::CreateCompanyRequest::company].
    pub fn set_or_clear_company<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Company>,
    {
        self.company = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCompanyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CreateCompanyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCompanyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __company,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCompanyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "company" => Ok(__FieldTag::__company),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCompanyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCompanyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__company => {
                            if !fields.insert(__FieldTag::__company) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for company",
                                ));
                            }
                            result.company =
                                map.next_value::<std::option::Option<crate::model::Company>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCompanyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.company.is_some() {
            state.serialize_entry("company", &self.company)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCompanyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCompanyRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("company", &self.company);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for getting a company by name.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCompanyRequest {
    /// Required. The resource name of the company to be retrieved.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}", for
    /// example, "projects/api-test-project/tenants/foo/companies/bar".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCompanyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCompanyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCompanyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.GetCompanyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCompanyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCompanyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCompanyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCompanyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCompanyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCompanyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCompanyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for updating a specified company.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCompanyRequest {
    /// Required. The company resource to replace the current resource in the
    /// system.
    pub company: std::option::Option<crate::model::Company>,

    /// Strongly recommended for the best service experience.
    ///
    /// If [update_mask][google.cloud.talent.v4.UpdateCompanyRequest.update_mask]
    /// is provided, only the specified fields in
    /// [company][google.cloud.talent.v4.UpdateCompanyRequest.company] are updated.
    /// Otherwise all the fields are updated.
    ///
    /// A field mask to specify the company fields to be updated. Only
    /// top level fields of [Company][google.cloud.talent.v4.Company] are
    /// supported.
    ///
    /// [google.cloud.talent.v4.Company]: crate::model::Company
    /// [google.cloud.talent.v4.UpdateCompanyRequest.company]: crate::model::UpdateCompanyRequest::company
    /// [google.cloud.talent.v4.UpdateCompanyRequest.update_mask]: crate::model::UpdateCompanyRequest::update_mask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCompanyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [company][crate::model::UpdateCompanyRequest::company].
    pub fn set_company<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Company>,
    {
        self.company = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [company][crate::model::UpdateCompanyRequest::company].
    pub fn set_or_clear_company<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Company>,
    {
        self.company = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCompanyRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCompanyRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCompanyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.UpdateCompanyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCompanyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __company,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCompanyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "company" => Ok(__FieldTag::__company),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCompanyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCompanyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__company => {
                            if !fields.insert(__FieldTag::__company) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for company",
                                ));
                            }
                            result.company =
                                map.next_value::<std::option::Option<crate::model::Company>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCompanyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.company.is_some() {
            state.serialize_entry("company", &self.company)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateCompanyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCompanyRequest");
        debug_struct.field("company", &self.company);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to delete a company.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCompanyRequest {
    /// Required. The resource name of the company to be deleted.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}", for
    /// example, "projects/foo/tenants/bar/companies/baz".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCompanyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCompanyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCompanyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.DeleteCompanyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCompanyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCompanyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCompanyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCompanyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCompanyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteCompanyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCompanyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List companies for which the client has ACL visibility.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCompaniesRequest {
    /// Required. Resource name of the tenant under which the company is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}", for example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// The starting indicator from which to return results.
    pub page_token: std::string::String,

    /// The maximum number of companies to be returned, at most 100.
    /// Default is 100 if a non-positive number is provided.
    pub page_size: i32,

    /// Set to true if the companies requested must have open jobs.
    ///
    /// Defaults to false.
    ///
    /// If true, at most
    /// [page_size][google.cloud.talent.v4.ListCompaniesRequest.page_size] of
    /// companies are fetched, among which only those with open jobs are returned.
    ///
    /// [google.cloud.talent.v4.ListCompaniesRequest.page_size]: crate::model::ListCompaniesRequest::page_size
    pub require_open_jobs: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCompaniesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCompaniesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCompaniesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCompaniesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [require_open_jobs][crate::model::ListCompaniesRequest::require_open_jobs].
    pub fn set_require_open_jobs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_open_jobs = v.into();
        self
    }
}

impl wkt::message::Message for ListCompaniesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ListCompaniesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCompaniesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            __require_open_jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCompaniesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "requireOpenJobs" => Ok(__FieldTag::__require_open_jobs),
                            "require_open_jobs" => Ok(__FieldTag::__require_open_jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCompaniesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCompaniesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__require_open_jobs => {
                            if !fields.insert(__FieldTag::__require_open_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_open_jobs",
                                ));
                            }
                            result.require_open_jobs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCompaniesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !wkt::internal::is_default(&self.require_open_jobs) {
            state.serialize_entry("requireOpenJobs", &self.require_open_jobs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCompaniesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCompaniesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("require_open_jobs", &self.require_open_jobs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The List companies response object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCompaniesResponse {
    /// Companies for the current client.
    pub companies: std::vec::Vec<crate::model::Company>,

    /// A token to retrieve the next page of results.
    pub next_page_token: std::string::String,

    /// Additional information for the API invocation, such as the request
    /// tracking id.
    pub metadata: std::option::Option<crate::model::ResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCompaniesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [companies][crate::model::ListCompaniesResponse::companies].
    pub fn set_companies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Company>,
    {
        use std::iter::Iterator;
        self.companies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCompaniesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ListCompaniesResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::ListCompaniesResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListCompaniesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ListCompaniesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCompaniesResponse {
    type PageItem = crate::model::Company;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.companies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCompaniesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __companies,
            __next_page_token,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCompaniesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "companies" => Ok(__FieldTag::__companies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCompaniesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCompaniesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__companies => {
                            if !fields.insert(__FieldTag::__companies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for companies",
                                ));
                            }
                            result.companies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Company>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<crate::model::ResponseMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCompaniesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.companies.is_empty() {
            state.serialize_entry("companies", &self.companies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCompaniesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCompaniesResponse");
        debug_struct.field("companies", &self.companies);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Auto-complete parameters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompleteQueryRequest {
    /// Required. Resource name of tenant the completion is performed within.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}", for example,
    /// "projects/foo/tenants/bar".
    pub tenant: std::string::String,

    /// Required. The query used to generate suggestions.
    ///
    /// The maximum number of allowed characters is 255.
    pub query: std::string::String,

    /// The list of languages of the query. This is
    /// the BCP-47 language code, such as "en-US" or "sr-Latn".
    /// For more information, see
    /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
    ///
    /// The maximum number of allowed characters is 255.
    pub language_codes: std::vec::Vec<std::string::String>,

    /// Required. Completion result count.
    ///
    /// The maximum allowed page size is 10.
    pub page_size: i32,

    /// If provided, restricts completion to specified company.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}", for
    /// example, "projects/foo/tenants/bar/companies/baz".
    pub company: std::string::String,

    /// The scope of the completion. The defaults is
    /// [CompletionScope.PUBLIC][google.cloud.talent.v4.CompleteQueryRequest.CompletionScope.PUBLIC].
    ///
    /// [google.cloud.talent.v4.CompleteQueryRequest.CompletionScope.PUBLIC]: crate::model::complete_query_request::CompletionScope::Public
    pub scope: crate::model::complete_query_request::CompletionScope,

    /// The completion topic. The default is
    /// [CompletionType.COMBINED][google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMBINED].
    ///
    /// [google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMBINED]: crate::model::complete_query_request::CompletionType::Combined
    pub r#type: crate::model::complete_query_request::CompletionType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenant][crate::model::CompleteQueryRequest::tenant].
    pub fn set_tenant<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tenant = v.into();
        self
    }

    /// Sets the value of [query][crate::model::CompleteQueryRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [language_codes][crate::model::CompleteQueryRequest::language_codes].
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_size][crate::model::CompleteQueryRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [company][crate::model::CompleteQueryRequest::company].
    pub fn set_company<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.company = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::CompleteQueryRequest::scope].
    pub fn set_scope<
        T: std::convert::Into<crate::model::complete_query_request::CompletionScope>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CompleteQueryRequest::type].
    pub fn set_type<T: std::convert::Into<crate::model::complete_query_request::CompletionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for CompleteQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CompleteQueryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompleteQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tenant,
            __query,
            __language_codes,
            __page_size,
            __company,
            __scope,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tenant" => Ok(__FieldTag::__tenant),
                            "query" => Ok(__FieldTag::__query),
                            "languageCodes" => Ok(__FieldTag::__language_codes),
                            "language_codes" => Ok(__FieldTag::__language_codes),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "company" => Ok(__FieldTag::__company),
                            "scope" => Ok(__FieldTag::__scope),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompleteQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tenant => {
                            if !fields.insert(__FieldTag::__tenant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant",
                                ));
                            }
                            result.tenant = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_codes => {
                            if !fields.insert(__FieldTag::__language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes",
                                ));
                            }
                            result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__company => {
                            if !fields.insert(__FieldTag::__company) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for company",
                                ));
                            }
                            result.company = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<
                                    crate::model::complete_query_request::CompletionScope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::complete_query_request::CompletionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompleteQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tenant.is_empty() {
            state.serialize_entry("tenant", &self.tenant)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.language_codes.is_empty() {
            state.serialize_entry("languageCodes", &self.language_codes)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.company.is_empty() {
            state.serialize_entry("company", &self.company)?;
        }
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompleteQueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteQueryRequest");
        debug_struct.field("tenant", &self.tenant);
        debug_struct.field("query", &self.query);
        debug_struct.field("language_codes", &self.language_codes);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("company", &self.company);
        debug_struct.field("scope", &self.scope);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CompleteQueryRequest].
pub mod complete_query_request {
    #[allow(unused_imports)]
    use super::*;

    /// Enum to specify the scope of completion.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompletionScope {
        /// Default value.
        Unspecified,
        /// Suggestions are based only on the data provided by the client.
        Tenant,
        /// Suggestions are based on all jobs data in the system that's visible to
        /// the client
        Public,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompletionScope::value] or
        /// [CompletionScope::name].
        UnknownValue(completion_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod completion_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompletionScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tenant => std::option::Option::Some(1),
                Self::Public => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPLETION_SCOPE_UNSPECIFIED"),
                Self::Tenant => std::option::Option::Some("TENANT"),
                Self::Public => std::option::Option::Some("PUBLIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompletionScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompletionScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompletionScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tenant,
                2 => Self::Public,
                _ => Self::UnknownValue(completion_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompletionScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPLETION_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "TENANT" => Self::Tenant,
                "PUBLIC" => Self::Public,
                _ => Self::UnknownValue(completion_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompletionScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tenant => serializer.serialize_i32(1),
                Self::Public => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompletionScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompletionScope>::new(
                ".google.cloud.talent.v4.CompleteQueryRequest.CompletionScope",
            ))
        }
    }

    /// Enum to specify auto-completion topics.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompletionType {
        /// Default value.
        Unspecified,
        /// Suggest job titles for jobs autocomplete.
        ///
        /// For
        /// [CompletionType.JOB_TITLE][google.cloud.talent.v4.CompleteQueryRequest.CompletionType.JOB_TITLE]
        /// type, only open jobs with the same
        /// [language_codes][google.cloud.talent.v4.CompleteQueryRequest.language_codes]
        /// are returned.
        ///
        /// [google.cloud.talent.v4.CompleteQueryRequest.CompletionType.JOB_TITLE]: crate::model::complete_query_request::CompletionType::JobTitle
        /// [google.cloud.talent.v4.CompleteQueryRequest.language_codes]: crate::model::CompleteQueryRequest::language_codes
        JobTitle,
        /// Suggest company names for jobs autocomplete.
        ///
        /// For
        /// [CompletionType.COMPANY_NAME][google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMPANY_NAME]
        /// type, only companies having open jobs with the same
        /// [language_codes][google.cloud.talent.v4.CompleteQueryRequest.language_codes]
        /// are returned.
        ///
        /// [google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMPANY_NAME]: crate::model::complete_query_request::CompletionType::CompanyName
        /// [google.cloud.talent.v4.CompleteQueryRequest.language_codes]: crate::model::CompleteQueryRequest::language_codes
        CompanyName,
        /// Suggest both job titles and company names for jobs autocomplete.
        ///
        /// For
        /// [CompletionType.COMBINED][google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMBINED]
        /// type, only open jobs with the same
        /// [language_codes][google.cloud.talent.v4.CompleteQueryRequest.language_codes]
        /// or companies having open jobs with the same
        /// [language_codes][google.cloud.talent.v4.CompleteQueryRequest.language_codes]
        /// are returned.
        ///
        /// [google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMBINED]: crate::model::complete_query_request::CompletionType::Combined
        /// [google.cloud.talent.v4.CompleteQueryRequest.language_codes]: crate::model::CompleteQueryRequest::language_codes
        Combined,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompletionType::value] or
        /// [CompletionType::name].
        UnknownValue(completion_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod completion_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompletionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::JobTitle => std::option::Option::Some(1),
                Self::CompanyName => std::option::Option::Some(2),
                Self::Combined => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPLETION_TYPE_UNSPECIFIED"),
                Self::JobTitle => std::option::Option::Some("JOB_TITLE"),
                Self::CompanyName => std::option::Option::Some("COMPANY_NAME"),
                Self::Combined => std::option::Option::Some("COMBINED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompletionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompletionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompletionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::JobTitle,
                2 => Self::CompanyName,
                3 => Self::Combined,
                _ => Self::UnknownValue(completion_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompletionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPLETION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "JOB_TITLE" => Self::JobTitle,
                "COMPANY_NAME" => Self::CompanyName,
                "COMBINED" => Self::Combined,
                _ => Self::UnknownValue(completion_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompletionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::JobTitle => serializer.serialize_i32(1),
                Self::CompanyName => serializer.serialize_i32(2),
                Self::Combined => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompletionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompletionType>::new(
                ".google.cloud.talent.v4.CompleteQueryRequest.CompletionType",
            ))
        }
    }
}

/// Response of auto-complete query.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompleteQueryResponse {
    /// Results of the matching job/company candidates.
    pub completion_results: std::vec::Vec<crate::model::complete_query_response::CompletionResult>,

    /// Additional information for the API invocation, such as the request
    /// tracking id.
    pub metadata: std::option::Option<crate::model::ResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteQueryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [completion_results][crate::model::CompleteQueryResponse::completion_results].
    pub fn set_completion_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::complete_query_response::CompletionResult>,
    {
        use std::iter::Iterator;
        self.completion_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::CompleteQueryResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::CompleteQueryResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CompleteQueryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CompleteQueryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompleteQueryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __completion_results,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteQueryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "completionResults" => Ok(__FieldTag::__completion_results),
                            "completion_results" => Ok(__FieldTag::__completion_results),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompleteQueryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteQueryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__completion_results => {
                            if !fields.insert(__FieldTag::__completion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_results",
                                ));
                            }
                            result.completion_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::complete_query_response::CompletionResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<crate::model::ResponseMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompleteQueryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.completion_results.is_empty() {
            state.serialize_entry("completionResults", &self.completion_results)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompleteQueryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteQueryResponse");
        debug_struct.field("completion_results", &self.completion_results);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CompleteQueryResponse].
pub mod complete_query_response {
    #[allow(unused_imports)]
    use super::*;

    /// Resource that represents completion results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CompletionResult {
        /// The suggestion for the query.
        pub suggestion: std::string::String,

        /// The completion topic.
        pub r#type: crate::model::complete_query_request::CompletionType,

        /// The URI of the company image for
        /// [COMPANY_NAME][google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMPANY_NAME].
        ///
        /// [google.cloud.talent.v4.CompleteQueryRequest.CompletionType.COMPANY_NAME]: crate::model::complete_query_request::CompletionType::CompanyName
        pub image_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CompletionResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [suggestion][crate::model::complete_query_response::CompletionResult::suggestion].
        pub fn set_suggestion<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.suggestion = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::complete_query_response::CompletionResult::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::complete_query_request::CompletionType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [image_uri][crate::model::complete_query_response::CompletionResult::image_uri].
        pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for CompletionResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.CompleteQueryResponse.CompletionResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CompletionResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __suggestion,
                __type,
                __image_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CompletionResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "suggestion" => Ok(__FieldTag::__suggestion),
                                "type" => Ok(__FieldTag::__type),
                                "imageUri" => Ok(__FieldTag::__image_uri),
                                "image_uri" => Ok(__FieldTag::__image_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CompletionResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CompletionResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__suggestion => {
                                if !fields.insert(__FieldTag::__suggestion) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suggestion",
                                    ));
                                }
                                result.suggestion = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::complete_query_request::CompletionType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__image_uri => {
                                if !fields.insert(__FieldTag::__image_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for image_uri",
                                    ));
                                }
                                result.image_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CompletionResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.suggestion.is_empty() {
                state.serialize_entry("suggestion", &self.suggestion)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.image_uri.is_empty() {
                state.serialize_entry("imageUri", &self.image_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CompletionResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CompletionResult");
            debug_struct.field("suggestion", &self.suggestion);
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("image_uri", &self.image_uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// An event issued when an end user interacts with the application that
/// implements Cloud Talent Solution. Providing this information improves the
/// quality of results for the API clients, enabling the
/// service to perform optimally. The number of events sent must be consistent
/// with other calls, such as job searches, issued to the service by the client.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClientEvent {
    /// Strongly recommended for the best service experience.
    ///
    /// A unique ID generated in the API responses. It can be found in
    /// [ResponseMetadata.request_id][google.cloud.talent.v4.ResponseMetadata.request_id].
    ///
    /// [google.cloud.talent.v4.ResponseMetadata.request_id]: crate::model::ResponseMetadata::request_id
    pub request_id: std::string::String,

    /// Required. A unique identifier, generated by the client application.
    pub event_id: std::string::String,

    /// Required. The timestamp of the event.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Notes about the event provided by recruiters or other users, for example,
    /// feedback on why a job was bookmarked.
    pub event_notes: std::string::String,

    /// Required.
    ///
    /// The detail information of a specific event type.
    pub event: std::option::Option<crate::model::client_event::Event>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClientEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_id][crate::model::ClientEvent::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [event_id][crate::model::ClientEvent::event_id].
    pub fn set_event_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ClientEvent::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ClientEvent::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event_notes][crate::model::ClientEvent::event_notes].
    pub fn set_event_notes<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_notes = v.into();
        self
    }

    /// Sets the value of [event][crate::model::ClientEvent::event].
    ///
    /// Note that all the setters affecting `event` are mutually
    /// exclusive.
    pub fn set_event<
        T: std::convert::Into<std::option::Option<crate::model::client_event::Event>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event = v.into();
        self
    }

    /// The value of [event][crate::model::ClientEvent::event]
    /// if it holds a `JobEvent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn job_event(&self) -> std::option::Option<&std::boxed::Box<crate::model::JobEvent>> {
        #[allow(unreachable_patterns)]
        self.event.as_ref().and_then(|v| match v {
            crate::model::client_event::Event::JobEvent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [event][crate::model::ClientEvent::event]
    /// to hold a `JobEvent`.
    ///
    /// Note that all the setters affecting `event` are
    /// mutually exclusive.
    pub fn set_job_event<T: std::convert::Into<std::boxed::Box<crate::model::JobEvent>>>(
        mut self,
        v: T,
    ) -> Self {
        self.event =
            std::option::Option::Some(crate::model::client_event::Event::JobEvent(v.into()));
        self
    }
}

impl wkt::message::Message for ClientEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ClientEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClientEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request_id,
            __event_id,
            __create_time,
            __job_event,
            __event_notes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClientEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "eventId" => Ok(__FieldTag::__event_id),
                            "event_id" => Ok(__FieldTag::__event_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "jobEvent" => Ok(__FieldTag::__job_event),
                            "job_event" => Ok(__FieldTag::__job_event),
                            "eventNotes" => Ok(__FieldTag::__event_notes),
                            "event_notes" => Ok(__FieldTag::__event_notes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClientEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClientEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_id => {
                            if !fields.insert(__FieldTag::__event_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_id",
                                ));
                            }
                            result.event_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__job_event => {
                            if !fields.insert(__FieldTag::__job_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_event",
                                ));
                            }
                            if result.event.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `event`, a oneof with full ID .google.cloud.talent.v4.ClientEvent.job_event, latest field was jobEvent",
                                ));
                            }
                            result.event = std::option::Option::Some(
                                crate::model::client_event::Event::JobEvent(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::JobEvent>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__event_notes => {
                            if !fields.insert(__FieldTag::__event_notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_notes",
                                ));
                            }
                            result.event_notes = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClientEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self.event_id.is_empty() {
            state.serialize_entry("eventId", &self.event_id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if let Some(value) = self.job_event() {
            state.serialize_entry("jobEvent", value)?;
        }
        if !self.event_notes.is_empty() {
            state.serialize_entry("eventNotes", &self.event_notes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClientEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClientEvent");
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("event_id", &self.event_id);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("event_notes", &self.event_notes);
        debug_struct.field("event", &self.event);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ClientEvent].
pub mod client_event {
    #[allow(unused_imports)]
    use super::*;

    /// Required.
    ///
    /// The detail information of a specific event type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Event {
        /// An event issued when a job seeker interacts with the application that
        /// implements Cloud Talent Solution.
        JobEvent(std::boxed::Box<crate::model::JobEvent>),
    }
}

/// An event issued when a job seeker interacts with the application that
/// implements Cloud Talent Solution.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JobEvent {
    /// Required. The type of the event (see
    /// [JobEventType][google.cloud.talent.v4.JobEvent.JobEventType]).
    ///
    /// [google.cloud.talent.v4.JobEvent.JobEventType]: crate::model::job_event::JobEventType
    pub r#type: crate::model::job_event::JobEventType,

    /// Required. The [job name(s)][google.cloud.talent.v4.Job.name] associated
    /// with this event. For example, if this is an
    /// [impression][google.cloud.talent.v4.JobEvent.JobEventType.IMPRESSION]
    /// event, this field contains the identifiers of all jobs shown to the job
    /// seeker. If this was a
    /// [view][google.cloud.talent.v4.JobEvent.JobEventType.VIEW] event, this field
    /// contains the identifier of the viewed job.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}", for
    /// example, "projects/foo/tenants/bar/jobs/baz".
    ///
    /// [google.cloud.talent.v4.Job.name]: crate::model::Job::name
    /// [google.cloud.talent.v4.JobEvent.JobEventType.IMPRESSION]: crate::model::job_event::JobEventType::Impression
    /// [google.cloud.talent.v4.JobEvent.JobEventType.VIEW]: crate::model::job_event::JobEventType::View
    pub jobs: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::JobEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::job_event::JobEventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::JobEvent::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.JobEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "jobs" => Ok(__FieldTag::__jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::job_event::JobEventType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for JobEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobEvent");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("jobs", &self.jobs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [JobEvent].
pub mod job_event {
    #[allow(unused_imports)]
    use super::*;

    /// An enumeration of an event attributed to the behavior of the end user,
    /// such as a job seeker.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobEventType {
        /// The event is unspecified by other provided values.
        Unspecified,
        /// The job seeker or other entity interacting with the service has
        /// had a job rendered in their view, such as in a list of search results in
        /// a compressed or clipped format. This event is typically associated with
        /// the viewing of a jobs list on a single page by a job seeker.
        Impression,
        /// The job seeker, or other entity interacting with the service, has
        /// viewed the details of a job, including the full description. This
        /// event doesn't apply to the viewing a snippet of a job appearing as a
        /// part of the job search results. Viewing a snippet is associated with an
        /// [impression][google.cloud.talent.v4.JobEvent.JobEventType.IMPRESSION]).
        ///
        /// [google.cloud.talent.v4.JobEvent.JobEventType.IMPRESSION]: crate::model::job_event::JobEventType::Impression
        View,
        /// The job seeker or other entity interacting with the service
        /// performed an action to view a job and was redirected to a different
        /// website for job.
        ViewRedirect,
        /// The job seeker or other entity interacting with the service
        /// began the process or demonstrated the intention of applying for a job.
        ApplicationStart,
        /// The job seeker or other entity interacting with the service
        /// submitted an application for a job.
        ApplicationFinish,
        /// The job seeker or other entity interacting with the service
        /// submitted an application for a job with a single click without
        /// entering information. If a job seeker performs this action, send only
        /// this event to the service. Do not also send
        /// [JobEventType.APPLICATION_START][google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_START]
        /// or
        /// [JobEventType.APPLICATION_FINISH][google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_FINISH]
        /// events.
        ///
        /// [google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_FINISH]: crate::model::job_event::JobEventType::ApplicationFinish
        /// [google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_START]: crate::model::job_event::JobEventType::ApplicationStart
        ApplicationQuickSubmission,
        /// The job seeker or other entity interacting with the service
        /// performed an action to apply to a job and was redirected to a different
        /// website to complete the application.
        ApplicationRedirect,
        /// The job seeker or other entity interacting with the service began the
        /// process or demonstrated the intention of applying for a job from the
        /// search results page without viewing the details of the job posting.
        /// If sending this event, JobEventType.VIEW event shouldn't be sent.
        ApplicationStartFromSearch,
        /// The job seeker, or other entity interacting with the service, performs an
        /// action with a single click from the search results page to apply to a job
        /// (without viewing the details of the job posting), and is redirected
        /// to a different website to complete the application. If a candidate
        /// performs this action, send only this event to the service. Do not also
        /// send
        /// [JobEventType.APPLICATION_START][google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_START],
        /// [JobEventType.APPLICATION_FINISH][google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_FINISH]
        /// or [JobEventType.VIEW][google.cloud.talent.v4.JobEvent.JobEventType.VIEW]
        /// events.
        ///
        /// [google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_FINISH]: crate::model::job_event::JobEventType::ApplicationFinish
        /// [google.cloud.talent.v4.JobEvent.JobEventType.APPLICATION_START]: crate::model::job_event::JobEventType::ApplicationStart
        /// [google.cloud.talent.v4.JobEvent.JobEventType.VIEW]: crate::model::job_event::JobEventType::View
        ApplicationRedirectFromSearch,
        /// This event should be used when a company submits an application
        /// on behalf of a job seeker. This event is intended for use by staffing
        /// agencies attempting to place candidates.
        ApplicationCompanySubmit,
        /// The job seeker or other entity interacting with the service demonstrated
        /// an interest in a job by bookmarking or saving it.
        Bookmark,
        /// The job seeker or other entity interacting with the service was
        /// sent a notification, such as an email alert or device notification,
        /// containing one or more jobs listings generated by the service.
        Notification,
        /// The job seeker or other entity interacting with the service was
        /// employed by the hiring entity (employer). Send this event
        /// only if the job seeker was hired through an application that was
        /// initiated by a search conducted through the Cloud Talent Solution
        /// service.
        Hired,
        /// A recruiter or staffing agency submitted an application on behalf of the
        /// candidate after interacting with the service to identify a suitable job
        /// posting.
        SentCv,
        /// The entity interacting with the service (for example, the job seeker),
        /// was granted an initial interview by the hiring entity (employer). This
        /// event should only be sent if the job seeker was granted an interview as
        /// part of an application that was initiated by a search conducted through /
        /// recommendation provided by the Cloud Talent Solution service.
        InterviewGranted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobEventType::value] or
        /// [JobEventType::name].
        UnknownValue(job_event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobEventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Impression => std::option::Option::Some(1),
                Self::View => std::option::Option::Some(2),
                Self::ViewRedirect => std::option::Option::Some(3),
                Self::ApplicationStart => std::option::Option::Some(4),
                Self::ApplicationFinish => std::option::Option::Some(5),
                Self::ApplicationQuickSubmission => std::option::Option::Some(6),
                Self::ApplicationRedirect => std::option::Option::Some(7),
                Self::ApplicationStartFromSearch => std::option::Option::Some(8),
                Self::ApplicationRedirectFromSearch => std::option::Option::Some(9),
                Self::ApplicationCompanySubmit => std::option::Option::Some(10),
                Self::Bookmark => std::option::Option::Some(11),
                Self::Notification => std::option::Option::Some(12),
                Self::Hired => std::option::Option::Some(13),
                Self::SentCv => std::option::Option::Some(14),
                Self::InterviewGranted => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JOB_EVENT_TYPE_UNSPECIFIED"),
                Self::Impression => std::option::Option::Some("IMPRESSION"),
                Self::View => std::option::Option::Some("VIEW"),
                Self::ViewRedirect => std::option::Option::Some("VIEW_REDIRECT"),
                Self::ApplicationStart => std::option::Option::Some("APPLICATION_START"),
                Self::ApplicationFinish => std::option::Option::Some("APPLICATION_FINISH"),
                Self::ApplicationQuickSubmission => {
                    std::option::Option::Some("APPLICATION_QUICK_SUBMISSION")
                }
                Self::ApplicationRedirect => std::option::Option::Some("APPLICATION_REDIRECT"),
                Self::ApplicationStartFromSearch => {
                    std::option::Option::Some("APPLICATION_START_FROM_SEARCH")
                }
                Self::ApplicationRedirectFromSearch => {
                    std::option::Option::Some("APPLICATION_REDIRECT_FROM_SEARCH")
                }
                Self::ApplicationCompanySubmit => {
                    std::option::Option::Some("APPLICATION_COMPANY_SUBMIT")
                }
                Self::Bookmark => std::option::Option::Some("BOOKMARK"),
                Self::Notification => std::option::Option::Some("NOTIFICATION"),
                Self::Hired => std::option::Option::Some("HIRED"),
                Self::SentCv => std::option::Option::Some("SENT_CV"),
                Self::InterviewGranted => std::option::Option::Some("INTERVIEW_GRANTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobEventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobEventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Impression,
                2 => Self::View,
                3 => Self::ViewRedirect,
                4 => Self::ApplicationStart,
                5 => Self::ApplicationFinish,
                6 => Self::ApplicationQuickSubmission,
                7 => Self::ApplicationRedirect,
                8 => Self::ApplicationStartFromSearch,
                9 => Self::ApplicationRedirectFromSearch,
                10 => Self::ApplicationCompanySubmit,
                11 => Self::Bookmark,
                12 => Self::Notification,
                13 => Self::Hired,
                14 => Self::SentCv,
                15 => Self::InterviewGranted,
                _ => Self::UnknownValue(job_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobEventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JOB_EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMPRESSION" => Self::Impression,
                "VIEW" => Self::View,
                "VIEW_REDIRECT" => Self::ViewRedirect,
                "APPLICATION_START" => Self::ApplicationStart,
                "APPLICATION_FINISH" => Self::ApplicationFinish,
                "APPLICATION_QUICK_SUBMISSION" => Self::ApplicationQuickSubmission,
                "APPLICATION_REDIRECT" => Self::ApplicationRedirect,
                "APPLICATION_START_FROM_SEARCH" => Self::ApplicationStartFromSearch,
                "APPLICATION_REDIRECT_FROM_SEARCH" => Self::ApplicationRedirectFromSearch,
                "APPLICATION_COMPANY_SUBMIT" => Self::ApplicationCompanySubmit,
                "BOOKMARK" => Self::Bookmark,
                "NOTIFICATION" => Self::Notification,
                "HIRED" => Self::Hired,
                "SENT_CV" => Self::SentCv,
                "INTERVIEW_GRANTED" => Self::InterviewGranted,
                _ => Self::UnknownValue(job_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobEventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Impression => serializer.serialize_i32(1),
                Self::View => serializer.serialize_i32(2),
                Self::ViewRedirect => serializer.serialize_i32(3),
                Self::ApplicationStart => serializer.serialize_i32(4),
                Self::ApplicationFinish => serializer.serialize_i32(5),
                Self::ApplicationQuickSubmission => serializer.serialize_i32(6),
                Self::ApplicationRedirect => serializer.serialize_i32(7),
                Self::ApplicationStartFromSearch => serializer.serialize_i32(8),
                Self::ApplicationRedirectFromSearch => serializer.serialize_i32(9),
                Self::ApplicationCompanySubmit => serializer.serialize_i32(10),
                Self::Bookmark => serializer.serialize_i32(11),
                Self::Notification => serializer.serialize_i32(12),
                Self::Hired => serializer.serialize_i32(13),
                Self::SentCv => serializer.serialize_i32(14),
                Self::InterviewGranted => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobEventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobEventType>::new(
                ".google.cloud.talent.v4.JobEvent.JobEventType",
            ))
        }
    }
}

/// The report event request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClientEventRequest {
    /// Required. Resource name of the tenant under which the event is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}", for example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// Required. Events issued when end user interacts with customer's application
    /// that uses Cloud Talent Solution.
    pub client_event: std::option::Option<crate::model::ClientEvent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClientEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClientEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [client_event][crate::model::CreateClientEventRequest::client_event].
    pub fn set_client_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClientEvent>,
    {
        self.client_event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_event][crate::model::CreateClientEventRequest::client_event].
    pub fn set_or_clear_client_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClientEvent>,
    {
        self.client_event = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateClientEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CreateClientEventRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClientEventRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __client_event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClientEventRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "clientEvent" => Ok(__FieldTag::__client_event),
                            "client_event" => Ok(__FieldTag::__client_event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClientEventRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClientEventRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_event => {
                            if !fields.insert(__FieldTag::__client_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_event",
                                ));
                            }
                            result.client_event =
                                map.next_value::<std::option::Option<crate::model::ClientEvent>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClientEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.client_event.is_some() {
            state.serialize_entry("clientEvent", &self.client_event)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateClientEventRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateClientEventRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("client_event", &self.client_event);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The query required to perform a search query.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JobQuery {
    /// The query string that matches against the job title, description, and
    /// location fields.
    ///
    /// The maximum number of allowed characters is 255.
    pub query: std::string::String,

    /// The language code of [query][google.cloud.talent.v4.JobQuery.query]. For
    /// example, "en-US". This field helps to better interpret the query.
    ///
    /// If a value isn't specified, the query language code is automatically
    /// detected, which may not be accurate.
    ///
    /// Language code should be in BCP-47 format, such as "en-US" or "sr-Latn".
    /// For more information, see
    /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
    ///
    /// [google.cloud.talent.v4.JobQuery.query]: crate::model::JobQuery::query
    pub query_language_code: std::string::String,

    /// This filter specifies the company entities to search against.
    ///
    /// If a value isn't specified, jobs are searched for against all
    /// companies.
    ///
    /// If multiple values are specified, jobs are searched against the
    /// companies specified.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}". For
    /// example, "projects/foo/tenants/bar/companies/baz".
    ///
    /// At most 20 company filters are allowed.
    pub companies: std::vec::Vec<std::string::String>,

    /// The location filter specifies geo-regions containing the jobs to
    /// search against. See [LocationFilter][google.cloud.talent.v4.LocationFilter]
    /// for more information.
    ///
    /// If a location value isn't specified, jobs fitting the other search
    /// criteria are retrieved regardless of where they're located.
    ///
    /// If multiple values are specified, jobs are retrieved from any of the
    /// specified locations. If different values are specified for the
    /// [LocationFilter.distance_in_miles][google.cloud.talent.v4.LocationFilter.distance_in_miles]
    /// parameter, the maximum provided distance is used for all locations.
    ///
    /// At most 5 location filters are allowed.
    ///
    /// [google.cloud.talent.v4.LocationFilter]: crate::model::LocationFilter
    /// [google.cloud.talent.v4.LocationFilter.distance_in_miles]: crate::model::LocationFilter::distance_in_miles
    pub location_filters: std::vec::Vec<crate::model::LocationFilter>,

    /// The category filter specifies the categories of jobs to search against.
    /// See [JobCategory][google.cloud.talent.v4.JobCategory] for more information.
    ///
    /// If a value isn't specified, jobs from any category are searched against.
    ///
    /// If multiple values are specified, jobs from any of the specified
    /// categories are searched against.
    ///
    /// [google.cloud.talent.v4.JobCategory]: crate::model::JobCategory
    pub job_categories: std::vec::Vec<crate::model::JobCategory>,

    /// Allows filtering jobs by commute time with different travel methods (for
    /// example, driving or public transit).
    ///
    /// Note: This only works when you specify a
    /// [CommuteMethod][google.cloud.talent.v4.CommuteMethod]. In this case,
    /// [location_filters][google.cloud.talent.v4.JobQuery.location_filters] is
    /// ignored.
    ///
    /// Currently we don't support sorting by commute time.
    ///
    /// [google.cloud.talent.v4.CommuteMethod]: crate::model::CommuteMethod
    /// [google.cloud.talent.v4.JobQuery.location_filters]: crate::model::JobQuery::location_filters
    pub commute_filter: std::option::Option<crate::model::CommuteFilter>,

    /// This filter specifies the company
    /// [Company.display_name][google.cloud.talent.v4.Company.display_name] of the
    /// jobs to search against. The company name must match the value exactly.
    ///
    /// Alternatively, the value being searched for can be wrapped in different
    /// match operators.
    /// `SUBSTRING_MATCH([value])`
    /// The company name must contain a case insensitive substring match of the
    /// value. Using this function may increase latency.
    ///
    /// Sample Value: `SUBSTRING_MATCH(google)`
    ///
    /// `MULTI_WORD_TOKEN_MATCH([value])`
    /// The value will be treated as a multi word token and the company name must
    /// contain a case insensitive match of the value. Using this function may
    /// increase latency.
    ///
    /// Sample Value: `MULTI_WORD_TOKEN_MATCH(google)`
    ///
    /// If a value isn't specified, jobs within the search results are
    /// associated with any company.
    ///
    /// If multiple values are specified, jobs within the search results may be
    /// associated with any of the specified companies.
    ///
    /// At most 20 company display name filters are allowed.
    ///
    /// [google.cloud.talent.v4.Company.display_name]: crate::model::Company::display_name
    pub company_display_names: std::vec::Vec<std::string::String>,

    /// This search filter is applied only to
    /// [Job.compensation_info][google.cloud.talent.v4.Job.compensation_info]. For
    /// example, if the filter is specified as "Hourly job with per-hour
    /// compensation > $15", only jobs meeting these criteria are searched. If a
    /// filter isn't defined, all open jobs are searched.
    ///
    /// [google.cloud.talent.v4.Job.compensation_info]: crate::model::Job::compensation_info
    pub compensation_filter: std::option::Option<crate::model::CompensationFilter>,

    /// This filter specifies a structured syntax to match against the
    /// [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes]
    /// marked as `filterable`.
    ///
    /// The syntax for this expression is a subset of SQL syntax.
    ///
    /// Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the
    /// left of the operator is a custom field key and the right of the operator
    /// is a number or a quoted string. You must escape backslash (\\) and
    /// quote (\") characters.
    ///
    /// Supported functions are `LOWER([field_name])` to
    /// perform a case insensitive match and `EMPTY([field_name])` to filter on the
    /// existence of a key.
    ///
    /// Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
    /// nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
    /// comparisons or functions are allowed in the expression. The expression
    /// must be < 10000 bytes in length.
    ///
    /// Sample Query:
    /// `(LOWER(driving_license)="class \"a\"" OR EMPTY(driving_license)) AND
    /// driving_years > 10`
    ///
    /// [google.cloud.talent.v4.Job.custom_attributes]: crate::model::Job::custom_attributes
    pub custom_attribute_filter: std::string::String,

    /// This flag controls the spell-check feature. If false, the
    /// service attempts to correct a misspelled query,
    /// for example, "enginee" is corrected to "engineer".
    ///
    /// Defaults to false: a spell check is performed.
    pub disable_spell_check: bool,

    /// The employment type filter specifies the employment type of jobs to
    /// search against, such as
    /// [EmploymentType.FULL_TIME][google.cloud.talent.v4.EmploymentType.FULL_TIME].
    ///
    /// If a value isn't specified, jobs in the search results includes any
    /// employment type.
    ///
    /// If multiple values are specified, jobs in the search results include
    /// any of the specified employment types.
    ///
    /// [google.cloud.talent.v4.EmploymentType.FULL_TIME]: crate::model::EmploymentType::FullTime
    pub employment_types: std::vec::Vec<crate::model::EmploymentType>,

    /// This filter specifies the locale of jobs to search against,
    /// for example, "en-US".
    ///
    /// If a value isn't specified, the search results can contain jobs in any
    /// locale.
    ///
    /// Language codes should be in BCP-47 format, such as "en-US" or "sr-Latn".
    /// For more information, see
    /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
    ///
    /// At most 10 language code filters are allowed.
    pub language_codes: std::vec::Vec<std::string::String>,

    /// Jobs published within a range specified by this filter are searched
    /// against.
    pub publish_time_range: std::option::Option<crate::model::TimestampRange>,

    /// This filter specifies a list of job names to be excluded during search.
    ///
    /// At most 400 excluded job names are allowed.
    pub excluded_jobs: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::JobQuery::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [query_language_code][crate::model::JobQuery::query_language_code].
    pub fn set_query_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.query_language_code = v.into();
        self
    }

    /// Sets the value of [companies][crate::model::JobQuery::companies].
    pub fn set_companies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.companies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location_filters][crate::model::JobQuery::location_filters].
    pub fn set_location_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LocationFilter>,
    {
        use std::iter::Iterator;
        self.location_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_categories][crate::model::JobQuery::job_categories].
    pub fn set_job_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobCategory>,
    {
        use std::iter::Iterator;
        self.job_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [commute_filter][crate::model::JobQuery::commute_filter].
    pub fn set_commute_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommuteFilter>,
    {
        self.commute_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [commute_filter][crate::model::JobQuery::commute_filter].
    pub fn set_or_clear_commute_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommuteFilter>,
    {
        self.commute_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [company_display_names][crate::model::JobQuery::company_display_names].
    pub fn set_company_display_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.company_display_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [compensation_filter][crate::model::JobQuery::compensation_filter].
    pub fn set_compensation_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompensationFilter>,
    {
        self.compensation_filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compensation_filter][crate::model::JobQuery::compensation_filter].
    pub fn set_or_clear_compensation_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompensationFilter>,
    {
        self.compensation_filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_attribute_filter][crate::model::JobQuery::custom_attribute_filter].
    pub fn set_custom_attribute_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_attribute_filter = v.into();
        self
    }

    /// Sets the value of [disable_spell_check][crate::model::JobQuery::disable_spell_check].
    pub fn set_disable_spell_check<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_spell_check = v.into();
        self
    }

    /// Sets the value of [employment_types][crate::model::JobQuery::employment_types].
    pub fn set_employment_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EmploymentType>,
    {
        use std::iter::Iterator;
        self.employment_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_codes][crate::model::JobQuery::language_codes].
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [publish_time_range][crate::model::JobQuery::publish_time_range].
    pub fn set_publish_time_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimestampRange>,
    {
        self.publish_time_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [publish_time_range][crate::model::JobQuery::publish_time_range].
    pub fn set_or_clear_publish_time_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimestampRange>,
    {
        self.publish_time_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [excluded_jobs][crate::model::JobQuery::excluded_jobs].
    pub fn set_excluded_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.excluded_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for JobQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.JobQuery"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __query_language_code,
            __companies,
            __location_filters,
            __job_categories,
            __commute_filter,
            __company_display_names,
            __compensation_filter,
            __custom_attribute_filter,
            __disable_spell_check,
            __employment_types,
            __language_codes,
            __publish_time_range,
            __excluded_jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "queryLanguageCode" => Ok(__FieldTag::__query_language_code),
                            "query_language_code" => Ok(__FieldTag::__query_language_code),
                            "companies" => Ok(__FieldTag::__companies),
                            "locationFilters" => Ok(__FieldTag::__location_filters),
                            "location_filters" => Ok(__FieldTag::__location_filters),
                            "jobCategories" => Ok(__FieldTag::__job_categories),
                            "job_categories" => Ok(__FieldTag::__job_categories),
                            "commuteFilter" => Ok(__FieldTag::__commute_filter),
                            "commute_filter" => Ok(__FieldTag::__commute_filter),
                            "companyDisplayNames" => Ok(__FieldTag::__company_display_names),
                            "company_display_names" => Ok(__FieldTag::__company_display_names),
                            "compensationFilter" => Ok(__FieldTag::__compensation_filter),
                            "compensation_filter" => Ok(__FieldTag::__compensation_filter),
                            "customAttributeFilter" => Ok(__FieldTag::__custom_attribute_filter),
                            "custom_attribute_filter" => Ok(__FieldTag::__custom_attribute_filter),
                            "disableSpellCheck" => Ok(__FieldTag::__disable_spell_check),
                            "disable_spell_check" => Ok(__FieldTag::__disable_spell_check),
                            "employmentTypes" => Ok(__FieldTag::__employment_types),
                            "employment_types" => Ok(__FieldTag::__employment_types),
                            "languageCodes" => Ok(__FieldTag::__language_codes),
                            "language_codes" => Ok(__FieldTag::__language_codes),
                            "publishTimeRange" => Ok(__FieldTag::__publish_time_range),
                            "publish_time_range" => Ok(__FieldTag::__publish_time_range),
                            "excludedJobs" => Ok(__FieldTag::__excluded_jobs),
                            "excluded_jobs" => Ok(__FieldTag::__excluded_jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_language_code => {
                            if !fields.insert(__FieldTag::__query_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_language_code",
                                ));
                            }
                            result.query_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__companies => {
                            if !fields.insert(__FieldTag::__companies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for companies",
                                ));
                            }
                            result.companies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__location_filters => {
                            if !fields.insert(__FieldTag::__location_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_filters",
                                ));
                            }
                            result.location_filters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LocationFilter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_categories => {
                            if !fields.insert(__FieldTag::__job_categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_categories",
                                ));
                            }
                            result.job_categories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobCategory>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__commute_filter => {
                            if !fields.insert(__FieldTag::__commute_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commute_filter",
                                ));
                            }
                            result.commute_filter = map
                                .next_value::<std::option::Option<crate::model::CommuteFilter>>()?;
                        }
                        __FieldTag::__company_display_names => {
                            if !fields.insert(__FieldTag::__company_display_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for company_display_names",
                                ));
                            }
                            result.company_display_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compensation_filter => {
                            if !fields.insert(__FieldTag::__compensation_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compensation_filter",
                                ));
                            }
                            result.compensation_filter = map.next_value::<std::option::Option<crate::model::CompensationFilter>>()?
                                ;
                        }
                        __FieldTag::__custom_attribute_filter => {
                            if !fields.insert(__FieldTag::__custom_attribute_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_attribute_filter",
                                ));
                            }
                            result.custom_attribute_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_spell_check => {
                            if !fields.insert(__FieldTag::__disable_spell_check) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_spell_check",
                                ));
                            }
                            result.disable_spell_check = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__employment_types => {
                            if !fields.insert(__FieldTag::__employment_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for employment_types",
                                ));
                            }
                            result.employment_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EmploymentType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_codes => {
                            if !fields.insert(__FieldTag::__language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes",
                                ));
                            }
                            result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__publish_time_range => {
                            if !fields.insert(__FieldTag::__publish_time_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_time_range",
                                ));
                            }
                            result.publish_time_range = map
                                .next_value::<std::option::Option<crate::model::TimestampRange>>(
                                )?;
                        }
                        __FieldTag::__excluded_jobs => {
                            if !fields.insert(__FieldTag::__excluded_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_jobs",
                                ));
                            }
                            result.excluded_jobs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobQuery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.query_language_code.is_empty() {
            state.serialize_entry("queryLanguageCode", &self.query_language_code)?;
        }
        if !self.companies.is_empty() {
            state.serialize_entry("companies", &self.companies)?;
        }
        if !self.location_filters.is_empty() {
            state.serialize_entry("locationFilters", &self.location_filters)?;
        }
        if !self.job_categories.is_empty() {
            state.serialize_entry("jobCategories", &self.job_categories)?;
        }
        if self.commute_filter.is_some() {
            state.serialize_entry("commuteFilter", &self.commute_filter)?;
        }
        if !self.company_display_names.is_empty() {
            state.serialize_entry("companyDisplayNames", &self.company_display_names)?;
        }
        if self.compensation_filter.is_some() {
            state.serialize_entry("compensationFilter", &self.compensation_filter)?;
        }
        if !self.custom_attribute_filter.is_empty() {
            state.serialize_entry("customAttributeFilter", &self.custom_attribute_filter)?;
        }
        if !wkt::internal::is_default(&self.disable_spell_check) {
            state.serialize_entry("disableSpellCheck", &self.disable_spell_check)?;
        }
        if !self.employment_types.is_empty() {
            state.serialize_entry("employmentTypes", &self.employment_types)?;
        }
        if !self.language_codes.is_empty() {
            state.serialize_entry("languageCodes", &self.language_codes)?;
        }
        if self.publish_time_range.is_some() {
            state.serialize_entry("publishTimeRange", &self.publish_time_range)?;
        }
        if !self.excluded_jobs.is_empty() {
            state.serialize_entry("excludedJobs", &self.excluded_jobs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for JobQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobQuery");
        debug_struct.field("query", &self.query);
        debug_struct.field("query_language_code", &self.query_language_code);
        debug_struct.field("companies", &self.companies);
        debug_struct.field("location_filters", &self.location_filters);
        debug_struct.field("job_categories", &self.job_categories);
        debug_struct.field("commute_filter", &self.commute_filter);
        debug_struct.field("company_display_names", &self.company_display_names);
        debug_struct.field("compensation_filter", &self.compensation_filter);
        debug_struct.field("custom_attribute_filter", &self.custom_attribute_filter);
        debug_struct.field("disable_spell_check", &self.disable_spell_check);
        debug_struct.field("employment_types", &self.employment_types);
        debug_struct.field("language_codes", &self.language_codes);
        debug_struct.field("publish_time_range", &self.publish_time_range);
        debug_struct.field("excluded_jobs", &self.excluded_jobs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Geographic region of the search.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationFilter {
    /// The address name, such as "Mountain View" or "Bay Area".
    pub address: std::string::String,

    /// CLDR region code of the country/region. This field may be used in two ways:
    ///
    /// 1. If telecommute preference is not set, this field is used address
    ///    ambiguity of the user-input address. For example, "Liverpool" may refer to
    ///    "Liverpool, NY, US" or "Liverpool, UK". This region code biases the
    ///    address resolution toward a specific country or territory. If this field is
    ///    not set, address resolution is biased toward the United States by default.
    ///
    /// 1. If telecommute preference is set to TELECOMMUTE_ALLOWED, the
    ///    telecommute location filter will be limited to the region specified in this
    ///    field. If this field is not set, the telecommute job locations will not be
    ///
    ///
    /// See
    /// <https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/territory_information.html>
    /// for details. Example: "CH" for Switzerland.
    pub region_code: std::string::String,

    /// The latitude and longitude of the geographic center to search from. This
    /// field is ignored if `address` is provided.
    pub lat_lng: std::option::Option<gtype::model::LatLng>,

    /// The distance_in_miles is applied when the location being searched for is
    /// identified as a city or smaller. This field is ignored if the location
    /// being searched for is a state or larger.
    pub distance_in_miles: f64,

    /// Allows the client to return jobs without a
    /// set location, specifically, telecommuting jobs (telecommuting is considered
    /// by the service as a special location).
    /// [Job.posting_region][google.cloud.talent.v4.Job.posting_region] indicates
    /// if a job permits telecommuting. If this field is set to
    /// [TelecommutePreference.TELECOMMUTE_ALLOWED][google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_ALLOWED],
    /// telecommuting jobs are searched, and
    /// [address][google.cloud.talent.v4.LocationFilter.address] and
    /// [lat_lng][google.cloud.talent.v4.LocationFilter.lat_lng] are ignored. If
    /// not set or set to
    /// [TelecommutePreference.TELECOMMUTE_EXCLUDED][google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_EXCLUDED],
    /// the telecommute status of the jobs is ignored. Jobs that have
    /// [PostingRegion.TELECOMMUTE][google.cloud.talent.v4.PostingRegion.TELECOMMUTE]
    /// and have additional [Job.addresses][google.cloud.talent.v4.Job.addresses]
    /// may still be matched based on other location filters using
    /// [address][google.cloud.talent.v4.LocationFilter.address] or
    /// [lat_lng][google.cloud.talent.v4.LocationFilter.lat_lng].
    ///
    /// This filter can be used by itself to search exclusively for telecommuting
    /// jobs, or it can be combined with another location
    /// filter to search for a combination of job locations,
    /// such as "Mountain View" or "telecommuting" jobs. However, when used in
    /// combination with other location filters, telecommuting jobs can be
    /// treated as less relevant than other jobs in the search response.
    ///
    /// This field is only used for job search requests.
    ///
    /// [google.cloud.talent.v4.Job.addresses]: crate::model::Job::addresses
    /// [google.cloud.talent.v4.Job.posting_region]: crate::model::Job::posting_region
    /// [google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_ALLOWED]: crate::model::location_filter::TelecommutePreference::TelecommuteAllowed
    /// [google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_EXCLUDED]: crate::model::location_filter::TelecommutePreference::TelecommuteExcluded
    /// [google.cloud.talent.v4.LocationFilter.address]: crate::model::LocationFilter::address
    /// [google.cloud.talent.v4.LocationFilter.lat_lng]: crate::model::LocationFilter::lat_lng
    /// [google.cloud.talent.v4.PostingRegion.TELECOMMUTE]: crate::model::PostingRegion::Telecommute
    pub telecommute_preference: crate::model::location_filter::TelecommutePreference,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [address][crate::model::LocationFilter::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [region_code][crate::model::LocationFilter::region_code].
    pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region_code = v.into();
        self
    }

    /// Sets the value of [lat_lng][crate::model::LocationFilter::lat_lng].
    pub fn set_lat_lng<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.lat_lng = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lat_lng][crate::model::LocationFilter::lat_lng].
    pub fn set_or_clear_lat_lng<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.lat_lng = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distance_in_miles][crate::model::LocationFilter::distance_in_miles].
    pub fn set_distance_in_miles<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.distance_in_miles = v.into();
        self
    }

    /// Sets the value of [telecommute_preference][crate::model::LocationFilter::telecommute_preference].
    pub fn set_telecommute_preference<
        T: std::convert::Into<crate::model::location_filter::TelecommutePreference>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.telecommute_preference = v.into();
        self
    }
}

impl wkt::message::Message for LocationFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.LocationFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __address,
            __region_code,
            __lat_lng,
            __distance_in_miles,
            __telecommute_preference,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "address" => Ok(__FieldTag::__address),
                            "regionCode" => Ok(__FieldTag::__region_code),
                            "region_code" => Ok(__FieldTag::__region_code),
                            "latLng" => Ok(__FieldTag::__lat_lng),
                            "lat_lng" => Ok(__FieldTag::__lat_lng),
                            "distanceInMiles" => Ok(__FieldTag::__distance_in_miles),
                            "distance_in_miles" => Ok(__FieldTag::__distance_in_miles),
                            "telecommutePreference" => Ok(__FieldTag::__telecommute_preference),
                            "telecommute_preference" => Ok(__FieldTag::__telecommute_preference),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__address => {
                            if !fields.insert(__FieldTag::__address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for address",
                                ));
                            }
                            result.address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region_code => {
                            if !fields.insert(__FieldTag::__region_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region_code",
                                ));
                            }
                            result.region_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lat_lng => {
                            if !fields.insert(__FieldTag::__lat_lng) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lat_lng",
                                ));
                            }
                            result.lat_lng =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__distance_in_miles => {
                            if !fields.insert(__FieldTag::__distance_in_miles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distance_in_miles",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.distance_in_miles =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__telecommute_preference => {
                            if !fields.insert(__FieldTag::__telecommute_preference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for telecommute_preference",
                                ));
                            }
                            result.telecommute_preference = map
                                .next_value::<std::option::Option<
                                    crate::model::location_filter::TelecommutePreference,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.address.is_empty() {
            state.serialize_entry("address", &self.address)?;
        }
        if !self.region_code.is_empty() {
            state.serialize_entry("regionCode", &self.region_code)?;
        }
        if self.lat_lng.is_some() {
            state.serialize_entry("latLng", &self.lat_lng)?;
        }
        if !wkt::internal::is_default(&self.distance_in_miles) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("distanceInMiles", &__With(&self.distance_in_miles))?;
        }
        if !wkt::internal::is_default(&self.telecommute_preference) {
            state.serialize_entry("telecommutePreference", &self.telecommute_preference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocationFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationFilter");
        debug_struct.field("address", &self.address);
        debug_struct.field("region_code", &self.region_code);
        debug_struct.field("lat_lng", &self.lat_lng);
        debug_struct.field("distance_in_miles", &self.distance_in_miles);
        debug_struct.field("telecommute_preference", &self.telecommute_preference);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LocationFilter].
pub mod location_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Specify whether to include telecommute jobs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TelecommutePreference {
        /// Default value if the telecommute preference isn't specified.
        Unspecified,
        /// Deprecated: Ignore telecommute status of jobs. Use
        /// TELECOMMUTE_JOBS_EXCLUDED if want to exclude telecommute jobs.
        #[deprecated]
        TelecommuteExcluded,
        /// Allow telecommute jobs.
        TelecommuteAllowed,
        /// Exclude telecommute jobs.
        TelecommuteJobsExcluded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TelecommutePreference::value] or
        /// [TelecommutePreference::name].
        UnknownValue(telecommute_preference::UnknownValue),
    }

    #[doc(hidden)]
    pub mod telecommute_preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TelecommutePreference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TelecommuteExcluded => std::option::Option::Some(1),
                Self::TelecommuteAllowed => std::option::Option::Some(2),
                Self::TelecommuteJobsExcluded => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TELECOMMUTE_PREFERENCE_UNSPECIFIED")
                }
                Self::TelecommuteExcluded => std::option::Option::Some("TELECOMMUTE_EXCLUDED"),
                Self::TelecommuteAllowed => std::option::Option::Some("TELECOMMUTE_ALLOWED"),
                Self::TelecommuteJobsExcluded => {
                    std::option::Option::Some("TELECOMMUTE_JOBS_EXCLUDED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TelecommutePreference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TelecommutePreference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TelecommutePreference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TelecommuteExcluded,
                2 => Self::TelecommuteAllowed,
                3 => Self::TelecommuteJobsExcluded,
                _ => Self::UnknownValue(telecommute_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TelecommutePreference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TELECOMMUTE_PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                "TELECOMMUTE_EXCLUDED" => Self::TelecommuteExcluded,
                "TELECOMMUTE_ALLOWED" => Self::TelecommuteAllowed,
                "TELECOMMUTE_JOBS_EXCLUDED" => Self::TelecommuteJobsExcluded,
                _ => Self::UnknownValue(telecommute_preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TelecommutePreference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TelecommuteExcluded => serializer.serialize_i32(1),
                Self::TelecommuteAllowed => serializer.serialize_i32(2),
                Self::TelecommuteJobsExcluded => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TelecommutePreference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TelecommutePreference>::new(
                ".google.cloud.talent.v4.LocationFilter.TelecommutePreference",
            ))
        }
    }
}

/// Filter on job compensation type and amount.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompensationFilter {
    /// Required. Type of filter.
    pub r#type: crate::model::compensation_filter::FilterType,

    /// Required. Specify desired `base compensation entry's`
    /// [CompensationInfo.CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit].
    ///
    /// [google.cloud.talent.v4.CompensationInfo.CompensationUnit]: crate::model::compensation_info::CompensationUnit
    pub units: std::vec::Vec<crate::model::compensation_info::CompensationUnit>,

    /// Compensation range.
    pub range: std::option::Option<crate::model::compensation_info::CompensationRange>,

    /// If set to true, jobs with unspecified compensation range fields are
    /// included.
    pub include_jobs_with_unspecified_compensation_range: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompensationFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::CompensationFilter::type].
    pub fn set_type<T: std::convert::Into<crate::model::compensation_filter::FilterType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [units][crate::model::CompensationFilter::units].
    pub fn set_units<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::compensation_info::CompensationUnit>,
    {
        use std::iter::Iterator;
        self.units = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [range][crate::model::CompensationFilter::range].
    pub fn set_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compensation_info::CompensationRange>,
    {
        self.range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [range][crate::model::CompensationFilter::range].
    pub fn set_or_clear_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::compensation_info::CompensationRange>,
    {
        self.range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [include_jobs_with_unspecified_compensation_range][crate::model::CompensationFilter::include_jobs_with_unspecified_compensation_range].
    pub fn set_include_jobs_with_unspecified_compensation_range<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.include_jobs_with_unspecified_compensation_range = v.into();
        self
    }
}

impl wkt::message::Message for CompensationFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CompensationFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompensationFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __units,
            __range,
            __include_jobs_with_unspecified_compensation_range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompensationFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "units" => Ok(__FieldTag::__units),
                            "range" => Ok(__FieldTag::__range),
                            "includeJobsWithUnspecifiedCompensationRange" => {
                                Ok(__FieldTag::__include_jobs_with_unspecified_compensation_range)
                            }
                            "include_jobs_with_unspecified_compensation_range" => {
                                Ok(__FieldTag::__include_jobs_with_unspecified_compensation_range)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompensationFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompensationFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::compensation_filter::FilterType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__units => {
                            if !fields.insert(__FieldTag::__units) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for units",
                                ));
                            }
                            result.units = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::compensation_info::CompensationUnit,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__range => {
                            if !fields.insert(__FieldTag::__range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range",
                                ));
                            }
                            result.range = map.next_value::<std::option::Option<
                                crate::model::compensation_info::CompensationRange,
                            >>()?;
                        }
                        __FieldTag::__include_jobs_with_unspecified_compensation_range => {
                            if !fields.insert(
                                __FieldTag::__include_jobs_with_unspecified_compensation_range,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_jobs_with_unspecified_compensation_range",
                                ));
                            }
                            result.include_jobs_with_unspecified_compensation_range = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompensationFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.units.is_empty() {
            state.serialize_entry("units", &self.units)?;
        }
        if self.range.is_some() {
            state.serialize_entry("range", &self.range)?;
        }
        if !wkt::internal::is_default(&self.include_jobs_with_unspecified_compensation_range) {
            state.serialize_entry(
                "includeJobsWithUnspecifiedCompensationRange",
                &self.include_jobs_with_unspecified_compensation_range,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompensationFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompensationFilter");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("units", &self.units);
        debug_struct.field("range", &self.range);
        debug_struct.field(
            "include_jobs_with_unspecified_compensation_range",
            &self.include_jobs_with_unspecified_compensation_range,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CompensationFilter].
pub mod compensation_filter {
    #[allow(unused_imports)]
    use super::*;

    /// Specify the type of filtering.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FilterType {
        /// Filter type unspecified. Position holder, INVALID, should never be used.
        Unspecified,
        /// Filter by `base compensation entry's` unit. A job is a match if and
        /// only if the job contains a base CompensationEntry and the base
        /// CompensationEntry's unit matches provided
        /// [units][google.cloud.talent.v4.CompensationFilter.units]. Populate one or
        /// more [units][google.cloud.talent.v4.CompensationFilter.units].
        ///
        /// See
        /// [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry]
        /// for definition of base compensation entry.
        ///
        /// [google.cloud.talent.v4.CompensationFilter.units]: crate::model::CompensationFilter::units
        /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry]: crate::model::compensation_info::CompensationEntry
        UnitOnly,
        /// Filter by `base compensation entry's` unit and amount / range. A job
        /// is a match if and only if the job contains a base CompensationEntry, and
        /// the base entry's unit matches provided
        /// [CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit]
        /// and amount or range overlaps with provided
        /// [CompensationRange][google.cloud.talent.v4.CompensationInfo.CompensationRange].
        ///
        /// See
        /// [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry]
        /// for definition of base compensation entry.
        ///
        /// Set exactly one [units][google.cloud.talent.v4.CompensationFilter.units]
        /// and populate [range][google.cloud.talent.v4.CompensationFilter.range].
        ///
        /// [google.cloud.talent.v4.CompensationFilter.range]: crate::model::CompensationFilter::range
        /// [google.cloud.talent.v4.CompensationFilter.units]: crate::model::CompensationFilter::units
        /// [google.cloud.talent.v4.CompensationInfo.CompensationEntry]: crate::model::compensation_info::CompensationEntry
        /// [google.cloud.talent.v4.CompensationInfo.CompensationRange]: crate::model::compensation_info::CompensationRange
        /// [google.cloud.talent.v4.CompensationInfo.CompensationUnit]: crate::model::compensation_info::CompensationUnit
        UnitAndAmount,
        /// Filter by annualized base compensation amount and `base compensation
        /// entry's` unit. Populate
        /// [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more
        /// [units][google.cloud.talent.v4.CompensationFilter.units].
        ///
        /// [google.cloud.talent.v4.CompensationFilter.range]: crate::model::CompensationFilter::range
        /// [google.cloud.talent.v4.CompensationFilter.units]: crate::model::CompensationFilter::units
        AnnualizedBaseAmount,
        /// Filter by annualized total compensation amount and `base compensation
        /// entry's` unit . Populate
        /// [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more
        /// [units][google.cloud.talent.v4.CompensationFilter.units].
        ///
        /// [google.cloud.talent.v4.CompensationFilter.range]: crate::model::CompensationFilter::range
        /// [google.cloud.talent.v4.CompensationFilter.units]: crate::model::CompensationFilter::units
        AnnualizedTotalAmount,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FilterType::value] or
        /// [FilterType::name].
        UnknownValue(filter_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod filter_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FilterType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnitOnly => std::option::Option::Some(1),
                Self::UnitAndAmount => std::option::Option::Some(2),
                Self::AnnualizedBaseAmount => std::option::Option::Some(3),
                Self::AnnualizedTotalAmount => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FILTER_TYPE_UNSPECIFIED"),
                Self::UnitOnly => std::option::Option::Some("UNIT_ONLY"),
                Self::UnitAndAmount => std::option::Option::Some("UNIT_AND_AMOUNT"),
                Self::AnnualizedBaseAmount => std::option::Option::Some("ANNUALIZED_BASE_AMOUNT"),
                Self::AnnualizedTotalAmount => std::option::Option::Some("ANNUALIZED_TOTAL_AMOUNT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FilterType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FilterType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FilterType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnitOnly,
                2 => Self::UnitAndAmount,
                3 => Self::AnnualizedBaseAmount,
                4 => Self::AnnualizedTotalAmount,
                _ => Self::UnknownValue(filter_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FilterType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FILTER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "UNIT_ONLY" => Self::UnitOnly,
                "UNIT_AND_AMOUNT" => Self::UnitAndAmount,
                "ANNUALIZED_BASE_AMOUNT" => Self::AnnualizedBaseAmount,
                "ANNUALIZED_TOTAL_AMOUNT" => Self::AnnualizedTotalAmount,
                _ => Self::UnknownValue(filter_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FilterType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnitOnly => serializer.serialize_i32(1),
                Self::UnitAndAmount => serializer.serialize_i32(2),
                Self::AnnualizedBaseAmount => serializer.serialize_i32(3),
                Self::AnnualizedTotalAmount => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FilterType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FilterType>::new(
                ".google.cloud.talent.v4.CompensationFilter.FilterType",
            ))
        }
    }
}

/// Parameters needed for commute search.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CommuteFilter {
    /// Required. The method of transportation to calculate the commute time for.
    pub commute_method: crate::model::CommuteMethod,

    /// Required. The latitude and longitude of the location to calculate the
    /// commute time from.
    pub start_coordinates: std::option::Option<gtype::model::LatLng>,

    /// Required. The maximum travel time in seconds. The maximum allowed value is
    /// `3600s` (one hour). Format is `123s`.
    pub travel_duration: std::option::Option<wkt::Duration>,

    /// If `true`, jobs without street level addresses may also be returned.
    /// For city level addresses, the city center is used. For state and coarser
    /// level addresses, text matching is used.
    /// If this field is set to `false` or isn't specified, only jobs that include
    /// street level addresses will be returned by commute search.
    pub allow_imprecise_addresses: bool,

    /// Traffic factor to take into account while searching by commute.
    pub traffic_option: std::option::Option<crate::model::commute_filter::TrafficOption>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommuteFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [commute_method][crate::model::CommuteFilter::commute_method].
    pub fn set_commute_method<T: std::convert::Into<crate::model::CommuteMethod>>(
        mut self,
        v: T,
    ) -> Self {
        self.commute_method = v.into();
        self
    }

    /// Sets the value of [start_coordinates][crate::model::CommuteFilter::start_coordinates].
    pub fn set_start_coordinates<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.start_coordinates = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_coordinates][crate::model::CommuteFilter::start_coordinates].
    pub fn set_or_clear_start_coordinates<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.start_coordinates = v.map(|x| x.into());
        self
    }

    /// Sets the value of [travel_duration][crate::model::CommuteFilter::travel_duration].
    pub fn set_travel_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.travel_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [travel_duration][crate::model::CommuteFilter::travel_duration].
    pub fn set_or_clear_travel_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.travel_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_imprecise_addresses][crate::model::CommuteFilter::allow_imprecise_addresses].
    pub fn set_allow_imprecise_addresses<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_imprecise_addresses = v.into();
        self
    }

    /// Sets the value of [traffic_option][crate::model::CommuteFilter::traffic_option].
    ///
    /// Note that all the setters affecting `traffic_option` are mutually
    /// exclusive.
    pub fn set_traffic_option<
        T: std::convert::Into<std::option::Option<crate::model::commute_filter::TrafficOption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.traffic_option = v.into();
        self
    }

    /// The value of [traffic_option][crate::model::CommuteFilter::traffic_option]
    /// if it holds a `RoadTraffic`, `None` if the field is not set or
    /// holds a different branch.
    pub fn road_traffic(&self) -> std::option::Option<&crate::model::commute_filter::RoadTraffic> {
        #[allow(unreachable_patterns)]
        self.traffic_option.as_ref().and_then(|v| match v {
            crate::model::commute_filter::TrafficOption::RoadTraffic(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [traffic_option][crate::model::CommuteFilter::traffic_option]
    /// to hold a `RoadTraffic`.
    ///
    /// Note that all the setters affecting `traffic_option` are
    /// mutually exclusive.
    pub fn set_road_traffic<T: std::convert::Into<crate::model::commute_filter::RoadTraffic>>(
        mut self,
        v: T,
    ) -> Self {
        self.traffic_option = std::option::Option::Some(
            crate::model::commute_filter::TrafficOption::RoadTraffic(v.into()),
        );
        self
    }

    /// The value of [traffic_option][crate::model::CommuteFilter::traffic_option]
    /// if it holds a `DepartureTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn departure_time(&self) -> std::option::Option<&std::boxed::Box<gtype::model::TimeOfDay>> {
        #[allow(unreachable_patterns)]
        self.traffic_option.as_ref().and_then(|v| match v {
            crate::model::commute_filter::TrafficOption::DepartureTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [traffic_option][crate::model::CommuteFilter::traffic_option]
    /// to hold a `DepartureTime`.
    ///
    /// Note that all the setters affecting `traffic_option` are
    /// mutually exclusive.
    pub fn set_departure_time<T: std::convert::Into<std::boxed::Box<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.traffic_option = std::option::Option::Some(
            crate::model::commute_filter::TrafficOption::DepartureTime(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CommuteFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CommuteFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommuteFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __commute_method,
            __start_coordinates,
            __travel_duration,
            __allow_imprecise_addresses,
            __road_traffic,
            __departure_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommuteFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commuteMethod" => Ok(__FieldTag::__commute_method),
                            "commute_method" => Ok(__FieldTag::__commute_method),
                            "startCoordinates" => Ok(__FieldTag::__start_coordinates),
                            "start_coordinates" => Ok(__FieldTag::__start_coordinates),
                            "travelDuration" => Ok(__FieldTag::__travel_duration),
                            "travel_duration" => Ok(__FieldTag::__travel_duration),
                            "allowImpreciseAddresses" => {
                                Ok(__FieldTag::__allow_imprecise_addresses)
                            }
                            "allow_imprecise_addresses" => {
                                Ok(__FieldTag::__allow_imprecise_addresses)
                            }
                            "roadTraffic" => Ok(__FieldTag::__road_traffic),
                            "road_traffic" => Ok(__FieldTag::__road_traffic),
                            "departureTime" => Ok(__FieldTag::__departure_time),
                            "departure_time" => Ok(__FieldTag::__departure_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommuteFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommuteFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__commute_method => {
                            if !fields.insert(__FieldTag::__commute_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commute_method",
                                ));
                            }
                            result.commute_method = map
                                .next_value::<std::option::Option<crate::model::CommuteMethod>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_coordinates => {
                            if !fields.insert(__FieldTag::__start_coordinates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_coordinates",
                                ));
                            }
                            result.start_coordinates =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__travel_duration => {
                            if !fields.insert(__FieldTag::__travel_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for travel_duration",
                                ));
                            }
                            result.travel_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__allow_imprecise_addresses => {
                            if !fields.insert(__FieldTag::__allow_imprecise_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_imprecise_addresses",
                                ));
                            }
                            result.allow_imprecise_addresses = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__road_traffic => {
                            if !fields.insert(__FieldTag::__road_traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for road_traffic",
                                ));
                            }
                            if result.traffic_option.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `traffic_option`, a oneof with full ID .google.cloud.talent.v4.CommuteFilter.road_traffic, latest field was roadTraffic",
                                ));
                            }
                            result.traffic_option = std::option::Option::Some(
                                crate::model::commute_filter::TrafficOption::RoadTraffic(
                                    map.next_value::<std::option::Option<
                                        crate::model::commute_filter::RoadTraffic,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__departure_time => {
                            if !fields.insert(__FieldTag::__departure_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for departure_time",
                                ));
                            }
                            if result.traffic_option.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `traffic_option`, a oneof with full ID .google.cloud.talent.v4.CommuteFilter.departure_time, latest field was departureTime",
                                ));
                            }
                            result.traffic_option = std::option::Option::Some(
                                crate::model::commute_filter::TrafficOption::DepartureTime(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<gtype::model::TimeOfDay>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommuteFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.commute_method) {
            state.serialize_entry("commuteMethod", &self.commute_method)?;
        }
        if self.start_coordinates.is_some() {
            state.serialize_entry("startCoordinates", &self.start_coordinates)?;
        }
        if self.travel_duration.is_some() {
            state.serialize_entry("travelDuration", &self.travel_duration)?;
        }
        if !wkt::internal::is_default(&self.allow_imprecise_addresses) {
            state.serialize_entry("allowImpreciseAddresses", &self.allow_imprecise_addresses)?;
        }
        if let Some(value) = self.road_traffic() {
            state.serialize_entry("roadTraffic", value)?;
        }
        if let Some(value) = self.departure_time() {
            state.serialize_entry("departureTime", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CommuteFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommuteFilter");
        debug_struct.field("commute_method", &self.commute_method);
        debug_struct.field("start_coordinates", &self.start_coordinates);
        debug_struct.field("travel_duration", &self.travel_duration);
        debug_struct.field("allow_imprecise_addresses", &self.allow_imprecise_addresses);
        debug_struct.field("traffic_option", &self.traffic_option);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CommuteFilter].
pub mod commute_filter {
    #[allow(unused_imports)]
    use super::*;

    /// The traffic density to use when calculating commute time.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoadTraffic {
        /// Road traffic situation isn't specified.
        Unspecified,
        /// Optimal commute time without considering any traffic impact.
        TrafficFree,
        /// Commute time calculation takes in account the peak traffic impact.
        BusyHour,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RoadTraffic::value] or
        /// [RoadTraffic::name].
        UnknownValue(road_traffic::UnknownValue),
    }

    #[doc(hidden)]
    pub mod road_traffic {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RoadTraffic {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TrafficFree => std::option::Option::Some(1),
                Self::BusyHour => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROAD_TRAFFIC_UNSPECIFIED"),
                Self::TrafficFree => std::option::Option::Some("TRAFFIC_FREE"),
                Self::BusyHour => std::option::Option::Some("BUSY_HOUR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RoadTraffic {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RoadTraffic {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RoadTraffic {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TrafficFree,
                2 => Self::BusyHour,
                _ => Self::UnknownValue(road_traffic::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RoadTraffic {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROAD_TRAFFIC_UNSPECIFIED" => Self::Unspecified,
                "TRAFFIC_FREE" => Self::TrafficFree,
                "BUSY_HOUR" => Self::BusyHour,
                _ => Self::UnknownValue(road_traffic::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RoadTraffic {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TrafficFree => serializer.serialize_i32(1),
                Self::BusyHour => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RoadTraffic {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RoadTraffic>::new(
                ".google.cloud.talent.v4.CommuteFilter.RoadTraffic",
            ))
        }
    }

    /// Traffic factor to take into account while searching by commute.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrafficOption {
        /// Specifies the traffic density to use when calculating commute time.
        RoadTraffic(crate::model::commute_filter::RoadTraffic),
        /// The departure time used to calculate traffic impact, represented as
        /// [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.
        ///
        /// Currently traffic model is restricted to hour level resolution.
        ///
        /// [google.type.TimeOfDay]: gtype::model::TimeOfDay
        DepartureTime(std::boxed::Box<gtype::model::TimeOfDay>),
    }
}

/// The histogram request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HistogramQuery {
    /// An expression specifies a histogram request against matching jobs for
    /// searches.
    ///
    /// See
    /// [SearchJobsRequest.histogram_queries][google.cloud.talent.v4.SearchJobsRequest.histogram_queries]
    /// for details about syntax.
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest.histogram_queries]: crate::model::SearchJobsRequest::histogram_queries
    pub histogram_query: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HistogramQuery {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [histogram_query][crate::model::HistogramQuery::histogram_query].
    pub fn set_histogram_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.histogram_query = v.into();
        self
    }
}

impl wkt::message::Message for HistogramQuery {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.HistogramQuery"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HistogramQuery {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __histogram_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HistogramQuery")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "histogramQuery" => Ok(__FieldTag::__histogram_query),
                            "histogram_query" => Ok(__FieldTag::__histogram_query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HistogramQuery;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HistogramQuery")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__histogram_query => {
                            if !fields.insert(__FieldTag::__histogram_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for histogram_query",
                                ));
                            }
                            result.histogram_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HistogramQuery {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.histogram_query.is_empty() {
            state.serialize_entry("histogramQuery", &self.histogram_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HistogramQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HistogramQuery");
        debug_struct.field("histogram_query", &self.histogram_query);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Histogram result that matches
/// [HistogramQuery][google.cloud.talent.v4.HistogramQuery] specified in
/// searches.
///
/// [google.cloud.talent.v4.HistogramQuery]: crate::model::HistogramQuery
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HistogramQueryResult {
    /// Requested histogram expression.
    pub histogram_query: std::string::String,

    /// A map from the values of the facet associated with distinct values to the
    /// number of matching entries with corresponding value.
    ///
    /// The key format is:
    ///
    /// * (for string histogram) string values stored in the field.
    /// * (for named numeric bucket) name specified in `bucket()` function, like
    ///   for `bucket(0, MAX, "non-negative")`, the key will be `non-negative`.
    /// * (for anonymous numeric bucket) range formatted as `<low>-<high>`, for
    ///   example, `0-1000`, `MIN-0`, and `0-MAX`.
    pub histogram: std::collections::HashMap<std::string::String, i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HistogramQueryResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [histogram_query][crate::model::HistogramQueryResult::histogram_query].
    pub fn set_histogram_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.histogram_query = v.into();
        self
    }

    /// Sets the value of [histogram][crate::model::HistogramQueryResult::histogram].
    pub fn set_histogram<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.histogram = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for HistogramQueryResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.HistogramQueryResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HistogramQueryResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __histogram_query,
            __histogram,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HistogramQueryResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "histogramQuery" => Ok(__FieldTag::__histogram_query),
                            "histogram_query" => Ok(__FieldTag::__histogram_query),
                            "histogram" => Ok(__FieldTag::__histogram),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HistogramQueryResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HistogramQueryResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__histogram_query => {
                            if !fields.insert(__FieldTag::__histogram_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for histogram_query",
                                ));
                            }
                            result.histogram_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__histogram => {
                            if !fields.insert(__FieldTag::__histogram) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for histogram",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.histogram = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HistogramQueryResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.histogram_query.is_empty() {
            state.serialize_entry("histogramQuery", &self.histogram_query)?;
        }
        if !self.histogram.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("histogram", &__With(&self.histogram))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HistogramQueryResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HistogramQueryResult");
        debug_struct.field("histogram_query", &self.histogram_query);
        debug_struct.field("histogram", &self.histogram);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Job resource represents a job posting (also referred to as a "job listing"
/// or "job requisition"). A job belongs to a
/// [Company][google.cloud.talent.v4.Company], which is the hiring entity
/// responsible for the job.
///
/// [google.cloud.talent.v4.Company]: crate::model::Company
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Job {
    /// Required during job update.
    ///
    /// The resource name for the job. This is generated by the service when a
    /// job is created.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}". For
    /// example, "projects/foo/tenants/bar/jobs/baz".
    ///
    /// Use of this field in job queries and API calls is preferred over the use of
    /// [requisition_id][google.cloud.talent.v4.Job.requisition_id] since this
    /// value is unique.
    ///
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    pub name: std::string::String,

    /// Required. The resource name of the company listing the job.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}". For
    /// example, "projects/foo/tenants/bar/companies/baz".
    pub company: std::string::String,

    /// Required. The requisition ID, also referred to as the posting ID, is
    /// assigned by the client to identify a job. This field is intended to be used
    /// by clients for client identification and tracking of postings. A job isn't
    /// allowed to be created if there is another job with the same
    /// [company][google.cloud.talent.v4.Job.name],
    /// [language_code][google.cloud.talent.v4.Job.language_code] and
    /// [requisition_id][google.cloud.talent.v4.Job.requisition_id].
    ///
    /// The maximum number of allowed characters is 255.
    ///
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.name]: crate::model::Job::name
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    pub requisition_id: std::string::String,

    /// Required. The title of the job, such as "Software Engineer"
    ///
    /// The maximum number of allowed characters is 500.
    pub title: std::string::String,

    /// Required. The description of the job, which typically includes a
    /// multi-paragraph description of the company and related information.
    /// Separate fields are provided on the job object for
    /// [responsibilities][google.cloud.talent.v4.Job.responsibilities],
    /// [qualifications][google.cloud.talent.v4.Job.qualifications], and other job
    /// characteristics. Use of these separate job fields is recommended.
    ///
    /// This field accepts and sanitizes HTML input, and also accepts
    /// bold, italic, ordered list, and unordered list markup tags.
    ///
    /// The maximum number of allowed characters is 100,000.
    ///
    /// [google.cloud.talent.v4.Job.qualifications]: crate::model::Job::qualifications
    /// [google.cloud.talent.v4.Job.responsibilities]: crate::model::Job::responsibilities
    pub description: std::string::String,

    /// Strongly recommended for the best service experience.
    ///
    /// Location(s) where the employer is looking to hire for this job posting.
    ///
    /// Specifying the full street address(es) of the hiring location enables
    /// better API results, especially job searches by commute time.
    ///
    /// At most 50 locations are allowed for best search performance. If a job has
    /// more locations, it is suggested to split it into multiple jobs with unique
    /// [requisition_id][google.cloud.talent.v4.Job.requisition_id]s (e.g. 'ReqA'
    /// becomes 'ReqA-1', 'ReqA-2', and so on.) as multiple jobs with the same
    /// [company][google.cloud.talent.v4.Job.company],
    /// [language_code][google.cloud.talent.v4.Job.language_code] and
    /// [requisition_id][google.cloud.talent.v4.Job.requisition_id] are not
    /// allowed. If the original
    /// [requisition_id][google.cloud.talent.v4.Job.requisition_id] must be
    /// preserved, a custom field should be used for storage. It is also suggested
    /// to group the locations that close to each other in the same job for better
    /// search experience.
    ///
    /// Jobs with multiple addresses must have their addresses with the same
    /// [LocationType][google.cloud.talent.v4.Location.LocationType] to allow
    /// location filtering to work properly. (For example, a Job with addresses
    /// "1600 Amphitheatre Parkway, Mountain View, CA, USA" and "London, UK" may
    /// not have location filters applied correctly at search time since the first
    /// is a
    /// [LocationType.STREET_ADDRESS][google.cloud.talent.v4.Location.LocationType.STREET_ADDRESS]
    /// and the second is a
    /// [LocationType.LOCALITY][google.cloud.talent.v4.Location.LocationType.LOCALITY].)
    /// If a job needs to have multiple addresses, it is suggested to split it into
    /// multiple jobs with same LocationTypes.
    ///
    /// The maximum number of allowed characters is 500.
    ///
    /// [google.cloud.talent.v4.Job.company]: crate::model::Job::company
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    /// [google.cloud.talent.v4.Location.LocationType]: crate::model::location::LocationType
    /// [google.cloud.talent.v4.Location.LocationType.LOCALITY]: crate::model::location::LocationType::Locality
    /// [google.cloud.talent.v4.Location.LocationType.STREET_ADDRESS]: crate::model::location::LocationType::StreetAddress
    pub addresses: std::vec::Vec<std::string::String>,

    /// Job application information.
    pub application_info: std::option::Option<crate::model::job::ApplicationInfo>,

    /// The benefits included with the job.
    pub job_benefits: std::vec::Vec<crate::model::JobBenefit>,

    /// Job compensation information (a.k.a. "pay rate") i.e., the compensation
    /// that will paid to the employee.
    pub compensation_info: std::option::Option<crate::model::CompensationInfo>,

    /// A map of fields to hold both filterable and non-filterable custom job
    /// attributes that are not covered by the provided structured fields.
    ///
    /// The keys of the map are strings up to 64 bytes and must match the
    /// pattern: `[a-zA-Z][a-zA-Z0-9_]*`. For example, key0LikeThis or
    /// KEY_1_LIKE_THIS.
    ///
    /// At most 100 filterable and at most 100 unfilterable keys are supported.
    /// For filterable `string_values`, across all keys at most 200 values are
    /// allowed, with each string no more than 255 characters. For unfilterable
    /// `string_values`, the maximum total size of `string_values` across all keys
    /// is 50KB.
    pub custom_attributes:
        std::collections::HashMap<std::string::String, crate::model::CustomAttribute>,

    /// The desired education degrees for the job, such as Bachelors, Masters.
    pub degree_types: std::vec::Vec<crate::model::DegreeType>,

    /// The department or functional area within the company with the open
    /// position.
    ///
    /// The maximum number of allowed characters is 255.
    pub department: std::string::String,

    /// The employment type(s) of a job, for example,
    /// [full time][google.cloud.talent.v4.EmploymentType.FULL_TIME] or
    /// [part time][google.cloud.talent.v4.EmploymentType.PART_TIME].
    ///
    /// [google.cloud.talent.v4.EmploymentType.FULL_TIME]: crate::model::EmploymentType::FullTime
    /// [google.cloud.talent.v4.EmploymentType.PART_TIME]: crate::model::EmploymentType::PartTime
    pub employment_types: std::vec::Vec<crate::model::EmploymentType>,

    /// A description of bonus, commission, and other compensation
    /// incentives associated with the job not including salary or pay.
    ///
    /// The maximum number of allowed characters is 10,000.
    pub incentives: std::string::String,

    /// The language of the posting. This field is distinct from
    /// any requirements for fluency that are associated with the job.
    ///
    /// Language codes must be in BCP-47 format, such as "en-US" or "sr-Latn".
    /// For more information, see
    /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47){:
    /// class="external" target="_blank" }.
    ///
    /// If this field is unspecified and
    /// [Job.description][google.cloud.talent.v4.Job.description] is present,
    /// detected language code based on
    /// [Job.description][google.cloud.talent.v4.Job.description] is assigned,
    /// otherwise defaults to 'en_US'.
    ///
    /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
    pub language_code: std::string::String,

    /// The experience level associated with the job, such as "Entry Level".
    pub job_level: crate::model::JobLevel,

    /// A promotion value of the job, as determined by the client.
    /// The value determines the sort order of the jobs returned when searching for
    /// jobs using the featured jobs search call, with higher promotional values
    /// being returned first and ties being resolved by relevance sort. Only the
    /// jobs with a promotionValue >0 are returned in a FEATURED_JOB_SEARCH.
    ///
    /// Default value is 0, and negative values are treated as 0.
    pub promotion_value: i32,

    /// A description of the qualifications required to perform the
    /// job. The use of this field is recommended
    /// as an alternative to using the more general
    /// [description][google.cloud.talent.v4.Job.description] field.
    ///
    /// This field accepts and sanitizes HTML input, and also accepts
    /// bold, italic, ordered list, and unordered list markup tags.
    ///
    /// The maximum number of allowed characters is 10,000.
    ///
    /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
    pub qualifications: std::string::String,

    /// A description of job responsibilities. The use of this field is
    /// recommended as an alternative to using the more general
    /// [description][google.cloud.talent.v4.Job.description] field.
    ///
    /// This field accepts and sanitizes HTML input, and also accepts
    /// bold, italic, ordered list, and unordered list markup tags.
    ///
    /// The maximum number of allowed characters is 10,000.
    ///
    /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
    pub responsibilities: std::string::String,

    /// The job [PostingRegion][google.cloud.talent.v4.PostingRegion] (for example,
    /// state, country) throughout which the job is available. If this field is
    /// set, a [LocationFilter][google.cloud.talent.v4.LocationFilter] in a search
    /// query within the job region finds this job posting if an exact location
    /// match isn't specified. If this field is set to
    /// [PostingRegion.NATION][google.cloud.talent.v4.PostingRegion.NATION] or
    /// [PostingRegion.ADMINISTRATIVE_AREA][google.cloud.talent.v4.PostingRegion.ADMINISTRATIVE_AREA],
    /// setting job [Job.addresses][google.cloud.talent.v4.Job.addresses] to the
    /// same location level as this field is strongly recommended.
    ///
    /// [google.cloud.talent.v4.Job.addresses]: crate::model::Job::addresses
    /// [google.cloud.talent.v4.LocationFilter]: crate::model::LocationFilter
    /// [google.cloud.talent.v4.PostingRegion]: crate::model::PostingRegion
    /// [google.cloud.talent.v4.PostingRegion.ADMINISTRATIVE_AREA]: crate::model::PostingRegion::AdministrativeArea
    /// [google.cloud.talent.v4.PostingRegion.NATION]: crate::model::PostingRegion::Nation
    pub posting_region: crate::model::PostingRegion,

    /// Deprecated. The job is only visible to the owner.
    ///
    /// The visibility of the job.
    ///
    /// Defaults to
    /// [Visibility.ACCOUNT_ONLY][google.cloud.talent.v4.Visibility.ACCOUNT_ONLY]
    /// if not specified.
    ///
    /// [google.cloud.talent.v4.Visibility.ACCOUNT_ONLY]: crate::model::Visibility::AccountOnly
    #[deprecated]
    pub visibility: crate::model::Visibility,

    /// The start timestamp of the job in UTC time zone. Typically this field
    /// is used for contracting engagements. Invalid timestamps are ignored.
    pub job_start_time: std::option::Option<wkt::Timestamp>,

    /// The end timestamp of the job. Typically this field is used for contracting
    /// engagements. Invalid timestamps are ignored.
    pub job_end_time: std::option::Option<wkt::Timestamp>,

    /// The timestamp this job posting was most recently published. The default
    /// value is the time the request arrives at the server. Invalid timestamps are
    /// ignored.
    pub posting_publish_time: std::option::Option<wkt::Timestamp>,

    /// Strongly recommended for the best service experience.
    ///
    /// The expiration timestamp of the job. After this timestamp, the
    /// job is marked as expired, and it no longer appears in search results. The
    /// expired job can't be listed by the
    /// [ListJobs][google.cloud.talent.v4.JobService.ListJobs] API, but it can be
    /// retrieved with the [GetJob][google.cloud.talent.v4.JobService.GetJob] API
    /// or updated with the
    /// [UpdateJob][google.cloud.talent.v4.JobService.UpdateJob] API or deleted
    /// with the [DeleteJob][google.cloud.talent.v4.JobService.DeleteJob] API. An
    /// expired job can be updated and opened again by using a future expiration
    /// timestamp. Updating an expired job fails if there is another existing open
    /// job with same [company][google.cloud.talent.v4.Job.company],
    /// [language_code][google.cloud.talent.v4.Job.language_code] and
    /// [requisition_id][google.cloud.talent.v4.Job.requisition_id].
    ///
    /// The expired jobs are retained in our system for 90 days. However, the
    /// overall expired job count cannot exceed 3 times the maximum number of
    /// open jobs over previous 7 days. If this threshold is exceeded,
    /// expired jobs are cleaned out in order of earliest expire time.
    /// Expired jobs are no longer accessible after they are cleaned
    /// out.
    ///
    /// Invalid timestamps are ignored, and treated as expire time not provided.
    ///
    /// If the timestamp is before the instant request is made, the job
    /// is treated as expired immediately on creation. This kind of job can
    /// not be updated. And when creating a job with past timestamp, the
    /// [posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
    /// must be set before
    /// [posting_expire_time][google.cloud.talent.v4.Job.posting_expire_time]. The
    /// purpose of this feature is to allow other objects, such as
    /// [ApplicationInfo][google.cloud.talent.v4.Job.ApplicationInfo], to refer a
    /// job that didn't exist in the system prior to becoming expired. If you want
    /// to modify a job that was expired on creation, delete it and create a new
    /// one.
    ///
    /// If this value isn't provided at the time of job creation or is invalid,
    /// the job posting expires after 30 days from the job's creation time. For
    /// example, if the job was created on 2017/01/01 13:00AM UTC with an
    /// unspecified expiration date, the job expires after 2017/01/31 13:00AM UTC.
    ///
    /// If this value isn't provided on job update, it depends on the field masks
    /// set by
    /// [UpdateJobRequest.update_mask][google.cloud.talent.v4.UpdateJobRequest.update_mask].
    /// If the field masks include
    /// [job_end_time][google.cloud.talent.v4.Job.job_end_time], or the masks are
    /// empty meaning that every field is updated, the job posting expires after 30
    /// days from the job's last update time. Otherwise the expiration date isn't
    /// updated.
    ///
    /// [google.cloud.talent.v4.Job.ApplicationInfo]: crate::model::job::ApplicationInfo
    /// [google.cloud.talent.v4.Job.company]: crate::model::Job::company
    /// [google.cloud.talent.v4.Job.job_end_time]: crate::model::Job::job_end_time
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.posting_expire_time]: crate::model::Job::posting_expire_time
    /// [google.cloud.talent.v4.Job.posting_publish_time]: crate::model::Job::posting_publish_time
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    /// [google.cloud.talent.v4.JobService.DeleteJob]: crate::client::JobService::delete_job
    /// [google.cloud.talent.v4.JobService.GetJob]: crate::client::JobService::get_job
    /// [google.cloud.talent.v4.JobService.ListJobs]: crate::client::JobService::list_jobs
    /// [google.cloud.talent.v4.JobService.UpdateJob]: crate::client::JobService::update_job
    /// [google.cloud.talent.v4.UpdateJobRequest.update_mask]: crate::model::UpdateJobRequest::update_mask
    pub posting_expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this job posting was created.
    pub posting_create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this job posting was last updated.
    pub posting_update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Display name of the company listing the job.
    pub company_display_name: std::string::String,

    /// Output only. Derived details about the job posting.
    pub derived_info: std::option::Option<crate::model::job::DerivedInfo>,

    /// Options for job processing.
    pub processing_options: std::option::Option<crate::model::job::ProcessingOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Job::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [company][crate::model::Job::company].
    pub fn set_company<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.company = v.into();
        self
    }

    /// Sets the value of [requisition_id][crate::model::Job::requisition_id].
    pub fn set_requisition_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.requisition_id = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Job::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Job::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [addresses][crate::model::Job::addresses].
    pub fn set_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [application_info][crate::model::Job::application_info].
    pub fn set_application_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::job::ApplicationInfo>,
    {
        self.application_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [application_info][crate::model::Job::application_info].
    pub fn set_or_clear_application_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::job::ApplicationInfo>,
    {
        self.application_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job_benefits][crate::model::Job::job_benefits].
    pub fn set_job_benefits<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobBenefit>,
    {
        use std::iter::Iterator;
        self.job_benefits = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [compensation_info][crate::model::Job::compensation_info].
    pub fn set_compensation_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompensationInfo>,
    {
        self.compensation_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compensation_info][crate::model::Job::compensation_info].
    pub fn set_or_clear_compensation_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompensationInfo>,
    {
        self.compensation_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_attributes][crate::model::Job::custom_attributes].
    pub fn set_custom_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CustomAttribute>,
    {
        use std::iter::Iterator;
        self.custom_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [degree_types][crate::model::Job::degree_types].
    pub fn set_degree_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DegreeType>,
    {
        use std::iter::Iterator;
        self.degree_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [department][crate::model::Job::department].
    pub fn set_department<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.department = v.into();
        self
    }

    /// Sets the value of [employment_types][crate::model::Job::employment_types].
    pub fn set_employment_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EmploymentType>,
    {
        use std::iter::Iterator;
        self.employment_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [incentives][crate::model::Job::incentives].
    pub fn set_incentives<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.incentives = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Job::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [job_level][crate::model::Job::job_level].
    pub fn set_job_level<T: std::convert::Into<crate::model::JobLevel>>(mut self, v: T) -> Self {
        self.job_level = v.into();
        self
    }

    /// Sets the value of [promotion_value][crate::model::Job::promotion_value].
    pub fn set_promotion_value<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.promotion_value = v.into();
        self
    }

    /// Sets the value of [qualifications][crate::model::Job::qualifications].
    pub fn set_qualifications<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.qualifications = v.into();
        self
    }

    /// Sets the value of [responsibilities][crate::model::Job::responsibilities].
    pub fn set_responsibilities<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.responsibilities = v.into();
        self
    }

    /// Sets the value of [posting_region][crate::model::Job::posting_region].
    pub fn set_posting_region<T: std::convert::Into<crate::model::PostingRegion>>(
        mut self,
        v: T,
    ) -> Self {
        self.posting_region = v.into();
        self
    }

    /// Sets the value of [visibility][crate::model::Job::visibility].
    #[deprecated]
    pub fn set_visibility<T: std::convert::Into<crate::model::Visibility>>(mut self, v: T) -> Self {
        self.visibility = v.into();
        self
    }

    /// Sets the value of [job_start_time][crate::model::Job::job_start_time].
    pub fn set_job_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.job_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job_start_time][crate::model::Job::job_start_time].
    pub fn set_or_clear_job_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.job_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job_end_time][crate::model::Job::job_end_time].
    pub fn set_job_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.job_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job_end_time][crate::model::Job::job_end_time].
    pub fn set_or_clear_job_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.job_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [posting_publish_time][crate::model::Job::posting_publish_time].
    pub fn set_posting_publish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_publish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [posting_publish_time][crate::model::Job::posting_publish_time].
    pub fn set_or_clear_posting_publish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_publish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [posting_expire_time][crate::model::Job::posting_expire_time].
    pub fn set_posting_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [posting_expire_time][crate::model::Job::posting_expire_time].
    pub fn set_or_clear_posting_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [posting_create_time][crate::model::Job::posting_create_time].
    pub fn set_posting_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [posting_create_time][crate::model::Job::posting_create_time].
    pub fn set_or_clear_posting_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [posting_update_time][crate::model::Job::posting_update_time].
    pub fn set_posting_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [posting_update_time][crate::model::Job::posting_update_time].
    pub fn set_or_clear_posting_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.posting_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [company_display_name][crate::model::Job::company_display_name].
    pub fn set_company_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.company_display_name = v.into();
        self
    }

    /// Sets the value of [derived_info][crate::model::Job::derived_info].
    pub fn set_derived_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::job::DerivedInfo>,
    {
        self.derived_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [derived_info][crate::model::Job::derived_info].
    pub fn set_or_clear_derived_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::job::DerivedInfo>,
    {
        self.derived_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [processing_options][crate::model::Job::processing_options].
    pub fn set_processing_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::job::ProcessingOptions>,
    {
        self.processing_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [processing_options][crate::model::Job::processing_options].
    pub fn set_or_clear_processing_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::job::ProcessingOptions>,
    {
        self.processing_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.Job"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __company,
            __requisition_id,
            __title,
            __description,
            __addresses,
            __application_info,
            __job_benefits,
            __compensation_info,
            __custom_attributes,
            __degree_types,
            __department,
            __employment_types,
            __incentives,
            __language_code,
            __job_level,
            __promotion_value,
            __qualifications,
            __responsibilities,
            __posting_region,
            __visibility,
            __job_start_time,
            __job_end_time,
            __posting_publish_time,
            __posting_expire_time,
            __posting_create_time,
            __posting_update_time,
            __company_display_name,
            __derived_info,
            __processing_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "company" => Ok(__FieldTag::__company),
                            "requisitionId" => Ok(__FieldTag::__requisition_id),
                            "requisition_id" => Ok(__FieldTag::__requisition_id),
                            "title" => Ok(__FieldTag::__title),
                            "description" => Ok(__FieldTag::__description),
                            "addresses" => Ok(__FieldTag::__addresses),
                            "applicationInfo" => Ok(__FieldTag::__application_info),
                            "application_info" => Ok(__FieldTag::__application_info),
                            "jobBenefits" => Ok(__FieldTag::__job_benefits),
                            "job_benefits" => Ok(__FieldTag::__job_benefits),
                            "compensationInfo" => Ok(__FieldTag::__compensation_info),
                            "compensation_info" => Ok(__FieldTag::__compensation_info),
                            "customAttributes" => Ok(__FieldTag::__custom_attributes),
                            "custom_attributes" => Ok(__FieldTag::__custom_attributes),
                            "degreeTypes" => Ok(__FieldTag::__degree_types),
                            "degree_types" => Ok(__FieldTag::__degree_types),
                            "department" => Ok(__FieldTag::__department),
                            "employmentTypes" => Ok(__FieldTag::__employment_types),
                            "employment_types" => Ok(__FieldTag::__employment_types),
                            "incentives" => Ok(__FieldTag::__incentives),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "jobLevel" => Ok(__FieldTag::__job_level),
                            "job_level" => Ok(__FieldTag::__job_level),
                            "promotionValue" => Ok(__FieldTag::__promotion_value),
                            "promotion_value" => Ok(__FieldTag::__promotion_value),
                            "qualifications" => Ok(__FieldTag::__qualifications),
                            "responsibilities" => Ok(__FieldTag::__responsibilities),
                            "postingRegion" => Ok(__FieldTag::__posting_region),
                            "posting_region" => Ok(__FieldTag::__posting_region),
                            "visibility" => Ok(__FieldTag::__visibility),
                            "jobStartTime" => Ok(__FieldTag::__job_start_time),
                            "job_start_time" => Ok(__FieldTag::__job_start_time),
                            "jobEndTime" => Ok(__FieldTag::__job_end_time),
                            "job_end_time" => Ok(__FieldTag::__job_end_time),
                            "postingPublishTime" => Ok(__FieldTag::__posting_publish_time),
                            "posting_publish_time" => Ok(__FieldTag::__posting_publish_time),
                            "postingExpireTime" => Ok(__FieldTag::__posting_expire_time),
                            "posting_expire_time" => Ok(__FieldTag::__posting_expire_time),
                            "postingCreateTime" => Ok(__FieldTag::__posting_create_time),
                            "posting_create_time" => Ok(__FieldTag::__posting_create_time),
                            "postingUpdateTime" => Ok(__FieldTag::__posting_update_time),
                            "posting_update_time" => Ok(__FieldTag::__posting_update_time),
                            "companyDisplayName" => Ok(__FieldTag::__company_display_name),
                            "company_display_name" => Ok(__FieldTag::__company_display_name),
                            "derivedInfo" => Ok(__FieldTag::__derived_info),
                            "derived_info" => Ok(__FieldTag::__derived_info),
                            "processingOptions" => Ok(__FieldTag::__processing_options),
                            "processing_options" => Ok(__FieldTag::__processing_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__company => {
                            if !fields.insert(__FieldTag::__company) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for company",
                                ));
                            }
                            result.company = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requisition_id => {
                            if !fields.insert(__FieldTag::__requisition_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requisition_id",
                                ));
                            }
                            result.requisition_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__addresses => {
                            if !fields.insert(__FieldTag::__addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for addresses",
                                ));
                            }
                            result.addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__application_info => {
                            if !fields.insert(__FieldTag::__application_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for application_info",
                                ));
                            }
                            result.application_info = map.next_value::<std::option::Option<crate::model::job::ApplicationInfo>>()?
                                ;
                        }
                        __FieldTag::__job_benefits => {
                            if !fields.insert(__FieldTag::__job_benefits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_benefits",
                                ));
                            }
                            result.job_benefits = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobBenefit>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__compensation_info => {
                            if !fields.insert(__FieldTag::__compensation_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compensation_info",
                                ));
                            }
                            result.compensation_info = map
                                .next_value::<std::option::Option<crate::model::CompensationInfo>>(
                                )?;
                        }
                        __FieldTag::__custom_attributes => {
                            if !fields.insert(__FieldTag::__custom_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_attributes",
                                ));
                            }
                            result.custom_attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::CustomAttribute,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__degree_types => {
                            if !fields.insert(__FieldTag::__degree_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for degree_types",
                                ));
                            }
                            result.degree_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DegreeType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__department => {
                            if !fields.insert(__FieldTag::__department) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for department",
                                ));
                            }
                            result.department = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__employment_types => {
                            if !fields.insert(__FieldTag::__employment_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for employment_types",
                                ));
                            }
                            result.employment_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EmploymentType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__incentives => {
                            if !fields.insert(__FieldTag::__incentives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incentives",
                                ));
                            }
                            result.incentives = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_level => {
                            if !fields.insert(__FieldTag::__job_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_level",
                                ));
                            }
                            result.job_level = map
                                .next_value::<std::option::Option<crate::model::JobLevel>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__promotion_value => {
                            if !fields.insert(__FieldTag::__promotion_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for promotion_value",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.promotion_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__qualifications => {
                            if !fields.insert(__FieldTag::__qualifications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for qualifications",
                                ));
                            }
                            result.qualifications = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__responsibilities => {
                            if !fields.insert(__FieldTag::__responsibilities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responsibilities",
                                ));
                            }
                            result.responsibilities = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__posting_region => {
                            if !fields.insert(__FieldTag::__posting_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posting_region",
                                ));
                            }
                            result.posting_region = map
                                .next_value::<std::option::Option<crate::model::PostingRegion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visibility => {
                            if !fields.insert(__FieldTag::__visibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visibility",
                                ));
                            }
                            result.visibility = map
                                .next_value::<std::option::Option<crate::model::Visibility>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_start_time => {
                            if !fields.insert(__FieldTag::__job_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_start_time",
                                ));
                            }
                            result.job_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__job_end_time => {
                            if !fields.insert(__FieldTag::__job_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_end_time",
                                ));
                            }
                            result.job_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__posting_publish_time => {
                            if !fields.insert(__FieldTag::__posting_publish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posting_publish_time",
                                ));
                            }
                            result.posting_publish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__posting_expire_time => {
                            if !fields.insert(__FieldTag::__posting_expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posting_expire_time",
                                ));
                            }
                            result.posting_expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__posting_create_time => {
                            if !fields.insert(__FieldTag::__posting_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posting_create_time",
                                ));
                            }
                            result.posting_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__posting_update_time => {
                            if !fields.insert(__FieldTag::__posting_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for posting_update_time",
                                ));
                            }
                            result.posting_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__company_display_name => {
                            if !fields.insert(__FieldTag::__company_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for company_display_name",
                                ));
                            }
                            result.company_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__derived_info => {
                            if !fields.insert(__FieldTag::__derived_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for derived_info",
                                ));
                            }
                            result.derived_info = map
                                .next_value::<std::option::Option<crate::model::job::DerivedInfo>>(
                                )?;
                        }
                        __FieldTag::__processing_options => {
                            if !fields.insert(__FieldTag::__processing_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_options",
                                ));
                            }
                            result.processing_options = map.next_value::<std::option::Option<crate::model::job::ProcessingOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Job {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.company.is_empty() {
            state.serialize_entry("company", &self.company)?;
        }
        if !self.requisition_id.is_empty() {
            state.serialize_entry("requisitionId", &self.requisition_id)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.addresses.is_empty() {
            state.serialize_entry("addresses", &self.addresses)?;
        }
        if self.application_info.is_some() {
            state.serialize_entry("applicationInfo", &self.application_info)?;
        }
        if !self.job_benefits.is_empty() {
            state.serialize_entry("jobBenefits", &self.job_benefits)?;
        }
        if self.compensation_info.is_some() {
            state.serialize_entry("compensationInfo", &self.compensation_info)?;
        }
        if !self.custom_attributes.is_empty() {
            state.serialize_entry("customAttributes", &self.custom_attributes)?;
        }
        if !self.degree_types.is_empty() {
            state.serialize_entry("degreeTypes", &self.degree_types)?;
        }
        if !self.department.is_empty() {
            state.serialize_entry("department", &self.department)?;
        }
        if !self.employment_types.is_empty() {
            state.serialize_entry("employmentTypes", &self.employment_types)?;
        }
        if !self.incentives.is_empty() {
            state.serialize_entry("incentives", &self.incentives)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.job_level) {
            state.serialize_entry("jobLevel", &self.job_level)?;
        }
        if !wkt::internal::is_default(&self.promotion_value) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("promotionValue", &__With(&self.promotion_value))?;
        }
        if !self.qualifications.is_empty() {
            state.serialize_entry("qualifications", &self.qualifications)?;
        }
        if !self.responsibilities.is_empty() {
            state.serialize_entry("responsibilities", &self.responsibilities)?;
        }
        if !wkt::internal::is_default(&self.posting_region) {
            state.serialize_entry("postingRegion", &self.posting_region)?;
        }
        if !wkt::internal::is_default(&self.visibility) {
            state.serialize_entry("visibility", &self.visibility)?;
        }
        if self.job_start_time.is_some() {
            state.serialize_entry("jobStartTime", &self.job_start_time)?;
        }
        if self.job_end_time.is_some() {
            state.serialize_entry("jobEndTime", &self.job_end_time)?;
        }
        if self.posting_publish_time.is_some() {
            state.serialize_entry("postingPublishTime", &self.posting_publish_time)?;
        }
        if self.posting_expire_time.is_some() {
            state.serialize_entry("postingExpireTime", &self.posting_expire_time)?;
        }
        if self.posting_create_time.is_some() {
            state.serialize_entry("postingCreateTime", &self.posting_create_time)?;
        }
        if self.posting_update_time.is_some() {
            state.serialize_entry("postingUpdateTime", &self.posting_update_time)?;
        }
        if !self.company_display_name.is_empty() {
            state.serialize_entry("companyDisplayName", &self.company_display_name)?;
        }
        if self.derived_info.is_some() {
            state.serialize_entry("derivedInfo", &self.derived_info)?;
        }
        if self.processing_options.is_some() {
            state.serialize_entry("processingOptions", &self.processing_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Job");
        debug_struct.field("name", &self.name);
        debug_struct.field("company", &self.company);
        debug_struct.field("requisition_id", &self.requisition_id);
        debug_struct.field("title", &self.title);
        debug_struct.field("description", &self.description);
        debug_struct.field("addresses", &self.addresses);
        debug_struct.field("application_info", &self.application_info);
        debug_struct.field("job_benefits", &self.job_benefits);
        debug_struct.field("compensation_info", &self.compensation_info);
        debug_struct.field("custom_attributes", &self.custom_attributes);
        debug_struct.field("degree_types", &self.degree_types);
        debug_struct.field("department", &self.department);
        debug_struct.field("employment_types", &self.employment_types);
        debug_struct.field("incentives", &self.incentives);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("job_level", &self.job_level);
        debug_struct.field("promotion_value", &self.promotion_value);
        debug_struct.field("qualifications", &self.qualifications);
        debug_struct.field("responsibilities", &self.responsibilities);
        debug_struct.field("posting_region", &self.posting_region);
        debug_struct.field("visibility", &self.visibility);
        debug_struct.field("job_start_time", &self.job_start_time);
        debug_struct.field("job_end_time", &self.job_end_time);
        debug_struct.field("posting_publish_time", &self.posting_publish_time);
        debug_struct.field("posting_expire_time", &self.posting_expire_time);
        debug_struct.field("posting_create_time", &self.posting_create_time);
        debug_struct.field("posting_update_time", &self.posting_update_time);
        debug_struct.field("company_display_name", &self.company_display_name);
        debug_struct.field("derived_info", &self.derived_info);
        debug_struct.field("processing_options", &self.processing_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    /// Application related details of a job posting.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ApplicationInfo {
        /// Use this field to specify email address(es) to which resumes or
        /// applications can be sent.
        ///
        /// The maximum number of allowed characters for each entry is 255.
        pub emails: std::vec::Vec<std::string::String>,

        /// Use this field to provide instructions, such as "Mail your application
        /// to ...", that a candidate can follow to apply for the job.
        ///
        /// This field accepts and sanitizes HTML input, and also accepts
        /// bold, italic, ordered list, and unordered list markup tags.
        ///
        /// The maximum number of allowed characters is 3,000.
        pub instruction: std::string::String,

        /// Use this URI field to direct an applicant to a website, for example to
        /// link to an online application form.
        ///
        /// The maximum number of allowed characters for each entry is 2,000.
        pub uris: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ApplicationInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [emails][crate::model::job::ApplicationInfo::emails].
        pub fn set_emails<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.emails = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [instruction][crate::model::job::ApplicationInfo::instruction].
        pub fn set_instruction<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instruction = v.into();
            self
        }

        /// Sets the value of [uris][crate::model::job::ApplicationInfo::uris].
        pub fn set_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ApplicationInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.Job.ApplicationInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ApplicationInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __emails,
                __instruction,
                __uris,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ApplicationInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "emails" => Ok(__FieldTag::__emails),
                                "instruction" => Ok(__FieldTag::__instruction),
                                "uris" => Ok(__FieldTag::__uris),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ApplicationInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ApplicationInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__emails => {
                                if !fields.insert(__FieldTag::__emails) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for emails",
                                    ));
                                }
                                result.emails = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__instruction => {
                                if !fields.insert(__FieldTag::__instruction) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for instruction",
                                    ));
                                }
                                result.instruction = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__uris => {
                                if !fields.insert(__FieldTag::__uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uris",
                                    ));
                                }
                                result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ApplicationInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.emails.is_empty() {
                state.serialize_entry("emails", &self.emails)?;
            }
            if !self.instruction.is_empty() {
                state.serialize_entry("instruction", &self.instruction)?;
            }
            if !self.uris.is_empty() {
                state.serialize_entry("uris", &self.uris)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ApplicationInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ApplicationInfo");
            debug_struct.field("emails", &self.emails);
            debug_struct.field("instruction", &self.instruction);
            debug_struct.field("uris", &self.uris);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Derived details about the job posting.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DerivedInfo {
        /// Structured locations of the job, resolved from
        /// [Job.addresses][google.cloud.talent.v4.Job.addresses].
        ///
        /// [locations][google.cloud.talent.v4.Job.DerivedInfo.locations] are exactly
        /// matched to [Job.addresses][google.cloud.talent.v4.Job.addresses] in the
        /// same order.
        ///
        /// [google.cloud.talent.v4.Job.DerivedInfo.locations]: crate::model::job::DerivedInfo::locations
        /// [google.cloud.talent.v4.Job.addresses]: crate::model::Job::addresses
        pub locations: std::vec::Vec<crate::model::Location>,

        /// Job categories derived from [Job.title][google.cloud.talent.v4.Job.title]
        /// and [Job.description][google.cloud.talent.v4.Job.description].
        ///
        /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
        /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
        pub job_categories: std::vec::Vec<crate::model::JobCategory>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DerivedInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [locations][crate::model::job::DerivedInfo::locations].
        pub fn set_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Location>,
        {
            use std::iter::Iterator;
            self.locations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [job_categories][crate::model::job::DerivedInfo::job_categories].
        pub fn set_job_categories<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::JobCategory>,
        {
            use std::iter::Iterator;
            self.job_categories = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DerivedInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.Job.DerivedInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DerivedInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __locations,
                __job_categories,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DerivedInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "locations" => Ok(__FieldTag::__locations),
                                "jobCategories" => Ok(__FieldTag::__job_categories),
                                "job_categories" => Ok(__FieldTag::__job_categories),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DerivedInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DerivedInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__locations => {
                                if !fields.insert(__FieldTag::__locations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for locations",
                                    ));
                                }
                                result.locations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Location>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__job_categories => {
                                if !fields.insert(__FieldTag::__job_categories) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_categories",
                                    ));
                                }
                                result.job_categories =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::JobCategory>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DerivedInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.locations.is_empty() {
                state.serialize_entry("locations", &self.locations)?;
            }
            if !self.job_categories.is_empty() {
                state.serialize_entry("jobCategories", &self.job_categories)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DerivedInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DerivedInfo");
            debug_struct.field("locations", &self.locations);
            debug_struct.field("job_categories", &self.job_categories);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Options for job processing.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProcessingOptions {
        /// If set to `true`, the service does not attempt to resolve a
        /// more precise address for the job.
        pub disable_street_address_resolution: bool,

        /// Option for job HTML content sanitization. Applied fields are:
        ///
        /// * description
        /// * applicationInfo.instruction
        /// * incentives
        /// * qualifications
        /// * responsibilities
        ///
        /// HTML tags in these fields may be stripped if sanitiazation isn't
        /// disabled.
        ///
        /// Defaults to
        /// [HtmlSanitization.SIMPLE_FORMATTING_ONLY][google.cloud.talent.v4.HtmlSanitization.SIMPLE_FORMATTING_ONLY].
        ///
        /// [google.cloud.talent.v4.HtmlSanitization.SIMPLE_FORMATTING_ONLY]: crate::model::HtmlSanitization::SimpleFormattingOnly
        pub html_sanitization: crate::model::HtmlSanitization,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProcessingOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disable_street_address_resolution][crate::model::job::ProcessingOptions::disable_street_address_resolution].
        pub fn set_disable_street_address_resolution<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.disable_street_address_resolution = v.into();
            self
        }

        /// Sets the value of [html_sanitization][crate::model::job::ProcessingOptions::html_sanitization].
        pub fn set_html_sanitization<T: std::convert::Into<crate::model::HtmlSanitization>>(
            mut self,
            v: T,
        ) -> Self {
            self.html_sanitization = v.into();
            self
        }
    }

    impl wkt::message::Message for ProcessingOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.Job.ProcessingOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ProcessingOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __disable_street_address_resolution,
                __html_sanitization,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ProcessingOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "disableStreetAddressResolution" => {
                                    Ok(__FieldTag::__disable_street_address_resolution)
                                }
                                "disable_street_address_resolution" => {
                                    Ok(__FieldTag::__disable_street_address_resolution)
                                }
                                "htmlSanitization" => Ok(__FieldTag::__html_sanitization),
                                "html_sanitization" => Ok(__FieldTag::__html_sanitization),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ProcessingOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ProcessingOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__disable_street_address_resolution => {
                                if !fields.insert(__FieldTag::__disable_street_address_resolution) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disable_street_address_resolution",
                                    ));
                                }
                                result.disable_street_address_resolution = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__html_sanitization => {
                                if !fields.insert(__FieldTag::__html_sanitization) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for html_sanitization",
                                    ));
                                }
                                result.html_sanitization = map.next_value::<std::option::Option<crate::model::HtmlSanitization>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ProcessingOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.disable_street_address_resolution) {
                state.serialize_entry(
                    "disableStreetAddressResolution",
                    &self.disable_street_address_resolution,
                )?;
            }
            if !wkt::internal::is_default(&self.html_sanitization) {
                state.serialize_entry("htmlSanitization", &self.html_sanitization)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ProcessingOptions {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ProcessingOptions");
            debug_struct.field(
                "disable_street_address_resolution",
                &self.disable_street_address_resolution,
            );
            debug_struct.field("html_sanitization", &self.html_sanitization);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Create job request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateJobRequest {
    /// Required. The resource name of the tenant under which the job is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}". For example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// Required. The Job to be created.
    pub job: std::option::Option<crate::model::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [job][crate::model::CreateJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::CreateJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CreateJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "job" => Ok(__FieldTag::__job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("job", &self.job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Get job request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The resource name of the job to retrieve.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}". For
    /// example, "projects/foo/tenants/bar/jobs/baz".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.GetJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update job request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateJobRequest {
    /// Required. The Job to be updated.
    pub job: std::option::Option<crate::model::Job>,

    /// Strongly recommended for the best service experience.
    ///
    /// If [update_mask][google.cloud.talent.v4.UpdateJobRequest.update_mask] is
    /// provided, only the specified fields in
    /// [job][google.cloud.talent.v4.UpdateJobRequest.job] are updated. Otherwise
    /// all the fields are updated.
    ///
    /// A field mask to restrict the fields that are updated. Only
    /// top level fields of [Job][google.cloud.talent.v4.Job] are supported.
    ///
    /// [google.cloud.talent.v4.Job]: crate::model::Job
    /// [google.cloud.talent.v4.UpdateJobRequest.job]: crate::model::UpdateJobRequest::job
    /// [google.cloud.talent.v4.UpdateJobRequest.update_mask]: crate::model::UpdateJobRequest::update_mask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateJobRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateJobRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.UpdateJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "job" => Ok(__FieldTag::__job),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateJobRequest");
        debug_struct.field("job", &self.job);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Delete job request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteJobRequest {
    /// Required. The resource name of the job to be deleted.
    ///
    /// The format is
    /// "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}". For
    /// example, "projects/foo/tenants/bar/jobs/baz".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.DeleteJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List jobs request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The resource name of the tenant under which the job is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}". For example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// Required. The filter string specifies the jobs to be enumerated.
    ///
    /// Supported operator: =, AND
    ///
    /// The fields eligible for filtering are:
    ///
    /// * `companyName`
    /// * `requisitionId`
    /// * `status` Available values: OPEN, EXPIRED, ALL. Defaults to
    ///   OPEN if no value is specified.
    ///
    /// At least one of `companyName` and `requisitionId` must present or an
    /// INVALID_ARGUMENT error is thrown.
    ///
    /// Sample Query:
    ///
    /// * companyName = "projects/foo/tenants/bar/companies/baz"
    /// * companyName = "projects/foo/tenants/bar/companies/baz" AND
    ///   requisitionId = "req-1"
    /// * companyName = "projects/foo/tenants/bar/companies/baz" AND
    ///   status = "EXPIRED"
    /// * requisitionId = "req-1"
    /// * requisitionId = "req-1" AND status = "EXPIRED"
    pub filter: std::string::String,

    /// The starting point of a query result.
    pub page_token: std::string::String,

    /// The maximum number of jobs to be returned per page of results.
    ///
    /// If [job_view][google.cloud.talent.v4.ListJobsRequest.job_view] is set to
    /// [JobView.JOB_VIEW_ID_ONLY][google.cloud.talent.v4.JobView.JOB_VIEW_ID_ONLY],
    /// the maximum allowed page size is 1000. Otherwise, the maximum allowed page
    /// size is 100.
    ///
    /// Default is 100 if empty or a number < 1 is specified.
    ///
    /// [google.cloud.talent.v4.JobView.JOB_VIEW_ID_ONLY]: crate::model::JobView::IdOnly
    /// [google.cloud.talent.v4.ListJobsRequest.job_view]: crate::model::ListJobsRequest::job_view
    pub page_size: i32,

    /// The desired job attributes returned for jobs in the
    /// search response. Defaults to
    /// [JobView.JOB_VIEW_FULL][google.cloud.talent.v4.JobView.JOB_VIEW_FULL] if no
    /// value is specified.
    ///
    /// [google.cloud.talent.v4.JobView.JOB_VIEW_FULL]: crate::model::JobView::Full
    pub job_view: crate::model::JobView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [job_view][crate::model::ListJobsRequest::job_view].
    pub fn set_job_view<T: std::convert::Into<crate::model::JobView>>(mut self, v: T) -> Self {
        self.job_view = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ListJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_token,
            __page_size,
            __job_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "jobView" => Ok(__FieldTag::__job_view),
                            "job_view" => Ok(__FieldTag::__job_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__job_view => {
                            if !fields.insert(__FieldTag::__job_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_view",
                                ));
                            }
                            result.job_view = map
                                .next_value::<std::option::Option<crate::model::JobView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !wkt::internal::is_default(&self.job_view) {
            state.serialize_entry("jobView", &self.job_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("job_view", &self.job_view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List jobs response.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// The Jobs for a given company.
    ///
    /// The maximum number of items returned is based on the limit field
    /// provided in the request.
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// A token to retrieve the next page of results.
    pub next_page_token: std::string::String,

    /// Additional information for the API invocation, such as the request
    /// tracking id.
    pub metadata: std::option::Option<crate::model::ResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ListJobsResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::ListJobsResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __jobs,
            __next_page_token,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobs" => Ok(__FieldTag::__jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<crate::model::ResponseMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsResponse");
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The Request body of the `SearchJobs` call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchJobsRequest {
    /// Required. The resource name of the tenant to search within.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}". For example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// Mode of a search.
    ///
    /// Defaults to
    /// [SearchMode.JOB_SEARCH][google.cloud.talent.v4.SearchJobsRequest.SearchMode.JOB_SEARCH].
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest.SearchMode.JOB_SEARCH]: crate::model::search_jobs_request::SearchMode::JobSearch
    pub search_mode: crate::model::search_jobs_request::SearchMode,

    /// Required. The meta information collected about the job searcher, used to
    /// improve the search quality of the service. The identifiers (such as
    /// `user_id`) are provided by users, and must be unique and consistent.
    pub request_metadata: std::option::Option<crate::model::RequestMetadata>,

    /// Query used to search against jobs, such as keyword, location filters, etc.
    pub job_query: std::option::Option<crate::model::JobQuery>,

    /// Controls whether to broaden the search when it produces sparse results.
    /// Broadened queries append results to the end of the matching results
    /// list.
    ///
    /// Defaults to false.
    pub enable_broadening: bool,

    /// An expression specifies a histogram request against matching jobs.
    ///
    /// Expression syntax is an aggregation function call with histogram facets and
    /// other options.
    ///
    /// Available aggregation function calls are:
    ///
    /// * `count(string_histogram_facet)`: Count the number of matching entities,
    ///   for each distinct attribute value.
    /// * `count(numeric_histogram_facet, list of buckets)`: Count the number of
    ///   matching entities within each bucket.
    ///
    /// A maximum of 200 histogram buckets are supported.
    ///
    /// Data types:
    ///
    /// * Histogram facet: facet names with format `[a-zA-Z][a-zA-Z0-9_]+`.
    /// * String: string like "any string with backslash escape for quote(\")."
    /// * Number: whole number and floating point number like 10, -1 and -0.01.
    /// * List: list of elements with comma(,) separator surrounded by square
    ///   brackets, for example, [1, 2, 3] and ["one", "two", "three"].
    ///
    /// Built-in constants:
    ///
    /// * MIN (minimum number similar to java Double.MIN_VALUE)
    /// * MAX (maximum number similar to java Double.MAX_VALUE)
    ///
    /// Built-in functions:
    ///
    /// * bucket(start, end[, label]): bucket built-in function creates a bucket
    ///   with range of [start, end). Note that the end is exclusive, for example,
    ///   bucket(1, MAX, "positive number") or bucket(1, 10).
    ///
    /// Job histogram facets:
    ///
    /// * company_display_name: histogram by
    ///   [Job.company_display_name][google.cloud.talent.v4.Job.company_display_name].
    /// * employment_type: histogram by
    ///   [Job.employment_types][google.cloud.talent.v4.Job.employment_types], for
    ///   example,
    ///   "FULL_TIME", "PART_TIME".
    /// * company_size (DEPRECATED): histogram by
    ///   [CompanySize][google.cloud.talent.v4.CompanySize], for example, "SMALL",
    ///   "MEDIUM", "BIG".
    /// * publish_time_in_day: histogram by the
    ///   [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
    ///   in days.
    ///   Must specify list of numeric buckets in spec.
    /// * publish_time_in_month: histogram by the
    ///   [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
    ///   in months.
    ///   Must specify list of numeric buckets in spec.
    /// * publish_time_in_year: histogram by the
    ///   [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
    ///   in years.
    ///   Must specify list of numeric buckets in spec.
    /// * degree_types: histogram by the
    ///   [Job.degree_types][google.cloud.talent.v4.Job.degree_types], for example,
    ///   "Bachelors", "Masters".
    /// * job_level: histogram by the
    ///   [Job.job_level][google.cloud.talent.v4.Job.job_level], for example, "Entry
    ///   Level".
    /// * country: histogram by the country code of jobs, for example, "US", "FR".
    /// * admin1: histogram by the admin1 code of jobs, which is a global
    ///   placeholder referring to the state, province, or the particular term a
    ///   country uses to define the geographic structure below the country level,
    ///   for example, "CA", "IL".
    /// * city: histogram by a combination of the "city name, admin1 code". For
    ///   example,  "Mountain View, CA", "New York, NY".
    /// * admin1_country: histogram by a combination of the "admin1 code, country",
    ///   for example, "CA, US", "IL, US".
    /// * city_coordinate: histogram by the city center's GPS coordinates (latitude
    ///   and longitude), for example, 37.4038522,-122.0987765. Since the
    ///   coordinates of a city center can change, customers may need to refresh
    ///   them periodically.
    /// * locale: histogram by the
    ///   [Job.language_code][google.cloud.talent.v4.Job.language_code], for example,
    ///   "en-US",
    ///   "fr-FR".
    /// * language: histogram by the language subtag of the
    ///   [Job.language_code][google.cloud.talent.v4.Job.language_code],
    ///   for example, "en", "fr".
    /// * category: histogram by the
    ///   [JobCategory][google.cloud.talent.v4.JobCategory], for example,
    ///   "COMPUTER_AND_IT", "HEALTHCARE".
    /// * base_compensation_unit: histogram by the
    ///   [CompensationInfo.CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit]
    ///   of base salary, for example, "WEEKLY", "MONTHLY".
    /// * base_compensation: histogram by the base salary. Must specify list of
    ///   numeric buckets to group results by.
    /// * annualized_base_compensation: histogram by the base annualized salary.
    ///   Must specify list of numeric buckets to group results by.
    /// * annualized_total_compensation: histogram by the total annualized salary.
    ///   Must specify list of numeric buckets to group results by.
    /// * string_custom_attribute: histogram by string
    ///   [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes].
    ///   Values can be accessed via square bracket notations like
    ///   string_custom_attribute["key1"].
    /// * numeric_custom_attribute: histogram by numeric
    ///   [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes].
    ///   Values can be accessed via square bracket notations like
    ///   numeric_custom_attribute["key1"]. Must specify list of numeric buckets to
    ///   group results by.
    ///
    /// Example expressions:
    ///
    /// * `count(admin1)`
    /// * `count(base_compensation, [bucket(1000, 10000), bucket(10000, 100000),
    ///   bucket(100000, MAX)])`
    /// * `count(string_custom_attribute["some-string-custom-attribute"])`
    /// * `count(numeric_custom_attribute["some-numeric-custom-attribute"],
    ///   [bucket(MIN, 0, "negative"), bucket(0, MAX, "non-negative")])`
    ///
    /// [google.cloud.talent.v4.CompanySize]: crate::model::CompanySize
    /// [google.cloud.talent.v4.CompensationInfo.CompensationUnit]: crate::model::compensation_info::CompensationUnit
    /// [google.cloud.talent.v4.Job.company_display_name]: crate::model::Job::company_display_name
    /// [google.cloud.talent.v4.Job.custom_attributes]: crate::model::Job::custom_attributes
    /// [google.cloud.talent.v4.Job.degree_types]: crate::model::Job::degree_types
    /// [google.cloud.talent.v4.Job.employment_types]: crate::model::Job::employment_types
    /// [google.cloud.talent.v4.Job.job_level]: crate::model::Job::job_level
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.posting_publish_time]: crate::model::Job::posting_publish_time
    /// [google.cloud.talent.v4.JobCategory]: crate::model::JobCategory
    pub histogram_queries: std::vec::Vec<crate::model::HistogramQuery>,

    /// The desired job attributes returned for jobs in the search response.
    /// Defaults to
    /// [JobView.JOB_VIEW_SMALL][google.cloud.talent.v4.JobView.JOB_VIEW_SMALL] if
    /// no value is specified.
    ///
    /// [google.cloud.talent.v4.JobView.JOB_VIEW_SMALL]: crate::model::JobView::Small
    pub job_view: crate::model::JobView,

    /// An integer that specifies the current offset (that is, starting result
    /// location, amongst the jobs deemed by the API as relevant) in search
    /// results. This field is only considered if
    /// [page_token][google.cloud.talent.v4.SearchJobsRequest.page_token] is unset.
    ///
    /// The maximum allowed value is 5000. Otherwise an error is thrown.
    ///
    /// For example, 0 means to  return results starting from the first matching
    /// job, and 10 means to return from the 11th job. This can be used for
    /// pagination, (for example, pageSize = 10 and offset = 10 means to return
    /// from the second page).
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest.page_token]: crate::model::SearchJobsRequest::page_token
    pub offset: i32,

    /// A limit on the number of jobs returned in the search results.
    /// Increasing this value above the default value of 10 can increase search
    /// response time. The value can be between 1 and 100.
    pub max_page_size: i32,

    /// The token specifying the current offset within
    /// search results. See
    /// [SearchJobsResponse.next_page_token][google.cloud.talent.v4.SearchJobsResponse.next_page_token]
    /// for an explanation of how to obtain the next set of query results.
    ///
    /// [google.cloud.talent.v4.SearchJobsResponse.next_page_token]: crate::model::SearchJobsResponse::next_page_token
    pub page_token: std::string::String,

    /// The criteria determining how search results are sorted. Default is
    /// `"relevance desc"`.
    ///
    /// Supported options are:
    ///
    /// * `"relevance desc"`: By relevance descending, as determined by the API
    ///   algorithms. Relevance thresholding of query results is only available
    ///   with this ordering.
    /// * `"posting_publish_time desc"`: By
    ///   [Job.posting_publish_time][google.cloud.talent.v4.Job.posting_publish_time]
    ///   descending.
    /// * `"posting_update_time desc"`: By
    ///   [Job.posting_update_time][google.cloud.talent.v4.Job.posting_update_time]
    ///   descending.
    /// * `"title"`: By [Job.title][google.cloud.talent.v4.Job.title] ascending.
    /// * `"title desc"`: By [Job.title][google.cloud.talent.v4.Job.title]
    ///   descending.
    /// * `"annualized_base_compensation"`: By job's
    ///   [CompensationInfo.annualized_base_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_base_compensation_range]
    ///   ascending. Jobs whose annualized base compensation is unspecified are put
    ///   at the end of search results.
    /// * `"annualized_base_compensation desc"`: By job's
    ///   [CompensationInfo.annualized_base_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_base_compensation_range]
    ///   descending. Jobs whose annualized base compensation is unspecified are
    ///   put at the end of search results.
    /// * `"annualized_total_compensation"`: By job's
    ///   [CompensationInfo.annualized_total_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_total_compensation_range]
    ///   ascending. Jobs whose annualized base compensation is unspecified are put
    ///   at the end of search results.
    /// * `"annualized_total_compensation desc"`: By job's
    ///   [CompensationInfo.annualized_total_compensation_range][google.cloud.talent.v4.CompensationInfo.annualized_total_compensation_range]
    ///   descending. Jobs whose annualized base compensation is unspecified are
    ///   put at the end of search results.
    /// * `"custom_ranking desc"`: By the relevance score adjusted to the
    ///   [SearchJobsRequest.CustomRankingInfo.ranking_expression][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression]
    ///   with weight factor assigned by
    ///   [SearchJobsRequest.CustomRankingInfo.importance_level][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.importance_level]
    ///   in descending order.
    /// * Location sorting: Use the special syntax to order jobs by distance:\<br\>
    ///   `"distance_from('Hawaii')"`: Order by distance from Hawaii.\<br\>
    ///   `"distance_from(19.89, 155.5)"`: Order by distance from a coordinate.\<br\>
    ///   `"distance_from('Hawaii'), distance_from('Puerto Rico')"`: Order by
    ///   multiple locations. See details below.\<br\>
    ///   `"distance_from('Hawaii'), distance_from(19.89, 155.5)"`: Order by
    ///   multiple locations. See details below.\<br\>
    ///   The string can have a maximum of 256 characters. When multiple distance
    ///   centers are provided, a job that is close to any of the distance centers
    ///   would have a high rank. When a job has multiple locations, the job
    ///   location closest to one of the distance centers will be used. Jobs that
    ///   don't have locations will be ranked at the bottom. Distance is calculated
    ///   with a precision of 11.3 meters (37.4 feet). Diversification strategy is
    ///   still applied unless explicitly disabled in
    ///   [diversification_level][google.cloud.talent.v4.SearchJobsRequest.diversification_level].
    ///
    /// [google.cloud.talent.v4.CompensationInfo.annualized_base_compensation_range]: crate::model::CompensationInfo::annualized_base_compensation_range
    /// [google.cloud.talent.v4.CompensationInfo.annualized_total_compensation_range]: crate::model::CompensationInfo::annualized_total_compensation_range
    /// [google.cloud.talent.v4.Job.posting_publish_time]: crate::model::Job::posting_publish_time
    /// [google.cloud.talent.v4.Job.posting_update_time]: crate::model::Job::posting_update_time
    /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
    /// [google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.importance_level]: crate::model::search_jobs_request::CustomRankingInfo::importance_level
    /// [google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression]: crate::model::search_jobs_request::CustomRankingInfo::ranking_expression
    /// [google.cloud.talent.v4.SearchJobsRequest.diversification_level]: crate::model::SearchJobsRequest::diversification_level
    pub order_by: std::string::String,

    /// Controls whether highly similar jobs are returned next to each other in
    /// the search results. Jobs are identified as highly similar based on
    /// their titles, job categories, and locations. Highly similar results are
    /// clustered so that only one representative job of the cluster is
    /// displayed to the job seeker higher up in the results, with the other jobs
    /// being displayed lower down in the results.
    ///
    /// Defaults to
    /// [DiversificationLevel.SIMPLE][google.cloud.talent.v4.SearchJobsRequest.DiversificationLevel.SIMPLE]
    /// if no value is specified.
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest.DiversificationLevel.SIMPLE]: crate::model::search_jobs_request::DiversificationLevel::Simple
    pub diversification_level: crate::model::search_jobs_request::DiversificationLevel,

    /// Controls over how job documents get ranked on top of existing relevance
    /// score (determined by API algorithm).
    pub custom_ranking_info:
        std::option::Option<crate::model::search_jobs_request::CustomRankingInfo>,

    /// This field is deprecated. Please use
    /// [SearchJobsRequest.keyword_match_mode][google.cloud.talent.v4.SearchJobsRequest.keyword_match_mode]
    /// going forward.
    ///
    /// To migrate, disable_keyword_match set to false maps to
    /// [KeywordMatchMode.KEYWORD_MATCH_ALL][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL],
    /// and disable_keyword_match set to true maps to
    /// [KeywordMatchMode.KEYWORD_MATCH_DISABLED][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_DISABLED].
    /// If
    /// [SearchJobsRequest.keyword_match_mode][google.cloud.talent.v4.SearchJobsRequest.keyword_match_mode]
    /// is set, this field is ignored.
    ///
    /// Controls whether to disable exact keyword match on
    /// [Job.title][google.cloud.talent.v4.Job.title],
    /// [Job.description][google.cloud.talent.v4.Job.description],
    /// [Job.company_display_name][google.cloud.talent.v4.Job.company_display_name],
    /// [Job.addresses][google.cloud.talent.v4.Job.addresses],
    /// [Job.qualifications][google.cloud.talent.v4.Job.qualifications]. When
    /// disable keyword match is turned off, a keyword match returns jobs that do
    /// not match given category filters when there are matching keywords. For
    /// example, for the query "program manager," a result is returned even if the
    /// job posting has the title "software developer," which doesn't fall into
    /// "program manager" ontology, but does have "program manager" appearing in
    /// its description.
    ///
    /// For queries like "cloud" that don't contain title or
    /// location specific ontology, jobs with "cloud" keyword matches are returned
    /// regardless of this flag's value.
    ///
    /// Use
    /// [Company.keyword_searchable_job_custom_attributes][google.cloud.talent.v4.Company.keyword_searchable_job_custom_attributes]
    /// if company-specific globally matched custom field/attribute string values
    /// are needed. Enabling keyword match improves recall of subsequent search
    /// requests.
    ///
    /// Defaults to false.
    ///
    /// [google.cloud.talent.v4.Company.keyword_searchable_job_custom_attributes]: crate::model::Company::keyword_searchable_job_custom_attributes
    /// [google.cloud.talent.v4.Job.addresses]: crate::model::Job::addresses
    /// [google.cloud.talent.v4.Job.company_display_name]: crate::model::Job::company_display_name
    /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
    /// [google.cloud.talent.v4.Job.qualifications]: crate::model::Job::qualifications
    /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
    /// [google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL]: crate::model::search_jobs_request::KeywordMatchMode::KeywordMatchAll
    /// [google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_DISABLED]: crate::model::search_jobs_request::KeywordMatchMode::KeywordMatchDisabled
    /// [google.cloud.talent.v4.SearchJobsRequest.keyword_match_mode]: crate::model::SearchJobsRequest::keyword_match_mode
    #[deprecated]
    pub disable_keyword_match: bool,

    /// Controls what keyword match options to use. If both keyword_match_mode and
    /// disable_keyword_match are set, keyword_match_mode will take precedence.
    ///
    /// Defaults to
    /// [KeywordMatchMode.KEYWORD_MATCH_ALL][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL]
    /// if no value is specified.
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL]: crate::model::search_jobs_request::KeywordMatchMode::KeywordMatchAll
    pub keyword_match_mode: crate::model::search_jobs_request::KeywordMatchMode,

    /// Optional. The relevance threshold of the search results.
    ///
    /// Default to Google defined threshold, leveraging a balance of
    /// precision and recall to deliver both highly accurate results and
    /// comprehensive coverage of relevant information.
    pub relevance_threshold: crate::model::search_jobs_request::RelevanceThreshold,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [search_mode][crate::model::SearchJobsRequest::search_mode].
    pub fn set_search_mode<T: std::convert::Into<crate::model::search_jobs_request::SearchMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_mode = v.into();
        self
    }

    /// Sets the value of [request_metadata][crate::model::SearchJobsRequest::request_metadata].
    pub fn set_request_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RequestMetadata>,
    {
        self.request_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_metadata][crate::model::SearchJobsRequest::request_metadata].
    pub fn set_or_clear_request_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RequestMetadata>,
    {
        self.request_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job_query][crate::model::SearchJobsRequest::job_query].
    pub fn set_job_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobQuery>,
    {
        self.job_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job_query][crate::model::SearchJobsRequest::job_query].
    pub fn set_or_clear_job_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobQuery>,
    {
        self.job_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_broadening][crate::model::SearchJobsRequest::enable_broadening].
    pub fn set_enable_broadening<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_broadening = v.into();
        self
    }

    /// Sets the value of [histogram_queries][crate::model::SearchJobsRequest::histogram_queries].
    pub fn set_histogram_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HistogramQuery>,
    {
        use std::iter::Iterator;
        self.histogram_queries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_view][crate::model::SearchJobsRequest::job_view].
    pub fn set_job_view<T: std::convert::Into<crate::model::JobView>>(mut self, v: T) -> Self {
        self.job_view = v.into();
        self
    }

    /// Sets the value of [offset][crate::model::SearchJobsRequest::offset].
    pub fn set_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.offset = v.into();
        self
    }

    /// Sets the value of [max_page_size][crate::model::SearchJobsRequest::max_page_size].
    pub fn set_max_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [diversification_level][crate::model::SearchJobsRequest::diversification_level].
    pub fn set_diversification_level<
        T: std::convert::Into<crate::model::search_jobs_request::DiversificationLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.diversification_level = v.into();
        self
    }

    /// Sets the value of [custom_ranking_info][crate::model::SearchJobsRequest::custom_ranking_info].
    pub fn set_custom_ranking_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_jobs_request::CustomRankingInfo>,
    {
        self.custom_ranking_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_ranking_info][crate::model::SearchJobsRequest::custom_ranking_info].
    pub fn set_or_clear_custom_ranking_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_jobs_request::CustomRankingInfo>,
    {
        self.custom_ranking_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disable_keyword_match][crate::model::SearchJobsRequest::disable_keyword_match].
    #[deprecated]
    pub fn set_disable_keyword_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_keyword_match = v.into();
        self
    }

    /// Sets the value of [keyword_match_mode][crate::model::SearchJobsRequest::keyword_match_mode].
    pub fn set_keyword_match_mode<
        T: std::convert::Into<crate::model::search_jobs_request::KeywordMatchMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.keyword_match_mode = v.into();
        self
    }

    /// Sets the value of [relevance_threshold][crate::model::SearchJobsRequest::relevance_threshold].
    pub fn set_relevance_threshold<
        T: std::convert::Into<crate::model::search_jobs_request::RelevanceThreshold>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.relevance_threshold = v.into();
        self
    }
}

impl wkt::message::Message for SearchJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.SearchJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __search_mode,
            __request_metadata,
            __job_query,
            __enable_broadening,
            __histogram_queries,
            __job_view,
            __offset,
            __max_page_size,
            __page_token,
            __order_by,
            __diversification_level,
            __custom_ranking_info,
            __disable_keyword_match,
            __keyword_match_mode,
            __relevance_threshold,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "searchMode" => Ok(__FieldTag::__search_mode),
                            "search_mode" => Ok(__FieldTag::__search_mode),
                            "requestMetadata" => Ok(__FieldTag::__request_metadata),
                            "request_metadata" => Ok(__FieldTag::__request_metadata),
                            "jobQuery" => Ok(__FieldTag::__job_query),
                            "job_query" => Ok(__FieldTag::__job_query),
                            "enableBroadening" => Ok(__FieldTag::__enable_broadening),
                            "enable_broadening" => Ok(__FieldTag::__enable_broadening),
                            "histogramQueries" => Ok(__FieldTag::__histogram_queries),
                            "histogram_queries" => Ok(__FieldTag::__histogram_queries),
                            "jobView" => Ok(__FieldTag::__job_view),
                            "job_view" => Ok(__FieldTag::__job_view),
                            "offset" => Ok(__FieldTag::__offset),
                            "maxPageSize" => Ok(__FieldTag::__max_page_size),
                            "max_page_size" => Ok(__FieldTag::__max_page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "diversificationLevel" => Ok(__FieldTag::__diversification_level),
                            "diversification_level" => Ok(__FieldTag::__diversification_level),
                            "customRankingInfo" => Ok(__FieldTag::__custom_ranking_info),
                            "custom_ranking_info" => Ok(__FieldTag::__custom_ranking_info),
                            "disableKeywordMatch" => Ok(__FieldTag::__disable_keyword_match),
                            "disable_keyword_match" => Ok(__FieldTag::__disable_keyword_match),
                            "keywordMatchMode" => Ok(__FieldTag::__keyword_match_mode),
                            "keyword_match_mode" => Ok(__FieldTag::__keyword_match_mode),
                            "relevanceThreshold" => Ok(__FieldTag::__relevance_threshold),
                            "relevance_threshold" => Ok(__FieldTag::__relevance_threshold),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__search_mode => {
                            if !fields.insert(__FieldTag::__search_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_mode",
                                ));
                            }
                            result.search_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::search_jobs_request::SearchMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_metadata => {
                            if !fields.insert(__FieldTag::__request_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_metadata",
                                ));
                            }
                            result.request_metadata = map
                                .next_value::<std::option::Option<crate::model::RequestMetadata>>(
                                )?;
                        }
                        __FieldTag::__job_query => {
                            if !fields.insert(__FieldTag::__job_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_query",
                                ));
                            }
                            result.job_query =
                                map.next_value::<std::option::Option<crate::model::JobQuery>>()?;
                        }
                        __FieldTag::__enable_broadening => {
                            if !fields.insert(__FieldTag::__enable_broadening) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_broadening",
                                ));
                            }
                            result.enable_broadening = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__histogram_queries => {
                            if !fields.insert(__FieldTag::__histogram_queries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for histogram_queries",
                                ));
                            }
                            result.histogram_queries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::HistogramQuery>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_view => {
                            if !fields.insert(__FieldTag::__job_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_view",
                                ));
                            }
                            result.job_view = map
                                .next_value::<std::option::Option<crate::model::JobView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__offset => {
                            if !fields.insert(__FieldTag::__offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_page_size => {
                            if !fields.insert(__FieldTag::__max_page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_page_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diversification_level => {
                            if !fields.insert(__FieldTag::__diversification_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diversification_level",
                                ));
                            }
                            result.diversification_level = map
                                .next_value::<std::option::Option<
                                    crate::model::search_jobs_request::DiversificationLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_ranking_info => {
                            if !fields.insert(__FieldTag::__custom_ranking_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_ranking_info",
                                ));
                            }
                            result.custom_ranking_info = map.next_value::<std::option::Option<
                                crate::model::search_jobs_request::CustomRankingInfo,
                            >>()?;
                        }
                        __FieldTag::__disable_keyword_match => {
                            if !fields.insert(__FieldTag::__disable_keyword_match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_keyword_match",
                                ));
                            }
                            result.disable_keyword_match = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__keyword_match_mode => {
                            if !fields.insert(__FieldTag::__keyword_match_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keyword_match_mode",
                                ));
                            }
                            result.keyword_match_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::search_jobs_request::KeywordMatchMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relevance_threshold => {
                            if !fields.insert(__FieldTag::__relevance_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relevance_threshold",
                                ));
                            }
                            result.relevance_threshold = map
                                .next_value::<std::option::Option<
                                    crate::model::search_jobs_request::RelevanceThreshold,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.search_mode) {
            state.serialize_entry("searchMode", &self.search_mode)?;
        }
        if self.request_metadata.is_some() {
            state.serialize_entry("requestMetadata", &self.request_metadata)?;
        }
        if self.job_query.is_some() {
            state.serialize_entry("jobQuery", &self.job_query)?;
        }
        if !wkt::internal::is_default(&self.enable_broadening) {
            state.serialize_entry("enableBroadening", &self.enable_broadening)?;
        }
        if !self.histogram_queries.is_empty() {
            state.serialize_entry("histogramQueries", &self.histogram_queries)?;
        }
        if !wkt::internal::is_default(&self.job_view) {
            state.serialize_entry("jobView", &self.job_view)?;
        }
        if !wkt::internal::is_default(&self.offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("offset", &__With(&self.offset))?;
        }
        if !wkt::internal::is_default(&self.max_page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxPageSize", &__With(&self.max_page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.diversification_level) {
            state.serialize_entry("diversificationLevel", &self.diversification_level)?;
        }
        if self.custom_ranking_info.is_some() {
            state.serialize_entry("customRankingInfo", &self.custom_ranking_info)?;
        }
        if !wkt::internal::is_default(&self.disable_keyword_match) {
            state.serialize_entry("disableKeywordMatch", &self.disable_keyword_match)?;
        }
        if !wkt::internal::is_default(&self.keyword_match_mode) {
            state.serialize_entry("keywordMatchMode", &self.keyword_match_mode)?;
        }
        if !wkt::internal::is_default(&self.relevance_threshold) {
            state.serialize_entry("relevanceThreshold", &self.relevance_threshold)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("search_mode", &self.search_mode);
        debug_struct.field("request_metadata", &self.request_metadata);
        debug_struct.field("job_query", &self.job_query);
        debug_struct.field("enable_broadening", &self.enable_broadening);
        debug_struct.field("histogram_queries", &self.histogram_queries);
        debug_struct.field("job_view", &self.job_view);
        debug_struct.field("offset", &self.offset);
        debug_struct.field("max_page_size", &self.max_page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("diversification_level", &self.diversification_level);
        debug_struct.field("custom_ranking_info", &self.custom_ranking_info);
        debug_struct.field("disable_keyword_match", &self.disable_keyword_match);
        debug_struct.field("keyword_match_mode", &self.keyword_match_mode);
        debug_struct.field("relevance_threshold", &self.relevance_threshold);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SearchJobsRequest].
pub mod search_jobs_request {
    #[allow(unused_imports)]
    use super::*;

    /// Custom ranking information for
    /// [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest]: crate::model::SearchJobsRequest
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CustomRankingInfo {
        /// Required. Controls over how important the score of
        /// [CustomRankingInfo.ranking_expression][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression]
        /// gets applied to job's final ranking position.
        ///
        /// An error is thrown if not specified.
        ///
        /// [google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression]: crate::model::search_jobs_request::CustomRankingInfo::ranking_expression
        pub importance_level:
            crate::model::search_jobs_request::custom_ranking_info::ImportanceLevel,

        /// Required. Controls over how job documents get ranked on top of existing
        /// relevance score (determined by API algorithm). A combination of the
        /// ranking expression and relevance score is used to determine job's final
        /// ranking position.
        ///
        /// The syntax for this expression is a subset of Google SQL syntax.
        ///
        /// Supported operators are: +, -, *, /, where the left and right side of
        /// the operator is either a numeric
        /// [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes]
        /// key, integer/double value or an expression that can be evaluated to a
        /// number.
        ///
        /// Parenthesis are supported to adjust calculation precedence. The
        /// expression must be < 200 characters in length.
        ///
        /// The expression is considered invalid for a job if the expression
        /// references custom attributes that are not populated on the job or if the
        /// expression results in a divide by zero. If an expression is invalid for a
        /// job, that job is demoted to the end of the results.
        ///
        /// Sample ranking expression
        /// (year + 25) * 0.25 - (freshness / 0.5)
        ///
        /// [google.cloud.talent.v4.Job.custom_attributes]: crate::model::Job::custom_attributes
        pub ranking_expression: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomRankingInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [importance_level][crate::model::search_jobs_request::CustomRankingInfo::importance_level].
        pub fn set_importance_level<
            T: std::convert::Into<
                    crate::model::search_jobs_request::custom_ranking_info::ImportanceLevel,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.importance_level = v.into();
            self
        }

        /// Sets the value of [ranking_expression][crate::model::search_jobs_request::CustomRankingInfo::ranking_expression].
        pub fn set_ranking_expression<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ranking_expression = v.into();
            self
        }
    }

    impl wkt::message::Message for CustomRankingInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CustomRankingInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __importance_level,
                __ranking_expression,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CustomRankingInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "importanceLevel" => Ok(__FieldTag::__importance_level),
                                "importance_level" => Ok(__FieldTag::__importance_level),
                                "rankingExpression" => Ok(__FieldTag::__ranking_expression),
                                "ranking_expression" => Ok(__FieldTag::__ranking_expression),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CustomRankingInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CustomRankingInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__importance_level => {
                                if !fields.insert(__FieldTag::__importance_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for importance_level",
                                    ));
                                }
                                result.importance_level = map.next_value::<std::option::Option<crate::model::search_jobs_request::custom_ranking_info::ImportanceLevel>>()?.unwrap_or_default();
                            }
                            __FieldTag::__ranking_expression => {
                                if !fields.insert(__FieldTag::__ranking_expression) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ranking_expression",
                                    ));
                                }
                                result.ranking_expression = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CustomRankingInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.importance_level) {
                state.serialize_entry("importanceLevel", &self.importance_level)?;
            }
            if !self.ranking_expression.is_empty() {
                state.serialize_entry("rankingExpression", &self.ranking_expression)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CustomRankingInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CustomRankingInfo");
            debug_struct.field("importance_level", &self.importance_level);
            debug_struct.field("ranking_expression", &self.ranking_expression);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [CustomRankingInfo].
    pub mod custom_ranking_info {
        #[allow(unused_imports)]
        use super::*;

        /// The importance level for
        /// [CustomRankingInfo.ranking_expression][google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression].
        ///
        /// [google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ranking_expression]: crate::model::search_jobs_request::CustomRankingInfo::ranking_expression
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ImportanceLevel {
            /// Default value if the importance level isn't specified.
            Unspecified,
            /// The given ranking expression is of None importance, existing relevance
            /// score (determined by API algorithm) dominates job's final ranking
            /// position.
            None,
            /// The given ranking expression is of Low importance in terms of job's
            /// final ranking position compared to existing relevance
            /// score (determined by API algorithm).
            Low,
            /// The given ranking expression is of Mild importance in terms of job's
            /// final ranking position compared to existing relevance
            /// score (determined by API algorithm).
            Mild,
            /// The given ranking expression is of Medium importance in terms of job's
            /// final ranking position compared to existing relevance
            /// score (determined by API algorithm).
            Medium,
            /// The given ranking expression is of High importance in terms of job's
            /// final ranking position compared to existing relevance
            /// score (determined by API algorithm).
            High,
            /// The given ranking expression is of Extreme importance, and dominates
            /// job's final ranking position with existing relevance
            /// score (determined by API algorithm) ignored.
            Extreme,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ImportanceLevel::value] or
            /// [ImportanceLevel::name].
            UnknownValue(importance_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod importance_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ImportanceLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::None => std::option::Option::Some(1),
                    Self::Low => std::option::Option::Some(2),
                    Self::Mild => std::option::Option::Some(3),
                    Self::Medium => std::option::Option::Some(4),
                    Self::High => std::option::Option::Some(5),
                    Self::Extreme => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("IMPORTANCE_LEVEL_UNSPECIFIED"),
                    Self::None => std::option::Option::Some("NONE"),
                    Self::Low => std::option::Option::Some("LOW"),
                    Self::Mild => std::option::Option::Some("MILD"),
                    Self::Medium => std::option::Option::Some("MEDIUM"),
                    Self::High => std::option::Option::Some("HIGH"),
                    Self::Extreme => std::option::Option::Some("EXTREME"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ImportanceLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ImportanceLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ImportanceLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::None,
                    2 => Self::Low,
                    3 => Self::Mild,
                    4 => Self::Medium,
                    5 => Self::High,
                    6 => Self::Extreme,
                    _ => Self::UnknownValue(importance_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ImportanceLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "IMPORTANCE_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "NONE" => Self::None,
                    "LOW" => Self::Low,
                    "MILD" => Self::Mild,
                    "MEDIUM" => Self::Medium,
                    "HIGH" => Self::High,
                    "EXTREME" => Self::Extreme,
                    _ => Self::UnknownValue(importance_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ImportanceLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::None => serializer.serialize_i32(1),
                    Self::Low => serializer.serialize_i32(2),
                    Self::Mild => serializer.serialize_i32(3),
                    Self::Medium => serializer.serialize_i32(4),
                    Self::High => serializer.serialize_i32(5),
                    Self::Extreme => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ImportanceLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportanceLevel>::new(
                    ".google.cloud.talent.v4.SearchJobsRequest.CustomRankingInfo.ImportanceLevel",
                ))
            }
        }
    }

    /// A string-represented enumeration of the job search mode. The service
    /// operate differently for different modes of service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SearchMode {
        /// The mode of the search method isn't specified. The default search
        /// behavior is identical to JOB_SEARCH search behavior.
        Unspecified,
        /// The job search matches against all jobs, and featured jobs
        /// (jobs with promotionValue > 0) are not specially handled.
        JobSearch,
        /// The job search matches only against featured jobs (jobs with a
        /// promotionValue > 0). This method doesn't return any jobs having a
        /// promotionValue <= 0. The search results order is determined by the
        /// promotionValue (jobs with a higher promotionValue are returned higher up
        /// in the search results), with relevance being used as a tiebreaker.
        FeaturedJobSearch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SearchMode::value] or
        /// [SearchMode::name].
        UnknownValue(search_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod search_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SearchMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::JobSearch => std::option::Option::Some(1),
                Self::FeaturedJobSearch => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEARCH_MODE_UNSPECIFIED"),
                Self::JobSearch => std::option::Option::Some("JOB_SEARCH"),
                Self::FeaturedJobSearch => std::option::Option::Some("FEATURED_JOB_SEARCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SearchMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SearchMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SearchMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::JobSearch,
                2 => Self::FeaturedJobSearch,
                _ => Self::UnknownValue(search_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SearchMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEARCH_MODE_UNSPECIFIED" => Self::Unspecified,
                "JOB_SEARCH" => Self::JobSearch,
                "FEATURED_JOB_SEARCH" => Self::FeaturedJobSearch,
                _ => Self::UnknownValue(search_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SearchMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::JobSearch => serializer.serialize_i32(1),
                Self::FeaturedJobSearch => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SearchMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchMode>::new(
                ".google.cloud.talent.v4.SearchJobsRequest.SearchMode",
            ))
        }
    }

    /// Controls whether highly similar jobs are returned next to each other in
    /// the search results. Jobs are identified as highly similar based on
    /// their titles, job categories, and locations. Highly similar results are
    /// clustered so that only one representative job of the cluster is
    /// displayed to the job seeker higher up in the results, with the other jobs
    /// being displayed lower down in the results.
    ///
    /// If you are using pageToken to page through the result set,
    /// latency might be lower but we can't guarantee that all results are
    /// returned. If you are using page offset, latency might be higher but all
    /// results are returned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiversificationLevel {
        /// The diversification level isn't specified.
        Unspecified,
        /// Disables diversification. Jobs that would normally be pushed to the last
        /// page would not have their positions altered. This may result in highly
        /// similar jobs appearing in sequence in the search results.
        Disabled,
        /// Default diversifying behavior. The result list is ordered so that
        /// highly similar results are pushed to the end of the last page of search
        /// results.
        Simple,
        /// Only one job from the same company will be shown at once, other jobs
        /// under same company are pushed to the end of the last page of search
        /// result.
        OnePerCompany,
        /// Similar to ONE_PER_COMPANY, but it allows at most two jobs in the
        /// same company to be shown at once, the other jobs under same company are
        /// pushed to the end of the last page of search result.
        TwoPerCompany,
        /// Similar to ONE_PER_COMPANY, but it allows at most three jobs in the
        /// same company to be shown at once, the other jobs under same company are
        /// dropped.
        MaxThreePerCompany,
        /// The result list is ordered such that somewhat similar results are pushed
        /// to the end of the last page of the search results. This option is
        /// recommended if SIMPLE diversification does not diversify enough.
        DiversifyByLooserSimilarity,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiversificationLevel::value] or
        /// [DiversificationLevel::name].
        UnknownValue(diversification_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod diversification_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiversificationLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Simple => std::option::Option::Some(2),
                Self::OnePerCompany => std::option::Option::Some(3),
                Self::TwoPerCompany => std::option::Option::Some(4),
                Self::MaxThreePerCompany => std::option::Option::Some(6),
                Self::DiversifyByLooserSimilarity => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIVERSIFICATION_LEVEL_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Simple => std::option::Option::Some("SIMPLE"),
                Self::OnePerCompany => std::option::Option::Some("ONE_PER_COMPANY"),
                Self::TwoPerCompany => std::option::Option::Some("TWO_PER_COMPANY"),
                Self::MaxThreePerCompany => std::option::Option::Some("MAX_THREE_PER_COMPANY"),
                Self::DiversifyByLooserSimilarity => {
                    std::option::Option::Some("DIVERSIFY_BY_LOOSER_SIMILARITY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiversificationLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiversificationLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiversificationLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Simple,
                3 => Self::OnePerCompany,
                4 => Self::TwoPerCompany,
                5 => Self::DiversifyByLooserSimilarity,
                6 => Self::MaxThreePerCompany,
                _ => Self::UnknownValue(diversification_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiversificationLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIVERSIFICATION_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "SIMPLE" => Self::Simple,
                "ONE_PER_COMPANY" => Self::OnePerCompany,
                "TWO_PER_COMPANY" => Self::TwoPerCompany,
                "MAX_THREE_PER_COMPANY" => Self::MaxThreePerCompany,
                "DIVERSIFY_BY_LOOSER_SIMILARITY" => Self::DiversifyByLooserSimilarity,
                _ => Self::UnknownValue(diversification_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiversificationLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Simple => serializer.serialize_i32(2),
                Self::OnePerCompany => serializer.serialize_i32(3),
                Self::TwoPerCompany => serializer.serialize_i32(4),
                Self::MaxThreePerCompany => serializer.serialize_i32(6),
                Self::DiversifyByLooserSimilarity => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiversificationLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiversificationLevel>::new(
                ".google.cloud.talent.v4.SearchJobsRequest.DiversificationLevel",
            ))
        }
    }

    /// Controls what keyword matching behavior the search has. When keyword
    /// matching is enabled, a keyword match returns jobs that may not match given
    /// category filters when there are matching keywords. For example, for the
    /// query "program manager" with KeywordMatchMode set to KEYWORD_MATCH_ALL, a
    /// job posting with the title "software developer," which doesn't fall into
    /// "program manager" ontology, and "program manager" appearing in its
    /// description will be surfaced.
    ///
    /// For queries like "cloud" that don't contain title or
    /// location specific ontology, jobs with "cloud" keyword matches are returned
    /// regardless of this enum's value.
    ///
    /// Use
    /// [Company.keyword_searchable_job_custom_attributes][google.cloud.talent.v4.Company.keyword_searchable_job_custom_attributes]
    /// if company-specific globally matched custom field/attribute string values
    /// are needed. Enabling keyword match improves recall of subsequent search
    /// requests.
    ///
    /// [google.cloud.talent.v4.Company.keyword_searchable_job_custom_attributes]: crate::model::Company::keyword_searchable_job_custom_attributes
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeywordMatchMode {
        /// The keyword match option isn't specified. Defaults to
        /// [KeywordMatchMode.KEYWORD_MATCH_ALL][google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL]
        /// behavior.
        ///
        /// [google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode.KEYWORD_MATCH_ALL]: crate::model::search_jobs_request::KeywordMatchMode::KeywordMatchAll
        Unspecified,
        /// Disables keyword matching.
        KeywordMatchDisabled,
        /// Enable keyword matching over
        /// [Job.title][google.cloud.talent.v4.Job.title],
        /// [Job.description][google.cloud.talent.v4.Job.description],
        /// [Job.company_display_name][google.cloud.talent.v4.Job.company_display_name],
        /// [Job.addresses][google.cloud.talent.v4.Job.addresses],
        /// [Job.qualifications][google.cloud.talent.v4.Job.qualifications], and
        /// keyword searchable
        /// [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes]
        /// fields.
        ///
        /// [google.cloud.talent.v4.Job.addresses]: crate::model::Job::addresses
        /// [google.cloud.talent.v4.Job.company_display_name]: crate::model::Job::company_display_name
        /// [google.cloud.talent.v4.Job.custom_attributes]: crate::model::Job::custom_attributes
        /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
        /// [google.cloud.talent.v4.Job.qualifications]: crate::model::Job::qualifications
        /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
        KeywordMatchAll,
        /// Only enable keyword matching over
        /// [Job.title][google.cloud.talent.v4.Job.title].
        ///
        /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
        KeywordMatchTitleOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeywordMatchMode::value] or
        /// [KeywordMatchMode::name].
        UnknownValue(keyword_match_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod keyword_match_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KeywordMatchMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::KeywordMatchDisabled => std::option::Option::Some(1),
                Self::KeywordMatchAll => std::option::Option::Some(2),
                Self::KeywordMatchTitleOnly => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KEYWORD_MATCH_MODE_UNSPECIFIED"),
                Self::KeywordMatchDisabled => std::option::Option::Some("KEYWORD_MATCH_DISABLED"),
                Self::KeywordMatchAll => std::option::Option::Some("KEYWORD_MATCH_ALL"),
                Self::KeywordMatchTitleOnly => {
                    std::option::Option::Some("KEYWORD_MATCH_TITLE_ONLY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KeywordMatchMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KeywordMatchMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KeywordMatchMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::KeywordMatchDisabled,
                2 => Self::KeywordMatchAll,
                3 => Self::KeywordMatchTitleOnly,
                _ => Self::UnknownValue(keyword_match_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KeywordMatchMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEYWORD_MATCH_MODE_UNSPECIFIED" => Self::Unspecified,
                "KEYWORD_MATCH_DISABLED" => Self::KeywordMatchDisabled,
                "KEYWORD_MATCH_ALL" => Self::KeywordMatchAll,
                "KEYWORD_MATCH_TITLE_ONLY" => Self::KeywordMatchTitleOnly,
                _ => Self::UnknownValue(keyword_match_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KeywordMatchMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::KeywordMatchDisabled => serializer.serialize_i32(1),
                Self::KeywordMatchAll => serializer.serialize_i32(2),
                Self::KeywordMatchTitleOnly => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KeywordMatchMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KeywordMatchMode>::new(
                ".google.cloud.talent.v4.SearchJobsRequest.KeywordMatchMode",
            ))
        }
    }

    /// The relevance threshold of the search results. The higher relevance
    /// threshold is, the higher relevant results are shown and the less number of
    /// results are returned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RelevanceThreshold {
        /// Default value. In this case, server behavior defaults to Google defined
        /// threshold.
        Unspecified,
        /// Lowest relevance threshold.
        Lowest,
        /// Low relevance threshold.
        Low,
        /// Medium relevance threshold.
        Medium,
        /// High relevance threshold.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RelevanceThreshold::value] or
        /// [RelevanceThreshold::name].
        UnknownValue(relevance_threshold::UnknownValue),
    }

    #[doc(hidden)]
    pub mod relevance_threshold {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RelevanceThreshold {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Lowest => std::option::Option::Some(1),
                Self::Low => std::option::Option::Some(2),
                Self::Medium => std::option::Option::Some(3),
                Self::High => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RELEVANCE_THRESHOLD_UNSPECIFIED"),
                Self::Lowest => std::option::Option::Some("LOWEST"),
                Self::Low => std::option::Option::Some("LOW"),
                Self::Medium => std::option::Option::Some("MEDIUM"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RelevanceThreshold {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RelevanceThreshold {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RelevanceThreshold {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Lowest,
                2 => Self::Low,
                3 => Self::Medium,
                4 => Self::High,
                _ => Self::UnknownValue(relevance_threshold::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RelevanceThreshold {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RELEVANCE_THRESHOLD_UNSPECIFIED" => Self::Unspecified,
                "LOWEST" => Self::Lowest,
                "LOW" => Self::Low,
                "MEDIUM" => Self::Medium,
                "HIGH" => Self::High,
                _ => Self::UnknownValue(relevance_threshold::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RelevanceThreshold {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Lowest => serializer.serialize_i32(1),
                Self::Low => serializer.serialize_i32(2),
                Self::Medium => serializer.serialize_i32(3),
                Self::High => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RelevanceThreshold {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RelevanceThreshold>::new(
                ".google.cloud.talent.v4.SearchJobsRequest.RelevanceThreshold",
            ))
        }
    }
}

/// Response for SearchJob method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchJobsResponse {
    /// The Job entities that match the specified
    /// [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest]: crate::model::SearchJobsRequest
    pub matching_jobs: std::vec::Vec<crate::model::search_jobs_response::MatchingJob>,

    /// The histogram results that match with specified
    /// [SearchJobsRequest.histogram_queries][google.cloud.talent.v4.SearchJobsRequest.histogram_queries].
    ///
    /// [google.cloud.talent.v4.SearchJobsRequest.histogram_queries]: crate::model::SearchJobsRequest::histogram_queries
    pub histogram_query_results: std::vec::Vec<crate::model::HistogramQueryResult>,

    /// The token that specifies the starting position of the next page of results.
    /// This field is empty if there are no more results.
    pub next_page_token: std::string::String,

    /// The location filters that the service applied to the specified query. If
    /// any filters are lat-lng based, the
    /// [Location.location_type][google.cloud.talent.v4.Location.location_type] is
    /// [Location.LocationType.LOCATION_TYPE_UNSPECIFIED][google.cloud.talent.v4.Location.LocationType.LOCATION_TYPE_UNSPECIFIED].
    ///
    /// [google.cloud.talent.v4.Location.LocationType.LOCATION_TYPE_UNSPECIFIED]: crate::model::location::LocationType::Unspecified
    /// [google.cloud.talent.v4.Location.location_type]: crate::model::Location::location_type
    pub location_filters: std::vec::Vec<crate::model::Location>,

    /// Number of jobs that match the specified query.
    ///
    /// Note: This size is precise only if the total is less than 100,000.
    pub total_size: i32,

    /// Additional information for the API invocation, such as the request
    /// tracking id.
    pub metadata: std::option::Option<crate::model::ResponseMetadata>,

    /// If query broadening is enabled, we may append additional results from the
    /// broadened query. This number indicates how many of the jobs returned in the
    /// jobs field are from the broadened query. These results are always at the
    /// end of the jobs list. In particular, a value of 0, or if the field isn't
    /// set, all the jobs in the jobs list are from the original
    /// (without broadening) query. If this field is non-zero, subsequent requests
    /// with offset after this result set should contain all broadened results.
    pub broadened_query_jobs_count: i32,

    /// The spell checking result, and correction.
    pub spell_correction: std::option::Option<crate::model::SpellingCorrection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [matching_jobs][crate::model::SearchJobsResponse::matching_jobs].
    pub fn set_matching_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_jobs_response::MatchingJob>,
    {
        use std::iter::Iterator;
        self.matching_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [histogram_query_results][crate::model::SearchJobsResponse::histogram_query_results].
    pub fn set_histogram_query_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HistogramQueryResult>,
    {
        use std::iter::Iterator;
        self.histogram_query_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [location_filters][crate::model::SearchJobsResponse::location_filters].
    pub fn set_location_filters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Location>,
    {
        use std::iter::Iterator;
        self.location_filters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_size][crate::model::SearchJobsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::SearchJobsResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::SearchJobsResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [broadened_query_jobs_count][crate::model::SearchJobsResponse::broadened_query_jobs_count].
    pub fn set_broadened_query_jobs_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.broadened_query_jobs_count = v.into();
        self
    }

    /// Sets the value of [spell_correction][crate::model::SearchJobsResponse::spell_correction].
    pub fn set_spell_correction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpellingCorrection>,
    {
        self.spell_correction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spell_correction][crate::model::SearchJobsResponse::spell_correction].
    pub fn set_or_clear_spell_correction<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpellingCorrection>,
    {
        self.spell_correction = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.SearchJobsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __matching_jobs,
            __histogram_query_results,
            __next_page_token,
            __location_filters,
            __total_size,
            __metadata,
            __broadened_query_jobs_count,
            __spell_correction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "matchingJobs" => Ok(__FieldTag::__matching_jobs),
                            "matching_jobs" => Ok(__FieldTag::__matching_jobs),
                            "histogramQueryResults" => Ok(__FieldTag::__histogram_query_results),
                            "histogram_query_results" => Ok(__FieldTag::__histogram_query_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "locationFilters" => Ok(__FieldTag::__location_filters),
                            "location_filters" => Ok(__FieldTag::__location_filters),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "broadenedQueryJobsCount" => {
                                Ok(__FieldTag::__broadened_query_jobs_count)
                            }
                            "broadened_query_jobs_count" => {
                                Ok(__FieldTag::__broadened_query_jobs_count)
                            }
                            "spellCorrection" => Ok(__FieldTag::__spell_correction),
                            "spell_correction" => Ok(__FieldTag::__spell_correction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__matching_jobs => {
                            if !fields.insert(__FieldTag::__matching_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matching_jobs",
                                ));
                            }
                            result.matching_jobs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::search_jobs_response::MatchingJob>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__histogram_query_results => {
                            if !fields.insert(__FieldTag::__histogram_query_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for histogram_query_results",
                                ));
                            }
                            result.histogram_query_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::HistogramQueryResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_filters => {
                            if !fields.insert(__FieldTag::__location_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_filters",
                                ));
                            }
                            result.location_filters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Location>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<crate::model::ResponseMetadata>>(
                                )?;
                        }
                        __FieldTag::__broadened_query_jobs_count => {
                            if !fields.insert(__FieldTag::__broadened_query_jobs_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for broadened_query_jobs_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.broadened_query_jobs_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__spell_correction => {
                            if !fields.insert(__FieldTag::__spell_correction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spell_correction",
                                ));
                            }
                            result.spell_correction = map.next_value::<std::option::Option<crate::model::SpellingCorrection>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.matching_jobs.is_empty() {
            state.serialize_entry("matchingJobs", &self.matching_jobs)?;
        }
        if !self.histogram_query_results.is_empty() {
            state.serialize_entry("histogramQueryResults", &self.histogram_query_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.location_filters.is_empty() {
            state.serialize_entry("locationFilters", &self.location_filters)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !wkt::internal::is_default(&self.broadened_query_jobs_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "broadenedQueryJobsCount",
                &__With(&self.broadened_query_jobs_count),
            )?;
        }
        if self.spell_correction.is_some() {
            state.serialize_entry("spellCorrection", &self.spell_correction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchJobsResponse");
        debug_struct.field("matching_jobs", &self.matching_jobs);
        debug_struct.field("histogram_query_results", &self.histogram_query_results);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("location_filters", &self.location_filters);
        debug_struct.field("total_size", &self.total_size);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field(
            "broadened_query_jobs_count",
            &self.broadened_query_jobs_count,
        );
        debug_struct.field("spell_correction", &self.spell_correction);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SearchJobsResponse].
pub mod search_jobs_response {
    #[allow(unused_imports)]
    use super::*;

    /// Job entry with metadata inside
    /// [SearchJobsResponse][google.cloud.talent.v4.SearchJobsResponse].
    ///
    /// [google.cloud.talent.v4.SearchJobsResponse]: crate::model::SearchJobsResponse
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MatchingJob {
        /// Job resource that matches the specified
        /// [SearchJobsRequest][google.cloud.talent.v4.SearchJobsRequest].
        ///
        /// [google.cloud.talent.v4.SearchJobsRequest]: crate::model::SearchJobsRequest
        pub job: std::option::Option<crate::model::Job>,

        /// A summary of the job with core information that's displayed on the search
        /// results listing page.
        pub job_summary: std::string::String,

        /// Contains snippets of text from the
        /// [Job.title][google.cloud.talent.v4.Job.title] field most closely matching
        /// a search query's keywords, if available. The matching query keywords are
        /// enclosed in HTML bold tags.
        ///
        /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
        pub job_title_snippet: std::string::String,

        /// Contains snippets of text from the
        /// [Job.description][google.cloud.talent.v4.Job.description] and similar
        /// fields that most closely match a search query's keywords, if available.
        /// All HTML tags in the original fields are stripped when returned in this
        /// field, and matching query keywords are enclosed in HTML bold tags.
        ///
        /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
        pub search_text_snippet: std::string::String,

        /// Commute information which is generated based on specified
        /// [CommuteFilter][google.cloud.talent.v4.CommuteFilter].
        ///
        /// [google.cloud.talent.v4.CommuteFilter]: crate::model::CommuteFilter
        pub commute_info: std::option::Option<crate::model::search_jobs_response::CommuteInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MatchingJob {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [job][crate::model::search_jobs_response::MatchingJob::job].
        pub fn set_job<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Job>,
        {
            self.job = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [job][crate::model::search_jobs_response::MatchingJob::job].
        pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Job>,
        {
            self.job = v.map(|x| x.into());
            self
        }

        /// Sets the value of [job_summary][crate::model::search_jobs_response::MatchingJob::job_summary].
        pub fn set_job_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.job_summary = v.into();
            self
        }

        /// Sets the value of [job_title_snippet][crate::model::search_jobs_response::MatchingJob::job_title_snippet].
        pub fn set_job_title_snippet<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.job_title_snippet = v.into();
            self
        }

        /// Sets the value of [search_text_snippet][crate::model::search_jobs_response::MatchingJob::search_text_snippet].
        pub fn set_search_text_snippet<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.search_text_snippet = v.into();
            self
        }

        /// Sets the value of [commute_info][crate::model::search_jobs_response::MatchingJob::commute_info].
        pub fn set_commute_info<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_jobs_response::CommuteInfo>,
        {
            self.commute_info = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [commute_info][crate::model::search_jobs_response::MatchingJob::commute_info].
        pub fn set_or_clear_commute_info<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_jobs_response::CommuteInfo>,
        {
            self.commute_info = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MatchingJob {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.SearchJobsResponse.MatchingJob"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MatchingJob {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __job,
                __job_summary,
                __job_title_snippet,
                __search_text_snippet,
                __commute_info,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MatchingJob")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "job" => Ok(__FieldTag::__job),
                                "jobSummary" => Ok(__FieldTag::__job_summary),
                                "job_summary" => Ok(__FieldTag::__job_summary),
                                "jobTitleSnippet" => Ok(__FieldTag::__job_title_snippet),
                                "job_title_snippet" => Ok(__FieldTag::__job_title_snippet),
                                "searchTextSnippet" => Ok(__FieldTag::__search_text_snippet),
                                "search_text_snippet" => Ok(__FieldTag::__search_text_snippet),
                                "commuteInfo" => Ok(__FieldTag::__commute_info),
                                "commute_info" => Ok(__FieldTag::__commute_info),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MatchingJob;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MatchingJob")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__job => {
                                if !fields.insert(__FieldTag::__job) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job",
                                    ));
                                }
                                result.job =
                                    map.next_value::<std::option::Option<crate::model::Job>>()?;
                            }
                            __FieldTag::__job_summary => {
                                if !fields.insert(__FieldTag::__job_summary) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_summary",
                                    ));
                                }
                                result.job_summary = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__job_title_snippet => {
                                if !fields.insert(__FieldTag::__job_title_snippet) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_title_snippet",
                                    ));
                                }
                                result.job_title_snippet = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__search_text_snippet => {
                                if !fields.insert(__FieldTag::__search_text_snippet) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for search_text_snippet",
                                    ));
                                }
                                result.search_text_snippet = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__commute_info => {
                                if !fields.insert(__FieldTag::__commute_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for commute_info",
                                    ));
                                }
                                result.commute_info = map.next_value::<std::option::Option<
                                    crate::model::search_jobs_response::CommuteInfo,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MatchingJob {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.job.is_some() {
                state.serialize_entry("job", &self.job)?;
            }
            if !self.job_summary.is_empty() {
                state.serialize_entry("jobSummary", &self.job_summary)?;
            }
            if !self.job_title_snippet.is_empty() {
                state.serialize_entry("jobTitleSnippet", &self.job_title_snippet)?;
            }
            if !self.search_text_snippet.is_empty() {
                state.serialize_entry("searchTextSnippet", &self.search_text_snippet)?;
            }
            if self.commute_info.is_some() {
                state.serialize_entry("commuteInfo", &self.commute_info)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MatchingJob {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MatchingJob");
            debug_struct.field("job", &self.job);
            debug_struct.field("job_summary", &self.job_summary);
            debug_struct.field("job_title_snippet", &self.job_title_snippet);
            debug_struct.field("search_text_snippet", &self.search_text_snippet);
            debug_struct.field("commute_info", &self.commute_info);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Commute details related to this job.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CommuteInfo {
        /// Location used as the destination in the commute calculation.
        pub job_location: std::option::Option<crate::model::Location>,

        /// The number of seconds required to travel to the job location from the
        /// query location. A duration of 0 seconds indicates that the job isn't
        /// reachable within the requested duration, but was returned as part of an
        /// expanded query.
        pub travel_duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CommuteInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [job_location][crate::model::search_jobs_response::CommuteInfo::job_location].
        pub fn set_job_location<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Location>,
        {
            self.job_location = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [job_location][crate::model::search_jobs_response::CommuteInfo::job_location].
        pub fn set_or_clear_job_location<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Location>,
        {
            self.job_location = v.map(|x| x.into());
            self
        }

        /// Sets the value of [travel_duration][crate::model::search_jobs_response::CommuteInfo::travel_duration].
        pub fn set_travel_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.travel_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [travel_duration][crate::model::search_jobs_response::CommuteInfo::travel_duration].
        pub fn set_or_clear_travel_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.travel_duration = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for CommuteInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.talent.v4.SearchJobsResponse.CommuteInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CommuteInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __job_location,
                __travel_duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CommuteInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "jobLocation" => Ok(__FieldTag::__job_location),
                                "job_location" => Ok(__FieldTag::__job_location),
                                "travelDuration" => Ok(__FieldTag::__travel_duration),
                                "travel_duration" => Ok(__FieldTag::__travel_duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CommuteInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CommuteInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__job_location => {
                                if !fields.insert(__FieldTag::__job_location) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_location",
                                    ));
                                }
                                result.job_location = map
                                    .next_value::<std::option::Option<crate::model::Location>>()?;
                            }
                            __FieldTag::__travel_duration => {
                                if !fields.insert(__FieldTag::__travel_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for travel_duration",
                                    ));
                                }
                                result.travel_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CommuteInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.job_location.is_some() {
                state.serialize_entry("jobLocation", &self.job_location)?;
            }
            if self.travel_duration.is_some() {
                state.serialize_entry("travelDuration", &self.travel_duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CommuteInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CommuteInfo");
            debug_struct.field("job_location", &self.job_location);
            debug_struct.field("travel_duration", &self.travel_duration);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Request to create a batch of jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateJobsRequest {
    /// Required. The resource name of the tenant under which the job is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}". For example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// Required. The jobs to be created.
    /// A maximum of 200 jobs can be created in a batch.
    pub jobs: std::vec::Vec<crate::model::Job>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::BatchCreateJobsRequest::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.BatchCreateJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "jobs" => Ok(__FieldTag::__jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchCreateJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("jobs", &self.jobs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to update a batch of jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateJobsRequest {
    /// Required. The resource name of the tenant under which the job is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}". For example,
    /// "projects/foo/tenants/bar".
    pub parent: std::string::String,

    /// Required. The jobs to be updated.
    /// A maximum of 200 jobs can be updated in a batch.
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// Strongly recommended for the best service experience. Be aware that it will
    /// also increase latency when checking the status of a batch operation.
    ///
    /// If [update_mask][google.cloud.talent.v4.BatchUpdateJobsRequest.update_mask]
    /// is provided, only the specified fields in [Job][google.cloud.talent.v4.Job]
    /// are updated. Otherwise all the fields are updated.
    ///
    /// A field mask to restrict the fields that are updated. Only
    /// top level fields of [Job][google.cloud.talent.v4.Job] are supported.
    ///
    /// If [update_mask][google.cloud.talent.v4.BatchUpdateJobsRequest.update_mask]
    /// is provided, The [Job][google.cloud.talent.v4.Job] inside
    /// [JobResult][google.cloud.talent.v4.JobResult]
    /// will only contains fields that is updated, plus the Id of the Job.
    /// Otherwise,  [Job][google.cloud.talent.v4.Job] will include all fields,
    /// which can yield a very large response.
    ///
    /// [google.cloud.talent.v4.BatchUpdateJobsRequest.update_mask]: crate::model::BatchUpdateJobsRequest::update_mask
    /// [google.cloud.talent.v4.Job]: crate::model::Job
    /// [google.cloud.talent.v4.JobResult]: crate::model::JobResult
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchUpdateJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::BatchUpdateJobsRequest::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_mask][crate::model::BatchUpdateJobsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::BatchUpdateJobsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchUpdateJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.BatchUpdateJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __jobs,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "jobs" => Ok(__FieldTag::__jobs),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to delete a batch of jobs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteJobsRequest {
    /// Required. The resource name of the tenant under which the job is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}". For example,
    /// "projects/foo/tenants/bar".
    ///
    /// The parent of all of the jobs specified in `names` must match this field.
    pub parent: std::string::String,

    /// The names of the jobs to delete.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}/jobs/{job_id}".
    /// For example, "projects/foo/tenants/bar/jobs/baz".
    ///
    /// A maximum of 200 jobs can be deleted in a batch.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDeleteJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeleteJobsRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeleteJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.BatchDeleteJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchDeleteJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchDeleteJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("names", &self.names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Mutation result of a job from a batch operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct JobResult {
    /// Here [Job][google.cloud.talent.v4.Job] only contains basic information
    /// including [name][google.cloud.talent.v4.Job.name],
    /// [company][google.cloud.talent.v4.Job.company],
    /// [language_code][google.cloud.talent.v4.Job.language_code] and
    /// [requisition_id][google.cloud.talent.v4.Job.requisition_id], use getJob
    /// method to retrieve detailed information of the created/updated job.
    ///
    /// [google.cloud.talent.v4.Job]: crate::model::Job
    /// [google.cloud.talent.v4.Job.company]: crate::model::Job::company
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.name]: crate::model::Job::name
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    pub job: std::option::Option<crate::model::Job>,

    /// The status of the job processed. This field is populated if the
    /// processing of the [job][google.cloud.talent.v4.JobResult.job] fails.
    ///
    /// [google.cloud.talent.v4.JobResult.job]: crate::model::JobResult::job
    pub status: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::JobResult::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::JobResult::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::JobResult::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::JobResult::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for JobResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.JobResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "job" => Ok(__FieldTag::__job),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for JobResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobResult");
        debug_struct.field("job", &self.job);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The result of
/// [JobService.BatchCreateJobs][google.cloud.talent.v4.JobService.BatchCreateJobs].
/// It's used to replace
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// in case of success.
///
/// [google.cloud.talent.v4.JobService.BatchCreateJobs]: crate::client::JobService::batch_create_jobs
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateJobsResponse {
    /// List of job mutation results from a batch create operation. It can change
    /// until operation status is FINISHED, FAILED or CANCELLED.
    pub job_results: std::vec::Vec<crate::model::JobResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchCreateJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_results][crate::model::BatchCreateJobsResponse::job_results].
    pub fn set_job_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobResult>,
    {
        use std::iter::Iterator;
        self.job_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchCreateJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.BatchCreateJobsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobResults" => Ok(__FieldTag::__job_results),
                            "job_results" => Ok(__FieldTag::__job_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_results => {
                            if !fields.insert(__FieldTag::__job_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_results",
                                ));
                            }
                            result.job_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_results.is_empty() {
            state.serialize_entry("jobResults", &self.job_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchCreateJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchCreateJobsResponse");
        debug_struct.field("job_results", &self.job_results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The result of
/// [JobService.BatchUpdateJobs][google.cloud.talent.v4.JobService.BatchUpdateJobs].
/// It's used to replace
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// in case of success.
///
/// [google.cloud.talent.v4.JobService.BatchUpdateJobs]: crate::client::JobService::batch_update_jobs
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateJobsResponse {
    /// List of job mutation results from a batch update operation. It can change
    /// until operation status is FINISHED, FAILED or CANCELLED.
    pub job_results: std::vec::Vec<crate::model::JobResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_results][crate::model::BatchUpdateJobsResponse::job_results].
    pub fn set_job_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobResult>,
    {
        use std::iter::Iterator;
        self.job_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.BatchUpdateJobsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobResults" => Ok(__FieldTag::__job_results),
                            "job_results" => Ok(__FieldTag::__job_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_results => {
                            if !fields.insert(__FieldTag::__job_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_results",
                                ));
                            }
                            result.job_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_results.is_empty() {
            state.serialize_entry("jobResults", &self.job_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateJobsResponse");
        debug_struct.field("job_results", &self.job_results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The result of
/// [JobService.BatchDeleteJobs][google.cloud.talent.v4.JobService.BatchDeleteJobs].
/// It's used to replace
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// in case of success.
///
/// [google.cloud.talent.v4.JobService.BatchDeleteJobs]: crate::client::JobService::batch_delete_jobs
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteJobsResponse {
    /// List of job mutation results from a batch delete operation. It can change
    /// until operation status is FINISHED, FAILED or CANCELLED.
    pub job_results: std::vec::Vec<crate::model::JobResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDeleteJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_results][crate::model::BatchDeleteJobsResponse::job_results].
    pub fn set_job_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobResult>,
    {
        use std::iter::Iterator;
        self.job_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchDeleteJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.BatchDeleteJobsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobResults" => Ok(__FieldTag::__job_results),
                            "job_results" => Ok(__FieldTag::__job_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_results => {
                            if !fields.insert(__FieldTag::__job_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_results",
                                ));
                            }
                            result.job_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_results.is_empty() {
            state.serialize_entry("jobResults", &self.job_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchDeleteJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchDeleteJobsResponse");
        debug_struct.field("job_results", &self.job_results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Tenant resource represents a tenant in the service. A tenant is a group or
/// entity that shares common access with specific privileges for resources like
/// jobs. Customer may create multiple tenants to provide data isolation for
/// different groups.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Tenant {
    /// Required during tenant update.
    ///
    /// The resource name for a tenant. This is generated by the service when a
    /// tenant is created.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}", for example,
    /// "projects/foo/tenants/bar".
    pub name: std::string::String,

    /// Required. Client side tenant identifier, used to uniquely identify the
    /// tenant.
    ///
    /// The maximum number of allowed characters is 255.
    pub external_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tenant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Tenant::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [external_id][crate::model::Tenant::external_id].
    pub fn set_external_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_id = v.into();
        self
    }
}

impl wkt::message::Message for Tenant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.Tenant"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Tenant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __external_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tenant")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "externalId" => Ok(__FieldTag::__external_id),
                            "external_id" => Ok(__FieldTag::__external_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Tenant;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tenant")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_id => {
                            if !fields.insert(__FieldTag::__external_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_id",
                                ));
                            }
                            result.external_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Tenant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.external_id.is_empty() {
            state.serialize_entry("externalId", &self.external_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Tenant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Tenant");
        debug_struct.field("name", &self.name);
        debug_struct.field("external_id", &self.external_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The Request of the CreateTenant method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTenantRequest {
    /// Required. Resource name of the project under which the tenant is created.
    ///
    /// The format is "projects/{project_id}", for example,
    /// "projects/foo".
    pub parent: std::string::String,

    /// Required. The tenant to be created.
    pub tenant: std::option::Option<crate::model::Tenant>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTenantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTenantRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [tenant][crate::model::CreateTenantRequest::tenant].
    pub fn set_tenant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tenant>,
    {
        self.tenant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tenant][crate::model::CreateTenantRequest::tenant].
    pub fn set_or_clear_tenant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tenant>,
    {
        self.tenant = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTenantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.CreateTenantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTenantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __tenant,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTenantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tenant" => Ok(__FieldTag::__tenant),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTenantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTenantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tenant => {
                            if !fields.insert(__FieldTag::__tenant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant",
                                ));
                            }
                            result.tenant =
                                map.next_value::<std::option::Option<crate::model::Tenant>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTenantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.tenant.is_some() {
            state.serialize_entry("tenant", &self.tenant)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTenantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTenantRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("tenant", &self.tenant);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for getting a tenant by name.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTenantRequest {
    /// Required. The resource name of the tenant to be retrieved.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}", for example,
    /// "projects/foo/tenants/bar".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTenantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTenantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTenantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.GetTenantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTenantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTenantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTenantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTenantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTenantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTenantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTenantRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for updating a specified tenant.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTenantRequest {
    /// Required. The tenant resource to replace the current resource in the
    /// system.
    pub tenant: std::option::Option<crate::model::Tenant>,

    /// Strongly recommended for the best service experience.
    ///
    /// If [update_mask][google.cloud.talent.v4.UpdateTenantRequest.update_mask] is
    /// provided, only the specified fields in
    /// [tenant][google.cloud.talent.v4.UpdateTenantRequest.tenant] are updated.
    /// Otherwise all the fields are updated.
    ///
    /// A field mask to specify the tenant fields to be updated. Only
    /// top level fields of [Tenant][google.cloud.talent.v4.Tenant] are supported.
    ///
    /// [google.cloud.talent.v4.Tenant]: crate::model::Tenant
    /// [google.cloud.talent.v4.UpdateTenantRequest.tenant]: crate::model::UpdateTenantRequest::tenant
    /// [google.cloud.talent.v4.UpdateTenantRequest.update_mask]: crate::model::UpdateTenantRequest::update_mask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTenantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenant][crate::model::UpdateTenantRequest::tenant].
    pub fn set_tenant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tenant>,
    {
        self.tenant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tenant][crate::model::UpdateTenantRequest::tenant].
    pub fn set_or_clear_tenant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tenant>,
    {
        self.tenant = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTenantRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTenantRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTenantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.UpdateTenantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTenantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tenant,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTenantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tenant" => Ok(__FieldTag::__tenant),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTenantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTenantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tenant => {
                            if !fields.insert(__FieldTag::__tenant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenant",
                                ));
                            }
                            result.tenant =
                                map.next_value::<std::option::Option<crate::model::Tenant>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTenantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tenant.is_some() {
            state.serialize_entry("tenant", &self.tenant)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTenantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTenantRequest");
        debug_struct.field("tenant", &self.tenant);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to delete a tenant.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTenantRequest {
    /// Required. The resource name of the tenant to be deleted.
    ///
    /// The format is "projects/{project_id}/tenants/{tenant_id}", for example,
    /// "projects/foo/tenants/bar".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTenantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTenantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTenantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.DeleteTenantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTenantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTenantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTenantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTenantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTenantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTenantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTenantRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List tenants for which the client has ACL visibility.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTenantsRequest {
    /// Required. Resource name of the project under which the tenant is created.
    ///
    /// The format is "projects/{project_id}", for example,
    /// "projects/foo".
    pub parent: std::string::String,

    /// The starting indicator from which to return results.
    pub page_token: std::string::String,

    /// The maximum number of tenants to be returned, at most 100.
    /// Default is 100 if a non-positive number is provided.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTenantsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTenantsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTenantsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTenantsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListTenantsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ListTenantsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTenantsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTenantsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTenantsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTenantsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTenantsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTenantsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTenantsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The List tenants response object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTenantsResponse {
    /// Tenants for the current client.
    pub tenants: std::vec::Vec<crate::model::Tenant>,

    /// A token to retrieve the next page of results.
    pub next_page_token: std::string::String,

    /// Additional information for the API invocation, such as the request
    /// tracking id.
    pub metadata: std::option::Option<crate::model::ResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTenantsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tenants][crate::model::ListTenantsResponse::tenants].
    pub fn set_tenants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Tenant>,
    {
        use std::iter::Iterator;
        self.tenants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTenantsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ListTenantsResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::ListTenantsResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListTenantsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.talent.v4.ListTenantsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTenantsResponse {
    type PageItem = crate::model::Tenant;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tenants
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTenantsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tenants,
            __next_page_token,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTenantsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tenants" => Ok(__FieldTag::__tenants),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTenantsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTenantsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tenants => {
                            if !fields.insert(__FieldTag::__tenants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tenants",
                                ));
                            }
                            result.tenants = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tenant>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<crate::model::ResponseMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTenantsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tenants.is_empty() {
            state.serialize_entry("tenants", &self.tenants)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTenantsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTenantsResponse");
        debug_struct.field("tenants", &self.tenants);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An enum that represents the size of the company.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CompanySize {
    /// Default value if the size isn't specified.
    Unspecified,
    /// The company has less than 50 employees.
    Mini,
    /// The company has between 50 and 99 employees.
    Small,
    /// The company has between 100 and 499 employees.
    Smedium,
    /// The company has between 500 and 999 employees.
    Medium,
    /// The company has between 1,000 and 4,999 employees.
    Big,
    /// The company has between 5,000 and 9,999 employees.
    Bigger,
    /// The company has 10,000 or more employees.
    Giant,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CompanySize::value] or
    /// [CompanySize::name].
    UnknownValue(company_size::UnknownValue),
}

#[doc(hidden)]
pub mod company_size {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CompanySize {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Mini => std::option::Option::Some(1),
            Self::Small => std::option::Option::Some(2),
            Self::Smedium => std::option::Option::Some(3),
            Self::Medium => std::option::Option::Some(4),
            Self::Big => std::option::Option::Some(5),
            Self::Bigger => std::option::Option::Some(6),
            Self::Giant => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPANY_SIZE_UNSPECIFIED"),
            Self::Mini => std::option::Option::Some("MINI"),
            Self::Small => std::option::Option::Some("SMALL"),
            Self::Smedium => std::option::Option::Some("SMEDIUM"),
            Self::Medium => std::option::Option::Some("MEDIUM"),
            Self::Big => std::option::Option::Some("BIG"),
            Self::Bigger => std::option::Option::Some("BIGGER"),
            Self::Giant => std::option::Option::Some("GIANT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CompanySize {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CompanySize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CompanySize {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Mini,
            2 => Self::Small,
            3 => Self::Smedium,
            4 => Self::Medium,
            5 => Self::Big,
            6 => Self::Bigger,
            7 => Self::Giant,
            _ => Self::UnknownValue(company_size::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CompanySize {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPANY_SIZE_UNSPECIFIED" => Self::Unspecified,
            "MINI" => Self::Mini,
            "SMALL" => Self::Small,
            "SMEDIUM" => Self::Smedium,
            "MEDIUM" => Self::Medium,
            "BIG" => Self::Big,
            "BIGGER" => Self::Bigger,
            "GIANT" => Self::Giant,
            _ => Self::UnknownValue(company_size::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CompanySize {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Mini => serializer.serialize_i32(1),
            Self::Small => serializer.serialize_i32(2),
            Self::Smedium => serializer.serialize_i32(3),
            Self::Medium => serializer.serialize_i32(4),
            Self::Big => serializer.serialize_i32(5),
            Self::Bigger => serializer.serialize_i32(6),
            Self::Giant => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CompanySize {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompanySize>::new(
            ".google.cloud.talent.v4.CompanySize",
        ))
    }
}

/// An enum that represents employee benefits included with the job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum JobBenefit {
    /// Default value if the type isn't specified.
    Unspecified,
    /// The job includes access to programs that support child care, such
    /// as daycare.
    ChildCare,
    /// The job includes dental services covered by a dental
    /// insurance plan.
    Dental,
    /// The job offers specific benefits to domestic partners.
    DomesticPartner,
    /// The job allows for a flexible work schedule.
    FlexibleHours,
    /// The job includes health services covered by a medical insurance plan.
    Medical,
    /// The job includes a life insurance plan provided by the employer or
    /// available for purchase by the employee.
    LifeInsurance,
    /// The job allows for a leave of absence to a parent to care for a newborn
    /// child.
    ParentalLeave,
    /// The job includes a workplace retirement plan provided by the
    /// employer or available for purchase by the employee.
    RetirementPlan,
    /// The job allows for paid time off due to illness.
    SickDays,
    /// The job includes paid time off for vacation.
    Vacation,
    /// The job includes vision services covered by a vision
    /// insurance plan.
    Vision,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [JobBenefit::value] or
    /// [JobBenefit::name].
    UnknownValue(job_benefit::UnknownValue),
}

#[doc(hidden)]
pub mod job_benefit {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl JobBenefit {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ChildCare => std::option::Option::Some(1),
            Self::Dental => std::option::Option::Some(2),
            Self::DomesticPartner => std::option::Option::Some(3),
            Self::FlexibleHours => std::option::Option::Some(4),
            Self::Medical => std::option::Option::Some(5),
            Self::LifeInsurance => std::option::Option::Some(6),
            Self::ParentalLeave => std::option::Option::Some(7),
            Self::RetirementPlan => std::option::Option::Some(8),
            Self::SickDays => std::option::Option::Some(9),
            Self::Vacation => std::option::Option::Some(10),
            Self::Vision => std::option::Option::Some(11),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("JOB_BENEFIT_UNSPECIFIED"),
            Self::ChildCare => std::option::Option::Some("CHILD_CARE"),
            Self::Dental => std::option::Option::Some("DENTAL"),
            Self::DomesticPartner => std::option::Option::Some("DOMESTIC_PARTNER"),
            Self::FlexibleHours => std::option::Option::Some("FLEXIBLE_HOURS"),
            Self::Medical => std::option::Option::Some("MEDICAL"),
            Self::LifeInsurance => std::option::Option::Some("LIFE_INSURANCE"),
            Self::ParentalLeave => std::option::Option::Some("PARENTAL_LEAVE"),
            Self::RetirementPlan => std::option::Option::Some("RETIREMENT_PLAN"),
            Self::SickDays => std::option::Option::Some("SICK_DAYS"),
            Self::Vacation => std::option::Option::Some("VACATION"),
            Self::Vision => std::option::Option::Some("VISION"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for JobBenefit {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for JobBenefit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for JobBenefit {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ChildCare,
            2 => Self::Dental,
            3 => Self::DomesticPartner,
            4 => Self::FlexibleHours,
            5 => Self::Medical,
            6 => Self::LifeInsurance,
            7 => Self::ParentalLeave,
            8 => Self::RetirementPlan,
            9 => Self::SickDays,
            10 => Self::Vacation,
            11 => Self::Vision,
            _ => Self::UnknownValue(job_benefit::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for JobBenefit {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "JOB_BENEFIT_UNSPECIFIED" => Self::Unspecified,
            "CHILD_CARE" => Self::ChildCare,
            "DENTAL" => Self::Dental,
            "DOMESTIC_PARTNER" => Self::DomesticPartner,
            "FLEXIBLE_HOURS" => Self::FlexibleHours,
            "MEDICAL" => Self::Medical,
            "LIFE_INSURANCE" => Self::LifeInsurance,
            "PARENTAL_LEAVE" => Self::ParentalLeave,
            "RETIREMENT_PLAN" => Self::RetirementPlan,
            "SICK_DAYS" => Self::SickDays,
            "VACATION" => Self::Vacation,
            "VISION" => Self::Vision,
            _ => Self::UnknownValue(job_benefit::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for JobBenefit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ChildCare => serializer.serialize_i32(1),
            Self::Dental => serializer.serialize_i32(2),
            Self::DomesticPartner => serializer.serialize_i32(3),
            Self::FlexibleHours => serializer.serialize_i32(4),
            Self::Medical => serializer.serialize_i32(5),
            Self::LifeInsurance => serializer.serialize_i32(6),
            Self::ParentalLeave => serializer.serialize_i32(7),
            Self::RetirementPlan => serializer.serialize_i32(8),
            Self::SickDays => serializer.serialize_i32(9),
            Self::Vacation => serializer.serialize_i32(10),
            Self::Vision => serializer.serialize_i32(11),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for JobBenefit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobBenefit>::new(
            ".google.cloud.talent.v4.JobBenefit",
        ))
    }
}

/// Educational degree level defined in International Standard Classification
/// of Education (ISCED).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DegreeType {
    /// Default value. Represents no degree, or early childhood education.
    /// Maps to ISCED code 0.
    /// Ex) Kindergarten
    Unspecified,
    /// Primary education which is typically the first stage of compulsory
    /// education. ISCED code 1.
    /// Ex) Elementary school
    PrimaryEducation,
    /// Lower secondary education; First stage of secondary education building on
    /// primary education, typically with a more subject-oriented curriculum.
    /// ISCED code 2.
    /// Ex) Middle school
    LowerSecondaryEducation,
    /// Middle education; Second/final stage of secondary education preparing for
    /// tertiary education and/or providing skills relevant to employment.
    /// Usually with an increased range of subject options and streams. ISCED
    /// code 3.
    /// Ex) High school
    UpperSecondaryEducation,
    /// Adult Remedial Education; Programmes providing learning experiences that
    /// build on secondary education and prepare for labour market entry and/or
    /// tertiary education. The content is broader than secondary but not as
    /// complex as tertiary education. ISCED code 4.
    AdultRemedialEducation,
    /// Associate's or equivalent; Short first tertiary programmes that are
    /// typically practically-based, occupationally-specific and prepare for
    /// labour market entry. These programmes may also provide a pathway to other
    /// tertiary programmes. ISCED code 5.
    AssociatesOrEquivalent,
    /// Bachelor's or equivalent; Programmes designed to provide intermediate
    /// academic and/or professional knowledge, skills and competencies leading
    /// to a first tertiary degree or equivalent qualification. ISCED code 6.
    BachelorsOrEquivalent,
    /// Master's or equivalent; Programmes designed to provide advanced academic
    /// and/or professional knowledge, skills and competencies leading to a
    /// second tertiary degree or equivalent qualification. ISCED code 7.
    MastersOrEquivalent,
    /// Doctoral or equivalent; Programmes designed primarily to lead to an
    /// advanced research qualification, usually concluding with the submission
    /// and defense of a substantive dissertation of publishable quality based on
    /// original research. ISCED code 8.
    DoctoralOrEquivalent,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DegreeType::value] or
    /// [DegreeType::name].
    UnknownValue(degree_type::UnknownValue),
}

#[doc(hidden)]
pub mod degree_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DegreeType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PrimaryEducation => std::option::Option::Some(1),
            Self::LowerSecondaryEducation => std::option::Option::Some(2),
            Self::UpperSecondaryEducation => std::option::Option::Some(3),
            Self::AdultRemedialEducation => std::option::Option::Some(4),
            Self::AssociatesOrEquivalent => std::option::Option::Some(5),
            Self::BachelorsOrEquivalent => std::option::Option::Some(6),
            Self::MastersOrEquivalent => std::option::Option::Some(7),
            Self::DoctoralOrEquivalent => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DEGREE_TYPE_UNSPECIFIED"),
            Self::PrimaryEducation => std::option::Option::Some("PRIMARY_EDUCATION"),
            Self::LowerSecondaryEducation => std::option::Option::Some("LOWER_SECONDARY_EDUCATION"),
            Self::UpperSecondaryEducation => std::option::Option::Some("UPPER_SECONDARY_EDUCATION"),
            Self::AdultRemedialEducation => std::option::Option::Some("ADULT_REMEDIAL_EDUCATION"),
            Self::AssociatesOrEquivalent => std::option::Option::Some("ASSOCIATES_OR_EQUIVALENT"),
            Self::BachelorsOrEquivalent => std::option::Option::Some("BACHELORS_OR_EQUIVALENT"),
            Self::MastersOrEquivalent => std::option::Option::Some("MASTERS_OR_EQUIVALENT"),
            Self::DoctoralOrEquivalent => std::option::Option::Some("DOCTORAL_OR_EQUIVALENT"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DegreeType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DegreeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DegreeType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PrimaryEducation,
            2 => Self::LowerSecondaryEducation,
            3 => Self::UpperSecondaryEducation,
            4 => Self::AdultRemedialEducation,
            5 => Self::AssociatesOrEquivalent,
            6 => Self::BachelorsOrEquivalent,
            7 => Self::MastersOrEquivalent,
            8 => Self::DoctoralOrEquivalent,
            _ => Self::UnknownValue(degree_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DegreeType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DEGREE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PRIMARY_EDUCATION" => Self::PrimaryEducation,
            "LOWER_SECONDARY_EDUCATION" => Self::LowerSecondaryEducation,
            "UPPER_SECONDARY_EDUCATION" => Self::UpperSecondaryEducation,
            "ADULT_REMEDIAL_EDUCATION" => Self::AdultRemedialEducation,
            "ASSOCIATES_OR_EQUIVALENT" => Self::AssociatesOrEquivalent,
            "BACHELORS_OR_EQUIVALENT" => Self::BachelorsOrEquivalent,
            "MASTERS_OR_EQUIVALENT" => Self::MastersOrEquivalent,
            "DOCTORAL_OR_EQUIVALENT" => Self::DoctoralOrEquivalent,
            _ => Self::UnknownValue(degree_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DegreeType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PrimaryEducation => serializer.serialize_i32(1),
            Self::LowerSecondaryEducation => serializer.serialize_i32(2),
            Self::UpperSecondaryEducation => serializer.serialize_i32(3),
            Self::AdultRemedialEducation => serializer.serialize_i32(4),
            Self::AssociatesOrEquivalent => serializer.serialize_i32(5),
            Self::BachelorsOrEquivalent => serializer.serialize_i32(6),
            Self::MastersOrEquivalent => serializer.serialize_i32(7),
            Self::DoctoralOrEquivalent => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DegreeType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DegreeType>::new(
            ".google.cloud.talent.v4.DegreeType",
        ))
    }
}

/// An enum that represents the employment type of a job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EmploymentType {
    /// The default value if the employment type isn't specified.
    Unspecified,
    /// The job requires working a number of hours that constitute full
    /// time employment, typically 40 or more hours per week.
    FullTime,
    /// The job entails working fewer hours than a full time job,
    /// typically less than 40 hours a week.
    PartTime,
    /// The job is offered as a contracted, as opposed to a salaried employee,
    /// position.
    Contractor,
    /// The job is offered as a contracted position with the understanding
    /// that it's converted into a full-time position at the end of the
    /// contract. Jobs of this type are also returned by a search for
    /// [EmploymentType.CONTRACTOR][google.cloud.talent.v4.EmploymentType.CONTRACTOR]
    /// jobs.
    ///
    /// [google.cloud.talent.v4.EmploymentType.CONTRACTOR]: crate::model::EmploymentType::Contractor
    ContractToHire,
    /// The job is offered as a temporary employment opportunity, usually
    /// a short-term engagement.
    Temporary,
    /// The job is a fixed-term opportunity for students or entry-level job
    /// seekers to obtain on-the-job training, typically offered as a summer
    /// position.
    Intern,
    /// The is an opportunity for an individual to volunteer, where there's no
    /// expectation of compensation for the provided services.
    Volunteer,
    /// The job requires an employee to work on an as-needed basis with a
    /// flexible schedule.
    PerDiem,
    /// The job involves employing people in remote areas and flying them
    /// temporarily to the work site instead of relocating employees and their
    /// families permanently.
    FlyInFlyOut,
    /// The job does not fit any of the other listed types.
    OtherEmploymentType,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EmploymentType::value] or
    /// [EmploymentType::name].
    UnknownValue(employment_type::UnknownValue),
}

#[doc(hidden)]
pub mod employment_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EmploymentType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::FullTime => std::option::Option::Some(1),
            Self::PartTime => std::option::Option::Some(2),
            Self::Contractor => std::option::Option::Some(3),
            Self::ContractToHire => std::option::Option::Some(4),
            Self::Temporary => std::option::Option::Some(5),
            Self::Intern => std::option::Option::Some(6),
            Self::Volunteer => std::option::Option::Some(7),
            Self::PerDiem => std::option::Option::Some(8),
            Self::FlyInFlyOut => std::option::Option::Some(9),
            Self::OtherEmploymentType => std::option::Option::Some(10),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("EMPLOYMENT_TYPE_UNSPECIFIED"),
            Self::FullTime => std::option::Option::Some("FULL_TIME"),
            Self::PartTime => std::option::Option::Some("PART_TIME"),
            Self::Contractor => std::option::Option::Some("CONTRACTOR"),
            Self::ContractToHire => std::option::Option::Some("CONTRACT_TO_HIRE"),
            Self::Temporary => std::option::Option::Some("TEMPORARY"),
            Self::Intern => std::option::Option::Some("INTERN"),
            Self::Volunteer => std::option::Option::Some("VOLUNTEER"),
            Self::PerDiem => std::option::Option::Some("PER_DIEM"),
            Self::FlyInFlyOut => std::option::Option::Some("FLY_IN_FLY_OUT"),
            Self::OtherEmploymentType => std::option::Option::Some("OTHER_EMPLOYMENT_TYPE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EmploymentType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EmploymentType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EmploymentType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::FullTime,
            2 => Self::PartTime,
            3 => Self::Contractor,
            4 => Self::ContractToHire,
            5 => Self::Temporary,
            6 => Self::Intern,
            7 => Self::Volunteer,
            8 => Self::PerDiem,
            9 => Self::FlyInFlyOut,
            10 => Self::OtherEmploymentType,
            _ => Self::UnknownValue(employment_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EmploymentType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "EMPLOYMENT_TYPE_UNSPECIFIED" => Self::Unspecified,
            "FULL_TIME" => Self::FullTime,
            "PART_TIME" => Self::PartTime,
            "CONTRACTOR" => Self::Contractor,
            "CONTRACT_TO_HIRE" => Self::ContractToHire,
            "TEMPORARY" => Self::Temporary,
            "INTERN" => Self::Intern,
            "VOLUNTEER" => Self::Volunteer,
            "PER_DIEM" => Self::PerDiem,
            "FLY_IN_FLY_OUT" => Self::FlyInFlyOut,
            "OTHER_EMPLOYMENT_TYPE" => Self::OtherEmploymentType,
            _ => Self::UnknownValue(employment_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EmploymentType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::FullTime => serializer.serialize_i32(1),
            Self::PartTime => serializer.serialize_i32(2),
            Self::Contractor => serializer.serialize_i32(3),
            Self::ContractToHire => serializer.serialize_i32(4),
            Self::Temporary => serializer.serialize_i32(5),
            Self::Intern => serializer.serialize_i32(6),
            Self::Volunteer => serializer.serialize_i32(7),
            Self::PerDiem => serializer.serialize_i32(8),
            Self::FlyInFlyOut => serializer.serialize_i32(9),
            Self::OtherEmploymentType => serializer.serialize_i32(10),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EmploymentType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EmploymentType>::new(
            ".google.cloud.talent.v4.EmploymentType",
        ))
    }
}

/// An enum that represents the required experience level required for the job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum JobLevel {
    /// The default value if the level isn't specified.
    Unspecified,
    /// Entry-level individual contributors, typically with less than 2 years of
    /// experience in a similar role. Includes interns.
    EntryLevel,
    /// Experienced individual contributors, typically with 2+ years of
    /// experience in a similar role.
    Experienced,
    /// Entry- to mid-level managers responsible for managing a team of people.
    Manager,
    /// Senior-level managers responsible for managing teams of managers.
    Director,
    /// Executive-level managers and above, including C-level positions.
    Executive,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [JobLevel::value] or
    /// [JobLevel::name].
    UnknownValue(job_level::UnknownValue),
}

#[doc(hidden)]
pub mod job_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl JobLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EntryLevel => std::option::Option::Some(1),
            Self::Experienced => std::option::Option::Some(2),
            Self::Manager => std::option::Option::Some(3),
            Self::Director => std::option::Option::Some(4),
            Self::Executive => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("JOB_LEVEL_UNSPECIFIED"),
            Self::EntryLevel => std::option::Option::Some("ENTRY_LEVEL"),
            Self::Experienced => std::option::Option::Some("EXPERIENCED"),
            Self::Manager => std::option::Option::Some("MANAGER"),
            Self::Director => std::option::Option::Some("DIRECTOR"),
            Self::Executive => std::option::Option::Some("EXECUTIVE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for JobLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for JobLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for JobLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EntryLevel,
            2 => Self::Experienced,
            3 => Self::Manager,
            4 => Self::Director,
            5 => Self::Executive,
            _ => Self::UnknownValue(job_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for JobLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "JOB_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "ENTRY_LEVEL" => Self::EntryLevel,
            "EXPERIENCED" => Self::Experienced,
            "MANAGER" => Self::Manager,
            "DIRECTOR" => Self::Director,
            "EXECUTIVE" => Self::Executive,
            _ => Self::UnknownValue(job_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for JobLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EntryLevel => serializer.serialize_i32(1),
            Self::Experienced => serializer.serialize_i32(2),
            Self::Manager => serializer.serialize_i32(3),
            Self::Director => serializer.serialize_i32(4),
            Self::Executive => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for JobLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobLevel>::new(
            ".google.cloud.talent.v4.JobLevel",
        ))
    }
}

/// An enum that represents the categorization or primary focus of specific
/// role. This value is different than the "industry" associated with a role,
/// which is related to the categorization of the company listing the job.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum JobCategory {
    /// The default value if the category isn't specified.
    Unspecified,
    /// An accounting and finance job, such as an Accountant.
    AccountingAndFinance,
    /// An administrative and office job, such as an Administrative Assistant.
    AdministrativeAndOffice,
    /// An advertising and marketing job, such as Marketing Manager.
    AdvertisingAndMarketing,
    /// An animal care job, such as Veterinarian.
    AnimalCare,
    /// An art, fashion, or design job, such as Designer.
    ArtFashionAndDesign,
    /// A business operations job, such as Business Operations Manager.
    BusinessOperations,
    /// A cleaning and facilities job, such as Custodial Staff.
    CleaningAndFacilities,
    /// A computer and IT job, such as Systems Administrator.
    ComputerAndIt,
    /// A construction job, such as General Laborer.
    Construction,
    /// A customer service job, such s Cashier.
    CustomerService,
    /// An education job, such as School Teacher.
    Education,
    /// An entertainment and travel job, such as Flight Attendant.
    EntertainmentAndTravel,
    /// A farming or outdoor job, such as Park Ranger.
    FarmingAndOutdoors,
    /// A healthcare job, such as Registered Nurse.
    Healthcare,
    /// A human resources job, such as Human Resources Director.
    HumanResources,
    /// An installation, maintenance, or repair job, such as Electrician.
    InstallationMaintenanceAndRepair,
    /// A legal job, such as Law Clerk.
    Legal,
    /// A management job, often used in conjunction with another category,
    /// such as Store Manager.
    Management,
    /// A manufacturing or warehouse job, such as Assembly Technician.
    ManufacturingAndWarehouse,
    /// A media, communications, or writing job, such as Media Relations.
    MediaCommunicationsAndWriting,
    /// An oil, gas or mining job, such as Offshore Driller.
    OilGasAndMining,
    /// A personal care and services job, such as Hair Stylist.
    PersonalCareAndServices,
    /// A protective services job, such as Security Guard.
    ProtectiveServices,
    /// A real estate job, such as Buyer's Agent.
    RealEstate,
    /// A restaurant and hospitality job, such as Restaurant Server.
    RestaurantAndHospitality,
    /// A sales and/or retail job, such Sales Associate.
    SalesAndRetail,
    /// A science and engineering job, such as Lab Technician.
    ScienceAndEngineering,
    /// A social services or non-profit job, such as Case Worker.
    SocialServicesAndNonProfit,
    /// A sports, fitness, or recreation job, such as Personal Trainer.
    SportsFitnessAndRecreation,
    /// A transportation or logistics job, such as Truck Driver.
    TransportationAndLogistics,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [JobCategory::value] or
    /// [JobCategory::name].
    UnknownValue(job_category::UnknownValue),
}

#[doc(hidden)]
pub mod job_category {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl JobCategory {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::AccountingAndFinance => std::option::Option::Some(1),
            Self::AdministrativeAndOffice => std::option::Option::Some(2),
            Self::AdvertisingAndMarketing => std::option::Option::Some(3),
            Self::AnimalCare => std::option::Option::Some(4),
            Self::ArtFashionAndDesign => std::option::Option::Some(5),
            Self::BusinessOperations => std::option::Option::Some(6),
            Self::CleaningAndFacilities => std::option::Option::Some(7),
            Self::ComputerAndIt => std::option::Option::Some(8),
            Self::Construction => std::option::Option::Some(9),
            Self::CustomerService => std::option::Option::Some(10),
            Self::Education => std::option::Option::Some(11),
            Self::EntertainmentAndTravel => std::option::Option::Some(12),
            Self::FarmingAndOutdoors => std::option::Option::Some(13),
            Self::Healthcare => std::option::Option::Some(14),
            Self::HumanResources => std::option::Option::Some(15),
            Self::InstallationMaintenanceAndRepair => std::option::Option::Some(16),
            Self::Legal => std::option::Option::Some(17),
            Self::Management => std::option::Option::Some(18),
            Self::ManufacturingAndWarehouse => std::option::Option::Some(19),
            Self::MediaCommunicationsAndWriting => std::option::Option::Some(20),
            Self::OilGasAndMining => std::option::Option::Some(21),
            Self::PersonalCareAndServices => std::option::Option::Some(22),
            Self::ProtectiveServices => std::option::Option::Some(23),
            Self::RealEstate => std::option::Option::Some(24),
            Self::RestaurantAndHospitality => std::option::Option::Some(25),
            Self::SalesAndRetail => std::option::Option::Some(26),
            Self::ScienceAndEngineering => std::option::Option::Some(27),
            Self::SocialServicesAndNonProfit => std::option::Option::Some(28),
            Self::SportsFitnessAndRecreation => std::option::Option::Some(29),
            Self::TransportationAndLogistics => std::option::Option::Some(30),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("JOB_CATEGORY_UNSPECIFIED"),
            Self::AccountingAndFinance => std::option::Option::Some("ACCOUNTING_AND_FINANCE"),
            Self::AdministrativeAndOffice => std::option::Option::Some("ADMINISTRATIVE_AND_OFFICE"),
            Self::AdvertisingAndMarketing => std::option::Option::Some("ADVERTISING_AND_MARKETING"),
            Self::AnimalCare => std::option::Option::Some("ANIMAL_CARE"),
            Self::ArtFashionAndDesign => std::option::Option::Some("ART_FASHION_AND_DESIGN"),
            Self::BusinessOperations => std::option::Option::Some("BUSINESS_OPERATIONS"),
            Self::CleaningAndFacilities => std::option::Option::Some("CLEANING_AND_FACILITIES"),
            Self::ComputerAndIt => std::option::Option::Some("COMPUTER_AND_IT"),
            Self::Construction => std::option::Option::Some("CONSTRUCTION"),
            Self::CustomerService => std::option::Option::Some("CUSTOMER_SERVICE"),
            Self::Education => std::option::Option::Some("EDUCATION"),
            Self::EntertainmentAndTravel => std::option::Option::Some("ENTERTAINMENT_AND_TRAVEL"),
            Self::FarmingAndOutdoors => std::option::Option::Some("FARMING_AND_OUTDOORS"),
            Self::Healthcare => std::option::Option::Some("HEALTHCARE"),
            Self::HumanResources => std::option::Option::Some("HUMAN_RESOURCES"),
            Self::InstallationMaintenanceAndRepair => {
                std::option::Option::Some("INSTALLATION_MAINTENANCE_AND_REPAIR")
            }
            Self::Legal => std::option::Option::Some("LEGAL"),
            Self::Management => std::option::Option::Some("MANAGEMENT"),
            Self::ManufacturingAndWarehouse => {
                std::option::Option::Some("MANUFACTURING_AND_WAREHOUSE")
            }
            Self::MediaCommunicationsAndWriting => {
                std::option::Option::Some("MEDIA_COMMUNICATIONS_AND_WRITING")
            }
            Self::OilGasAndMining => std::option::Option::Some("OIL_GAS_AND_MINING"),
            Self::PersonalCareAndServices => {
                std::option::Option::Some("PERSONAL_CARE_AND_SERVICES")
            }
            Self::ProtectiveServices => std::option::Option::Some("PROTECTIVE_SERVICES"),
            Self::RealEstate => std::option::Option::Some("REAL_ESTATE"),
            Self::RestaurantAndHospitality => {
                std::option::Option::Some("RESTAURANT_AND_HOSPITALITY")
            }
            Self::SalesAndRetail => std::option::Option::Some("SALES_AND_RETAIL"),
            Self::ScienceAndEngineering => std::option::Option::Some("SCIENCE_AND_ENGINEERING"),
            Self::SocialServicesAndNonProfit => {
                std::option::Option::Some("SOCIAL_SERVICES_AND_NON_PROFIT")
            }
            Self::SportsFitnessAndRecreation => {
                std::option::Option::Some("SPORTS_FITNESS_AND_RECREATION")
            }
            Self::TransportationAndLogistics => {
                std::option::Option::Some("TRANSPORTATION_AND_LOGISTICS")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for JobCategory {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for JobCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for JobCategory {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::AccountingAndFinance,
            2 => Self::AdministrativeAndOffice,
            3 => Self::AdvertisingAndMarketing,
            4 => Self::AnimalCare,
            5 => Self::ArtFashionAndDesign,
            6 => Self::BusinessOperations,
            7 => Self::CleaningAndFacilities,
            8 => Self::ComputerAndIt,
            9 => Self::Construction,
            10 => Self::CustomerService,
            11 => Self::Education,
            12 => Self::EntertainmentAndTravel,
            13 => Self::FarmingAndOutdoors,
            14 => Self::Healthcare,
            15 => Self::HumanResources,
            16 => Self::InstallationMaintenanceAndRepair,
            17 => Self::Legal,
            18 => Self::Management,
            19 => Self::ManufacturingAndWarehouse,
            20 => Self::MediaCommunicationsAndWriting,
            21 => Self::OilGasAndMining,
            22 => Self::PersonalCareAndServices,
            23 => Self::ProtectiveServices,
            24 => Self::RealEstate,
            25 => Self::RestaurantAndHospitality,
            26 => Self::SalesAndRetail,
            27 => Self::ScienceAndEngineering,
            28 => Self::SocialServicesAndNonProfit,
            29 => Self::SportsFitnessAndRecreation,
            30 => Self::TransportationAndLogistics,
            _ => Self::UnknownValue(job_category::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for JobCategory {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "JOB_CATEGORY_UNSPECIFIED" => Self::Unspecified,
            "ACCOUNTING_AND_FINANCE" => Self::AccountingAndFinance,
            "ADMINISTRATIVE_AND_OFFICE" => Self::AdministrativeAndOffice,
            "ADVERTISING_AND_MARKETING" => Self::AdvertisingAndMarketing,
            "ANIMAL_CARE" => Self::AnimalCare,
            "ART_FASHION_AND_DESIGN" => Self::ArtFashionAndDesign,
            "BUSINESS_OPERATIONS" => Self::BusinessOperations,
            "CLEANING_AND_FACILITIES" => Self::CleaningAndFacilities,
            "COMPUTER_AND_IT" => Self::ComputerAndIt,
            "CONSTRUCTION" => Self::Construction,
            "CUSTOMER_SERVICE" => Self::CustomerService,
            "EDUCATION" => Self::Education,
            "ENTERTAINMENT_AND_TRAVEL" => Self::EntertainmentAndTravel,
            "FARMING_AND_OUTDOORS" => Self::FarmingAndOutdoors,
            "HEALTHCARE" => Self::Healthcare,
            "HUMAN_RESOURCES" => Self::HumanResources,
            "INSTALLATION_MAINTENANCE_AND_REPAIR" => Self::InstallationMaintenanceAndRepair,
            "LEGAL" => Self::Legal,
            "MANAGEMENT" => Self::Management,
            "MANUFACTURING_AND_WAREHOUSE" => Self::ManufacturingAndWarehouse,
            "MEDIA_COMMUNICATIONS_AND_WRITING" => Self::MediaCommunicationsAndWriting,
            "OIL_GAS_AND_MINING" => Self::OilGasAndMining,
            "PERSONAL_CARE_AND_SERVICES" => Self::PersonalCareAndServices,
            "PROTECTIVE_SERVICES" => Self::ProtectiveServices,
            "REAL_ESTATE" => Self::RealEstate,
            "RESTAURANT_AND_HOSPITALITY" => Self::RestaurantAndHospitality,
            "SALES_AND_RETAIL" => Self::SalesAndRetail,
            "SCIENCE_AND_ENGINEERING" => Self::ScienceAndEngineering,
            "SOCIAL_SERVICES_AND_NON_PROFIT" => Self::SocialServicesAndNonProfit,
            "SPORTS_FITNESS_AND_RECREATION" => Self::SportsFitnessAndRecreation,
            "TRANSPORTATION_AND_LOGISTICS" => Self::TransportationAndLogistics,
            _ => Self::UnknownValue(job_category::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for JobCategory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::AccountingAndFinance => serializer.serialize_i32(1),
            Self::AdministrativeAndOffice => serializer.serialize_i32(2),
            Self::AdvertisingAndMarketing => serializer.serialize_i32(3),
            Self::AnimalCare => serializer.serialize_i32(4),
            Self::ArtFashionAndDesign => serializer.serialize_i32(5),
            Self::BusinessOperations => serializer.serialize_i32(6),
            Self::CleaningAndFacilities => serializer.serialize_i32(7),
            Self::ComputerAndIt => serializer.serialize_i32(8),
            Self::Construction => serializer.serialize_i32(9),
            Self::CustomerService => serializer.serialize_i32(10),
            Self::Education => serializer.serialize_i32(11),
            Self::EntertainmentAndTravel => serializer.serialize_i32(12),
            Self::FarmingAndOutdoors => serializer.serialize_i32(13),
            Self::Healthcare => serializer.serialize_i32(14),
            Self::HumanResources => serializer.serialize_i32(15),
            Self::InstallationMaintenanceAndRepair => serializer.serialize_i32(16),
            Self::Legal => serializer.serialize_i32(17),
            Self::Management => serializer.serialize_i32(18),
            Self::ManufacturingAndWarehouse => serializer.serialize_i32(19),
            Self::MediaCommunicationsAndWriting => serializer.serialize_i32(20),
            Self::OilGasAndMining => serializer.serialize_i32(21),
            Self::PersonalCareAndServices => serializer.serialize_i32(22),
            Self::ProtectiveServices => serializer.serialize_i32(23),
            Self::RealEstate => serializer.serialize_i32(24),
            Self::RestaurantAndHospitality => serializer.serialize_i32(25),
            Self::SalesAndRetail => serializer.serialize_i32(26),
            Self::ScienceAndEngineering => serializer.serialize_i32(27),
            Self::SocialServicesAndNonProfit => serializer.serialize_i32(28),
            Self::SportsFitnessAndRecreation => serializer.serialize_i32(29),
            Self::TransportationAndLogistics => serializer.serialize_i32(30),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for JobCategory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobCategory>::new(
            ".google.cloud.talent.v4.JobCategory",
        ))
    }
}

/// An enum that represents the job posting region. In most cases, job postings
/// don't need to specify a region. If a region is given, jobs are
/// eligible for searches in the specified region.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PostingRegion {
    /// If the region is unspecified, the job is only returned if it
    /// matches the [LocationFilter][google.cloud.talent.v4.LocationFilter].
    ///
    /// [google.cloud.talent.v4.LocationFilter]: crate::model::LocationFilter
    Unspecified,
    /// In addition to exact location matching, job posting is returned when the
    /// [LocationFilter][google.cloud.talent.v4.LocationFilter] in the search query
    /// is in the same administrative area as the returned job posting. For
    /// example, if a `ADMINISTRATIVE_AREA` job is posted in "CA, USA", it's
    /// returned if [LocationFilter][google.cloud.talent.v4.LocationFilter] has
    /// "Mountain View".
    ///
    /// Administrative area refers to top-level administrative subdivision of this
    /// country. For example, US state, IT region, UK constituent nation and
    /// JP prefecture.
    ///
    /// [google.cloud.talent.v4.LocationFilter]: crate::model::LocationFilter
    AdministrativeArea,
    /// In addition to exact location matching, job is returned when
    /// [LocationFilter][google.cloud.talent.v4.LocationFilter] in search query is
    /// in the same country as this job. For example, if a `NATION_WIDE` job is
    /// posted in "USA", it's returned if
    /// [LocationFilter][google.cloud.talent.v4.LocationFilter] has 'Mountain
    /// View'.
    ///
    /// [google.cloud.talent.v4.LocationFilter]: crate::model::LocationFilter
    Nation,
    /// Job allows employees to work remotely (telecommute).
    /// If locations are provided with this value, the job is
    /// considered as having a location, but telecommuting is allowed.
    Telecommute,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PostingRegion::value] or
    /// [PostingRegion::name].
    UnknownValue(posting_region::UnknownValue),
}

#[doc(hidden)]
pub mod posting_region {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl PostingRegion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::AdministrativeArea => std::option::Option::Some(1),
            Self::Nation => std::option::Option::Some(2),
            Self::Telecommute => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("POSTING_REGION_UNSPECIFIED"),
            Self::AdministrativeArea => std::option::Option::Some("ADMINISTRATIVE_AREA"),
            Self::Nation => std::option::Option::Some("NATION"),
            Self::Telecommute => std::option::Option::Some("TELECOMMUTE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for PostingRegion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for PostingRegion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for PostingRegion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::AdministrativeArea,
            2 => Self::Nation,
            3 => Self::Telecommute,
            _ => Self::UnknownValue(posting_region::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for PostingRegion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "POSTING_REGION_UNSPECIFIED" => Self::Unspecified,
            "ADMINISTRATIVE_AREA" => Self::AdministrativeArea,
            "NATION" => Self::Nation,
            "TELECOMMUTE" => Self::Telecommute,
            _ => Self::UnknownValue(posting_region::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for PostingRegion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::AdministrativeArea => serializer.serialize_i32(1),
            Self::Nation => serializer.serialize_i32(2),
            Self::Telecommute => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for PostingRegion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PostingRegion>::new(
            ".google.cloud.talent.v4.PostingRegion",
        ))
    }
}

/// Deprecated. All resources are only visible to the owner.
///
/// An enum that represents who has view access to the resource.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
#[deprecated]
pub enum Visibility {
    /// Default value.
    Unspecified,
    /// The resource is only visible to the GCP account who owns it.
    AccountOnly,
    /// The resource is visible to the owner and may be visible to other
    /// applications and processes at Google.
    SharedWithGoogle,
    /// The resource is visible to the owner and may be visible to all other API
    /// clients.
    SharedWithPublic,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Visibility::value] or
    /// [Visibility::name].
    UnknownValue(visibility::UnknownValue),
}

#[doc(hidden)]
pub mod visibility {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Visibility {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::AccountOnly => std::option::Option::Some(1),
            Self::SharedWithGoogle => std::option::Option::Some(2),
            Self::SharedWithPublic => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VISIBILITY_UNSPECIFIED"),
            Self::AccountOnly => std::option::Option::Some("ACCOUNT_ONLY"),
            Self::SharedWithGoogle => std::option::Option::Some("SHARED_WITH_GOOGLE"),
            Self::SharedWithPublic => std::option::Option::Some("SHARED_WITH_PUBLIC"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Visibility {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Visibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Visibility {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::AccountOnly,
            2 => Self::SharedWithGoogle,
            3 => Self::SharedWithPublic,
            _ => Self::UnknownValue(visibility::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Visibility {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VISIBILITY_UNSPECIFIED" => Self::Unspecified,
            "ACCOUNT_ONLY" => Self::AccountOnly,
            "SHARED_WITH_GOOGLE" => Self::SharedWithGoogle,
            "SHARED_WITH_PUBLIC" => Self::SharedWithPublic,
            _ => Self::UnknownValue(visibility::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Visibility {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::AccountOnly => serializer.serialize_i32(1),
            Self::SharedWithGoogle => serializer.serialize_i32(2),
            Self::SharedWithPublic => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Visibility {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Visibility>::new(
            ".google.cloud.talent.v4.Visibility",
        ))
    }
}

/// Option for HTML content sanitization on user input fields, for example, job
/// description. By setting this option, user can determine whether and how
/// sanitization is performed on these fields.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum HtmlSanitization {
    /// Default value.
    Unspecified,
    /// Disables sanitization on HTML input.
    Disabled,
    /// Sanitizes HTML input, only accepts bold, italic, ordered list, and
    /// unordered list markup tags.
    SimpleFormattingOnly,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [HtmlSanitization::value] or
    /// [HtmlSanitization::name].
    UnknownValue(html_sanitization::UnknownValue),
}

#[doc(hidden)]
pub mod html_sanitization {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl HtmlSanitization {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Disabled => std::option::Option::Some(1),
            Self::SimpleFormattingOnly => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("HTML_SANITIZATION_UNSPECIFIED"),
            Self::Disabled => std::option::Option::Some("HTML_SANITIZATION_DISABLED"),
            Self::SimpleFormattingOnly => std::option::Option::Some("SIMPLE_FORMATTING_ONLY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for HtmlSanitization {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for HtmlSanitization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for HtmlSanitization {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Disabled,
            2 => Self::SimpleFormattingOnly,
            _ => Self::UnknownValue(html_sanitization::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for HtmlSanitization {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "HTML_SANITIZATION_UNSPECIFIED" => Self::Unspecified,
            "HTML_SANITIZATION_DISABLED" => Self::Disabled,
            "SIMPLE_FORMATTING_ONLY" => Self::SimpleFormattingOnly,
            _ => Self::UnknownValue(html_sanitization::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for HtmlSanitization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Disabled => serializer.serialize_i32(1),
            Self::SimpleFormattingOnly => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for HtmlSanitization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<HtmlSanitization>::new(
            ".google.cloud.talent.v4.HtmlSanitization",
        ))
    }
}

/// Method for commute. Walking, biking and wheelchair accessible transit is
/// still in the Preview stage.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum CommuteMethod {
    /// Commute method isn't specified.
    Unspecified,
    /// Commute time is calculated based on driving time.
    Driving,
    /// Commute time is calculated based on public transit including bus, metro,
    /// subway, and so on.
    Transit,
    /// Commute time is calculated based on walking time.
    Walking,
    /// Commute time is calculated based on biking time.
    Cycling,
    /// Commute time is calculated based on public transit that is wheelchair
    /// accessible.
    TransitAccessible,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [CommuteMethod::value] or
    /// [CommuteMethod::name].
    UnknownValue(commute_method::UnknownValue),
}

#[doc(hidden)]
pub mod commute_method {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl CommuteMethod {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Driving => std::option::Option::Some(1),
            Self::Transit => std::option::Option::Some(2),
            Self::Walking => std::option::Option::Some(3),
            Self::Cycling => std::option::Option::Some(4),
            Self::TransitAccessible => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMMUTE_METHOD_UNSPECIFIED"),
            Self::Driving => std::option::Option::Some("DRIVING"),
            Self::Transit => std::option::Option::Some("TRANSIT"),
            Self::Walking => std::option::Option::Some("WALKING"),
            Self::Cycling => std::option::Option::Some("CYCLING"),
            Self::TransitAccessible => std::option::Option::Some("TRANSIT_ACCESSIBLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for CommuteMethod {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for CommuteMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for CommuteMethod {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Driving,
            2 => Self::Transit,
            3 => Self::Walking,
            4 => Self::Cycling,
            5 => Self::TransitAccessible,
            _ => Self::UnknownValue(commute_method::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for CommuteMethod {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMMUTE_METHOD_UNSPECIFIED" => Self::Unspecified,
            "DRIVING" => Self::Driving,
            "TRANSIT" => Self::Transit,
            "WALKING" => Self::Walking,
            "CYCLING" => Self::Cycling,
            "TRANSIT_ACCESSIBLE" => Self::TransitAccessible,
            _ => Self::UnknownValue(commute_method::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for CommuteMethod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Driving => serializer.serialize_i32(1),
            Self::Transit => serializer.serialize_i32(2),
            Self::Walking => serializer.serialize_i32(3),
            Self::Cycling => serializer.serialize_i32(4),
            Self::TransitAccessible => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for CommuteMethod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<CommuteMethod>::new(
            ".google.cloud.talent.v4.CommuteMethod",
        ))
    }
}

/// An enum that specifies the job attributes that are returned in the
/// [MatchingJob.job][google.cloud.talent.v4.SearchJobsResponse.MatchingJob.job]
/// or [ListJobsResponse.jobs][google.cloud.talent.v4.ListJobsResponse.jobs]
/// fields.
///
/// [google.cloud.talent.v4.ListJobsResponse.jobs]: crate::model::ListJobsResponse::jobs
/// [google.cloud.talent.v4.SearchJobsResponse.MatchingJob.job]: crate::model::search_jobs_response::MatchingJob::job
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum JobView {
    /// Default value.
    Unspecified,
    /// A ID only view of job, with following attributes:
    /// [Job.name][google.cloud.talent.v4.Job.name],
    /// [Job.requisition_id][google.cloud.talent.v4.Job.requisition_id],
    /// [Job.language_code][google.cloud.talent.v4.Job.language_code].
    ///
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.name]: crate::model::Job::name
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    IdOnly,
    /// A minimal view of the job, with the following attributes:
    /// [Job.name][google.cloud.talent.v4.Job.name],
    /// [Job.requisition_id][google.cloud.talent.v4.Job.requisition_id],
    /// [Job.title][google.cloud.talent.v4.Job.title],
    /// [Job.company][google.cloud.talent.v4.Job.company],
    /// [Job.DerivedInfo.locations][google.cloud.talent.v4.Job.DerivedInfo.locations],
    /// [Job.language_code][google.cloud.talent.v4.Job.language_code].
    ///
    /// [google.cloud.talent.v4.Job.DerivedInfo.locations]: crate::model::job::DerivedInfo::locations
    /// [google.cloud.talent.v4.Job.company]: crate::model::Job::company
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.name]: crate::model::Job::name
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
    Minimal,
    /// A small view of the job, with the following attributes in the search
    /// results: [Job.name][google.cloud.talent.v4.Job.name],
    /// [Job.requisition_id][google.cloud.talent.v4.Job.requisition_id],
    /// [Job.title][google.cloud.talent.v4.Job.title],
    /// [Job.company][google.cloud.talent.v4.Job.company],
    /// [Job.DerivedInfo.locations][google.cloud.talent.v4.Job.DerivedInfo.locations],
    /// [Job.visibility][google.cloud.talent.v4.Job.visibility],
    /// [Job.language_code][google.cloud.talent.v4.Job.language_code],
    /// [Job.description][google.cloud.talent.v4.Job.description].
    ///
    /// [google.cloud.talent.v4.Job.DerivedInfo.locations]: crate::model::job::DerivedInfo::locations
    /// [google.cloud.talent.v4.Job.company]: crate::model::Job::company
    /// [google.cloud.talent.v4.Job.description]: crate::model::Job::description
    /// [google.cloud.talent.v4.Job.language_code]: crate::model::Job::language_code
    /// [google.cloud.talent.v4.Job.name]: crate::model::Job::name
    /// [google.cloud.talent.v4.Job.requisition_id]: crate::model::Job::requisition_id
    /// [google.cloud.talent.v4.Job.title]: crate::model::Job::title
    /// [google.cloud.talent.v4.Job.visibility]: crate::model::Job::visibility
    Small,
    /// All available attributes are included in the search results.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [JobView::value] or
    /// [JobView::name].
    UnknownValue(job_view::UnknownValue),
}

#[doc(hidden)]
pub mod job_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl JobView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::IdOnly => std::option::Option::Some(1),
            Self::Minimal => std::option::Option::Some(2),
            Self::Small => std::option::Option::Some(3),
            Self::Full => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("JOB_VIEW_UNSPECIFIED"),
            Self::IdOnly => std::option::Option::Some("JOB_VIEW_ID_ONLY"),
            Self::Minimal => std::option::Option::Some("JOB_VIEW_MINIMAL"),
            Self::Small => std::option::Option::Some("JOB_VIEW_SMALL"),
            Self::Full => std::option::Option::Some("JOB_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for JobView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for JobView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for JobView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::IdOnly,
            2 => Self::Minimal,
            3 => Self::Small,
            4 => Self::Full,
            _ => Self::UnknownValue(job_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for JobView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "JOB_VIEW_UNSPECIFIED" => Self::Unspecified,
            "JOB_VIEW_ID_ONLY" => Self::IdOnly,
            "JOB_VIEW_MINIMAL" => Self::Minimal,
            "JOB_VIEW_SMALL" => Self::Small,
            "JOB_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(job_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for JobView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::IdOnly => serializer.serialize_i32(1),
            Self::Minimal => serializer.serialize_i32(2),
            Self::Small => serializer.serialize_i32(3),
            Self::Full => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for JobView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobView>::new(
            ".google.cloud.talent.v4.JobView",
        ))
    }
}
