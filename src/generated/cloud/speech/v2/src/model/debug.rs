// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for crate::model::CreateRecognizerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateRecognizerRequest");
        debug_struct.field("recognizer", &self.recognizer);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("recognizer_id", &self.recognizer_id);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("method", &self.method);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("request", &self.request);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ListRecognizersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRecognizersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ListRecognizersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListRecognizersResponse");
        debug_struct.field("recognizers", &self.recognizers);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::GetRecognizerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetRecognizerRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::UpdateRecognizerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateRecognizerRequest");
        debug_struct.field("recognizer", &self.recognizer);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::DeleteRecognizerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteRecognizerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::UndeleteRecognizerRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeleteRecognizerRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::Recognizer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Recognizer");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("model", &self.model);
        debug_struct.field("language_codes", &self.language_codes);
        debug_struct.field(
            "default_recognition_config",
            &self.default_recognition_config,
        );
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::AutoDetectDecodingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoDetectDecodingConfig");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ExplicitDecodingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExplicitDecodingConfig");
        debug_struct.field("encoding", &self.encoding);
        debug_struct.field("sample_rate_hertz", &self.sample_rate_hertz);
        debug_struct.field("audio_channel_count", &self.audio_channel_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::SpeakerDiarizationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeakerDiarizationConfig");
        debug_struct.field("min_speaker_count", &self.min_speaker_count);
        debug_struct.field("max_speaker_count", &self.max_speaker_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::RecognitionFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecognitionFeatures");
        debug_struct.field("profanity_filter", &self.profanity_filter);
        debug_struct.field("enable_word_time_offsets", &self.enable_word_time_offsets);
        debug_struct.field("enable_word_confidence", &self.enable_word_confidence);
        debug_struct.field(
            "enable_automatic_punctuation",
            &self.enable_automatic_punctuation,
        );
        debug_struct.field("enable_spoken_punctuation", &self.enable_spoken_punctuation);
        debug_struct.field("enable_spoken_emojis", &self.enable_spoken_emojis);
        debug_struct.field("multi_channel_mode", &self.multi_channel_mode);
        debug_struct.field("diarization_config", &self.diarization_config);
        debug_struct.field("max_alternatives", &self.max_alternatives);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::TranscriptNormalization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TranscriptNormalization");
        debug_struct.field("entries", &self.entries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::transcript_normalization::Entry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entry");
        debug_struct.field("search", &self.search);
        debug_struct.field("replace", &self.replace);
        debug_struct.field("case_sensitive", &self.case_sensitive);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::TranslationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TranslationConfig");
        debug_struct.field("target_language", &self.target_language);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::SpeechAdaptation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeechAdaptation");
        debug_struct.field("phrase_sets", &self.phrase_sets);
        debug_struct.field("custom_classes", &self.custom_classes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::speech_adaptation::AdaptationPhraseSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdaptationPhraseSet");
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::DenoiserConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DenoiserConfig");
        debug_struct.field("denoise_audio", &self.denoise_audio);
        debug_struct.field("snr_threshold", &self.snr_threshold);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::RecognitionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecognitionConfig");
        debug_struct.field("model", &self.model);
        debug_struct.field("language_codes", &self.language_codes);
        debug_struct.field("features", &self.features);
        debug_struct.field("adaptation", &self.adaptation);
        debug_struct.field("transcript_normalization", &self.transcript_normalization);
        debug_struct.field("translation_config", &self.translation_config);
        debug_struct.field("denoiser_config", &self.denoiser_config);
        debug_struct.field("decoding_config", &self.decoding_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::RecognizeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecognizeRequest");
        debug_struct.field("recognizer", &self.recognizer);
        debug_struct.field("config", &self.config);
        debug_struct.field("config_mask", &self.config_mask);
        debug_struct.field("audio_source", &self.audio_source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::RecognitionResponseMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecognitionResponseMetadata");
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("total_billed_duration", &self.total_billed_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::SpeechRecognitionAlternative {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeechRecognitionAlternative");
        debug_struct.field("transcript", &self.transcript);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("words", &self.words);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::WordInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WordInfo");
        debug_struct.field("start_offset", &self.start_offset);
        debug_struct.field("end_offset", &self.end_offset);
        debug_struct.field("word", &self.word);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("speaker_label", &self.speaker_label);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::SpeechRecognitionResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SpeechRecognitionResult");
        debug_struct.field("alternatives", &self.alternatives);
        debug_struct.field("channel_tag", &self.channel_tag);
        debug_struct.field("result_end_offset", &self.result_end_offset);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::RecognizeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecognizeResponse");
        debug_struct.field("results", &self.results);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::StreamingRecognitionFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingRecognitionFeatures");
        debug_struct.field(
            "enable_voice_activity_events",
            &self.enable_voice_activity_events,
        );
        debug_struct.field("interim_results", &self.interim_results);
        debug_struct.field("voice_activity_timeout", &self.voice_activity_timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::streaming_recognition_features::VoiceActivityTimeout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VoiceActivityTimeout");
        debug_struct.field("speech_start_timeout", &self.speech_start_timeout);
        debug_struct.field("speech_end_timeout", &self.speech_end_timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::StreamingRecognitionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingRecognitionConfig");
        debug_struct.field("config", &self.config);
        debug_struct.field("config_mask", &self.config_mask);
        debug_struct.field("streaming_features", &self.streaming_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::StreamingRecognizeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingRecognizeRequest");
        debug_struct.field("recognizer", &self.recognizer);
        debug_struct.field("streaming_request", &self.streaming_request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::BatchRecognizeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRecognizeRequest");
        debug_struct.field("recognizer", &self.recognizer);
        debug_struct.field("config", &self.config);
        debug_struct.field("config_mask", &self.config_mask);
        debug_struct.field("files", &self.files);
        debug_struct.field("recognition_output_config", &self.recognition_output_config);
        debug_struct.field("processing_strategy", &self.processing_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::GcsOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsOutputConfig");
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::InlineOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InlineOutputConfig");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::NativeOutputFileFormatConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NativeOutputFileFormatConfig");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::VttOutputFileFormatConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VttOutputFileFormatConfig");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::SrtOutputFileFormatConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SrtOutputFileFormatConfig");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::OutputFormatConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputFormatConfig");
        debug_struct.field("native", &self.native);
        debug_struct.field("vtt", &self.vtt);
        debug_struct.field("srt", &self.srt);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::RecognitionOutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecognitionOutputConfig");
        debug_struct.field("output_format_config", &self.output_format_config);
        debug_struct.field("output", &self.output);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::BatchRecognizeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRecognizeResponse");
        debug_struct.field("results", &self.results);
        debug_struct.field("total_billed_duration", &self.total_billed_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::BatchRecognizeResults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRecognizeResults");
        debug_struct.field("results", &self.results);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::CloudStorageResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudStorageResult");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("vtt_format_uri", &self.vtt_format_uri);
        debug_struct.field("srt_format_uri", &self.srt_format_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::InlineResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InlineResult");
        debug_struct.field("transcript", &self.transcript);
        debug_struct.field("vtt_captions", &self.vtt_captions);
        debug_struct.field("srt_captions", &self.srt_captions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::BatchRecognizeFileResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRecognizeFileResult");
        debug_struct.field("error", &self.error);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("transcript", &self.transcript);
        debug_struct.field("result", &self.result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::BatchRecognizeTranscriptionMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRecognizeTranscriptionMetadata");
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("error", &self.error);
        debug_struct.field("uri", &self.uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::BatchRecognizeMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRecognizeMetadata");
        debug_struct.field("transcription_metadata", &self.transcription_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::BatchRecognizeFileMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchRecognizeFileMetadata");
        debug_struct.field("config", &self.config);
        debug_struct.field("config_mask", &self.config_mask);
        debug_struct.field("audio_source", &self.audio_source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::StreamingRecognitionResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingRecognitionResult");
        debug_struct.field("alternatives", &self.alternatives);
        debug_struct.field("is_final", &self.is_final);
        debug_struct.field("stability", &self.stability);
        debug_struct.field("result_end_offset", &self.result_end_offset);
        debug_struct.field("channel_tag", &self.channel_tag);
        debug_struct.field("language_code", &self.language_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::StreamingRecognizeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StreamingRecognizeResponse");
        debug_struct.field("results", &self.results);
        debug_struct.field("speech_event_type", &self.speech_event_type);
        debug_struct.field("speech_event_offset", &self.speech_event_offset);
        debug_struct.field("metadata", &self.metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::Config {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Config");
        debug_struct.field("name", &self.name);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::GetConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::UpdateConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConfigRequest");
        debug_struct.field("config", &self.config);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::CustomClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomClass");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("items", &self.items);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::custom_class::ClassItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClassItem");
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::PhraseSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhraseSet");
        debug_struct.field("name", &self.name);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("phrases", &self.phrases);
        debug_struct.field("boost", &self.boost);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("kms_key_name", &self.kms_key_name);
        debug_struct.field("kms_key_version_name", &self.kms_key_version_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::phrase_set::Phrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Phrase");
        debug_struct.field("value", &self.value);
        debug_struct.field("boost", &self.boost);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::CreateCustomClassRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCustomClassRequest");
        debug_struct.field("custom_class", &self.custom_class);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("custom_class_id", &self.custom_class_id);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ListCustomClassesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCustomClassesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ListCustomClassesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCustomClassesResponse");
        debug_struct.field("custom_classes", &self.custom_classes);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::GetCustomClassRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCustomClassRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::UpdateCustomClassRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCustomClassRequest");
        debug_struct.field("custom_class", &self.custom_class);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::DeleteCustomClassRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteCustomClassRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::UndeleteCustomClassRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeleteCustomClassRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::CreatePhraseSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePhraseSetRequest");
        debug_struct.field("phrase_set", &self.phrase_set);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("phrase_set_id", &self.phrase_set_id);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ListPhraseSetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPhraseSetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("show_deleted", &self.show_deleted);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ListPhraseSetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPhraseSetsResponse");
        debug_struct.field("phrase_sets", &self.phrase_sets);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::GetPhraseSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPhraseSetRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::UpdatePhraseSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdatePhraseSetRequest");
        debug_struct.field("phrase_set", &self.phrase_set);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::DeletePhraseSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePhraseSetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::UndeletePhraseSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeletePhraseSetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ModelFeature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelFeature");
        debug_struct.field("feature", &self.feature);
        debug_struct.field("release_state", &self.release_state);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ModelFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelFeatures");
        debug_struct.field("model_feature", &self.model_feature);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::ModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ModelMetadata");
        debug_struct.field("model_features", &self.model_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::LanguageMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LanguageMetadata");
        debug_struct.field("models", &self.models);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::AccessMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AccessMetadata");
        debug_struct.field("constraint_type", &self.constraint_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for crate::model::LocationsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationsMetadata");
        debug_struct.field("languages", &self.languages);
        debug_struct.field("access_metadata", &self.access_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
