// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for the
/// [CreateRecognizer][google.cloud.speech.v2.Speech.CreateRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.CreateRecognizer]: crate::client::Speech::create_recognizer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRecognizerRequest {
    /// Required. The Recognizer to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recognizer: std::option::Option<crate::model::Recognizer>,

    /// If set, validate the request and preview the Recognizer, but do not
    /// actually create it.
    pub validate_only: bool,

    /// The ID to use for the Recognizer, which will become the final component of
    /// the Recognizer's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recognizer_id: std::string::String,

    /// Required. The project and location where this Recognizer will be created.
    /// The expected format is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::CreateRecognizerRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::option::Option<crate::model::Recognizer>>>(
        mut self,
        v: T,
    ) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [recognizer_id][crate::model::CreateRecognizerRequest::recognizer_id].
    pub fn set_recognizer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreateRecognizerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CreateRecognizerRequest"
    }
}

/// Represents the metadata of a long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// The method that triggered the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method: std::string::String,

    /// The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the content of the Operation is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which content of the Operation is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    /// The percent progress of the Operation. Values can range from 0-100. If the
    /// value is 100, then the operation is finished.
    pub progress_percent: i32,

    /// The request that spawned the Operation.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::operation_metadata::Request>,

    /// Specific metadata per RPC.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::operation_metadata::Metadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::OperationMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::OperationMetadata::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [method][crate::model::OperationMetadata::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::OperationMetadata::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::OperationMetadata::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [progress_percent][crate::model::OperationMetadata::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::operation_metadata::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `BatchRecognizeRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn batch_recognize_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BatchRecognizeRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::BatchRecognizeRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `CreateRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::CreateRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdateRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdateRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `DeleteRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeleteRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::DeleteRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UndeleteRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn undelete_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UndeleteRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UndeleteRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `CreateCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::CreateCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdateCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdateCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `DeleteCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeleteCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::DeleteCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UndeleteCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn undelete_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UndeleteCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UndeleteCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `CreatePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreatePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::CreatePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdatePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdatePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdatePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `DeletePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeletePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::DeletePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UndeletePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn undelete_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UndeletePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UndeletePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdateConfigRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_config_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateConfigRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdateConfigRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `BatchRecognizeRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_batch_recognize_request<
        T: std::convert::Into<std::boxed::Box<crate::model::BatchRecognizeRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::BatchRecognizeRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `CreateRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::CreateRecognizerRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdateRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdateRecognizerRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `DeleteRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeleteRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::DeleteRecognizerRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UndeleteRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_undelete_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UndeleteRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UndeleteRecognizerRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `CreateCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::CreateCustomClassRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdateCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdateCustomClassRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `DeleteCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeleteCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::DeleteCustomClassRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UndeleteCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_undelete_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UndeleteCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UndeleteCustomClassRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `CreatePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreatePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::CreatePhraseSetRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdatePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdatePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdatePhraseSetRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `DeletePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeletePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::DeletePhraseSetRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UndeletePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_undelete_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UndeletePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UndeletePhraseSetRequest(v.into()),
        );
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdateConfigRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_config_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateConfigRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdateConfigRequest(v.into()),
        );
        self
    }

    /// Sets the value of [metadata][crate::model::OperationMetadata::metadata].
    ///
    /// Note that all the setters affecting `metadata` are mutually
    /// exclusive.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::operation_metadata::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::OperationMetadata::metadata]
    /// if it holds a `BatchRecognizeMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn batch_recognize_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BatchRecognizeMetadata>> {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Metadata::BatchRecognizeMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::OperationMetadata::metadata]
    /// to hold a `BatchRecognizeMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_batch_recognize_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::BatchRecognizeMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = std::option::Option::Some(
            crate::model::operation_metadata::Metadata::BatchRecognizeMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.OperationMetadata"
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The request that spawned the Operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// The BatchRecognizeRequest that spawned the Operation.
        BatchRecognizeRequest(std::boxed::Box<crate::model::BatchRecognizeRequest>),
        /// The CreateRecognizerRequest that spawned the Operation.
        CreateRecognizerRequest(std::boxed::Box<crate::model::CreateRecognizerRequest>),
        /// The UpdateRecognizerRequest that spawned the Operation.
        UpdateRecognizerRequest(std::boxed::Box<crate::model::UpdateRecognizerRequest>),
        /// The DeleteRecognizerRequest that spawned the Operation.
        DeleteRecognizerRequest(std::boxed::Box<crate::model::DeleteRecognizerRequest>),
        /// The UndeleteRecognizerRequest that spawned the Operation.
        UndeleteRecognizerRequest(std::boxed::Box<crate::model::UndeleteRecognizerRequest>),
        /// The CreateCustomClassRequest that spawned the Operation.
        CreateCustomClassRequest(std::boxed::Box<crate::model::CreateCustomClassRequest>),
        /// The UpdateCustomClassRequest that spawned the Operation.
        UpdateCustomClassRequest(std::boxed::Box<crate::model::UpdateCustomClassRequest>),
        /// The DeleteCustomClassRequest that spawned the Operation.
        DeleteCustomClassRequest(std::boxed::Box<crate::model::DeleteCustomClassRequest>),
        /// The UndeleteCustomClassRequest that spawned the Operation.
        UndeleteCustomClassRequest(std::boxed::Box<crate::model::UndeleteCustomClassRequest>),
        /// The CreatePhraseSetRequest that spawned the Operation.
        CreatePhraseSetRequest(std::boxed::Box<crate::model::CreatePhraseSetRequest>),
        /// The UpdatePhraseSetRequest that spawned the Operation.
        UpdatePhraseSetRequest(std::boxed::Box<crate::model::UpdatePhraseSetRequest>),
        /// The DeletePhraseSetRequest that spawned the Operation.
        DeletePhraseSetRequest(std::boxed::Box<crate::model::DeletePhraseSetRequest>),
        /// The UndeletePhraseSetRequest that spawned the Operation.
        UndeletePhraseSetRequest(std::boxed::Box<crate::model::UndeletePhraseSetRequest>),
        /// The UpdateConfigRequest that spawned the Operation.
        UpdateConfigRequest(std::boxed::Box<crate::model::UpdateConfigRequest>),
    }

    /// Specific metadata per RPC.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Metadata {
        /// Metadata specific to the BatchRecognize method.
        BatchRecognizeMetadata(std::boxed::Box<crate::model::BatchRecognizeMetadata>),
    }
}

/// Request message for the
/// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] method.
///
/// [google.cloud.speech.v2.Speech.ListRecognizers]: crate::client::Speech::list_recognizers
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRecognizersRequest {
    /// Required. The project and location of Recognizers to list. The expected
    /// format is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of Recognizers to return. The service may return fewer
    /// than this value. If unspecified, at most 5 Recognizers will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] must match
    /// the call that provided the page token.
    ///
    /// [google.cloud.speech.v2.Speech.ListRecognizers]: crate::client::Speech::list_recognizers
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Whether, or not, to show resources that have been deleted.
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecognizersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRecognizersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRecognizersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRecognizersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListRecognizersRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListRecognizersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListRecognizersRequest"
    }
}

/// Response message for the
/// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] method.
///
/// [google.cloud.speech.v2.Speech.ListRecognizers]: crate::client::Speech::list_recognizers
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRecognizersResponse {
    /// The list of requested Recognizers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub recognizers: std::vec::Vec<crate::model::Recognizer>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.speech.v2.ListRecognizersRequest.page_token] to
    /// retrieve the next page. If this field is omitted, there are no subsequent
    /// pages. This token expires after 72 hours.
    ///
    /// [google.cloud.speech.v2.ListRecognizersRequest.page_token]: crate::model::ListRecognizersRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecognizersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRecognizersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [recognizers][crate::model::ListRecognizersResponse::recognizers].
    pub fn set_recognizers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Recognizer>,
    {
        use std::iter::Iterator;
        self.recognizers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRecognizersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListRecognizersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRecognizersResponse {
    type PageItem = crate::model::Recognizer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.recognizers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for the
/// [GetRecognizer][google.cloud.speech.v2.Speech.GetRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.GetRecognizer]: crate::client::Speech::get_recognizer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRecognizerRequest {
    /// Required. The name of the Recognizer to retrieve. The expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRecognizerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetRecognizerRequest"
    }
}

/// Request message for the
/// [UpdateRecognizer][google.cloud.speech.v2.Speech.UpdateRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.UpdateRecognizer]: crate::client::Speech::update_recognizer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRecognizerRequest {
    /// Required. The Recognizer to update.
    ///
    /// The Recognizer's `name` field is used to identify the Recognizer to update.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recognizer: std::option::Option<crate::model::Recognizer>,

    /// The list of fields to update. If empty, all non-default valued fields are
    /// considered for update. Use `*` to update the entire Recognizer resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the updated Recognizer, but do not
    /// actually update it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::UpdateRecognizerRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::option::Option<crate::model::Recognizer>>>(
        mut self,
        v: T,
    ) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRecognizerRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdateRecognizerRequest"
    }
}

/// Request message for the
/// [DeleteRecognizer][google.cloud.speech.v2.Speech.DeleteRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.DeleteRecognizer]: crate::client::Speech::delete_recognizer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRecognizerRequest {
    /// Required. The name of the Recognizer to delete.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, validate the request and preview the deleted Recognizer, but do not
    /// actually delete it.
    pub validate_only: bool,

    /// If set to true, and the Recognizer is not found, the request will succeed
    /// and  be a no-op (no Operation is recorded in this case).
    pub allow_missing: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRecognizerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteRecognizerRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRecognizerRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.DeleteRecognizerRequest"
    }
}

/// Request message for the
/// [UndeleteRecognizer][google.cloud.speech.v2.Speech.UndeleteRecognizer]
/// method.
///
/// [google.cloud.speech.v2.Speech.UndeleteRecognizer]: crate::client::Speech::undelete_recognizer
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteRecognizerRequest {
    /// Required. The name of the Recognizer to undelete.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, validate the request and preview the undeleted Recognizer, but do
    /// not actually undelete it.
    pub validate_only: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteRecognizerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UndeleteRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UndeleteRecognizerRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UndeleteRecognizerRequest"
    }
}

/// A Recognizer message. Stores recognition configuration and metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Recognizer {
    /// Output only. Identifier. The resource name of the Recognizer.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System-assigned unique identifier for the Recognizer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// User-settable, human-readable name for the Recognizer. Must be 63
    /// characters or less.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. This field is now deprecated. Prefer the
    /// [`model`][google.cloud.speech.v2.RecognitionConfig.model] field in the
    /// [`RecognitionConfig`][google.cloud.speech.v2.RecognitionConfig] message.
    ///
    /// Which model to use for recognition requests. Select the model best suited
    /// to your domain to get best results.
    ///
    /// Guidance for choosing which model to use can be found in the [Transcription
    /// Models
    /// Documentation](https://cloud.google.com/speech-to-text/v2/docs/transcription-model)
    /// and the models supported in each region can be found in the [Table Of
    /// Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    ///
    /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
    /// [google.cloud.speech.v2.RecognitionConfig.model]: crate::model::RecognitionConfig::model
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. This field is now deprecated. Prefer the
    /// [`language_codes`][google.cloud.speech.v2.RecognitionConfig.language_codes]
    /// field in the
    /// [`RecognitionConfig`][google.cloud.speech.v2.RecognitionConfig] message.
    ///
    /// The language of the supplied audio as a
    /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
    ///
    /// Supported languages for each model are listed in the [Table of Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    ///
    /// If additional languages are provided, recognition result will contain
    /// recognition in the most likely language detected. The recognition result
    /// will include the language tag of the language detected in the audio.
    /// When you create or update a Recognizer, these values are
    /// stored in normalized BCP-47 form. For example, "en-us" is stored as
    /// "en-US".
    ///
    /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
    /// [google.cloud.speech.v2.RecognitionConfig.language_codes]: crate::model::RecognitionConfig::language_codes
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub language_codes: std::vec::Vec<std::string::String>,

    /// Default configuration to use for requests with this Recognizer.
    /// This can be overwritten by inline configuration in the
    /// [RecognizeRequest.config][google.cloud.speech.v2.RecognizeRequest.config]
    /// field.
    ///
    /// [google.cloud.speech.v2.RecognizeRequest.config]: crate::model::RecognizeRequest::config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub default_recognition_config: std::option::Option<crate::model::RecognitionConfig>,

    /// Allows users to store small amounts of arbitrary data.
    /// Both the key and the value must be 63 characters or less each.
    /// At most 100 annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The Recognizer lifecycle state.
    pub state: crate::model::recognizer::State,

    /// Output only. Creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time this Recognizer was modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this Recognizer was requested for deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this Recognizer will be purged.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields. This may be sent on update, undelete, and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Whether or not this Recognizer is in the process of being
    /// updated.
    pub reconciling: bool,

    /// Output only. The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the Recognizer is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which the Recognizer is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Recognizer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Recognizer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Recognizer::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Recognizer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model][crate::model::Recognizer::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [default_recognition_config][crate::model::Recognizer::default_recognition_config].
    pub fn set_default_recognition_config<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.default_recognition_config = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Recognizer::state].
    pub fn set_state<T: std::convert::Into<crate::model::recognizer::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Recognizer::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Recognizer::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Recognizer::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Recognizer::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Recognizer::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Recognizer::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Recognizer::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::Recognizer::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [language_codes][crate::model::Recognizer::language_codes].
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Recognizer::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Recognizer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.Recognizer"
    }
}

/// Defines additional types related to [Recognizer].
pub mod recognizer {
    #[allow(unused_imports)]
    use super::*;

    /// Set of states that define the lifecycle of a Recognizer.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The default value. This value is used if the state is omitted.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The Recognizer is active and ready for use.
        pub const ACTIVE: State = State::new(2);

        /// This Recognizer has been deleted.
        pub const DELETED: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                4 => std::borrow::Cow::Borrowed("DELETED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "DELETED" => std::option::Option::Some(Self::DELETED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Automatically detected decoding parameters.
/// Supported for the following encodings:
///
/// * WAV_LINEAR16: 16-bit signed little-endian PCM samples in a WAV container.
///
/// * WAV_MULAW: 8-bit companded mulaw samples in a WAV container.
///
/// * WAV_ALAW: 8-bit companded alaw samples in a WAV container.
///
/// * RFC4867_5_AMR: AMR frames with an rfc4867.5 header.
///
/// * RFC4867_5_AMRWB: AMR-WB frames with an rfc4867.5 header.
///
/// * FLAC: FLAC frames in the "native FLAC" container format.
///
/// * MP3: MPEG audio frames with optional (ignored) ID3 metadata.
///
/// * OGG_OPUS: Opus audio frames in an Ogg container.
///
/// * WEBM_OPUS: Opus audio frames in a WebM container.
///
/// * MP4_AAC: AAC audio frames in an MP4 container.
///
/// * M4A_AAC: AAC audio frames in an M4A container.
///
/// * MOV_AAC: AAC audio frames in an MOV container.
///
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoDetectDecodingConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoDetectDecodingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AutoDetectDecodingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.AutoDetectDecodingConfig"
    }
}

/// Explicitly specified decoding parameters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExplicitDecodingConfig {
    /// Required. Encoding of the audio data sent for recognition.
    pub encoding: crate::model::explicit_decoding_config::AudioEncoding,

    /// Optional. Sample rate in Hertz of the audio data sent for recognition.
    /// Valid values are: 8000-48000. 16000 is optimal. For best results, set the
    /// sampling rate of the audio source to 16000 Hz. If that's not possible, use
    /// the native sample rate of the audio source (instead of re-sampling).
    /// Note that this field is marked as OPTIONAL for backward compatibility
    /// reasons. It is (and has always been) effectively REQUIRED.
    pub sample_rate_hertz: i32,

    /// Optional. Number of channels present in the audio data sent for
    /// recognition. Note that this field is marked as OPTIONAL for backward
    /// compatibility reasons. It is (and has always been) effectively REQUIRED.
    ///
    /// The maximum allowed value is 8.
    pub audio_channel_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExplicitDecodingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encoding][crate::model::ExplicitDecodingConfig::encoding].
    pub fn set_encoding<
        T: std::convert::Into<crate::model::explicit_decoding_config::AudioEncoding>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::ExplicitDecodingConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [audio_channel_count][crate::model::ExplicitDecodingConfig::audio_channel_count].
    pub fn set_audio_channel_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.audio_channel_count = v.into();
        self
    }
}

impl wkt::message::Message for ExplicitDecodingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ExplicitDecodingConfig"
    }
}

/// Defines additional types related to [ExplicitDecodingConfig].
pub mod explicit_decoding_config {
    #[allow(unused_imports)]
    use super::*;

    /// Supported audio data encodings.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AudioEncoding(i32);

    impl AudioEncoding {
        /// Default value. This value is unused.
        pub const AUDIO_ENCODING_UNSPECIFIED: AudioEncoding = AudioEncoding::new(0);

        /// Headerless 16-bit signed little-endian PCM samples.
        pub const LINEAR16: AudioEncoding = AudioEncoding::new(1);

        /// Headerless 8-bit companded mulaw samples.
        pub const MULAW: AudioEncoding = AudioEncoding::new(2);

        /// Headerless 8-bit companded alaw samples.
        pub const ALAW: AudioEncoding = AudioEncoding::new(3);

        /// AMR frames with an rfc4867.5 header.
        pub const AMR: AudioEncoding = AudioEncoding::new(4);

        /// AMR-WB frames with an rfc4867.5 header.
        pub const AMR_WB: AudioEncoding = AudioEncoding::new(5);

        /// FLAC frames in the "native FLAC" container format.
        pub const FLAC: AudioEncoding = AudioEncoding::new(6);

        /// MPEG audio frames with optional (ignored) ID3 metadata.
        pub const MP3: AudioEncoding = AudioEncoding::new(7);

        /// Opus audio frames in an Ogg container.
        pub const OGG_OPUS: AudioEncoding = AudioEncoding::new(8);

        /// Opus audio frames in a WebM container.
        pub const WEBM_OPUS: AudioEncoding = AudioEncoding::new(9);

        /// AAC audio frames in an MP4 container.
        pub const MP4_AAC: AudioEncoding = AudioEncoding::new(10);

        /// AAC audio frames in an M4A container.
        pub const M4A_AAC: AudioEncoding = AudioEncoding::new(11);

        /// AAC audio frames in an MOV container.
        pub const MOV_AAC: AudioEncoding = AudioEncoding::new(12);

        /// Creates a new AudioEncoding instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("AUDIO_ENCODING_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("LINEAR16"),
                2 => std::borrow::Cow::Borrowed("MULAW"),
                3 => std::borrow::Cow::Borrowed("ALAW"),
                4 => std::borrow::Cow::Borrowed("AMR"),
                5 => std::borrow::Cow::Borrowed("AMR_WB"),
                6 => std::borrow::Cow::Borrowed("FLAC"),
                7 => std::borrow::Cow::Borrowed("MP3"),
                8 => std::borrow::Cow::Borrowed("OGG_OPUS"),
                9 => std::borrow::Cow::Borrowed("WEBM_OPUS"),
                10 => std::borrow::Cow::Borrowed("MP4_AAC"),
                11 => std::borrow::Cow::Borrowed("M4A_AAC"),
                12 => std::borrow::Cow::Borrowed("MOV_AAC"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "AUDIO_ENCODING_UNSPECIFIED" => {
                    std::option::Option::Some(Self::AUDIO_ENCODING_UNSPECIFIED)
                }
                "LINEAR16" => std::option::Option::Some(Self::LINEAR16),
                "MULAW" => std::option::Option::Some(Self::MULAW),
                "ALAW" => std::option::Option::Some(Self::ALAW),
                "AMR" => std::option::Option::Some(Self::AMR),
                "AMR_WB" => std::option::Option::Some(Self::AMR_WB),
                "FLAC" => std::option::Option::Some(Self::FLAC),
                "MP3" => std::option::Option::Some(Self::MP3),
                "OGG_OPUS" => std::option::Option::Some(Self::OGG_OPUS),
                "WEBM_OPUS" => std::option::Option::Some(Self::WEBM_OPUS),
                "MP4_AAC" => std::option::Option::Some(Self::MP4_AAC),
                "M4A_AAC" => std::option::Option::Some(Self::M4A_AAC),
                "MOV_AAC" => std::option::Option::Some(Self::MOV_AAC),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AudioEncoding {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AudioEncoding {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Configuration to enable speaker diarization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpeakerDiarizationConfig {
    /// Required. Minimum number of speakers in the conversation. This range gives
    /// you more flexibility by allowing the system to automatically determine the
    /// correct number of speakers.
    ///
    /// To fix the number of speakers detected in the audio, set
    /// `min_speaker_count` = `max_speaker_count`.
    pub min_speaker_count: i32,

    /// Required. Maximum number of speakers in the conversation. Valid values are:
    /// 1-6. Must be >= `min_speaker_count`. This range gives you more flexibility
    /// by allowing the system to automatically determine the correct number of
    /// speakers.
    pub max_speaker_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeakerDiarizationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_speaker_count][crate::model::SpeakerDiarizationConfig::min_speaker_count].
    pub fn set_min_speaker_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_speaker_count = v.into();
        self
    }

    /// Sets the value of [max_speaker_count][crate::model::SpeakerDiarizationConfig::max_speaker_count].
    pub fn set_max_speaker_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_speaker_count = v.into();
        self
    }
}

impl wkt::message::Message for SpeakerDiarizationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeakerDiarizationConfig"
    }
}

/// Available recognition features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecognitionFeatures {
    /// If set to `true`, the server will attempt to filter out profanities,
    /// replacing all but the initial character in each filtered word with
    /// asterisks, for instance, "f***". If set to `false` or omitted, profanities
    /// won't be filtered out.
    pub profanity_filter: bool,

    /// If `true`, the top result includes a list of words and the start and end
    /// time offsets (timestamps) for those words. If `false`, no word-level time
    /// offset information is returned. The default is `false`.
    pub enable_word_time_offsets: bool,

    /// If `true`, the top result includes a list of words and the confidence for
    /// those words. If `false`, no word-level confidence information is returned.
    /// The default is `false`.
    pub enable_word_confidence: bool,

    /// If `true`, adds punctuation to recognition result hypotheses. This feature
    /// is only available in select languages. The default `false` value does not
    /// add punctuation to result hypotheses.
    pub enable_automatic_punctuation: bool,

    /// The spoken punctuation behavior for the call. If `true`, replaces spoken
    /// punctuation with the corresponding symbols in the request. For example,
    /// "how are you question mark" becomes "how are you?". See
    /// <https://cloud.google.com/speech-to-text/docs/spoken-punctuation> for
    /// support. If `false`, spoken punctuation is not replaced.
    pub enable_spoken_punctuation: bool,

    /// The spoken emoji behavior for the call. If `true`, adds spoken emoji
    /// formatting for the request. This will replace spoken emojis with the
    /// corresponding Unicode symbols in the final transcript. If `false`, spoken
    /// emojis are not replaced.
    pub enable_spoken_emojis: bool,

    /// Mode for recognizing multi-channel audio.
    pub multi_channel_mode: crate::model::recognition_features::MultiChannelMode,

    /// Configuration to enable speaker diarization and set additional
    /// parameters to make diarization better suited for your application.
    /// When this is enabled, we send all the words from the beginning of the
    /// audio for the top alternative in every consecutive STREAMING responses.
    /// This is done in order to improve our speaker tags as our models learn to
    /// identify the speakers in the conversation over time.
    /// For non-streaming requests, the diarization results will be provided only
    /// in the top alternative of the FINAL SpeechRecognitionResult.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub diarization_config: std::option::Option<crate::model::SpeakerDiarizationConfig>,

    /// Maximum number of recognition hypotheses to be returned.
    /// The server may return fewer than `max_alternatives`.
    /// Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
    /// one. If omitted, will return a maximum of one.
    pub max_alternatives: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profanity_filter][crate::model::RecognitionFeatures::profanity_filter].
    pub fn set_profanity_filter<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.profanity_filter = v.into();
        self
    }

    /// Sets the value of [enable_word_time_offsets][crate::model::RecognitionFeatures::enable_word_time_offsets].
    pub fn set_enable_word_time_offsets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_word_time_offsets = v.into();
        self
    }

    /// Sets the value of [enable_word_confidence][crate::model::RecognitionFeatures::enable_word_confidence].
    pub fn set_enable_word_confidence<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_word_confidence = v.into();
        self
    }

    /// Sets the value of [enable_automatic_punctuation][crate::model::RecognitionFeatures::enable_automatic_punctuation].
    pub fn set_enable_automatic_punctuation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_automatic_punctuation = v.into();
        self
    }

    /// Sets the value of [enable_spoken_punctuation][crate::model::RecognitionFeatures::enable_spoken_punctuation].
    pub fn set_enable_spoken_punctuation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_spoken_punctuation = v.into();
        self
    }

    /// Sets the value of [enable_spoken_emojis][crate::model::RecognitionFeatures::enable_spoken_emojis].
    pub fn set_enable_spoken_emojis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_spoken_emojis = v.into();
        self
    }

    /// Sets the value of [multi_channel_mode][crate::model::RecognitionFeatures::multi_channel_mode].
    pub fn set_multi_channel_mode<
        T: std::convert::Into<crate::model::recognition_features::MultiChannelMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.multi_channel_mode = v.into();
        self
    }

    /// Sets the value of [diarization_config][crate::model::RecognitionFeatures::diarization_config].
    pub fn set_diarization_config<
        T: std::convert::Into<std::option::Option<crate::model::SpeakerDiarizationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.diarization_config = v.into();
        self
    }

    /// Sets the value of [max_alternatives][crate::model::RecognitionFeatures::max_alternatives].
    pub fn set_max_alternatives<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_alternatives = v.into();
        self
    }
}

impl wkt::message::Message for RecognitionFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionFeatures"
    }
}

/// Defines additional types related to [RecognitionFeatures].
pub mod recognition_features {
    #[allow(unused_imports)]
    use super::*;

    /// Options for how to recognize multi-channel audio.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct MultiChannelMode(i32);

    impl MultiChannelMode {
        /// Default value for the multi-channel mode. If the audio contains
        /// multiple channels, only the first channel will be transcribed; other
        /// channels will be ignored.
        pub const MULTI_CHANNEL_MODE_UNSPECIFIED: MultiChannelMode = MultiChannelMode::new(0);

        /// If selected, each channel in the provided audio is transcribed
        /// independently. This cannot be selected if the selected
        /// [model][google.cloud.speech.v2.Recognizer.model] is `latest_short`.
        ///
        /// [google.cloud.speech.v2.Recognizer.model]: crate::model::Recognizer::model
        pub const SEPARATE_RECOGNITION_PER_CHANNEL: MultiChannelMode = MultiChannelMode::new(1);

        /// Creates a new MultiChannelMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("MULTI_CHANNEL_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SEPARATE_RECOGNITION_PER_CHANNEL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "MULTI_CHANNEL_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::MULTI_CHANNEL_MODE_UNSPECIFIED)
                }
                "SEPARATE_RECOGNITION_PER_CHANNEL" => {
                    std::option::Option::Some(Self::SEPARATE_RECOGNITION_PER_CHANNEL)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for MultiChannelMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for MultiChannelMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Transcription normalization configuration. Use transcription normalization
/// to automatically replace parts of the transcript with phrases of your
/// choosing. For StreamingRecognize, this normalization only applies to stable
/// partial transcripts (stability > 0.8) and final transcripts.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranscriptNormalization {
    /// A list of replacement entries. We will perform replacement with one entry
    /// at a time. For example, the second entry in ["cat" => "dog", "mountain cat"
    /// => "mountain dog"] will never be applied because we will always process the
    /// first entry before it. At most 100 entries.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::transcript_normalization::Entry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranscriptNormalization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::TranscriptNormalization::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transcript_normalization::Entry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranscriptNormalization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.TranscriptNormalization"
    }
}

/// Defines additional types related to [TranscriptNormalization].
pub mod transcript_normalization {
    #[allow(unused_imports)]
    use super::*;

    /// A single replacement configuration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Entry {
        /// What to replace. Max length is 100 characters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub search: std::string::String,

        /// What to replace with. Max length is 100 characters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub replace: std::string::String,

        /// Whether the search is case sensitive.
        pub case_sensitive: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Entry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search][crate::model::transcript_normalization::Entry::search].
        pub fn set_search<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.search = v.into();
            self
        }

        /// Sets the value of [replace][crate::model::transcript_normalization::Entry::replace].
        pub fn set_replace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.replace = v.into();
            self
        }

        /// Sets the value of [case_sensitive][crate::model::transcript_normalization::Entry::case_sensitive].
        pub fn set_case_sensitive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.case_sensitive = v.into();
            self
        }
    }

    impl wkt::message::Message for Entry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.TranscriptNormalization.Entry"
        }
    }
}

/// Translation configuration. Use to translate the given audio into text for the
/// desired language.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TranslationConfig {
    /// Required. The language code to translate to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_language: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_language][crate::model::TranslationConfig::target_language].
    pub fn set_target_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_language = v.into();
        self
    }
}

impl wkt::message::Message for TranslationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.TranslationConfig"
    }
}

/// Provides "hints" to the speech recognizer to favor specific words and phrases
/// in the results. PhraseSets can be specified as an inline resource, or a
/// reference to an existing PhraseSet resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpeechAdaptation {
    /// A list of inline or referenced PhraseSets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub phrase_sets: std::vec::Vec<crate::model::speech_adaptation::AdaptationPhraseSet>,

    /// A list of inline CustomClasses. Existing CustomClass resources can be
    /// referenced directly in a PhraseSet.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_classes: std::vec::Vec<crate::model::CustomClass>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechAdaptation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_sets][crate::model::SpeechAdaptation::phrase_sets].
    pub fn set_phrase_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::speech_adaptation::AdaptationPhraseSet>,
    {
        use std::iter::Iterator;
        self.phrase_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_classes][crate::model::SpeechAdaptation::custom_classes].
    pub fn set_custom_classes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomClass>,
    {
        use std::iter::Iterator;
        self.custom_classes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpeechAdaptation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeechAdaptation"
    }
}

/// Defines additional types related to [SpeechAdaptation].
pub mod speech_adaptation {
    #[allow(unused_imports)]
    use super::*;

    /// A biasing PhraseSet, which can be either a string referencing the name of
    /// an existing PhraseSets resource, or an inline definition of a PhraseSet.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AdaptationPhraseSet {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub value:
            std::option::Option<crate::model::speech_adaptation::adaptation_phrase_set::Value>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AdaptationPhraseSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::speech_adaptation::adaptation_phrase_set::Value,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// if it holds a `PhraseSet`, `None` if the field is not set or
        /// holds a different branch.
        pub fn phrase_set(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::speech_adaptation::adaptation_phrase_set::Value::PhraseSet(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// if it holds a `InlinePhraseSet`, `None` if the field is not set or
        /// holds a different branch.
        pub fn inline_phrase_set(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PhraseSet>> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::speech_adaptation::adaptation_phrase_set::Value::InlinePhraseSet(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// to hold a `PhraseSet`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_phrase_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::speech_adaptation::adaptation_phrase_set::Value::PhraseSet(v.into()),
            );
            self
        }

        /// Sets the value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// to hold a `InlinePhraseSet`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_inline_phrase_set<
            T: std::convert::Into<std::boxed::Box<crate::model::PhraseSet>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::speech_adaptation::adaptation_phrase_set::Value::InlinePhraseSet(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for AdaptationPhraseSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.SpeechAdaptation.AdaptationPhraseSet"
        }
    }

    /// Defines additional types related to [AdaptationPhraseSet].
    pub mod adaptation_phrase_set {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Value {
            /// The name of an existing PhraseSet resource. The user must have read
            /// access to the resource and it must not be deleted.
            PhraseSet(std::string::String),
            /// An inline defined PhraseSet.
            InlinePhraseSet(std::boxed::Box<crate::model::PhraseSet>),
        }
    }
}

/// Provides information to the Recognizer that specifies how to process the
/// recognition request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecognitionConfig {
    /// Optional. Which model to use for recognition requests. Select the model
    /// best suited to your domain to get best results.
    ///
    /// Guidance for choosing which model to use can be found in the [Transcription
    /// Models
    /// Documentation](https://cloud.google.com/speech-to-text/v2/docs/transcription-model)
    /// and the models supported in each region can be found in the [Table Of
    /// Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Optional. The language of the supplied audio as a
    /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
    /// Language tags are normalized to BCP-47 before they are used eg "en-us"
    /// becomes "en-US".
    ///
    /// Supported languages for each model are listed in the [Table of Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    ///
    /// If additional languages are provided, recognition result will contain
    /// recognition in the most likely language detected. The recognition result
    /// will include the language tag of the language detected in the audio.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub language_codes: std::vec::Vec<std::string::String>,

    /// Speech recognition features to enable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub features: std::option::Option<crate::model::RecognitionFeatures>,

    /// Speech adaptation context that weights recognizer predictions for specific
    /// words and phrases.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub adaptation: std::option::Option<crate::model::SpeechAdaptation>,

    /// Optional. Use transcription normalization to automatically replace parts of
    /// the transcript with phrases of your choosing. For StreamingRecognize, this
    /// normalization only applies to stable partial transcripts (stability > 0.8)
    /// and final transcripts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transcript_normalization: std::option::Option<crate::model::TranscriptNormalization>,

    /// Optional. Optional configuration used to automatically run translation on
    /// the given audio to the desired language for supported models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub translation_config: std::option::Option<crate::model::TranslationConfig>,

    /// Decoding parameters for audio being sent for recognition.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub decoding_config: std::option::Option<crate::model::recognition_config::DecodingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::RecognitionConfig::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [features][crate::model::RecognitionConfig::features].
    pub fn set_features<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionFeatures>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.features = v.into();
        self
    }

    /// Sets the value of [adaptation][crate::model::RecognitionConfig::adaptation].
    pub fn set_adaptation<
        T: std::convert::Into<std::option::Option<crate::model::SpeechAdaptation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.adaptation = v.into();
        self
    }

    /// Sets the value of [transcript_normalization][crate::model::RecognitionConfig::transcript_normalization].
    pub fn set_transcript_normalization<
        T: std::convert::Into<std::option::Option<crate::model::TranscriptNormalization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transcript_normalization = v.into();
        self
    }

    /// Sets the value of [translation_config][crate::model::RecognitionConfig::translation_config].
    pub fn set_translation_config<
        T: std::convert::Into<std::option::Option<crate::model::TranslationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.translation_config = v.into();
        self
    }

    /// Sets the value of [language_codes][crate::model::RecognitionConfig::language_codes].
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [decoding_config][crate::model::RecognitionConfig::decoding_config].
    ///
    /// Note that all the setters affecting `decoding_config` are mutually
    /// exclusive.
    pub fn set_decoding_config<
        T: std::convert::Into<std::option::Option<crate::model::recognition_config::DecodingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoding_config = v.into();
        self
    }

    /// The value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// if it holds a `AutoDecodingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_decoding_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutoDetectDecodingConfig>> {
        #[allow(unreachable_patterns)]
        self.decoding_config.as_ref().and_then(|v| match v {
            crate::model::recognition_config::DecodingConfig::AutoDecodingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// if it holds a `ExplicitDecodingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn explicit_decoding_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExplicitDecodingConfig>> {
        #[allow(unreachable_patterns)]
        self.decoding_config.as_ref().and_then(|v| match v {
            crate::model::recognition_config::DecodingConfig::ExplicitDecodingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// to hold a `AutoDecodingConfig`.
    ///
    /// Note that all the setters affecting `decoding_config` are
    /// mutually exclusive.
    pub fn set_auto_decoding_config<
        T: std::convert::Into<std::boxed::Box<crate::model::AutoDetectDecodingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoding_config = std::option::Option::Some(
            crate::model::recognition_config::DecodingConfig::AutoDecodingConfig(v.into()),
        );
        self
    }

    /// Sets the value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// to hold a `ExplicitDecodingConfig`.
    ///
    /// Note that all the setters affecting `decoding_config` are
    /// mutually exclusive.
    pub fn set_explicit_decoding_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ExplicitDecodingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoding_config = std::option::Option::Some(
            crate::model::recognition_config::DecodingConfig::ExplicitDecodingConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RecognitionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionConfig"
    }
}

/// Defines additional types related to [RecognitionConfig].
pub mod recognition_config {
    #[allow(unused_imports)]
    use super::*;

    /// Decoding parameters for audio being sent for recognition.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DecodingConfig {
        /// Automatically detect decoding parameters.
        /// Preferred for supported formats.
        AutoDecodingConfig(std::boxed::Box<crate::model::AutoDetectDecodingConfig>),
        /// Explicitly specified decoding parameters.
        /// Required if using headerless PCM audio (linear16, mulaw, alaw).
        ExplicitDecodingConfig(std::boxed::Box<crate::model::ExplicitDecodingConfig>),
    }
}

/// Request message for the
/// [Recognize][google.cloud.speech.v2.Speech.Recognize] method. Either
/// `content` or `uri` must be supplied. Supplying both or neither returns
/// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. See [content
/// limits](https://cloud.google.com/speech-to-text/quotas#content).
///
/// [google.cloud.speech.v2.Speech.Recognize]: crate::client::Speech::recognize
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecognizeRequest {
    /// Required. The name of the Recognizer to use during recognition. The
    /// expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`. The
    /// {recognizer} segment may be set to `_` to use an empty implicit Recognizer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recognizer: std::string::String,

    /// Features and audio metadata to use for the Automatic Speech Recognition.
    /// This field in combination with the
    /// [config_mask][google.cloud.speech.v2.RecognizeRequest.config_mask] field
    /// can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource.
    ///
    /// [google.cloud.speech.v2.RecognizeRequest.config_mask]: crate::model::RecognizeRequest::config_mask
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.RecognizeRequest.config] that override the
    /// values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all non-default valued fields in
    /// [config][google.cloud.speech.v2.RecognizeRequest.config] override the
    /// values in the recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.RecognizeRequest.config] completely
    /// overrides and replaces the config in the recognizer for this recognition
    /// request.
    ///
    /// [google.cloud.speech.v2.RecognizeRequest.config]: crate::model::RecognizeRequest::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// The audio source, which is either inline content or a Google Cloud
    /// Storage URI.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub audio_source: std::option::Option<crate::model::recognize_request::AudioSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::RecognizeRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [config][crate::model::RecognizeRequest::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [config_mask][crate::model::RecognizeRequest::config_mask].
    pub fn set_config_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_mask = v.into();
        self
    }

    /// Sets the value of [audio_source][crate::model::RecognizeRequest::audio_source].
    ///
    /// Note that all the setters affecting `audio_source` are mutually
    /// exclusive.
    pub fn set_audio_source<
        T: std::convert::Into<std::option::Option<crate::model::recognize_request::AudioSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.audio_source = v.into();
        self
    }

    /// The value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.audio_source.as_ref().and_then(|v| match v {
            crate::model::recognize_request::AudioSource::Content(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.audio_source.as_ref().and_then(|v| match v {
            crate::model::recognize_request::AudioSource::Uri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `audio_source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audio_source = std::option::Option::Some(
            crate::model::recognize_request::AudioSource::Content(v.into()),
        );
        self
    }

    /// Sets the value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `audio_source` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_source =
            std::option::Option::Some(crate::model::recognize_request::AudioSource::Uri(v.into()));
        self
    }
}

impl wkt::message::Message for RecognizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognizeRequest"
    }
}

/// Defines additional types related to [RecognizeRequest].
pub mod recognize_request {
    #[allow(unused_imports)]
    use super::*;

    /// The audio source, which is either inline content or a Google Cloud
    /// Storage URI.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AudioSource {
        /// The audio data bytes encoded as specified in
        /// [RecognitionConfig][google.cloud.speech.v2.RecognitionConfig]. As
        /// with all bytes fields, proto buffers use a pure binary representation,
        /// whereas JSON representations use base64.
        ///
        /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
        Content(::bytes::Bytes),
        /// URI that points to a file that contains audio data bytes as specified in
        /// [RecognitionConfig][google.cloud.speech.v2.RecognitionConfig]. The file
        /// must not be compressed (for example, gzip). Currently, only Google Cloud
        /// Storage URIs are supported, which must be specified in the following
        /// format: `gs://bucket_name/object_name` (other URI formats return
        /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]). For more
        /// information, see [Request
        /// URIs](https://cloud.google.com/storage/docs/reference-uris).
        ///
        /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
        Uri(std::string::String),
    }
}

/// Metadata about the recognition request and response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecognitionResponseMetadata {
    /// Global request identifier auto-generated by the API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// When available, billed audio seconds for the corresponding request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_billed_duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionResponseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_id][crate::model::RecognitionResponseMetadata::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [total_billed_duration][crate::model::RecognitionResponseMetadata::total_billed_duration].
    pub fn set_total_billed_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_billed_duration = v.into();
        self
    }
}

impl wkt::message::Message for RecognitionResponseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionResponseMetadata"
    }
}

/// Alternative hypotheses (a.k.a. n-best list).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpeechRecognitionAlternative {
    /// Transcript text representing the words that the user spoke.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub transcript: std::string::String,

    /// The confidence estimate between 0.0 and 1.0. A higher number
    /// indicates an estimated greater likelihood that the recognized words are
    /// correct. This field is set only for the top alternative of a non-streaming
    /// result or, of a streaming result where
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final] is
    /// set to `true`. This field is not guaranteed to be accurate and users should
    /// not rely on it to be always provided. The default of 0.0 is a sentinel
    /// value indicating `confidence` was not set.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    pub confidence: f32,

    /// A list of word-specific information for each recognized word.
    /// When the
    /// [SpeakerDiarizationConfig][google.cloud.speech.v2.SpeakerDiarizationConfig]
    /// is set, you will see all the words from the beginning of the audio.
    ///
    /// [google.cloud.speech.v2.SpeakerDiarizationConfig]: crate::model::SpeakerDiarizationConfig
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub words: std::vec::Vec<crate::model::WordInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechRecognitionAlternative {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcript][crate::model::SpeechRecognitionAlternative::transcript].
    pub fn set_transcript<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transcript = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SpeechRecognitionAlternative::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [words][crate::model::SpeechRecognitionAlternative::words].
    pub fn set_words<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WordInfo>,
    {
        use std::iter::Iterator;
        self.words = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpeechRecognitionAlternative {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeechRecognitionAlternative"
    }
}

/// Word-specific information for recognized words.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WordInfo {
    /// Time offset relative to the beginning of the audio,
    /// and corresponding to the start of the spoken word.
    /// This field is only set if
    /// [enable_word_time_offsets][google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]
    /// is `true` and only in the top hypothesis. This is an experimental feature
    /// and the accuracy of the time offset can vary.
    ///
    /// [google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]: crate::model::RecognitionFeatures::enable_word_time_offsets
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_offset: std::option::Option<wkt::Duration>,

    /// Time offset relative to the beginning of the audio,
    /// and corresponding to the end of the spoken word.
    /// This field is only set if
    /// [enable_word_time_offsets][google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]
    /// is `true` and only in the top hypothesis. This is an experimental feature
    /// and the accuracy of the time offset can vary.
    ///
    /// [google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]: crate::model::RecognitionFeatures::enable_word_time_offsets
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_offset: std::option::Option<wkt::Duration>,

    /// The word corresponding to this set of information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub word: std::string::String,

    /// The confidence estimate between 0.0 and 1.0. A higher number
    /// indicates an estimated greater likelihood that the recognized words are
    /// correct. This field is set only for the top alternative of a non-streaming
    /// result or, of a streaming result where
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final] is
    /// set to `true`. This field is not guaranteed to be accurate and users should
    /// not rely on it to be always provided. The default of 0.0 is a sentinel
    /// value indicating `confidence` was not set.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    pub confidence: f32,

    /// A distinct label is assigned for every speaker within the audio. This field
    /// specifies which one of those speakers was detected to have spoken this
    /// word. `speaker_label` is set if
    /// [SpeakerDiarizationConfig][google.cloud.speech.v2.SpeakerDiarizationConfig]
    /// is given and only in the top alternative.
    ///
    /// [google.cloud.speech.v2.SpeakerDiarizationConfig]: crate::model::SpeakerDiarizationConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub speaker_label: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WordInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_offset][crate::model::WordInfo::start_offset].
    pub fn set_start_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_offset = v.into();
        self
    }

    /// Sets the value of [end_offset][crate::model::WordInfo::end_offset].
    pub fn set_end_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_offset = v.into();
        self
    }

    /// Sets the value of [word][crate::model::WordInfo::word].
    pub fn set_word<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.word = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::WordInfo::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [speaker_label][crate::model::WordInfo::speaker_label].
    pub fn set_speaker_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.speaker_label = v.into();
        self
    }
}

impl wkt::message::Message for WordInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.WordInfo"
    }
}

/// A speech recognition result corresponding to a portion of the audio.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SpeechRecognitionResult {
    /// May contain one or more recognition hypotheses. These alternatives are
    /// ordered in terms of accuracy, with the top (first) alternative being the
    /// most probable, as ranked by the recognizer.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub alternatives: std::vec::Vec<crate::model::SpeechRecognitionAlternative>,

    /// For multi-channel audio, this is the channel number corresponding to the
    /// recognized result for the audio from that channel.
    /// For `audio_channel_count` = `N`, its output values can range from `1` to
    /// `N`.
    pub channel_tag: i32,

    /// Time offset of the end of this result relative to the beginning of the
    /// audio.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result_end_offset: std::option::Option<wkt::Duration>,

    /// Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag of the language in this result. This language code was
    /// detected to have the most likelihood of being spoken in the audio.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechRecognitionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel_tag][crate::model::SpeechRecognitionResult::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [result_end_offset][crate::model::SpeechRecognitionResult::result_end_offset].
    pub fn set_result_end_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_end_offset = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::SpeechRecognitionResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [alternatives][crate::model::SpeechRecognitionResult::alternatives].
    pub fn set_alternatives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionAlternative>,
    {
        use std::iter::Iterator;
        self.alternatives = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpeechRecognitionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeechRecognitionResult"
    }
}

/// Response message for the
/// [Recognize][google.cloud.speech.v2.Speech.Recognize] method.
///
/// [google.cloud.speech.v2.Speech.Recognize]: crate::client::Speech::recognize
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecognizeResponse {
    /// Sequential list of transcription results corresponding to sequential
    /// portions of audio.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::SpeechRecognitionResult>,

    /// Metadata about the recognition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata][crate::model::RecognizeResponse::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionResponseMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [results][crate::model::RecognizeResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RecognizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognizeResponse"
    }
}

/// Available recognition features specific to streaming recognition requests.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRecognitionFeatures {
    /// If `true`, responses with voice activity speech events will be returned as
    /// they are detected.
    pub enable_voice_activity_events: bool,

    /// Whether or not to stream interim results to the client. If set to true,
    /// interim results will be streamed to the client. Otherwise, only the final
    /// response will be streamed back.
    pub interim_results: bool,

    /// If set, the server will automatically close the stream after the specified
    /// duration has elapsed after the last VOICE_ACTIVITY speech event has been
    /// sent. The field `voice_activity_events` must also be set to true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub voice_activity_timeout:
        std::option::Option<crate::model::streaming_recognition_features::VoiceActivityTimeout>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognitionFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_voice_activity_events][crate::model::StreamingRecognitionFeatures::enable_voice_activity_events].
    pub fn set_enable_voice_activity_events<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_voice_activity_events = v.into();
        self
    }

    /// Sets the value of [interim_results][crate::model::StreamingRecognitionFeatures::interim_results].
    pub fn set_interim_results<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.interim_results = v.into();
        self
    }

    /// Sets the value of [voice_activity_timeout][crate::model::StreamingRecognitionFeatures::voice_activity_timeout].
    pub fn set_voice_activity_timeout<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::streaming_recognition_features::VoiceActivityTimeout,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.voice_activity_timeout = v.into();
        self
    }
}

impl wkt::message::Message for StreamingRecognitionFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionFeatures"
    }
}

/// Defines additional types related to [StreamingRecognitionFeatures].
pub mod streaming_recognition_features {
    #[allow(unused_imports)]
    use super::*;

    /// Events that a timeout can be set on for voice activity.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VoiceActivityTimeout {
        /// Duration to timeout the stream if no speech begins. If this is set and
        /// no speech is detected in this duration at the start of the stream, the
        /// server will close the stream.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub speech_start_timeout: std::option::Option<wkt::Duration>,

        /// Duration to timeout the stream after speech ends. If this is set and no
        /// speech is detected in this duration after speech was detected, the server
        /// will close the stream.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub speech_end_timeout: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VoiceActivityTimeout {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [speech_start_timeout][crate::model::streaming_recognition_features::VoiceActivityTimeout::speech_start_timeout].
        pub fn set_speech_start_timeout<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.speech_start_timeout = v.into();
            self
        }

        /// Sets the value of [speech_end_timeout][crate::model::streaming_recognition_features::VoiceActivityTimeout::speech_end_timeout].
        pub fn set_speech_end_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.speech_end_timeout = v.into();
            self
        }
    }

    impl wkt::message::Message for VoiceActivityTimeout {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionFeatures.VoiceActivityTimeout"
        }
    }
}

/// Provides configuration information for the StreamingRecognize request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRecognitionConfig {
    /// Required. Features and audio metadata to use for the Automatic Speech
    /// Recognition. This field in combination with the
    /// [config_mask][google.cloud.speech.v2.StreamingRecognitionConfig.config_mask]
    /// field can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource.
    ///
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    /// [google.cloud.speech.v2.StreamingRecognitionConfig.config_mask]: crate::model::StreamingRecognitionConfig::config_mask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.StreamingRecognitionConfig.config] that
    /// override the values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all non-default valued fields in
    /// [config][google.cloud.speech.v2.StreamingRecognitionConfig.config] override
    /// the values in the Recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// Recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.StreamingRecognitionConfig.config]
    /// completely overrides and replaces the config in the recognizer for this
    /// recognition request.
    ///
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    /// [google.cloud.speech.v2.StreamingRecognitionConfig.config]: crate::model::StreamingRecognitionConfig::config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// Speech recognition features to enable specific to streaming audio
    /// recognition requests.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub streaming_features: std::option::Option<crate::model::StreamingRecognitionFeatures>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognitionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::StreamingRecognitionConfig::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [config_mask][crate::model::StreamingRecognitionConfig::config_mask].
    pub fn set_config_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_mask = v.into();
        self
    }

    /// Sets the value of [streaming_features][crate::model::StreamingRecognitionConfig::streaming_features].
    pub fn set_streaming_features<
        T: std::convert::Into<std::option::Option<crate::model::StreamingRecognitionFeatures>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_features = v.into();
        self
    }
}

impl wkt::message::Message for StreamingRecognitionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionConfig"
    }
}

/// Request message for the
/// [StreamingRecognize][google.cloud.speech.v2.Speech.StreamingRecognize]
/// method. Multiple
/// [StreamingRecognizeRequest][google.cloud.speech.v2.StreamingRecognizeRequest]
/// messages are sent in one call.
///
/// If the [Recognizer][google.cloud.speech.v2.Recognizer] referenced by
/// [recognizer][google.cloud.speech.v2.StreamingRecognizeRequest.recognizer]
/// contains a fully specified request configuration then the stream may only
/// contain messages with only
/// [audio][google.cloud.speech.v2.StreamingRecognizeRequest.audio] set.
///
/// Otherwise the first message must contain a
/// [recognizer][google.cloud.speech.v2.StreamingRecognizeRequest.recognizer] and
/// a
/// [streaming_config][google.cloud.speech.v2.StreamingRecognizeRequest.streaming_config]
/// message that together fully specify the request configuration and must not
/// contain [audio][google.cloud.speech.v2.StreamingRecognizeRequest.audio]. All
/// subsequent messages must only have
/// [audio][google.cloud.speech.v2.StreamingRecognizeRequest.audio] set.
///
/// [google.cloud.speech.v2.Recognizer]: crate::model::Recognizer
/// [google.cloud.speech.v2.StreamingRecognizeRequest]: crate::model::StreamingRecognizeRequest
/// [google.cloud.speech.v2.StreamingRecognizeRequest.audio]: crate::model::StreamingRecognizeRequest::streaming_request
/// [google.cloud.speech.v2.StreamingRecognizeRequest.recognizer]: crate::model::StreamingRecognizeRequest::recognizer
/// [google.cloud.speech.v2.StreamingRecognizeRequest.streaming_config]: crate::model::StreamingRecognizeRequest::streaming_request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRecognizeRequest {
    /// Required. The name of the Recognizer to use during recognition. The
    /// expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`. The
    /// {recognizer} segment may be set to `_` to use an empty implicit Recognizer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recognizer: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub streaming_request:
        std::option::Option<crate::model::streaming_recognize_request::StreamingRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::StreamingRecognizeRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request].
    ///
    /// Note that all the setters affecting `streaming_request` are mutually
    /// exclusive.
    pub fn set_streaming_request<
        T: std::convert::Into<
                std::option::Option<crate::model::streaming_recognize_request::StreamingRequest>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_request = v.into();
        self
    }

    /// The value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// if it holds a `StreamingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn streaming_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamingRecognitionConfig>> {
        #[allow(unreachable_patterns)]
        self.streaming_request.as_ref().and_then(|v| match v {
            crate::model::streaming_recognize_request::StreamingRequest::StreamingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// if it holds a `Audio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn audio(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.streaming_request.as_ref().and_then(|v| match v {
            crate::model::streaming_recognize_request::StreamingRequest::Audio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// to hold a `StreamingConfig`.
    ///
    /// Note that all the setters affecting `streaming_request` are
    /// mutually exclusive.
    pub fn set_streaming_config<
        T: std::convert::Into<std::boxed::Box<crate::model::StreamingRecognitionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_request = std::option::Option::Some(
            crate::model::streaming_recognize_request::StreamingRequest::StreamingConfig(v.into()),
        );
        self
    }

    /// Sets the value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// to hold a `Audio`.
    ///
    /// Note that all the setters affecting `streaming_request` are
    /// mutually exclusive.
    pub fn set_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.streaming_request = std::option::Option::Some(
            crate::model::streaming_recognize_request::StreamingRequest::Audio(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StreamingRecognizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognizeRequest"
    }
}

/// Defines additional types related to [StreamingRecognizeRequest].
pub mod streaming_recognize_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum StreamingRequest {
        /// StreamingRecognitionConfig to be used in this recognition attempt.
        /// If provided, it will override the default RecognitionConfig stored in the
        /// Recognizer.
        StreamingConfig(std::boxed::Box<crate::model::StreamingRecognitionConfig>),
        /// Inline audio bytes to be Recognized.
        /// Maximum size for this field is 15 KB per request.
        Audio(::bytes::Bytes),
    }
}

/// Request message for the
/// [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize]
/// method.
///
/// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchRecognizeRequest {
    /// Required. The name of the Recognizer to use during recognition. The
    /// expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`. The
    /// {recognizer} segment may be set to `_` to use an empty implicit Recognizer.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recognizer: std::string::String,

    /// Features and audio metadata to use for the Automatic Speech Recognition.
    /// This field in combination with the
    /// [config_mask][google.cloud.speech.v2.BatchRecognizeRequest.config_mask]
    /// field can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeRequest.config_mask]: crate::model::BatchRecognizeRequest::config_mask
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] that override
    /// the values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all given fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] override the
    /// values in the recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] completely
    /// overrides and replaces the config in the recognizer for this recognition
    /// request.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeRequest.config]: crate::model::BatchRecognizeRequest::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// Audio files with file metadata for ASR.
    /// The maximum number of files allowed to be specified is 15.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::BatchRecognizeFileMetadata>,

    /// Configuration options for where to output the transcripts of each file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recognition_output_config: std::option::Option<crate::model::RecognitionOutputConfig>,

    /// Processing strategy to use for this request.
    pub processing_strategy: crate::model::batch_recognize_request::ProcessingStrategy,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::BatchRecognizeRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [config][crate::model::BatchRecognizeRequest::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [config_mask][crate::model::BatchRecognizeRequest::config_mask].
    pub fn set_config_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_mask = v.into();
        self
    }

    /// Sets the value of [recognition_output_config][crate::model::BatchRecognizeRequest::recognition_output_config].
    pub fn set_recognition_output_config<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recognition_output_config = v.into();
        self
    }

    /// Sets the value of [processing_strategy][crate::model::BatchRecognizeRequest::processing_strategy].
    pub fn set_processing_strategy<
        T: std::convert::Into<crate::model::batch_recognize_request::ProcessingStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processing_strategy = v.into();
        self
    }

    /// Sets the value of [files][crate::model::BatchRecognizeRequest::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BatchRecognizeFileMetadata>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchRecognizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeRequest"
    }
}

/// Defines additional types related to [BatchRecognizeRequest].
pub mod batch_recognize_request {
    #[allow(unused_imports)]
    use super::*;

    /// Possible processing strategies for batch requests.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ProcessingStrategy(i32);

    impl ProcessingStrategy {
        /// Default value for the processing strategy. The request is processed as
        /// soon as its received.
        pub const PROCESSING_STRATEGY_UNSPECIFIED: ProcessingStrategy = ProcessingStrategy::new(0);

        /// If selected, processes the request during lower utilization periods for a
        /// price discount. The request is fulfilled within 24 hours.
        pub const DYNAMIC_BATCHING: ProcessingStrategy = ProcessingStrategy::new(1);

        /// Creates a new ProcessingStrategy instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PROCESSING_STRATEGY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DYNAMIC_BATCHING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PROCESSING_STRATEGY_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PROCESSING_STRATEGY_UNSPECIFIED)
                }
                "DYNAMIC_BATCHING" => std::option::Option::Some(Self::DYNAMIC_BATCHING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ProcessingStrategy {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ProcessingStrategy {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Output configurations for Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsOutputConfig {
    /// The Cloud Storage URI prefix with which recognition results will be
    /// written.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsOutputConfig::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GcsOutputConfig"
    }
}

/// Output configurations for inline response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InlineOutputConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InlineOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.InlineOutputConfig"
    }
}

/// Output configurations for serialized `BatchRecognizeResults` protos.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NativeOutputFileFormatConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NativeOutputFileFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for NativeOutputFileFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.NativeOutputFileFormatConfig"
    }
}

/// Output configurations for [WebVTT](https://www.w3.org/TR/webvtt1/) formatted
/// subtitle file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VttOutputFileFormatConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VttOutputFileFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VttOutputFileFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.VttOutputFileFormatConfig"
    }
}

/// Output configurations [SubRip
/// Text](https://www.matroska.org/technical/subtitles.html#srt-subtitles)
/// formatted subtitle file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SrtOutputFileFormatConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SrtOutputFileFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SrtOutputFileFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SrtOutputFileFormatConfig"
    }
}

/// Configuration for the format of the results stored to `output`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OutputFormatConfig {
    /// Configuration for the native output format. If this field is set or if no
    /// other output format field is set, then transcripts will be written to the
    /// sink in the native format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub native: std::option::Option<crate::model::NativeOutputFileFormatConfig>,

    /// Configuration for the VTT output format. If this field is set, then
    /// transcripts will be written to the sink in the VTT format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vtt: std::option::Option<crate::model::VttOutputFileFormatConfig>,

    /// Configuration for the SRT output format. If this field is set, then
    /// transcripts will be written to the sink in the SRT format.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub srt: std::option::Option<crate::model::SrtOutputFileFormatConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [native][crate::model::OutputFormatConfig::native].
    pub fn set_native<
        T: std::convert::Into<std::option::Option<crate::model::NativeOutputFileFormatConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.native = v.into();
        self
    }

    /// Sets the value of [vtt][crate::model::OutputFormatConfig::vtt].
    pub fn set_vtt<
        T: std::convert::Into<std::option::Option<crate::model::VttOutputFileFormatConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vtt = v.into();
        self
    }

    /// Sets the value of [srt][crate::model::OutputFormatConfig::srt].
    pub fn set_srt<
        T: std::convert::Into<std::option::Option<crate::model::SrtOutputFileFormatConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.srt = v.into();
        self
    }
}

impl wkt::message::Message for OutputFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.OutputFormatConfig"
    }
}

/// Configuration options for the output(s) of recognition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecognitionOutputConfig {
    /// Optional. Configuration for the format of the results stored to `output`.
    /// If unspecified transcripts will be written in the `NATIVE` format only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_format_config: std::option::Option<crate::model::OutputFormatConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub output: std::option::Option<crate::model::recognition_output_config::Output>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_format_config][crate::model::RecognitionOutputConfig::output_format_config].
    pub fn set_output_format_config<
        T: std::convert::Into<std::option::Option<crate::model::OutputFormatConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_format_config = v.into();
        self
    }

    /// Sets the value of [output][crate::model::RecognitionOutputConfig::output].
    ///
    /// Note that all the setters affecting `output` are mutually
    /// exclusive.
    pub fn set_output<
        T: std::convert::Into<std::option::Option<crate::model::recognition_output_config::Output>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = v.into();
        self
    }

    /// The value of [output][crate::model::RecognitionOutputConfig::output]
    /// if it holds a `GcsOutputConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_output_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsOutputConfig>> {
        #[allow(unreachable_patterns)]
        self.output.as_ref().and_then(|v| match v {
            crate::model::recognition_output_config::Output::GcsOutputConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [output][crate::model::RecognitionOutputConfig::output]
    /// if it holds a `InlineResponseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_response_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineOutputConfig>> {
        #[allow(unreachable_patterns)]
        self.output.as_ref().and_then(|v| match v {
            crate::model::recognition_output_config::Output::InlineResponseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output][crate::model::RecognitionOutputConfig::output]
    /// to hold a `GcsOutputConfig`.
    ///
    /// Note that all the setters affecting `output` are
    /// mutually exclusive.
    pub fn set_gcs_output_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = std::option::Option::Some(
            crate::model::recognition_output_config::Output::GcsOutputConfig(v.into()),
        );
        self
    }

    /// Sets the value of [output][crate::model::RecognitionOutputConfig::output]
    /// to hold a `InlineResponseConfig`.
    ///
    /// Note that all the setters affecting `output` are
    /// mutually exclusive.
    pub fn set_inline_response_config<
        T: std::convert::Into<std::boxed::Box<crate::model::InlineOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = std::option::Option::Some(
            crate::model::recognition_output_config::Output::InlineResponseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RecognitionOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionOutputConfig"
    }
}

/// Defines additional types related to [RecognitionOutputConfig].
pub mod recognition_output_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Output {
        /// If this message is populated, recognition results are written to the
        /// provided Google Cloud Storage URI.
        GcsOutputConfig(std::boxed::Box<crate::model::GcsOutputConfig>),
        /// If this message is populated, recognition results are provided in the
        /// [BatchRecognizeResponse][google.cloud.speech.v2.BatchRecognizeResponse]
        /// message of the Operation when completed. This is only supported when
        /// calling [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize]
        /// with just one audio file.
        ///
        /// [google.cloud.speech.v2.BatchRecognizeResponse]: crate::model::BatchRecognizeResponse
        /// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
        InlineResponseConfig(std::boxed::Box<crate::model::InlineOutputConfig>),
    }
}

/// Response message for
/// [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize] that is
/// packaged into a longrunning [Operation][google.longrunning.Operation].
///
/// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
/// [google.longrunning.Operation]: longrunning::model::Operation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchRecognizeResponse {
    /// Map from filename to the final result for that file.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub results:
        std::collections::HashMap<std::string::String, crate::model::BatchRecognizeFileResult>,

    /// When available, billed audio seconds for the corresponding request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_billed_duration: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_billed_duration][crate::model::BatchRecognizeResponse::total_billed_duration].
    pub fn set_total_billed_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.total_billed_duration = v.into();
        self
    }

    /// Sets the value of [results][crate::model::BatchRecognizeResponse::results].
    pub fn set_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BatchRecognizeFileResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchRecognizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeResponse"
    }
}

/// Output type for Cloud Storage of BatchRecognize transcripts. Though this
/// proto isn't returned in this API anywhere, the Cloud Storage transcripts will
/// be this proto serialized and should be parsed as such.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchRecognizeResults {
    /// Sequential list of transcription results corresponding to sequential
    /// portions of audio.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::SpeechRecognitionResult>,

    /// Metadata about the recognition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata][crate::model::BatchRecognizeResults::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionResponseMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [results][crate::model::BatchRecognizeResults::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchRecognizeResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeResults"
    }
}

/// Final results written to Cloud Storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudStorageResult {
    /// The Cloud Storage URI to which recognition results were written.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// The Cloud Storage URI to which recognition results were written as VTT
    /// formatted captions. This is populated only when `VTT` output is requested.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vtt_format_uri: std::string::String,

    /// The Cloud Storage URI to which recognition results were written as SRT
    /// formatted captions. This is populated only when `SRT` output is requested.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub srt_format_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::CloudStorageResult::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [vtt_format_uri][crate::model::CloudStorageResult::vtt_format_uri].
    pub fn set_vtt_format_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vtt_format_uri = v.into();
        self
    }

    /// Sets the value of [srt_format_uri][crate::model::CloudStorageResult::srt_format_uri].
    pub fn set_srt_format_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.srt_format_uri = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CloudStorageResult"
    }
}

/// Final results returned inline in the recognition response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InlineResult {
    /// The transcript for the audio file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transcript: std::option::Option<crate::model::BatchRecognizeResults>,

    /// The transcript for the audio file as VTT formatted captions. This is
    /// populated only when `VTT` output is requested.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vtt_captions: std::string::String,

    /// The transcript for the audio file as SRT formatted captions. This is
    /// populated only when `SRT` output is requested.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub srt_captions: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcript][crate::model::InlineResult::transcript].
    pub fn set_transcript<
        T: std::convert::Into<std::option::Option<crate::model::BatchRecognizeResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transcript = v.into();
        self
    }

    /// Sets the value of [vtt_captions][crate::model::InlineResult::vtt_captions].
    pub fn set_vtt_captions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vtt_captions = v.into();
        self
    }

    /// Sets the value of [srt_captions][crate::model::InlineResult::srt_captions].
    pub fn set_srt_captions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.srt_captions = v.into();
        self
    }
}

impl wkt::message::Message for InlineResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.InlineResult"
    }
}

/// Final results for a single file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchRecognizeFileResult {
    /// Error if one was encountered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    /// Deprecated. Use `cloud_storage_result.native_format_uri` instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Deprecated. Use `inline_result.transcript` instead.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub transcript: std::option::Option<crate::model::BatchRecognizeResults>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::batch_recognize_file_result::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeFileResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::BatchRecognizeFileResult::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::BatchRecognizeFileResult::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionResponseMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::BatchRecognizeFileResult::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [transcript][crate::model::BatchRecognizeFileResult::transcript].
    pub fn set_transcript<
        T: std::convert::Into<std::option::Option<crate::model::BatchRecognizeResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transcript = v.into();
        self
    }

    /// Sets the value of [result][crate::model::BatchRecognizeFileResult::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::batch_recognize_file_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::BatchRecognizeFileResult::result]
    /// if it holds a `CloudStorageResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::batch_recognize_file_result::Result::CloudStorageResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [result][crate::model::BatchRecognizeFileResult::result]
    /// if it holds a `InlineResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::batch_recognize_file_result::Result::InlineResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::BatchRecognizeFileResult::result]
    /// to hold a `CloudStorageResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_cloud_storage_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::batch_recognize_file_result::Result::CloudStorageResult(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::BatchRecognizeFileResult::result]
    /// to hold a `InlineResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_inline_result<T: std::convert::Into<std::boxed::Box<crate::model::InlineResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::batch_recognize_file_result::Result::InlineResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchRecognizeFileResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeFileResult"
    }
}

/// Defines additional types related to [BatchRecognizeFileResult].
pub mod batch_recognize_file_result {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Recognition results written to Cloud Storage. This is
        /// populated only when
        /// [GcsOutputConfig][google.cloud.speech.v2.GcsOutputConfig] is set in
        /// the
        /// [RecognitionOutputConfig][[google.cloud.speech.v2.RecognitionOutputConfig].
        ///
        /// [google.cloud.speech.v2.GcsOutputConfig]: crate::model::GcsOutputConfig
        CloudStorageResult(std::boxed::Box<crate::model::CloudStorageResult>),
        /// Recognition results. This is populated only when
        /// [InlineOutputConfig][google.cloud.speech.v2.InlineOutputConfig] is set in
        /// the
        /// [RecognitionOutputConfig][[google.cloud.speech.v2.RecognitionOutputConfig].
        ///
        /// [google.cloud.speech.v2.InlineOutputConfig]: crate::model::InlineOutputConfig
        InlineResult(std::boxed::Box<crate::model::InlineResult>),
    }
}

/// Metadata about transcription for a single file (for example, progress
/// percent).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchRecognizeTranscriptionMetadata {
    /// How much of the file has been transcribed so far.
    pub progress_percent: i32,

    /// Error if one was encountered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The Cloud Storage URI to which recognition results will be written.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeTranscriptionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_percent][crate::model::BatchRecognizeTranscriptionMetadata::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BatchRecognizeTranscriptionMetadata::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::BatchRecognizeTranscriptionMetadata::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for BatchRecognizeTranscriptionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeTranscriptionMetadata"
    }
}

/// Operation metadata for
/// [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize].
///
/// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchRecognizeMetadata {
    /// Map from provided filename to the transcription metadata for that file.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub transcription_metadata: std::collections::HashMap<
        std::string::String,
        crate::model::BatchRecognizeTranscriptionMetadata,
    >,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcription_metadata][crate::model::BatchRecognizeMetadata::transcription_metadata].
    pub fn set_transcription_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BatchRecognizeTranscriptionMetadata>,
    {
        use std::iter::Iterator;
        self.transcription_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchRecognizeMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeMetadata"
    }
}

/// Metadata about a single file in a batch for BatchRecognize.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchRecognizeFileMetadata {
    /// Features and audio metadata to use for the Automatic Speech Recognition.
    /// This field in combination with the
    /// [config_mask][google.cloud.speech.v2.BatchRecognizeFileMetadata.config_mask]
    /// field can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource as well as the
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] at the
    /// request level.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeFileMetadata.config_mask]: crate::model::BatchRecognizeFileMetadata::config_mask
    /// [google.cloud.speech.v2.BatchRecognizeRequest.config]: crate::model::BatchRecognizeRequest::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeFileMetadata.config] that
    /// override the values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all non-default valued fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeFileMetadata.config] override
    /// the values in the recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.BatchRecognizeFileMetadata.config]
    /// completely overrides and replaces the config in the recognizer for this
    /// recognition request.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeFileMetadata.config]: crate::model::BatchRecognizeFileMetadata::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// The audio source, which is a Google Cloud Storage URI.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub audio_source: std::option::Option<crate::model::batch_recognize_file_metadata::AudioSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeFileMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::BatchRecognizeFileMetadata::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [config_mask][crate::model::BatchRecognizeFileMetadata::config_mask].
    pub fn set_config_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_mask = v.into();
        self
    }

    /// Sets the value of [audio_source][crate::model::BatchRecognizeFileMetadata::audio_source].
    ///
    /// Note that all the setters affecting `audio_source` are mutually
    /// exclusive.
    pub fn set_audio_source<
        T: std::convert::Into<
                std::option::Option<crate::model::batch_recognize_file_metadata::AudioSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.audio_source = v.into();
        self
    }

    /// The value of [audio_source][crate::model::BatchRecognizeFileMetadata::audio_source]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.audio_source.as_ref().and_then(|v| match v {
            crate::model::batch_recognize_file_metadata::AudioSource::Uri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [audio_source][crate::model::BatchRecognizeFileMetadata::audio_source]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `audio_source` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_source = std::option::Option::Some(
            crate::model::batch_recognize_file_metadata::AudioSource::Uri(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchRecognizeFileMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeFileMetadata"
    }
}

/// Defines additional types related to [BatchRecognizeFileMetadata].
pub mod batch_recognize_file_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The audio source, which is a Google Cloud Storage URI.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AudioSource {
        /// Cloud Storage URI for the audio file.
        Uri(std::string::String),
    }
}

/// A streaming speech recognition result corresponding to a portion of the audio
/// that is currently being processed.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRecognitionResult {
    /// May contain one or more recognition hypotheses. These alternatives are
    /// ordered in terms of accuracy, with the top (first) alternative being the
    /// most probable, as ranked by the recognizer.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub alternatives: std::vec::Vec<crate::model::SpeechRecognitionAlternative>,

    /// If `false`, this
    /// [StreamingRecognitionResult][google.cloud.speech.v2.StreamingRecognitionResult]
    /// represents an interim result that may change. If `true`, this is the final
    /// time the speech service will return this particular
    /// [StreamingRecognitionResult][google.cloud.speech.v2.StreamingRecognitionResult],
    /// the recognizer will not return any further hypotheses for this portion of
    /// the transcript and corresponding audio.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult]: crate::model::StreamingRecognitionResult
    pub is_final: bool,

    /// An estimate of the likelihood that the recognizer will not change its guess
    /// about this interim result. Values range from 0.0 (completely unstable)
    /// to 1.0 (completely stable). This field is only provided for interim results
    /// ([is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final]=`false`).
    /// The default of 0.0 is a sentinel value indicating `stability` was not set.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    pub stability: f32,

    /// Time offset of the end of this result relative to the beginning of the
    /// audio.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub result_end_offset: std::option::Option<wkt::Duration>,

    /// For multi-channel audio, this is the channel number corresponding to the
    /// recognized result for the audio from that channel.
    /// For
    /// `audio_channel_count` = `N`, its output values can range from `1` to `N`.
    pub channel_tag: i32,

    /// Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag of the language in this result. This language code was
    /// detected to have the most likelihood of being spoken in the audio.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognitionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_final][crate::model::StreamingRecognitionResult::is_final].
    pub fn set_is_final<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_final = v.into();
        self
    }

    /// Sets the value of [stability][crate::model::StreamingRecognitionResult::stability].
    pub fn set_stability<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.stability = v.into();
        self
    }

    /// Sets the value of [result_end_offset][crate::model::StreamingRecognitionResult::result_end_offset].
    pub fn set_result_end_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result_end_offset = v.into();
        self
    }

    /// Sets the value of [channel_tag][crate::model::StreamingRecognitionResult::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::StreamingRecognitionResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [alternatives][crate::model::StreamingRecognitionResult::alternatives].
    pub fn set_alternatives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionAlternative>,
    {
        use std::iter::Iterator;
        self.alternatives = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingRecognitionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionResult"
    }
}

/// `StreamingRecognizeResponse` is the only message returned to the client by
/// `StreamingRecognize`. A series of zero or more `StreamingRecognizeResponse`
/// messages are streamed back to the client. If there is no recognizable
/// audio then no messages are streamed back to the client.
///
/// Here are some examples of `StreamingRecognizeResponse`s that might
/// be returned while processing audio:
///
/// . results { alternatives { transcript: "tube" } stability: 0.01 }
///
/// . results { alternatives { transcript: "to be a" } stability: 0.01 }
///
/// . results { alternatives { transcript: "to be" } stability: 0.9 }
///   results { alternatives { transcript: " or not to be" } stability: 0.01 }
///
/// . results { alternatives { transcript: "to be or not to be"
///   confidence: 0.92 }
///   alternatives { transcript: "to bee or not to bee" }
///   is_final: true }
///
/// . results { alternatives { transcript: " that's" } stability: 0.01 }
///
/// . results { alternatives { transcript: " that is" } stability: 0.9 }
///   results { alternatives { transcript: " the question" } stability: 0.01 }
///
/// . results { alternatives { transcript: " that is the question"
///   confidence: 0.98 }
///   alternatives { transcript: " that was the question" }
///   is_final: true }
///
///
/// Notes:
///
/// - Only two of the above responses #4 and #7 contain final results; they are
///   indicated by `is_final: true`. Concatenating these together generates the
///   full transcript: "to be or not to be that is the question".
///
/// - The others contain interim `results`. #3 and #6 contain two interim
///   `results`: the first portion has a high stability and is less likely to
///   change; the second portion has a low stability and is very likely to
///   change. A UI designer might choose to show only high stability `results`.
///
/// - The specific `stability` and `confidence` values shown above are only for
///   illustrative purposes. Actual values may vary.
///
/// - In each response, only one of these fields will be set:
///   `error`,
///   `speech_event_type`, or
///   one or more (repeated) `results`.
///
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingRecognizeResponse {
    /// This repeated list contains zero or more results that
    /// correspond to consecutive portions of the audio currently being processed.
    /// It contains zero or one
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final]=`true`
    /// result (the newly settled portion), followed by zero or more
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final]=`false`
    /// results (the interim results).
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::StreamingRecognitionResult>,

    /// Indicates the type of speech event.
    pub speech_event_type: crate::model::streaming_recognize_response::SpeechEventType,

    /// Time offset between the beginning of the audio and event emission.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub speech_event_offset: std::option::Option<wkt::Duration>,

    /// Metadata about the recognition.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speech_event_type][crate::model::StreamingRecognizeResponse::speech_event_type].
    pub fn set_speech_event_type<
        T: std::convert::Into<crate::model::streaming_recognize_response::SpeechEventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speech_event_type = v.into();
        self
    }

    /// Sets the value of [speech_event_offset][crate::model::StreamingRecognizeResponse::speech_event_offset].
    pub fn set_speech_event_offset<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.speech_event_offset = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::StreamingRecognizeResponse::metadata].
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::RecognitionResponseMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// Sets the value of [results][crate::model::StreamingRecognizeResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StreamingRecognitionResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingRecognizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognizeResponse"
    }
}

/// Defines additional types related to [StreamingRecognizeResponse].
pub mod streaming_recognize_response {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of speech event.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SpeechEventType(i32);

    impl SpeechEventType {
        /// No speech event specified.
        pub const SPEECH_EVENT_TYPE_UNSPECIFIED: SpeechEventType = SpeechEventType::new(0);

        /// This event indicates that the server has detected the end of the user's
        /// speech utterance and expects no additional speech. Therefore, the server
        /// will not process additional audio and will close the gRPC bidirectional
        /// stream. This event is only sent if there was a force cutoff due to
        /// silence being detected early. This event is only available through the
        /// `latest_short` [model][google.cloud.speech.v2.Recognizer.model].
        ///
        /// [google.cloud.speech.v2.Recognizer.model]: crate::model::Recognizer::model
        pub const END_OF_SINGLE_UTTERANCE: SpeechEventType = SpeechEventType::new(1);

        /// This event indicates that the server has detected the beginning of human
        /// voice activity in the stream. This event can be returned multiple times
        /// if speech starts and stops repeatedly throughout the stream. This event
        /// is only sent if `voice_activity_events` is set to true.
        pub const SPEECH_ACTIVITY_BEGIN: SpeechEventType = SpeechEventType::new(2);

        /// This event indicates that the server has detected the end of human voice
        /// activity in the stream. This event can be returned multiple times if
        /// speech starts and stops repeatedly throughout the stream. This event is
        /// only sent if `voice_activity_events` is set to true.
        pub const SPEECH_ACTIVITY_END: SpeechEventType = SpeechEventType::new(3);

        /// Creates a new SpeechEventType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SPEECH_EVENT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("END_OF_SINGLE_UTTERANCE"),
                2 => std::borrow::Cow::Borrowed("SPEECH_ACTIVITY_BEGIN"),
                3 => std::borrow::Cow::Borrowed("SPEECH_ACTIVITY_END"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SPEECH_EVENT_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::SPEECH_EVENT_TYPE_UNSPECIFIED)
                }
                "END_OF_SINGLE_UTTERANCE" => {
                    std::option::Option::Some(Self::END_OF_SINGLE_UTTERANCE)
                }
                "SPEECH_ACTIVITY_BEGIN" => std::option::Option::Some(Self::SPEECH_ACTIVITY_BEGIN),
                "SPEECH_ACTIVITY_END" => std::option::Option::Some(Self::SPEECH_ACTIVITY_END),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for SpeechEventType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for SpeechEventType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Message representing the config for the Speech-to-Text API. This includes an
/// optional [KMS key](https://cloud.google.com/kms/docs/resource-hierarchy#keys)
/// with which incoming data will be encrypted.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Config {
    /// Output only. Identifier. The name of the config resource. There is exactly
    /// one config resource per project per location. The expected format is
    /// `projects/{project}/locations/{location}/config`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) that if
    /// present, will be used to encrypt Speech-to-Text resources at-rest. Updating
    /// this key will not encrypt existing resources using this key; only new
    /// resources will be encrypted using this key. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. The most recent time this resource was modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Config::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Config::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Config::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.Config"
    }
}

/// Request message for the
/// [GetConfig][google.cloud.speech.v2.Speech.GetConfig] method.
///
/// [google.cloud.speech.v2.Speech.GetConfig]: crate::client::Speech::get_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConfigRequest {
    /// Required. The name of the config to retrieve. There is exactly one config
    /// resource per project per location. The expected format is
    /// `projects/{project}/locations/{location}/config`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetConfigRequest"
    }
}

/// Request message for the
/// [UpdateConfig][google.cloud.speech.v2.Speech.UpdateConfig] method.
///
/// [google.cloud.speech.v2.Speech.UpdateConfig]: crate::client::Speech::update_config
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConfigRequest {
    /// Required. The config to update.
    ///
    /// The config's `name` field is used to identify the config to be updated.
    /// The expected format is `projects/{project}/locations/{location}/config`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::Config>,

    /// The list of fields to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::UpdateConfigRequest::config].
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::Config>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdateConfigRequest"
    }
}

/// CustomClass for biasing in speech recognition. Used to define a set of words
/// or phrases that represents a common concept or theme likely to appear in your
/// audio, for example a list of passenger ship names.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomClass {
    /// Output only. Identifier. The resource name of the CustomClass.
    /// Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System-assigned unique identifier for the CustomClass.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. User-settable, human-readable name for the CustomClass. Must be
    /// 63 characters or less.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// A collection of class items.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub items: std::vec::Vec<crate::model::custom_class::ClassItem>,

    /// Output only. The CustomClass lifecycle state.
    pub state: crate::model::custom_class::State,

    /// Output only. Creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time this resource was modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource was requested for deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource will be purged.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Allows users to store small amounts of arbitrary data.
    /// Both the key and the value must be 63 characters or less each.
    /// At most 100 annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields. This may be sent on update, undelete, and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Whether or not this CustomClass is in the process of being
    /// updated.
    pub reconciling: bool,

    /// Output only. The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the CustomClass is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which the CustomClass is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomClass {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomClass::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::CustomClass::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomClass::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CustomClass::state].
    pub fn set_state<T: std::convert::Into<crate::model::custom_class::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CustomClass::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CustomClass::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::CustomClass::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::CustomClass::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::CustomClass::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::CustomClass::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::CustomClass::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::CustomClass::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [items][crate::model::CustomClass::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_class::ClassItem>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::CustomClass::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CustomClass {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CustomClass"
    }
}

/// Defines additional types related to [CustomClass].
pub mod custom_class {
    #[allow(unused_imports)]
    use super::*;

    /// An item of the class.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClassItem {
        /// The class item's value.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClassItem {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::custom_class::ClassItem::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for ClassItem {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.CustomClass.ClassItem"
        }
    }

    /// Set of states that define the lifecycle of a CustomClass.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unspecified state.  This is only used/useful for distinguishing
        /// unset values.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The normal and active state.
        pub const ACTIVE: State = State::new(2);

        /// This CustomClass has been deleted.
        pub const DELETED: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                4 => std::borrow::Cow::Borrowed("DELETED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "DELETED" => std::option::Option::Some(Self::DELETED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// PhraseSet for biasing in speech recognition. A PhraseSet is used to provide
/// "hints" to the speech recognizer to favor specific words and phrases in the
/// results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PhraseSet {
    /// Output only. Identifier. The resource name of the PhraseSet.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System-assigned unique identifier for the PhraseSet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// A list of word and phrases.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub phrases: std::vec::Vec<crate::model::phrase_set::Phrase>,

    /// Hint Boost. Positive value will increase the probability that a specific
    /// phrase will be recognized over other similar sounding phrases. The higher
    /// the boost, the higher the chance of false positive recognition as well.
    /// Valid `boost` values are between 0 (exclusive) and 20. We recommend using a
    /// binary search approach to finding the optimal value for your use case as
    /// well as adding phrases both with and without boost to your requests.
    pub boost: f32,

    /// User-settable, human-readable name for the PhraseSet. Must be 63
    /// characters or less.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The PhraseSet lifecycle state.
    pub state: crate::model::phrase_set::State,

    /// Output only. Creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time this resource was modified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource was requested for deletion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource will be purged.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Allows users to store small amounts of arbitrary data.
    /// Both the key and the value must be 63 characters or less each.
    /// At most 100 annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields. This may be sent on update, undelete, and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Whether or not this PhraseSet is in the process of being
    /// updated.
    pub reconciling: bool,

    /// Output only. The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the PhraseSet is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    /// Output only. The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which the PhraseSet is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PhraseSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::PhraseSet::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [boost][crate::model::PhraseSet::boost].
    pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.boost = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PhraseSet::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PhraseSet::state].
    pub fn set_state<T: std::convert::Into<crate::model::phrase_set::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PhraseSet::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PhraseSet::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::PhraseSet::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::PhraseSet::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::PhraseSet::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::PhraseSet::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::PhraseSet::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::PhraseSet::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [phrases][crate::model::PhraseSet::phrases].
    pub fn set_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::phrase_set::Phrase>,
    {
        use std::iter::Iterator;
        self.phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::PhraseSet::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PhraseSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.PhraseSet"
    }
}

/// Defines additional types related to [PhraseSet].
pub mod phrase_set {
    #[allow(unused_imports)]
    use super::*;

    /// A Phrase contains words and phrase "hints" so that the speech recognition
    /// is more likely to recognize them. This can be used to improve the accuracy
    /// for specific words and phrases, for example, if specific commands are
    /// typically spoken by the user. This can also be used to add additional words
    /// to the vocabulary of the recognizer.
    ///
    /// List items can also include CustomClass references containing groups of
    /// words that represent common concepts that occur in natural language.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Phrase {
        /// The phrase itself.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        /// Hint Boost. Overrides the boost set at the phrase set level.
        /// Positive value will increase the probability that a specific phrase will
        /// be recognized over other similar sounding phrases. The higher the boost,
        /// the higher the chance of false positive recognition as well. Negative
        /// boost values would correspond to anti-biasing. Anti-biasing is not
        /// enabled, so negative boost values will return an error. Boost values must
        /// be between 0 and 20. Any values outside that range will return an error.
        /// We recommend using a binary search approach to finding the optimal value
        /// for your use case as well as adding phrases both with and without boost
        /// to your requests.
        pub boost: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Phrase {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::phrase_set::Phrase::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [boost][crate::model::phrase_set::Phrase::boost].
        pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.boost = v.into();
            self
        }
    }

    impl wkt::message::Message for Phrase {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.PhraseSet.Phrase"
        }
    }

    /// Set of states that define the lifecycle of a PhraseSet.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Unspecified state.  This is only used/useful for distinguishing
        /// unset values.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The normal and active state.
        pub const ACTIVE: State = State::new(2);

        /// This PhraseSet has been deleted.
        pub const DELETED: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                4 => std::borrow::Cow::Borrowed("DELETED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "DELETED" => std::option::Option::Some(Self::DELETED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request message for the
/// [CreateCustomClass][google.cloud.speech.v2.Speech.CreateCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.CreateCustomClass]: crate::client::Speech::create_custom_class
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCustomClassRequest {
    /// Required. The CustomClass to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_class: std::option::Option<crate::model::CustomClass>,

    /// If set, validate the request and preview the CustomClass, but do not
    /// actually create it.
    pub validate_only: bool,

    /// The ID to use for the CustomClass, which will become the final component of
    /// the CustomClass's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub custom_class_id: std::string::String,

    /// Required. The project and location where this CustomClass will be created.
    /// The expected format is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_class][crate::model::CreateCustomClassRequest::custom_class].
    pub fn set_custom_class<
        T: std::convert::Into<std::option::Option<crate::model::CustomClass>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.custom_class = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [custom_class_id][crate::model::CreateCustomClassRequest::custom_class_id].
    pub fn set_custom_class_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_class_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreateCustomClassRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CreateCustomClassRequest"
    }
}

/// Request message for the
/// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] method.
///
/// [google.cloud.speech.v2.Speech.ListCustomClasses]: crate::client::Speech::list_custom_classes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomClassesRequest {
    /// Required. The project and location of CustomClass resources to list. The
    /// expected format is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Number of results per requests. A valid page_size ranges from 0 to 100
    /// inclusive. If the page_size is zero or unspecified, a page size of 5 will
    /// be chosen. If the page size exceeds 100, it will be coerced down to 100.
    /// Note that a call might return fewer results than the requested page size.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] must
    /// match the call that provided the page token.
    ///
    /// [google.cloud.speech.v2.Speech.ListCustomClasses]: crate::client::Speech::list_custom_classes
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Whether, or not, to show resources that have been deleted.
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomClassesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomClassesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomClassesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomClassesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListCustomClassesRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomClassesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListCustomClassesRequest"
    }
}

/// Response message for the
/// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] method.
///
/// [google.cloud.speech.v2.Speech.ListCustomClasses]: crate::client::Speech::list_custom_classes
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCustomClassesResponse {
    /// The list of requested CustomClasses.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub custom_classes: std::vec::Vec<crate::model::CustomClass>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.speech.v2.ListCustomClassesRequest.page_token] to
    /// retrieve the next page. If this field is omitted, there are no subsequent
    /// pages. This token expires after 72 hours.
    ///
    /// [google.cloud.speech.v2.ListCustomClassesRequest.page_token]: crate::model::ListCustomClassesRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomClassesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomClassesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [custom_classes][crate::model::ListCustomClassesResponse::custom_classes].
    pub fn set_custom_classes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomClass>,
    {
        use std::iter::Iterator;
        self.custom_classes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCustomClassesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListCustomClassesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomClassesResponse {
    type PageItem = crate::model::CustomClass;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_classes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for the
/// [GetCustomClass][google.cloud.speech.v2.Speech.GetCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.GetCustomClass]: crate::client::Speech::get_custom_class
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCustomClassRequest {
    /// Required. The name of the CustomClass to retrieve. The expected format is
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomClassRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetCustomClassRequest"
    }
}

/// Request message for the
/// [UpdateCustomClass][google.cloud.speech.v2.Speech.UpdateCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.UpdateCustomClass]: crate::client::Speech::update_custom_class
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCustomClassRequest {
    /// Required. The CustomClass to update.
    ///
    /// The CustomClass's `name` field is used to identify the CustomClass to
    /// update. Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_class: std::option::Option<crate::model::CustomClass>,

    /// The list of fields to be updated. If empty, all fields are considered for
    /// update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the updated CustomClass, but do
    /// not actually update it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_class][crate::model::UpdateCustomClassRequest::custom_class].
    pub fn set_custom_class<
        T: std::convert::Into<std::option::Option<crate::model::CustomClass>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.custom_class = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCustomClassRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdateCustomClassRequest"
    }
}

/// Request message for the
/// [DeleteCustomClass][google.cloud.speech.v2.Speech.DeleteCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.DeleteCustomClass]: crate::client::Speech::delete_custom_class
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteCustomClassRequest {
    /// Required. The name of the CustomClass to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, validate the request and preview the deleted CustomClass, but do
    /// not actually delete it.
    pub validate_only: bool,

    /// If set to true, and the CustomClass is not found, the request will succeed
    /// and  be a no-op (no Operation is recorded in this case).
    pub allow_missing: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomClassRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteCustomClassRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteCustomClassRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.DeleteCustomClassRequest"
    }
}

/// Request message for the
/// [UndeleteCustomClass][google.cloud.speech.v2.Speech.UndeleteCustomClass]
/// method.
///
/// [google.cloud.speech.v2.Speech.UndeleteCustomClass]: crate::client::Speech::undelete_custom_class
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteCustomClassRequest {
    /// Required. The name of the CustomClass to undelete.
    /// Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, validate the request and preview the undeleted CustomClass, but do
    /// not actually undelete it.
    pub validate_only: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteCustomClassRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UndeleteCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UndeleteCustomClassRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UndeleteCustomClassRequest"
    }
}

/// Request message for the
/// [CreatePhraseSet][google.cloud.speech.v2.Speech.CreatePhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.CreatePhraseSet]: crate::client::Speech::create_phrase_set
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePhraseSetRequest {
    /// Required. The PhraseSet to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub phrase_set: std::option::Option<crate::model::PhraseSet>,

    /// If set, validate the request and preview the PhraseSet, but do not
    /// actually create it.
    pub validate_only: bool,

    /// The ID to use for the PhraseSet, which will become the final component of
    /// the PhraseSet's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub phrase_set_id: std::string::String,

    /// Required. The project and location where this PhraseSet will be created.
    /// The expected format is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_set][crate::model::CreatePhraseSetRequest::phrase_set].
    pub fn set_phrase_set<T: std::convert::Into<std::option::Option<crate::model::PhraseSet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.phrase_set = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreatePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [phrase_set_id][crate::model::CreatePhraseSetRequest::phrase_set_id].
    pub fn set_phrase_set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phrase_set_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreatePhraseSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreatePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CreatePhraseSetRequest"
    }
}

/// Request message for the
/// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] method.
///
/// [google.cloud.speech.v2.Speech.ListPhraseSets]: crate::client::Speech::list_phrase_sets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPhraseSetsRequest {
    /// Required. The project and location of PhraseSet resources to list. The
    /// expected format is `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of PhraseSets to return. The service may return fewer
    /// than this value. If unspecified, at most 5 PhraseSets will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] must match
    /// the call that provided the page token.
    ///
    /// [google.cloud.speech.v2.Speech.ListPhraseSets]: crate::client::Speech::list_phrase_sets
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Whether, or not, to show resources that have been deleted.
    pub show_deleted: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPhraseSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPhraseSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPhraseSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListPhraseSetsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListPhraseSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListPhraseSetsRequest"
    }
}

/// Response message for the
/// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] method.
///
/// [google.cloud.speech.v2.Speech.ListPhraseSets]: crate::client::Speech::list_phrase_sets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPhraseSetsResponse {
    /// The list of requested PhraseSets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub phrase_sets: std::vec::Vec<crate::model::PhraseSet>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.speech.v2.ListPhraseSetsRequest.page_token] to
    /// retrieve the next page. If this field is omitted, there are no subsequent
    /// pages. This token expires after 72 hours.
    ///
    /// [google.cloud.speech.v2.ListPhraseSetsRequest.page_token]: crate::model::ListPhraseSetsRequest::page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPhraseSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [phrase_sets][crate::model::ListPhraseSetsResponse::phrase_sets].
    pub fn set_phrase_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseSet>,
    {
        use std::iter::Iterator;
        self.phrase_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPhraseSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListPhraseSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPhraseSetsResponse {
    type PageItem = crate::model::PhraseSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.phrase_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for the
/// [GetPhraseSet][google.cloud.speech.v2.Speech.GetPhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.GetPhraseSet]: crate::client::Speech::get_phrase_set
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPhraseSetRequest {
    /// Required. The name of the PhraseSet to retrieve. The expected format is
    /// `projects/{project}/locations/{location}/phraseSets/{phrase_set}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPhraseSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetPhraseSetRequest"
    }
}

/// Request message for the
/// [UpdatePhraseSet][google.cloud.speech.v2.Speech.UpdatePhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.UpdatePhraseSet]: crate::client::Speech::update_phrase_set
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePhraseSetRequest {
    /// Required. The PhraseSet to update.
    ///
    /// The PhraseSet's `name` field is used to identify the PhraseSet to update.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub phrase_set: std::option::Option<crate::model::PhraseSet>,

    /// The list of fields to update. If empty, all non-default valued fields are
    /// considered for update. Use `*` to update the entire PhraseSet resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the updated PhraseSet, but do not
    /// actually update it.
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_set][crate::model::UpdatePhraseSetRequest::phrase_set].
    pub fn set_phrase_set<T: std::convert::Into<std::option::Option<crate::model::PhraseSet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.phrase_set = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePhraseSetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdatePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdatePhraseSetRequest"
    }
}

/// Request message for the
/// [DeletePhraseSet][google.cloud.speech.v2.Speech.DeletePhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.DeletePhraseSet]: crate::client::Speech::delete_phrase_set
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePhraseSetRequest {
    /// Required. The name of the PhraseSet to delete.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, validate the request and preview the deleted PhraseSet, but do not
    /// actually delete it.
    pub validate_only: bool,

    /// If set to true, and the PhraseSet is not found, the request will succeed
    /// and  be a no-op (no Operation is recorded in this case).
    pub allow_missing: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePhraseSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeletePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeletePhraseSetRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePhraseSetRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeletePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.DeletePhraseSetRequest"
    }
}

/// Request message for the
/// [UndeletePhraseSet][google.cloud.speech.v2.Speech.UndeletePhraseSet]
/// method.
///
/// [google.cloud.speech.v2.Speech.UndeletePhraseSet]: crate::client::Speech::undelete_phrase_set
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeletePhraseSetRequest {
    /// Required. The name of the PhraseSet to undelete.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// If set, validate the request and preview the undeleted PhraseSet, but do
    /// not actually undelete it.
    pub validate_only: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeletePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeletePhraseSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UndeletePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UndeletePhraseSetRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UndeletePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UndeletePhraseSetRequest"
    }
}

/// Representes a singular feature of a model. If the feature is `recognizer`,
/// the release_state of the feature represents the release_state of the model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelFeature {
    /// The name of the feature (Note: the feature can be `recognizer`)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub feature: std::string::String,

    /// The release state of the feature
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub release_state: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelFeature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature][crate::model::ModelFeature::feature].
    pub fn set_feature<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature = v.into();
        self
    }

    /// Sets the value of [release_state][crate::model::ModelFeature::release_state].
    pub fn set_release_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_state = v.into();
        self
    }
}

impl wkt::message::Message for ModelFeature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ModelFeature"
    }
}

/// Represents the collection of features belonging to a model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelFeatures {
    /// Repeated field that contains all features of the model
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub model_feature: std::vec::Vec<crate::model::ModelFeature>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_feature][crate::model::ModelFeatures::model_feature].
    pub fn set_model_feature<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelFeature>,
    {
        use std::iter::Iterator;
        self.model_feature = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModelFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ModelFeatures"
    }
}

/// The metadata about the models in a given region for a specific locale.
/// Currently this is just the features of the model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModelMetadata {
    /// Map of the model name -> features of that model
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub model_features: std::collections::HashMap<std::string::String, crate::model::ModelFeatures>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_features][crate::model::ModelMetadata::model_features].
    pub fn set_model_features<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ModelFeatures>,
    {
        use std::iter::Iterator;
        self.model_features = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ModelMetadata"
    }
}

/// The metadata about locales available in a given region. Currently this is
/// just the models that are available for each locale
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LanguageMetadata {
    /// Map of locale (language code) -> models
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub models: std::collections::HashMap<std::string::String, crate::model::ModelMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LanguageMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [models][crate::model::LanguageMetadata::models].
    pub fn set_models<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ModelMetadata>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for LanguageMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.LanguageMetadata"
    }
}

/// The access metadata for a particular region. This can be applied if the org
/// policy for the given project disallows a particular region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessMetadata {
    /// Describes the different types of constraints that are applied.
    pub constraint_type: crate::model::access_metadata::ConstraintType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraint_type][crate::model::AccessMetadata::constraint_type].
    pub fn set_constraint_type<
        T: std::convert::Into<crate::model::access_metadata::ConstraintType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = v.into();
        self
    }
}

impl wkt::message::Message for AccessMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.AccessMetadata"
    }
}

/// Defines additional types related to [AccessMetadata].
pub mod access_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the different types of constraints that can be applied on a
    /// region.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ConstraintType(i32);

    impl ConstraintType {
        /// Unspecified constraint applied.
        pub const CONSTRAINT_TYPE_UNSPECIFIED: ConstraintType = ConstraintType::new(0);

        /// The project's org policy disallows the given region.
        pub const RESOURCE_LOCATIONS_ORG_POLICY_CREATE_CONSTRAINT: ConstraintType =
            ConstraintType::new(1);

        /// Creates a new ConstraintType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CONSTRAINT_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("RESOURCE_LOCATIONS_ORG_POLICY_CREATE_CONSTRAINT"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CONSTRAINT_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CONSTRAINT_TYPE_UNSPECIFIED)
                }
                "RESOURCE_LOCATIONS_ORG_POLICY_CREATE_CONSTRAINT" => {
                    std::option::Option::Some(Self::RESOURCE_LOCATIONS_ORG_POLICY_CREATE_CONSTRAINT)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ConstraintType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ConstraintType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Main metadata for the Locations API for STT V2. Currently this is just the
/// metadata about locales, models, and features
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationsMetadata {
    /// Information about available locales, models, and features represented in
    /// the hierarchical structure of locales -> models -> features
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub languages: std::option::Option<crate::model::LanguageMetadata>,

    /// Information about access metadata for the region and given project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub access_metadata: std::option::Option<crate::model::AccessMetadata>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [languages][crate::model::LocationsMetadata::languages].
    pub fn set_languages<
        T: std::convert::Into<std::option::Option<crate::model::LanguageMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.languages = v.into();
        self
    }

    /// Sets the value of [access_metadata][crate::model::LocationsMetadata::access_metadata].
    pub fn set_access_metadata<
        T: std::convert::Into<std::option::Option<crate::model::AccessMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_metadata = v.into();
        self
    }
}

impl wkt::message::Message for LocationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.LocationsMetadata"
    }
}
