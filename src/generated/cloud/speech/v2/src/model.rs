// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for the
/// [CreateRecognizer][google.cloud.speech.v2.Speech.CreateRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.CreateRecognizer]: crate::client::Speech::create_recognizer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRecognizerRequest {
    /// Required. The Recognizer to create.
    pub recognizer: std::option::Option<crate::model::Recognizer>,

    /// If set, validate the request and preview the Recognizer, but do not
    /// actually create it.
    pub validate_only: bool,

    /// The ID to use for the Recognizer, which will become the final component of
    /// the Recognizer's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    pub recognizer_id: std::string::String,

    /// Required. The project and location where this Recognizer will be created.
    /// The expected format is `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::CreateRecognizerRequest::recognizer].
    pub fn set_recognizer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Recognizer>,
    {
        self.recognizer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recognizer][crate::model::CreateRecognizerRequest::recognizer].
    pub fn set_or_clear_recognizer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Recognizer>,
    {
        self.recognizer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [recognizer_id][crate::model::CreateRecognizerRequest::recognizer_id].
    pub fn set_recognizer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreateRecognizerRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CreateRecognizerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRecognizerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognizer,
            __validate_only,
            __recognizer_id,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRecognizerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognizer" => Ok(__FieldTag::__recognizer),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "recognizerId" => Ok(__FieldTag::__recognizer_id),
                            "recognizer_id" => Ok(__FieldTag::__recognizer_id),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRecognizerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRecognizerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognizer => {
                            if !fields.insert(__FieldTag::__recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognizer",
                                ));
                            }
                            result.recognizer =
                                map.next_value::<std::option::Option<crate::model::Recognizer>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recognizer_id => {
                            if !fields.insert(__FieldTag::__recognizer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognizer_id",
                                ));
                            }
                            result.recognizer_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRecognizerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.recognizer.is_some() {
            state.serialize_entry("recognizer", &self.recognizer)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.recognizer_id.is_empty() {
            state.serialize_entry("recognizerId", &self.recognizer_id)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of a long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource path for the target of the operation.
    pub resource: std::string::String,

    /// The method that triggered the operation.
    pub method: std::string::String,

    /// The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the content of the Operation is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    pub kms_key_name: std::string::String,

    /// The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which content of the Operation is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    pub kms_key_version_name: std::string::String,

    /// The percent progress of the Operation. Values can range from 0-100. If the
    /// value is 100, then the operation is finished.
    pub progress_percent: i32,

    /// The request that spawned the Operation.
    pub request: std::option::Option<crate::model::operation_metadata::Request>,

    /// Specific metadata per RPC.
    pub metadata: std::option::Option<crate::model::operation_metadata::Metadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::OperationMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::OperationMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource][crate::model::OperationMetadata::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [method][crate::model::OperationMetadata::method].
    pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::OperationMetadata::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::OperationMetadata::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }

    /// Sets the value of [progress_percent][crate::model::OperationMetadata::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::operation_metadata::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `BatchRecognizeRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn batch_recognize_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BatchRecognizeRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::BatchRecognizeRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `BatchRecognizeRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_batch_recognize_request<
        T: std::convert::Into<std::boxed::Box<crate::model::BatchRecognizeRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::BatchRecognizeRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `CreateRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::CreateRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `CreateRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::CreateRecognizerRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdateRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdateRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdateRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdateRecognizerRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `DeleteRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeleteRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::DeleteRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `DeleteRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeleteRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::DeleteRecognizerRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UndeleteRecognizerRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn undelete_recognizer_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UndeleteRecognizerRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UndeleteRecognizerRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UndeleteRecognizerRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_undelete_recognizer_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UndeleteRecognizerRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UndeleteRecognizerRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `CreateCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreateCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::CreateCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `CreateCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreateCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::CreateCustomClassRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdateCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdateCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdateCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdateCustomClassRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `DeleteCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeleteCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::DeleteCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `DeleteCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeleteCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::DeleteCustomClassRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UndeleteCustomClassRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn undelete_custom_class_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UndeleteCustomClassRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UndeleteCustomClassRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UndeleteCustomClassRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_undelete_custom_class_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UndeleteCustomClassRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UndeleteCustomClassRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `CreatePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn create_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreatePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::CreatePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `CreatePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_create_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::CreatePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::CreatePhraseSetRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdatePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn update_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdatePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdatePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdatePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_update_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdatePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdatePhraseSetRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `DeletePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DeletePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::DeletePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `DeletePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_delete_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::DeletePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::DeletePhraseSetRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UndeletePhraseSetRequest`, `None` if the field is not set or
    /// holds a different branch.
    pub fn undelete_phrase_set_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UndeletePhraseSetRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UndeletePhraseSetRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UndeletePhraseSetRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_undelete_phrase_set_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UndeletePhraseSetRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UndeletePhraseSetRequest(v.into()),
        );
        self
    }

    /// The value of [request][crate::model::OperationMetadata::request]
    /// if it holds a `UpdateConfigRequest`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn update_config_request(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UpdateConfigRequest>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Request::UpdateConfigRequest(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::OperationMetadata::request]
    /// to hold a `UpdateConfigRequest`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_update_config_request<
        T: std::convert::Into<std::boxed::Box<crate::model::UpdateConfigRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = std::option::Option::Some(
            crate::model::operation_metadata::Request::UpdateConfigRequest(v.into()),
        );
        self
    }

    /// Sets the value of [metadata][crate::model::OperationMetadata::metadata].
    ///
    /// Note that all the setters affecting `metadata` are mutually
    /// exclusive.
    pub fn set_metadata<
        T: std::convert::Into<std::option::Option<crate::model::operation_metadata::Metadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }

    /// The value of [metadata][crate::model::OperationMetadata::metadata]
    /// if it holds a `BatchRecognizeMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn batch_recognize_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BatchRecognizeMetadata>> {
        #[allow(unreachable_patterns)]
        self.metadata.as_ref().and_then(|v| match v {
            crate::model::operation_metadata::Metadata::BatchRecognizeMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metadata][crate::model::OperationMetadata::metadata]
    /// to hold a `BatchRecognizeMetadata`.
    ///
    /// Note that all the setters affecting `metadata` are
    /// mutually exclusive.
    pub fn set_batch_recognize_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::BatchRecognizeMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = std::option::Option::Some(
            crate::model::operation_metadata::Metadata::BatchRecognizeMetadata(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __resource,
            __method,
            __kms_key_name,
            __kms_key_version_name,
            __batch_recognize_request,
            __create_recognizer_request,
            __update_recognizer_request,
            __delete_recognizer_request,
            __undelete_recognizer_request,
            __create_custom_class_request,
            __update_custom_class_request,
            __delete_custom_class_request,
            __undelete_custom_class_request,
            __create_phrase_set_request,
            __update_phrase_set_request,
            __delete_phrase_set_request,
            __undelete_phrase_set_request,
            __update_config_request,
            __progress_percent,
            __batch_recognize_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "resource" => Ok(__FieldTag::__resource),
                            "method" => Ok(__FieldTag::__method),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            "batchRecognizeRequest" => Ok(__FieldTag::__batch_recognize_request),
                            "batch_recognize_request" => Ok(__FieldTag::__batch_recognize_request),
                            "createRecognizerRequest" => {
                                Ok(__FieldTag::__create_recognizer_request)
                            }
                            "create_recognizer_request" => {
                                Ok(__FieldTag::__create_recognizer_request)
                            }
                            "updateRecognizerRequest" => {
                                Ok(__FieldTag::__update_recognizer_request)
                            }
                            "update_recognizer_request" => {
                                Ok(__FieldTag::__update_recognizer_request)
                            }
                            "deleteRecognizerRequest" => {
                                Ok(__FieldTag::__delete_recognizer_request)
                            }
                            "delete_recognizer_request" => {
                                Ok(__FieldTag::__delete_recognizer_request)
                            }
                            "undeleteRecognizerRequest" => {
                                Ok(__FieldTag::__undelete_recognizer_request)
                            }
                            "undelete_recognizer_request" => {
                                Ok(__FieldTag::__undelete_recognizer_request)
                            }
                            "createCustomClassRequest" => {
                                Ok(__FieldTag::__create_custom_class_request)
                            }
                            "create_custom_class_request" => {
                                Ok(__FieldTag::__create_custom_class_request)
                            }
                            "updateCustomClassRequest" => {
                                Ok(__FieldTag::__update_custom_class_request)
                            }
                            "update_custom_class_request" => {
                                Ok(__FieldTag::__update_custom_class_request)
                            }
                            "deleteCustomClassRequest" => {
                                Ok(__FieldTag::__delete_custom_class_request)
                            }
                            "delete_custom_class_request" => {
                                Ok(__FieldTag::__delete_custom_class_request)
                            }
                            "undeleteCustomClassRequest" => {
                                Ok(__FieldTag::__undelete_custom_class_request)
                            }
                            "undelete_custom_class_request" => {
                                Ok(__FieldTag::__undelete_custom_class_request)
                            }
                            "createPhraseSetRequest" => Ok(__FieldTag::__create_phrase_set_request),
                            "create_phrase_set_request" => {
                                Ok(__FieldTag::__create_phrase_set_request)
                            }
                            "updatePhraseSetRequest" => Ok(__FieldTag::__update_phrase_set_request),
                            "update_phrase_set_request" => {
                                Ok(__FieldTag::__update_phrase_set_request)
                            }
                            "deletePhraseSetRequest" => Ok(__FieldTag::__delete_phrase_set_request),
                            "delete_phrase_set_request" => {
                                Ok(__FieldTag::__delete_phrase_set_request)
                            }
                            "undeletePhraseSetRequest" => {
                                Ok(__FieldTag::__undelete_phrase_set_request)
                            }
                            "undelete_phrase_set_request" => {
                                Ok(__FieldTag::__undelete_phrase_set_request)
                            }
                            "updateConfigRequest" => Ok(__FieldTag::__update_config_request),
                            "update_config_request" => Ok(__FieldTag::__update_config_request),
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "batchRecognizeMetadata" => Ok(__FieldTag::__batch_recognize_metadata),
                            "batch_recognize_metadata" => {
                                Ok(__FieldTag::__batch_recognize_metadata)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__method => {
                            if !fields.insert(__FieldTag::__method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method",
                                ));
                            }
                            result.method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__batch_recognize_request => {
                            if !fields.insert(__FieldTag::__batch_recognize_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_recognize_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.batch_recognize_request, latest field was batchRecognizeRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::BatchRecognizeRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BatchRecognizeRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_recognizer_request => {
                            if !fields.insert(__FieldTag::__create_recognizer_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_recognizer_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.create_recognizer_request, latest field was createRecognizerRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::CreateRecognizerRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreateRecognizerRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_recognizer_request => {
                            if !fields.insert(__FieldTag::__update_recognizer_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_recognizer_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.update_recognizer_request, latest field was updateRecognizerRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::UpdateRecognizerRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpdateRecognizerRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delete_recognizer_request => {
                            if !fields.insert(__FieldTag::__delete_recognizer_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_recognizer_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.delete_recognizer_request, latest field was deleteRecognizerRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::DeleteRecognizerRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeleteRecognizerRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__undelete_recognizer_request => {
                            if !fields.insert(__FieldTag::__undelete_recognizer_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for undelete_recognizer_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.undelete_recognizer_request, latest field was undeleteRecognizerRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::UndeleteRecognizerRequest(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::UndeleteRecognizerRequest>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__create_custom_class_request => {
                            if !fields.insert(__FieldTag::__create_custom_class_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_custom_class_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.create_custom_class_request, latest field was createCustomClassRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::CreateCustomClassRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreateCustomClassRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_custom_class_request => {
                            if !fields.insert(__FieldTag::__update_custom_class_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_custom_class_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.update_custom_class_request, latest field was updateCustomClassRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::UpdateCustomClassRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpdateCustomClassRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delete_custom_class_request => {
                            if !fields.insert(__FieldTag::__delete_custom_class_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_custom_class_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.delete_custom_class_request, latest field was deleteCustomClassRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::DeleteCustomClassRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeleteCustomClassRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__undelete_custom_class_request => {
                            if !fields.insert(__FieldTag::__undelete_custom_class_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for undelete_custom_class_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.undelete_custom_class_request, latest field was undeleteCustomClassRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::UndeleteCustomClassRequest(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::UndeleteCustomClassRequest>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__create_phrase_set_request => {
                            if !fields.insert(__FieldTag::__create_phrase_set_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_phrase_set_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.create_phrase_set_request, latest field was createPhraseSetRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::CreatePhraseSetRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreatePhraseSetRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_phrase_set_request => {
                            if !fields.insert(__FieldTag::__update_phrase_set_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_phrase_set_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.update_phrase_set_request, latest field was updatePhraseSetRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::UpdatePhraseSetRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpdatePhraseSetRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delete_phrase_set_request => {
                            if !fields.insert(__FieldTag::__delete_phrase_set_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_phrase_set_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.delete_phrase_set_request, latest field was deletePhraseSetRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::DeletePhraseSetRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DeletePhraseSetRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__undelete_phrase_set_request => {
                            if !fields.insert(__FieldTag::__undelete_phrase_set_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for undelete_phrase_set_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.undelete_phrase_set_request, latest field was undeletePhraseSetRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::UndeletePhraseSetRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UndeletePhraseSetRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_config_request => {
                            if !fields.insert(__FieldTag::__update_config_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_config_request",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.update_config_request, latest field was updateConfigRequest",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::operation_metadata::Request::UpdateConfigRequest(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UpdateConfigRequest>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__batch_recognize_metadata => {
                            if !fields.insert(__FieldTag::__batch_recognize_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_recognize_metadata",
                                ));
                            }
                            if result.metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metadata`, a oneof with full ID .google.cloud.speech.v2.OperationMetadata.batch_recognize_metadata, latest field was batchRecognizeMetadata",
                                ));
                            }
                            result.metadata = std::option::Option::Some(
                                crate::model::operation_metadata::Metadata::BatchRecognizeMetadata(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BatchRecognizeMetadata>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self.method.is_empty() {
            state.serialize_entry("method", &self.method)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if let Some(value) = self.batch_recognize_request() {
            state.serialize_entry("batchRecognizeRequest", value)?;
        }
        if let Some(value) = self.create_recognizer_request() {
            state.serialize_entry("createRecognizerRequest", value)?;
        }
        if let Some(value) = self.update_recognizer_request() {
            state.serialize_entry("updateRecognizerRequest", value)?;
        }
        if let Some(value) = self.delete_recognizer_request() {
            state.serialize_entry("deleteRecognizerRequest", value)?;
        }
        if let Some(value) = self.undelete_recognizer_request() {
            state.serialize_entry("undeleteRecognizerRequest", value)?;
        }
        if let Some(value) = self.create_custom_class_request() {
            state.serialize_entry("createCustomClassRequest", value)?;
        }
        if let Some(value) = self.update_custom_class_request() {
            state.serialize_entry("updateCustomClassRequest", value)?;
        }
        if let Some(value) = self.delete_custom_class_request() {
            state.serialize_entry("deleteCustomClassRequest", value)?;
        }
        if let Some(value) = self.undelete_custom_class_request() {
            state.serialize_entry("undeleteCustomClassRequest", value)?;
        }
        if let Some(value) = self.create_phrase_set_request() {
            state.serialize_entry("createPhraseSetRequest", value)?;
        }
        if let Some(value) = self.update_phrase_set_request() {
            state.serialize_entry("updatePhraseSetRequest", value)?;
        }
        if let Some(value) = self.delete_phrase_set_request() {
            state.serialize_entry("deletePhraseSetRequest", value)?;
        }
        if let Some(value) = self.undelete_phrase_set_request() {
            state.serialize_entry("undeletePhraseSetRequest", value)?;
        }
        if let Some(value) = self.update_config_request() {
            state.serialize_entry("updateConfigRequest", value)?;
        }
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if let Some(value) = self.batch_recognize_metadata() {
            state.serialize_entry("batchRecognizeMetadata", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The request that spawned the Operation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Request {
        /// The BatchRecognizeRequest that spawned the Operation.
        BatchRecognizeRequest(std::boxed::Box<crate::model::BatchRecognizeRequest>),
        /// The CreateRecognizerRequest that spawned the Operation.
        CreateRecognizerRequest(std::boxed::Box<crate::model::CreateRecognizerRequest>),
        /// The UpdateRecognizerRequest that spawned the Operation.
        UpdateRecognizerRequest(std::boxed::Box<crate::model::UpdateRecognizerRequest>),
        /// The DeleteRecognizerRequest that spawned the Operation.
        DeleteRecognizerRequest(std::boxed::Box<crate::model::DeleteRecognizerRequest>),
        /// The UndeleteRecognizerRequest that spawned the Operation.
        UndeleteRecognizerRequest(std::boxed::Box<crate::model::UndeleteRecognizerRequest>),
        /// The CreateCustomClassRequest that spawned the Operation.
        CreateCustomClassRequest(std::boxed::Box<crate::model::CreateCustomClassRequest>),
        /// The UpdateCustomClassRequest that spawned the Operation.
        UpdateCustomClassRequest(std::boxed::Box<crate::model::UpdateCustomClassRequest>),
        /// The DeleteCustomClassRequest that spawned the Operation.
        DeleteCustomClassRequest(std::boxed::Box<crate::model::DeleteCustomClassRequest>),
        /// The UndeleteCustomClassRequest that spawned the Operation.
        UndeleteCustomClassRequest(std::boxed::Box<crate::model::UndeleteCustomClassRequest>),
        /// The CreatePhraseSetRequest that spawned the Operation.
        CreatePhraseSetRequest(std::boxed::Box<crate::model::CreatePhraseSetRequest>),
        /// The UpdatePhraseSetRequest that spawned the Operation.
        UpdatePhraseSetRequest(std::boxed::Box<crate::model::UpdatePhraseSetRequest>),
        /// The DeletePhraseSetRequest that spawned the Operation.
        DeletePhraseSetRequest(std::boxed::Box<crate::model::DeletePhraseSetRequest>),
        /// The UndeletePhraseSetRequest that spawned the Operation.
        UndeletePhraseSetRequest(std::boxed::Box<crate::model::UndeletePhraseSetRequest>),
        /// The UpdateConfigRequest that spawned the Operation.
        #[deprecated]
        UpdateConfigRequest(std::boxed::Box<crate::model::UpdateConfigRequest>),
    }

    /// Specific metadata per RPC.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Metadata {
        /// Metadata specific to the BatchRecognize method.
        BatchRecognizeMetadata(std::boxed::Box<crate::model::BatchRecognizeMetadata>),
    }
}

/// Request message for the
/// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] method.
///
/// [google.cloud.speech.v2.Speech.ListRecognizers]: crate::client::Speech::list_recognizers
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRecognizersRequest {
    /// Required. The project and location of Recognizers to list. The expected
    /// format is `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of Recognizers to return. The service may return fewer
    /// than this value. If unspecified, at most 5 Recognizers will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] must match
    /// the call that provided the page token.
    ///
    /// [google.cloud.speech.v2.Speech.ListRecognizers]: crate::client::Speech::list_recognizers
    pub page_token: std::string::String,

    /// Whether, or not, to show resources that have been deleted.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecognizersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRecognizersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRecognizersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRecognizersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListRecognizersRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListRecognizersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListRecognizersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRecognizersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRecognizersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRecognizersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRecognizersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRecognizersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the
/// [ListRecognizers][google.cloud.speech.v2.Speech.ListRecognizers] method.
///
/// [google.cloud.speech.v2.Speech.ListRecognizers]: crate::client::Speech::list_recognizers
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRecognizersResponse {
    /// The list of requested Recognizers.
    pub recognizers: std::vec::Vec<crate::model::Recognizer>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.speech.v2.ListRecognizersRequest.page_token] to
    /// retrieve the next page. If this field is omitted, there are no subsequent
    /// pages. This token expires after 72 hours.
    ///
    /// [google.cloud.speech.v2.ListRecognizersRequest.page_token]: crate::model::ListRecognizersRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRecognizersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizers][crate::model::ListRecognizersResponse::recognizers].
    pub fn set_recognizers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Recognizer>,
    {
        use std::iter::Iterator;
        self.recognizers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRecognizersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRecognizersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListRecognizersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRecognizersResponse {
    type PageItem = crate::model::Recognizer;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.recognizers
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRecognizersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognizers,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRecognizersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognizers" => Ok(__FieldTag::__recognizers),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRecognizersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRecognizersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognizers => {
                            if !fields.insert(__FieldTag::__recognizers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognizers",
                                ));
                            }
                            result.recognizers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Recognizer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRecognizersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.recognizers.is_empty() {
            state.serialize_entry("recognizers", &self.recognizers)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [GetRecognizer][google.cloud.speech.v2.Speech.GetRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.GetRecognizer]: crate::client::Speech::get_recognizer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRecognizerRequest {
    /// Required. The name of the Recognizer to retrieve. The expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRecognizerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetRecognizerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRecognizerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRecognizerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRecognizerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRecognizerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRecognizerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [UpdateRecognizer][google.cloud.speech.v2.Speech.UpdateRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.UpdateRecognizer]: crate::client::Speech::update_recognizer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRecognizerRequest {
    /// Required. The Recognizer to update.
    ///
    /// The Recognizer's `name` field is used to identify the Recognizer to update.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    pub recognizer: std::option::Option<crate::model::Recognizer>,

    /// The list of fields to update. If empty, all non-default valued fields are
    /// considered for update. Use `*` to update the entire Recognizer resource.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the updated Recognizer, but do not
    /// actually update it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::UpdateRecognizerRequest::recognizer].
    pub fn set_recognizer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Recognizer>,
    {
        self.recognizer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recognizer][crate::model::UpdateRecognizerRequest::recognizer].
    pub fn set_or_clear_recognizer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Recognizer>,
    {
        self.recognizer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRecognizerRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRecognizerRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdateRecognizerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRecognizerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognizer,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRecognizerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognizer" => Ok(__FieldTag::__recognizer),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRecognizerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRecognizerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognizer => {
                            if !fields.insert(__FieldTag::__recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognizer",
                                ));
                            }
                            result.recognizer =
                                map.next_value::<std::option::Option<crate::model::Recognizer>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRecognizerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.recognizer.is_some() {
            state.serialize_entry("recognizer", &self.recognizer)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [DeleteRecognizer][google.cloud.speech.v2.Speech.DeleteRecognizer] method.
///
/// [google.cloud.speech.v2.Speech.DeleteRecognizer]: crate::client::Speech::delete_recognizer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRecognizerRequest {
    /// Required. The name of the Recognizer to delete.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`
    pub name: std::string::String,

    /// If set, validate the request and preview the deleted Recognizer, but do not
    /// actually delete it.
    pub validate_only: bool,

    /// If set to true, and the Recognizer is not found, the request will succeed
    /// and  be a no-op (no Operation is recorded in this case).
    pub allow_missing: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRecognizerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteRecognizerRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRecognizerRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.DeleteRecognizerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRecognizerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __allow_missing,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRecognizerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRecognizerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRecognizerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRecognizerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [UndeleteRecognizer][google.cloud.speech.v2.Speech.UndeleteRecognizer]
/// method.
///
/// [google.cloud.speech.v2.Speech.UndeleteRecognizer]: crate::client::Speech::undelete_recognizer
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteRecognizerRequest {
    /// Required. The name of the Recognizer to undelete.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`
    pub name: std::string::String,

    /// If set, validate the request and preview the undeleted Recognizer, but do
    /// not actually undelete it.
    pub validate_only: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteRecognizerRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteRecognizerRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UndeleteRecognizerRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UndeleteRecognizerRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteRecognizerRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UndeleteRecognizerRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteRecognizerRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteRecognizerRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteRecognizerRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteRecognizerRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteRecognizerRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Recognizer message. Stores recognition configuration and metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Recognizer {
    /// Output only. Identifier. The resource name of the Recognizer.
    /// Format: `projects/{project}/locations/{location}/recognizers/{recognizer}`.
    pub name: std::string::String,

    /// Output only. System-assigned unique identifier for the Recognizer.
    pub uid: std::string::String,

    /// User-settable, human-readable name for the Recognizer. Must be 63
    /// characters or less.
    pub display_name: std::string::String,

    /// Optional. This field is now deprecated. Prefer the
    /// [`model`][google.cloud.speech.v2.RecognitionConfig.model] field in the
    /// [`RecognitionConfig`][google.cloud.speech.v2.RecognitionConfig] message.
    ///
    /// Which model to use for recognition requests. Select the model best suited
    /// to your domain to get best results.
    ///
    /// Guidance for choosing which model to use can be found in the [Transcription
    /// Models
    /// Documentation](https://cloud.google.com/speech-to-text/v2/docs/transcription-model)
    /// and the models supported in each region can be found in the [Table Of
    /// Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    ///
    /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
    /// [google.cloud.speech.v2.RecognitionConfig.model]: crate::model::RecognitionConfig::model
    #[deprecated]
    pub model: std::string::String,

    /// Optional. This field is now deprecated. Prefer the
    /// [`language_codes`][google.cloud.speech.v2.RecognitionConfig.language_codes]
    /// field in the
    /// [`RecognitionConfig`][google.cloud.speech.v2.RecognitionConfig] message.
    ///
    /// The language of the supplied audio as a
    /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
    ///
    /// Supported languages for each model are listed in the [Table of Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    ///
    /// If additional languages are provided, recognition result will contain
    /// recognition in the most likely language detected. The recognition result
    /// will include the language tag of the language detected in the audio.
    /// When you create or update a Recognizer, these values are
    /// stored in normalized BCP-47 form. For example, "en-us" is stored as
    /// "en-US".
    ///
    /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
    /// [google.cloud.speech.v2.RecognitionConfig.language_codes]: crate::model::RecognitionConfig::language_codes
    #[deprecated]
    pub language_codes: std::vec::Vec<std::string::String>,

    /// Default configuration to use for requests with this Recognizer.
    /// This can be overwritten by inline configuration in the
    /// [RecognizeRequest.config][google.cloud.speech.v2.RecognizeRequest.config]
    /// field.
    ///
    /// [google.cloud.speech.v2.RecognizeRequest.config]: crate::model::RecognizeRequest::config
    pub default_recognition_config: std::option::Option<crate::model::RecognitionConfig>,

    /// Allows users to store small amounts of arbitrary data.
    /// Both the key and the value must be 63 characters or less each.
    /// At most 100 annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The Recognizer lifecycle state.
    pub state: crate::model::recognizer::State,

    /// Output only. Creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time this Recognizer was modified.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this Recognizer was requested for deletion.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this Recognizer will be purged.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields. This may be sent on update, undelete, and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. Whether or not this Recognizer is in the process of being
    /// updated.
    pub reconciling: bool,

    /// Output only. The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the Recognizer is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    pub kms_key_name: std::string::String,

    /// Output only. The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which the Recognizer is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    pub kms_key_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Recognizer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Recognizer::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Recognizer::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Recognizer::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model][crate::model::Recognizer::model].
    #[deprecated]
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [language_codes][crate::model::Recognizer::language_codes].
    #[deprecated]
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_recognition_config][crate::model::Recognizer::default_recognition_config].
    pub fn set_default_recognition_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.default_recognition_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_recognition_config][crate::model::Recognizer::default_recognition_config].
    pub fn set_or_clear_default_recognition_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.default_recognition_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::Recognizer::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Recognizer::state].
    pub fn set_state<T: std::convert::Into<crate::model::recognizer::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Recognizer::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Recognizer::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Recognizer::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Recognizer::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Recognizer::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Recognizer::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::Recognizer::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Recognizer::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Recognizer::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Recognizer::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Recognizer::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::Recognizer::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }
}

impl wkt::message::Message for Recognizer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.Recognizer"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Recognizer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __display_name,
            __model,
            __language_codes,
            __default_recognition_config,
            __annotations,
            __state,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __etag,
            __reconciling,
            __kms_key_name,
            __kms_key_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Recognizer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "model" => Ok(__FieldTag::__model),
                            "languageCodes" => Ok(__FieldTag::__language_codes),
                            "language_codes" => Ok(__FieldTag::__language_codes),
                            "defaultRecognitionConfig" => {
                                Ok(__FieldTag::__default_recognition_config)
                            }
                            "default_recognition_config" => {
                                Ok(__FieldTag::__default_recognition_config)
                            }
                            "annotations" => Ok(__FieldTag::__annotations),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Recognizer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Recognizer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_codes => {
                            if !fields.insert(__FieldTag::__language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes",
                                ));
                            }
                            result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_recognition_config => {
                            if !fields.insert(__FieldTag::__default_recognition_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_recognition_config",
                                ));
                            }
                            result.default_recognition_config = map
                                .next_value::<std::option::Option<crate::model::RecognitionConfig>>(
                                )?;
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::recognizer::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Recognizer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.language_codes.is_empty() {
            state.serialize_entry("languageCodes", &self.language_codes)?;
        }
        if self.default_recognition_config.is_some() {
            state.serialize_entry("defaultRecognitionConfig", &self.default_recognition_config)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Recognizer].
pub mod recognizer {
    #[allow(unused_imports)]
    use super::*;

    /// Set of states that define the lifecycle of a Recognizer.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified,
        /// The Recognizer is active and ready for use.
        Active,
        /// This Recognizer has been deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Active,
                4 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.speech.v2.Recognizer.State",
            ))
        }
    }
}

/// Automatically detected decoding parameters.
/// Supported for the following encodings:
///
/// * WAV_LINEAR16: 16-bit signed little-endian PCM samples in a WAV container.
///
/// * WAV_MULAW: 8-bit companded mulaw samples in a WAV container.
///
/// * WAV_ALAW: 8-bit companded alaw samples in a WAV container.
///
/// * RFC4867_5_AMR: AMR frames with an rfc4867.5 header.
///
/// * RFC4867_5_AMRWB: AMR-WB frames with an rfc4867.5 header.
///
/// * FLAC: FLAC frames in the "native FLAC" container format.
///
/// * MP3: MPEG audio frames with optional (ignored) ID3 metadata.
///
/// * OGG_OPUS: Opus audio frames in an Ogg container.
///
/// * WEBM_OPUS: Opus audio frames in a WebM container.
///
/// * MP4_AAC: AAC audio frames in an MP4 container.
///
/// * M4A_AAC: AAC audio frames in an M4A container.
///
/// * MOV_AAC: AAC audio frames in an MOV container.
///
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoDetectDecodingConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoDetectDecodingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AutoDetectDecodingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.AutoDetectDecodingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoDetectDecodingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoDetectDecodingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoDetectDecodingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoDetectDecodingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoDetectDecodingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Explicitly specified decoding parameters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExplicitDecodingConfig {
    /// Required. Encoding of the audio data sent for recognition.
    pub encoding: crate::model::explicit_decoding_config::AudioEncoding,

    /// Optional. Sample rate in Hertz of the audio data sent for recognition.
    /// Valid values are: 8000-48000, and 16000 is optimal. For best results, set
    /// the sampling rate of the audio source to 16000 Hz. If that's not possible,
    /// use the native sample rate of the audio source (instead of resampling).
    /// Note that this field is marked as OPTIONAL for backward compatibility
    /// reasons. It is (and has always been) effectively REQUIRED.
    pub sample_rate_hertz: i32,

    /// Optional. Number of channels present in the audio data sent for
    /// recognition. Note that this field is marked as OPTIONAL for backward
    /// compatibility reasons. It is (and has always been) effectively REQUIRED.
    ///
    /// The maximum allowed value is 8.
    pub audio_channel_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExplicitDecodingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encoding][crate::model::ExplicitDecodingConfig::encoding].
    pub fn set_encoding<
        T: std::convert::Into<crate::model::explicit_decoding_config::AudioEncoding>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::ExplicitDecodingConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [audio_channel_count][crate::model::ExplicitDecodingConfig::audio_channel_count].
    pub fn set_audio_channel_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.audio_channel_count = v.into();
        self
    }
}

impl wkt::message::Message for ExplicitDecodingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ExplicitDecodingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExplicitDecodingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encoding,
            __sample_rate_hertz,
            __audio_channel_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExplicitDecodingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encoding" => Ok(__FieldTag::__encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "audioChannelCount" => Ok(__FieldTag::__audio_channel_count),
                            "audio_channel_count" => Ok(__FieldTag::__audio_channel_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExplicitDecodingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExplicitDecodingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encoding => {
                            if !fields.insert(__FieldTag::__encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding",
                                ));
                            }
                            result.encoding = map
                                .next_value::<std::option::Option<
                                    crate::model::explicit_decoding_config::AudioEncoding,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__audio_channel_count => {
                            if !fields.insert(__FieldTag::__audio_channel_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_channel_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_channel_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExplicitDecodingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.encoding) {
            state.serialize_entry("encoding", &self.encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !wkt::internal::is_default(&self.audio_channel_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audioChannelCount", &__With(&self.audio_channel_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExplicitDecodingConfig].
pub mod explicit_decoding_config {
    #[allow(unused_imports)]
    use super::*;

    /// Supported audio data encodings.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AudioEncoding {
        /// Default value. This value is unused.
        Unspecified,
        /// Headerless 16-bit signed little-endian PCM samples.
        Linear16,
        /// Headerless 8-bit companded mulaw samples.
        Mulaw,
        /// Headerless 8-bit companded alaw samples.
        Alaw,
        /// AMR frames with an rfc4867.5 header.
        Amr,
        /// AMR-WB frames with an rfc4867.5 header.
        AmrWb,
        /// FLAC frames in the "native FLAC" container format.
        Flac,
        /// MPEG audio frames with optional (ignored) ID3 metadata.
        Mp3,
        /// Opus audio frames in an Ogg container.
        OggOpus,
        /// Opus audio frames in a WebM container.
        WebmOpus,
        /// AAC audio frames in an MP4 container.
        Mp4Aac,
        /// AAC audio frames in an M4A container.
        M4AAac,
        /// AAC audio frames in an MOV container.
        MovAac,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AudioEncoding::value] or
        /// [AudioEncoding::name].
        UnknownValue(audio_encoding::UnknownValue),
    }

    #[doc(hidden)]
    pub mod audio_encoding {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AudioEncoding {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Linear16 => std::option::Option::Some(1),
                Self::Mulaw => std::option::Option::Some(2),
                Self::Alaw => std::option::Option::Some(3),
                Self::Amr => std::option::Option::Some(4),
                Self::AmrWb => std::option::Option::Some(5),
                Self::Flac => std::option::Option::Some(6),
                Self::Mp3 => std::option::Option::Some(7),
                Self::OggOpus => std::option::Option::Some(8),
                Self::WebmOpus => std::option::Option::Some(9),
                Self::Mp4Aac => std::option::Option::Some(10),
                Self::M4AAac => std::option::Option::Some(11),
                Self::MovAac => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUDIO_ENCODING_UNSPECIFIED"),
                Self::Linear16 => std::option::Option::Some("LINEAR16"),
                Self::Mulaw => std::option::Option::Some("MULAW"),
                Self::Alaw => std::option::Option::Some("ALAW"),
                Self::Amr => std::option::Option::Some("AMR"),
                Self::AmrWb => std::option::Option::Some("AMR_WB"),
                Self::Flac => std::option::Option::Some("FLAC"),
                Self::Mp3 => std::option::Option::Some("MP3"),
                Self::OggOpus => std::option::Option::Some("OGG_OPUS"),
                Self::WebmOpus => std::option::Option::Some("WEBM_OPUS"),
                Self::Mp4Aac => std::option::Option::Some("MP4_AAC"),
                Self::M4AAac => std::option::Option::Some("M4A_AAC"),
                Self::MovAac => std::option::Option::Some("MOV_AAC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AudioEncoding {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AudioEncoding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AudioEncoding {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Linear16,
                2 => Self::Mulaw,
                3 => Self::Alaw,
                4 => Self::Amr,
                5 => Self::AmrWb,
                6 => Self::Flac,
                7 => Self::Mp3,
                8 => Self::OggOpus,
                9 => Self::WebmOpus,
                10 => Self::Mp4Aac,
                11 => Self::M4AAac,
                12 => Self::MovAac,
                _ => Self::UnknownValue(audio_encoding::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AudioEncoding {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUDIO_ENCODING_UNSPECIFIED" => Self::Unspecified,
                "LINEAR16" => Self::Linear16,
                "MULAW" => Self::Mulaw,
                "ALAW" => Self::Alaw,
                "AMR" => Self::Amr,
                "AMR_WB" => Self::AmrWb,
                "FLAC" => Self::Flac,
                "MP3" => Self::Mp3,
                "OGG_OPUS" => Self::OggOpus,
                "WEBM_OPUS" => Self::WebmOpus,
                "MP4_AAC" => Self::Mp4Aac,
                "M4A_AAC" => Self::M4AAac,
                "MOV_AAC" => Self::MovAac,
                _ => Self::UnknownValue(audio_encoding::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AudioEncoding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Linear16 => serializer.serialize_i32(1),
                Self::Mulaw => serializer.serialize_i32(2),
                Self::Alaw => serializer.serialize_i32(3),
                Self::Amr => serializer.serialize_i32(4),
                Self::AmrWb => serializer.serialize_i32(5),
                Self::Flac => serializer.serialize_i32(6),
                Self::Mp3 => serializer.serialize_i32(7),
                Self::OggOpus => serializer.serialize_i32(8),
                Self::WebmOpus => serializer.serialize_i32(9),
                Self::Mp4Aac => serializer.serialize_i32(10),
                Self::M4AAac => serializer.serialize_i32(11),
                Self::MovAac => serializer.serialize_i32(12),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AudioEncoding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AudioEncoding>::new(
                ".google.cloud.speech.v2.ExplicitDecodingConfig.AudioEncoding",
            ))
        }
    }
}

/// Configuration to enable speaker diarization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeakerDiarizationConfig {
    /// Required. Minimum number of speakers in the conversation. This range gives
    /// you more flexibility by allowing the system to automatically determine the
    /// correct number of speakers.
    ///
    /// To fix the number of speakers detected in the audio, set
    /// `min_speaker_count` = `max_speaker_count`.
    pub min_speaker_count: i32,

    /// Required. Maximum number of speakers in the conversation. Valid values are:
    /// 1-6. Must be >= `min_speaker_count`. This range gives you more flexibility
    /// by allowing the system to automatically determine the correct number of
    /// speakers.
    pub max_speaker_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeakerDiarizationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_speaker_count][crate::model::SpeakerDiarizationConfig::min_speaker_count].
    pub fn set_min_speaker_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_speaker_count = v.into();
        self
    }

    /// Sets the value of [max_speaker_count][crate::model::SpeakerDiarizationConfig::max_speaker_count].
    pub fn set_max_speaker_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_speaker_count = v.into();
        self
    }
}

impl wkt::message::Message for SpeakerDiarizationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeakerDiarizationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeakerDiarizationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_speaker_count,
            __max_speaker_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeakerDiarizationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minSpeakerCount" => Ok(__FieldTag::__min_speaker_count),
                            "min_speaker_count" => Ok(__FieldTag::__min_speaker_count),
                            "maxSpeakerCount" => Ok(__FieldTag::__max_speaker_count),
                            "max_speaker_count" => Ok(__FieldTag::__max_speaker_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeakerDiarizationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeakerDiarizationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_speaker_count => {
                            if !fields.insert(__FieldTag::__min_speaker_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_speaker_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_speaker_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_speaker_count => {
                            if !fields.insert(__FieldTag::__max_speaker_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_speaker_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_speaker_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpeakerDiarizationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_speaker_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minSpeakerCount", &__With(&self.min_speaker_count))?;
        }
        if !wkt::internal::is_default(&self.max_speaker_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSpeakerCount", &__With(&self.max_speaker_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Available recognition features.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecognitionFeatures {
    /// If set to `true`, the server will attempt to filter out profanities,
    /// replacing all but the initial character in each filtered word with
    /// asterisks, for instance, "f***". If set to `false` or omitted, profanities
    /// won't be filtered out.
    pub profanity_filter: bool,

    /// If `true`, the top result includes a list of words and the start and end
    /// time offsets (timestamps) for those words. If `false`, no word-level time
    /// offset information is returned. The default is `false`.
    pub enable_word_time_offsets: bool,

    /// If `true`, the top result includes a list of words and the confidence for
    /// those words. If `false`, no word-level confidence information is returned.
    /// The default is `false`.
    pub enable_word_confidence: bool,

    /// If `true`, adds punctuation to recognition result hypotheses. This feature
    /// is only available in select languages. The default `false` value does not
    /// add punctuation to result hypotheses.
    pub enable_automatic_punctuation: bool,

    /// The spoken punctuation behavior for the call. If `true`, replaces spoken
    /// punctuation with the corresponding symbols in the request. For example,
    /// "how are you question mark" becomes "how are you?". See
    /// <https://cloud.google.com/speech-to-text/docs/spoken-punctuation> for
    /// support. If `false`, spoken punctuation is not replaced.
    pub enable_spoken_punctuation: bool,

    /// The spoken emoji behavior for the call. If `true`, adds spoken emoji
    /// formatting for the request. This will replace spoken emojis with the
    /// corresponding Unicode symbols in the final transcript. If `false`, spoken
    /// emojis are not replaced.
    pub enable_spoken_emojis: bool,

    /// Mode for recognizing multi-channel audio.
    pub multi_channel_mode: crate::model::recognition_features::MultiChannelMode,

    /// Configuration to enable speaker diarization and set additional
    /// parameters to make diarization better suited for your application.
    /// When this is enabled, we send all the words from the beginning of the
    /// audio for the top alternative in every consecutive STREAMING responses.
    /// This is done in order to improve our speaker tags as our models learn to
    /// identify the speakers in the conversation over time.
    /// For non-streaming requests, the diarization results will be provided only
    /// in the top alternative of the FINAL SpeechRecognitionResult.
    pub diarization_config: std::option::Option<crate::model::SpeakerDiarizationConfig>,

    /// Maximum number of recognition hypotheses to be returned.
    /// The server may return fewer than `max_alternatives`.
    /// Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
    /// one. If omitted, will return a maximum of one.
    pub max_alternatives: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [profanity_filter][crate::model::RecognitionFeatures::profanity_filter].
    pub fn set_profanity_filter<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.profanity_filter = v.into();
        self
    }

    /// Sets the value of [enable_word_time_offsets][crate::model::RecognitionFeatures::enable_word_time_offsets].
    pub fn set_enable_word_time_offsets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_word_time_offsets = v.into();
        self
    }

    /// Sets the value of [enable_word_confidence][crate::model::RecognitionFeatures::enable_word_confidence].
    pub fn set_enable_word_confidence<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_word_confidence = v.into();
        self
    }

    /// Sets the value of [enable_automatic_punctuation][crate::model::RecognitionFeatures::enable_automatic_punctuation].
    pub fn set_enable_automatic_punctuation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_automatic_punctuation = v.into();
        self
    }

    /// Sets the value of [enable_spoken_punctuation][crate::model::RecognitionFeatures::enable_spoken_punctuation].
    pub fn set_enable_spoken_punctuation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_spoken_punctuation = v.into();
        self
    }

    /// Sets the value of [enable_spoken_emojis][crate::model::RecognitionFeatures::enable_spoken_emojis].
    pub fn set_enable_spoken_emojis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_spoken_emojis = v.into();
        self
    }

    /// Sets the value of [multi_channel_mode][crate::model::RecognitionFeatures::multi_channel_mode].
    pub fn set_multi_channel_mode<
        T: std::convert::Into<crate::model::recognition_features::MultiChannelMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.multi_channel_mode = v.into();
        self
    }

    /// Sets the value of [diarization_config][crate::model::RecognitionFeatures::diarization_config].
    pub fn set_diarization_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpeakerDiarizationConfig>,
    {
        self.diarization_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diarization_config][crate::model::RecognitionFeatures::diarization_config].
    pub fn set_or_clear_diarization_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpeakerDiarizationConfig>,
    {
        self.diarization_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_alternatives][crate::model::RecognitionFeatures::max_alternatives].
    pub fn set_max_alternatives<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_alternatives = v.into();
        self
    }
}

impl wkt::message::Message for RecognitionFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionFeatures"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecognitionFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __profanity_filter,
            __enable_word_time_offsets,
            __enable_word_confidence,
            __enable_automatic_punctuation,
            __enable_spoken_punctuation,
            __enable_spoken_emojis,
            __multi_channel_mode,
            __diarization_config,
            __max_alternatives,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecognitionFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "profanityFilter" => Ok(__FieldTag::__profanity_filter),
                            "profanity_filter" => Ok(__FieldTag::__profanity_filter),
                            "enableWordTimeOffsets" => Ok(__FieldTag::__enable_word_time_offsets),
                            "enable_word_time_offsets" => {
                                Ok(__FieldTag::__enable_word_time_offsets)
                            }
                            "enableWordConfidence" => Ok(__FieldTag::__enable_word_confidence),
                            "enable_word_confidence" => Ok(__FieldTag::__enable_word_confidence),
                            "enableAutomaticPunctuation" => {
                                Ok(__FieldTag::__enable_automatic_punctuation)
                            }
                            "enable_automatic_punctuation" => {
                                Ok(__FieldTag::__enable_automatic_punctuation)
                            }
                            "enableSpokenPunctuation" => {
                                Ok(__FieldTag::__enable_spoken_punctuation)
                            }
                            "enable_spoken_punctuation" => {
                                Ok(__FieldTag::__enable_spoken_punctuation)
                            }
                            "enableSpokenEmojis" => Ok(__FieldTag::__enable_spoken_emojis),
                            "enable_spoken_emojis" => Ok(__FieldTag::__enable_spoken_emojis),
                            "multiChannelMode" => Ok(__FieldTag::__multi_channel_mode),
                            "multi_channel_mode" => Ok(__FieldTag::__multi_channel_mode),
                            "diarizationConfig" => Ok(__FieldTag::__diarization_config),
                            "diarization_config" => Ok(__FieldTag::__diarization_config),
                            "maxAlternatives" => Ok(__FieldTag::__max_alternatives),
                            "max_alternatives" => Ok(__FieldTag::__max_alternatives),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecognitionFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecognitionFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__profanity_filter => {
                            if !fields.insert(__FieldTag::__profanity_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for profanity_filter",
                                ));
                            }
                            result.profanity_filter = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_word_time_offsets => {
                            if !fields.insert(__FieldTag::__enable_word_time_offsets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_word_time_offsets",
                                ));
                            }
                            result.enable_word_time_offsets = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_word_confidence => {
                            if !fields.insert(__FieldTag::__enable_word_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_word_confidence",
                                ));
                            }
                            result.enable_word_confidence = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_automatic_punctuation => {
                            if !fields.insert(__FieldTag::__enable_automatic_punctuation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_automatic_punctuation",
                                ));
                            }
                            result.enable_automatic_punctuation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_spoken_punctuation => {
                            if !fields.insert(__FieldTag::__enable_spoken_punctuation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_spoken_punctuation",
                                ));
                            }
                            result.enable_spoken_punctuation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_spoken_emojis => {
                            if !fields.insert(__FieldTag::__enable_spoken_emojis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_spoken_emojis",
                                ));
                            }
                            result.enable_spoken_emojis = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multi_channel_mode => {
                            if !fields.insert(__FieldTag::__multi_channel_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_channel_mode",
                                ));
                            }
                            result.multi_channel_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::recognition_features::MultiChannelMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diarization_config => {
                            if !fields.insert(__FieldTag::__diarization_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diarization_config",
                                ));
                            }
                            result.diarization_config = map.next_value::<std::option::Option<crate::model::SpeakerDiarizationConfig>>()?
                                ;
                        }
                        __FieldTag::__max_alternatives => {
                            if !fields.insert(__FieldTag::__max_alternatives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_alternatives",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_alternatives =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecognitionFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.profanity_filter) {
            state.serialize_entry("profanityFilter", &self.profanity_filter)?;
        }
        if !wkt::internal::is_default(&self.enable_word_time_offsets) {
            state.serialize_entry("enableWordTimeOffsets", &self.enable_word_time_offsets)?;
        }
        if !wkt::internal::is_default(&self.enable_word_confidence) {
            state.serialize_entry("enableWordConfidence", &self.enable_word_confidence)?;
        }
        if !wkt::internal::is_default(&self.enable_automatic_punctuation) {
            state.serialize_entry(
                "enableAutomaticPunctuation",
                &self.enable_automatic_punctuation,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_spoken_punctuation) {
            state.serialize_entry("enableSpokenPunctuation", &self.enable_spoken_punctuation)?;
        }
        if !wkt::internal::is_default(&self.enable_spoken_emojis) {
            state.serialize_entry("enableSpokenEmojis", &self.enable_spoken_emojis)?;
        }
        if !wkt::internal::is_default(&self.multi_channel_mode) {
            state.serialize_entry("multiChannelMode", &self.multi_channel_mode)?;
        }
        if self.diarization_config.is_some() {
            state.serialize_entry("diarizationConfig", &self.diarization_config)?;
        }
        if !wkt::internal::is_default(&self.max_alternatives) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxAlternatives", &__With(&self.max_alternatives))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RecognitionFeatures].
pub mod recognition_features {
    #[allow(unused_imports)]
    use super::*;

    /// Options for how to recognize multi-channel audio.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MultiChannelMode {
        /// Default value for the multi-channel mode. If the audio contains
        /// multiple channels, only the first channel will be transcribed; other
        /// channels will be ignored.
        Unspecified,
        /// If selected, each channel in the provided audio is transcribed
        /// independently. This cannot be selected if the selected
        /// [model][google.cloud.speech.v2.Recognizer.model] is `latest_short`.
        ///
        /// [google.cloud.speech.v2.Recognizer.model]: crate::model::Recognizer::model
        SeparateRecognitionPerChannel,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MultiChannelMode::value] or
        /// [MultiChannelMode::name].
        UnknownValue(multi_channel_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod multi_channel_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MultiChannelMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SeparateRecognitionPerChannel => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MULTI_CHANNEL_MODE_UNSPECIFIED"),
                Self::SeparateRecognitionPerChannel => {
                    std::option::Option::Some("SEPARATE_RECOGNITION_PER_CHANNEL")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MultiChannelMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MultiChannelMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MultiChannelMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SeparateRecognitionPerChannel,
                _ => Self::UnknownValue(multi_channel_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MultiChannelMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MULTI_CHANNEL_MODE_UNSPECIFIED" => Self::Unspecified,
                "SEPARATE_RECOGNITION_PER_CHANNEL" => Self::SeparateRecognitionPerChannel,
                _ => Self::UnknownValue(multi_channel_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MultiChannelMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SeparateRecognitionPerChannel => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MultiChannelMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MultiChannelMode>::new(
                ".google.cloud.speech.v2.RecognitionFeatures.MultiChannelMode",
            ))
        }
    }
}

/// Transcription normalization configuration. Use transcription normalization
/// to automatically replace parts of the transcript with phrases of your
/// choosing. For StreamingRecognize, this normalization only applies to stable
/// partial transcripts (stability > 0.8) and final transcripts.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranscriptNormalization {
    /// A list of replacement entries. We will perform replacement with one entry
    /// at a time. For example, the second entry in ["cat" => "dog", "mountain cat"
    /// => "mountain dog"] will never be applied because we will always process the
    /// first entry before it. At most 100 entries.
    pub entries: std::vec::Vec<crate::model::transcript_normalization::Entry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranscriptNormalization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::TranscriptNormalization::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transcript_normalization::Entry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranscriptNormalization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.TranscriptNormalization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranscriptNormalization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranscriptNormalization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entries" => Ok(__FieldTag::__entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranscriptNormalization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranscriptNormalization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::transcript_normalization::Entry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranscriptNormalization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TranscriptNormalization].
pub mod transcript_normalization {
    #[allow(unused_imports)]
    use super::*;

    /// A single replacement configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Entry {
        /// What to replace. Max length is 100 characters.
        pub search: std::string::String,

        /// What to replace with. Max length is 100 characters.
        pub replace: std::string::String,

        /// Whether the search is case sensitive.
        pub case_sensitive: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Entry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search][crate::model::transcript_normalization::Entry::search].
        pub fn set_search<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.search = v.into();
            self
        }

        /// Sets the value of [replace][crate::model::transcript_normalization::Entry::replace].
        pub fn set_replace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.replace = v.into();
            self
        }

        /// Sets the value of [case_sensitive][crate::model::transcript_normalization::Entry::case_sensitive].
        pub fn set_case_sensitive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.case_sensitive = v.into();
            self
        }
    }

    impl wkt::message::Message for Entry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.TranscriptNormalization.Entry"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Entry {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __search,
                __replace,
                __case_sensitive,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Entry")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "search" => Ok(__FieldTag::__search),
                                "replace" => Ok(__FieldTag::__replace),
                                "caseSensitive" => Ok(__FieldTag::__case_sensitive),
                                "case_sensitive" => Ok(__FieldTag::__case_sensitive),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Entry;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Entry")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__search => {
                                if !fields.insert(__FieldTag::__search) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for search",
                                    ));
                                }
                                result.search = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__replace => {
                                if !fields.insert(__FieldTag::__replace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replace",
                                    ));
                                }
                                result.replace = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__case_sensitive => {
                                if !fields.insert(__FieldTag::__case_sensitive) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for case_sensitive",
                                    ));
                                }
                                result.case_sensitive = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Entry {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.search.is_empty() {
                state.serialize_entry("search", &self.search)?;
            }
            if !self.replace.is_empty() {
                state.serialize_entry("replace", &self.replace)?;
            }
            if !wkt::internal::is_default(&self.case_sensitive) {
                state.serialize_entry("caseSensitive", &self.case_sensitive)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Translation configuration. Use to translate the given audio into text for the
/// desired language.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslationConfig {
    /// Required. The language code to translate to.
    pub target_language: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_language][crate::model::TranslationConfig::target_language].
    pub fn set_target_language<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_language = v.into();
        self
    }
}

impl wkt::message::Message for TranslationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.TranslationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_language,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetLanguage" => Ok(__FieldTag::__target_language),
                            "target_language" => Ok(__FieldTag::__target_language),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_language => {
                            if !fields.insert(__FieldTag::__target_language) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language",
                                ));
                            }
                            result.target_language = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_language.is_empty() {
            state.serialize_entry("targetLanguage", &self.target_language)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Provides "hints" to the speech recognizer to favor specific words and phrases
/// in the results. PhraseSets can be specified as an inline resource, or a
/// reference to an existing PhraseSet resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechAdaptation {
    /// A list of inline or referenced PhraseSets.
    pub phrase_sets: std::vec::Vec<crate::model::speech_adaptation::AdaptationPhraseSet>,

    /// A list of inline CustomClasses. Existing CustomClass resources can be
    /// referenced directly in a PhraseSet.
    pub custom_classes: std::vec::Vec<crate::model::CustomClass>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechAdaptation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_sets][crate::model::SpeechAdaptation::phrase_sets].
    pub fn set_phrase_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::speech_adaptation::AdaptationPhraseSet>,
    {
        use std::iter::Iterator;
        self.phrase_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_classes][crate::model::SpeechAdaptation::custom_classes].
    pub fn set_custom_classes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomClass>,
    {
        use std::iter::Iterator;
        self.custom_classes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpeechAdaptation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeechAdaptation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechAdaptation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase_sets,
            __custom_classes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechAdaptation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phraseSets" => Ok(__FieldTag::__phrase_sets),
                            "phrase_sets" => Ok(__FieldTag::__phrase_sets),
                            "customClasses" => Ok(__FieldTag::__custom_classes),
                            "custom_classes" => Ok(__FieldTag::__custom_classes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechAdaptation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechAdaptation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase_sets => {
                            if !fields.insert(__FieldTag::__phrase_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_sets",
                                ));
                            }
                            result.phrase_sets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::speech_adaptation::AdaptationPhraseSet,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_classes => {
                            if !fields.insert(__FieldTag::__custom_classes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_classes",
                                ));
                            }
                            result.custom_classes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CustomClass>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpeechAdaptation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.phrase_sets.is_empty() {
            state.serialize_entry("phraseSets", &self.phrase_sets)?;
        }
        if !self.custom_classes.is_empty() {
            state.serialize_entry("customClasses", &self.custom_classes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SpeechAdaptation].
pub mod speech_adaptation {
    #[allow(unused_imports)]
    use super::*;

    /// A biasing PhraseSet, which can be either a string referencing the name of
    /// an existing PhraseSets resource, or an inline definition of a PhraseSet.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AdaptationPhraseSet {
        pub value:
            std::option::Option<crate::model::speech_adaptation::adaptation_phrase_set::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AdaptationPhraseSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::speech_adaptation::adaptation_phrase_set::Value,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// if it holds a `PhraseSet`, `None` if the field is not set or
        /// holds a different branch.
        pub fn phrase_set(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::speech_adaptation::adaptation_phrase_set::Value::PhraseSet(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// to hold a `PhraseSet`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_phrase_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::speech_adaptation::adaptation_phrase_set::Value::PhraseSet(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// if it holds a `InlinePhraseSet`, `None` if the field is not set or
        /// holds a different branch.
        pub fn inline_phrase_set(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::PhraseSet>> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::speech_adaptation::adaptation_phrase_set::Value::InlinePhraseSet(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::speech_adaptation::AdaptationPhraseSet::value]
        /// to hold a `InlinePhraseSet`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_inline_phrase_set<
            T: std::convert::Into<std::boxed::Box<crate::model::PhraseSet>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::speech_adaptation::adaptation_phrase_set::Value::InlinePhraseSet(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for AdaptationPhraseSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.SpeechAdaptation.AdaptationPhraseSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AdaptationPhraseSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __phrase_set,
                __inline_phrase_set,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AdaptationPhraseSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "phraseSet" => Ok(__FieldTag::__phrase_set),
                                "phrase_set" => Ok(__FieldTag::__phrase_set),
                                "inlinePhraseSet" => Ok(__FieldTag::__inline_phrase_set),
                                "inline_phrase_set" => Ok(__FieldTag::__inline_phrase_set),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AdaptationPhraseSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AdaptationPhraseSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__phrase_set => {
                                if !fields.insert(__FieldTag::__phrase_set) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for phrase_set",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.speech.v2.SpeechAdaptation.AdaptationPhraseSet.phrase_set, latest field was phraseSet",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::speech_adaptation::adaptation_phrase_set::Value::PhraseSet(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__inline_phrase_set => {
                                if !fields.insert(__FieldTag::__inline_phrase_set) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for inline_phrase_set",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.cloud.speech.v2.SpeechAdaptation.AdaptationPhraseSet.inline_phrase_set, latest field was inlinePhraseSet",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::speech_adaptation::adaptation_phrase_set::Value::InlinePhraseSet(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::PhraseSet>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AdaptationPhraseSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.phrase_set() {
                state.serialize_entry("phraseSet", value)?;
            }
            if let Some(value) = self.inline_phrase_set() {
                state.serialize_entry("inlinePhraseSet", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [AdaptationPhraseSet].
    pub mod adaptation_phrase_set {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// The name of an existing PhraseSet resource. The user must have read
            /// access to the resource and it must not be deleted.
            PhraseSet(std::string::String),
            /// An inline defined PhraseSet.
            InlinePhraseSet(std::boxed::Box<crate::model::PhraseSet>),
        }
    }
}

/// Denoiser config. May not be supported for all models and may
/// have no effect.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DenoiserConfig {
    /// Denoise audio before sending to the transcription model.
    pub denoise_audio: bool,

    /// Signal-to-Noise Ratio (SNR) threshold for the denoiser. Here SNR means the
    /// loudness of the speech signal. Audio with an SNR below this threshold,
    /// meaning the speech is too quiet, will be prevented from being sent to the
    /// transcription model.
    ///
    /// If snr_threshold=0, no filtering will be applied.
    pub snr_threshold: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DenoiserConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [denoise_audio][crate::model::DenoiserConfig::denoise_audio].
    pub fn set_denoise_audio<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.denoise_audio = v.into();
        self
    }

    /// Sets the value of [snr_threshold][crate::model::DenoiserConfig::snr_threshold].
    pub fn set_snr_threshold<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.snr_threshold = v.into();
        self
    }
}

impl wkt::message::Message for DenoiserConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.DenoiserConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DenoiserConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __denoise_audio,
            __snr_threshold,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DenoiserConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "denoiseAudio" => Ok(__FieldTag::__denoise_audio),
                            "denoise_audio" => Ok(__FieldTag::__denoise_audio),
                            "snrThreshold" => Ok(__FieldTag::__snr_threshold),
                            "snr_threshold" => Ok(__FieldTag::__snr_threshold),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DenoiserConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DenoiserConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__denoise_audio => {
                            if !fields.insert(__FieldTag::__denoise_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denoise_audio",
                                ));
                            }
                            result.denoise_audio = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snr_threshold => {
                            if !fields.insert(__FieldTag::__snr_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snr_threshold",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.snr_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DenoiserConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.denoise_audio) {
            state.serialize_entry("denoiseAudio", &self.denoise_audio)?;
        }
        if !wkt::internal::is_default(&self.snr_threshold) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("snrThreshold", &__With(&self.snr_threshold))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Provides information to the Recognizer that specifies how to process the
/// recognition request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecognitionConfig {
    /// Optional. Which model to use for recognition requests. Select the model
    /// best suited to your domain to get best results.
    ///
    /// Guidance for choosing which model to use can be found in the [Transcription
    /// Models
    /// Documentation](https://cloud.google.com/speech-to-text/v2/docs/transcription-model)
    /// and the models supported in each region can be found in the [Table Of
    /// Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    pub model: std::string::String,

    /// Optional. The language of the supplied audio as a
    /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
    /// Language tags are normalized to BCP-47 before they are used eg "en-us"
    /// becomes "en-US".
    ///
    /// Supported languages for each model are listed in the [Table of Supported
    /// Models](https://cloud.google.com/speech-to-text/v2/docs/speech-to-text-supported-languages).
    ///
    /// If additional languages are provided, recognition result will contain
    /// recognition in the most likely language detected. The recognition result
    /// will include the language tag of the language detected in the audio.
    pub language_codes: std::vec::Vec<std::string::String>,

    /// Speech recognition features to enable.
    pub features: std::option::Option<crate::model::RecognitionFeatures>,

    /// Speech adaptation context that weights recognizer predictions for specific
    /// words and phrases.
    pub adaptation: std::option::Option<crate::model::SpeechAdaptation>,

    /// Optional. Use transcription normalization to automatically replace parts of
    /// the transcript with phrases of your choosing. For StreamingRecognize, this
    /// normalization only applies to stable partial transcripts (stability > 0.8)
    /// and final transcripts.
    pub transcript_normalization: std::option::Option<crate::model::TranscriptNormalization>,

    /// Optional. Optional configuration used to automatically run translation on
    /// the given audio to the desired language for supported models.
    pub translation_config: std::option::Option<crate::model::TranslationConfig>,

    /// Optional. Optional denoiser config. May not be supported for all models
    /// and may have no effect.
    pub denoiser_config: std::option::Option<crate::model::DenoiserConfig>,

    /// Decoding parameters for audio being sent for recognition.
    pub decoding_config: std::option::Option<crate::model::recognition_config::DecodingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::RecognitionConfig::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [language_codes][crate::model::RecognitionConfig::language_codes].
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [features][crate::model::RecognitionConfig::features].
    pub fn set_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionFeatures>,
    {
        self.features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [features][crate::model::RecognitionConfig::features].
    pub fn set_or_clear_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionFeatures>,
    {
        self.features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [adaptation][crate::model::RecognitionConfig::adaptation].
    pub fn set_adaptation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpeechAdaptation>,
    {
        self.adaptation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [adaptation][crate::model::RecognitionConfig::adaptation].
    pub fn set_or_clear_adaptation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpeechAdaptation>,
    {
        self.adaptation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transcript_normalization][crate::model::RecognitionConfig::transcript_normalization].
    pub fn set_transcript_normalization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TranscriptNormalization>,
    {
        self.transcript_normalization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transcript_normalization][crate::model::RecognitionConfig::transcript_normalization].
    pub fn set_or_clear_transcript_normalization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TranscriptNormalization>,
    {
        self.transcript_normalization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [translation_config][crate::model::RecognitionConfig::translation_config].
    pub fn set_translation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TranslationConfig>,
    {
        self.translation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [translation_config][crate::model::RecognitionConfig::translation_config].
    pub fn set_or_clear_translation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TranslationConfig>,
    {
        self.translation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [denoiser_config][crate::model::RecognitionConfig::denoiser_config].
    pub fn set_denoiser_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DenoiserConfig>,
    {
        self.denoiser_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [denoiser_config][crate::model::RecognitionConfig::denoiser_config].
    pub fn set_or_clear_denoiser_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DenoiserConfig>,
    {
        self.denoiser_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decoding_config][crate::model::RecognitionConfig::decoding_config].
    ///
    /// Note that all the setters affecting `decoding_config` are mutually
    /// exclusive.
    pub fn set_decoding_config<
        T: std::convert::Into<std::option::Option<crate::model::recognition_config::DecodingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoding_config = v.into();
        self
    }

    /// The value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// if it holds a `AutoDecodingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_decoding_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AutoDetectDecodingConfig>> {
        #[allow(unreachable_patterns)]
        self.decoding_config.as_ref().and_then(|v| match v {
            crate::model::recognition_config::DecodingConfig::AutoDecodingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// to hold a `AutoDecodingConfig`.
    ///
    /// Note that all the setters affecting `decoding_config` are
    /// mutually exclusive.
    pub fn set_auto_decoding_config<
        T: std::convert::Into<std::boxed::Box<crate::model::AutoDetectDecodingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoding_config = std::option::Option::Some(
            crate::model::recognition_config::DecodingConfig::AutoDecodingConfig(v.into()),
        );
        self
    }

    /// The value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// if it holds a `ExplicitDecodingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn explicit_decoding_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExplicitDecodingConfig>> {
        #[allow(unreachable_patterns)]
        self.decoding_config.as_ref().and_then(|v| match v {
            crate::model::recognition_config::DecodingConfig::ExplicitDecodingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [decoding_config][crate::model::RecognitionConfig::decoding_config]
    /// to hold a `ExplicitDecodingConfig`.
    ///
    /// Note that all the setters affecting `decoding_config` are
    /// mutually exclusive.
    pub fn set_explicit_decoding_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ExplicitDecodingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.decoding_config = std::option::Option::Some(
            crate::model::recognition_config::DecodingConfig::ExplicitDecodingConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RecognitionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecognitionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_decoding_config,
            __explicit_decoding_config,
            __model,
            __language_codes,
            __features,
            __adaptation,
            __transcript_normalization,
            __translation_config,
            __denoiser_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecognitionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoDecodingConfig" => Ok(__FieldTag::__auto_decoding_config),
                            "auto_decoding_config" => Ok(__FieldTag::__auto_decoding_config),
                            "explicitDecodingConfig" => Ok(__FieldTag::__explicit_decoding_config),
                            "explicit_decoding_config" => {
                                Ok(__FieldTag::__explicit_decoding_config)
                            }
                            "model" => Ok(__FieldTag::__model),
                            "languageCodes" => Ok(__FieldTag::__language_codes),
                            "language_codes" => Ok(__FieldTag::__language_codes),
                            "features" => Ok(__FieldTag::__features),
                            "adaptation" => Ok(__FieldTag::__adaptation),
                            "transcriptNormalization" => Ok(__FieldTag::__transcript_normalization),
                            "transcript_normalization" => {
                                Ok(__FieldTag::__transcript_normalization)
                            }
                            "translationConfig" => Ok(__FieldTag::__translation_config),
                            "translation_config" => Ok(__FieldTag::__translation_config),
                            "denoiserConfig" => Ok(__FieldTag::__denoiser_config),
                            "denoiser_config" => Ok(__FieldTag::__denoiser_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecognitionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecognitionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_decoding_config => {
                            if !fields.insert(__FieldTag::__auto_decoding_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_decoding_config",
                                ));
                            }
                            if result.decoding_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decoding_config`, a oneof with full ID .google.cloud.speech.v2.RecognitionConfig.auto_decoding_config, latest field was autoDecodingConfig",
                                ));
                            }
                            result.decoding_config = std::option::Option::Some(
                                crate::model::recognition_config::DecodingConfig::AutoDecodingConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AutoDetectDecodingConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__explicit_decoding_config => {
                            if !fields.insert(__FieldTag::__explicit_decoding_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explicit_decoding_config",
                                ));
                            }
                            if result.decoding_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `decoding_config`, a oneof with full ID .google.cloud.speech.v2.RecognitionConfig.explicit_decoding_config, latest field was explicitDecodingConfig",
                                ));
                            }
                            result.decoding_config = std::option::Option::Some(
                                crate::model::recognition_config::DecodingConfig::ExplicitDecodingConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ExplicitDecodingConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_codes => {
                            if !fields.insert(__FieldTag::__language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes",
                                ));
                            }
                            result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for features",
                                ));
                            }
                            result.features = map.next_value::<std::option::Option<crate::model::RecognitionFeatures>>()?
                                ;
                        }
                        __FieldTag::__adaptation => {
                            if !fields.insert(__FieldTag::__adaptation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adaptation",
                                ));
                            }
                            result.adaptation = map
                                .next_value::<std::option::Option<crate::model::SpeechAdaptation>>(
                                )?;
                        }
                        __FieldTag::__transcript_normalization => {
                            if !fields.insert(__FieldTag::__transcript_normalization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript_normalization",
                                ));
                            }
                            result.transcript_normalization = map.next_value::<std::option::Option<crate::model::TranscriptNormalization>>()?
                                ;
                        }
                        __FieldTag::__translation_config => {
                            if !fields.insert(__FieldTag::__translation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translation_config",
                                ));
                            }
                            result.translation_config = map
                                .next_value::<std::option::Option<crate::model::TranslationConfig>>(
                                )?;
                        }
                        __FieldTag::__denoiser_config => {
                            if !fields.insert(__FieldTag::__denoiser_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denoiser_config",
                                ));
                            }
                            result.denoiser_config = map
                                .next_value::<std::option::Option<crate::model::DenoiserConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecognitionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.auto_decoding_config() {
            state.serialize_entry("autoDecodingConfig", value)?;
        }
        if let Some(value) = self.explicit_decoding_config() {
            state.serialize_entry("explicitDecodingConfig", value)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.language_codes.is_empty() {
            state.serialize_entry("languageCodes", &self.language_codes)?;
        }
        if self.features.is_some() {
            state.serialize_entry("features", &self.features)?;
        }
        if self.adaptation.is_some() {
            state.serialize_entry("adaptation", &self.adaptation)?;
        }
        if self.transcript_normalization.is_some() {
            state.serialize_entry("transcriptNormalization", &self.transcript_normalization)?;
        }
        if self.translation_config.is_some() {
            state.serialize_entry("translationConfig", &self.translation_config)?;
        }
        if self.denoiser_config.is_some() {
            state.serialize_entry("denoiserConfig", &self.denoiser_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RecognitionConfig].
pub mod recognition_config {
    #[allow(unused_imports)]
    use super::*;

    /// Decoding parameters for audio being sent for recognition.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DecodingConfig {
        /// Automatically detect decoding parameters.
        /// Preferred for supported formats.
        AutoDecodingConfig(std::boxed::Box<crate::model::AutoDetectDecodingConfig>),
        /// Explicitly specified decoding parameters.
        /// Required if using headerless PCM audio (linear16, mulaw, alaw).
        ExplicitDecodingConfig(std::boxed::Box<crate::model::ExplicitDecodingConfig>),
    }
}

/// Request message for the
/// [Recognize][google.cloud.speech.v2.Speech.Recognize] method. Either
/// `content` or `uri` must be supplied. Supplying both or neither returns
/// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. See [content
/// limits](https://cloud.google.com/speech-to-text/quotas#content).
///
/// [google.cloud.speech.v2.Speech.Recognize]: crate::client::Speech::recognize
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecognizeRequest {
    /// Required. The name of the Recognizer to use during recognition. The
    /// expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`. The
    /// {recognizer} segment may be set to `_` to use an empty implicit Recognizer.
    pub recognizer: std::string::String,

    /// Features and audio metadata to use for the Automatic Speech Recognition.
    /// This field in combination with the
    /// [config_mask][google.cloud.speech.v2.RecognizeRequest.config_mask] field
    /// can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource.
    ///
    /// [google.cloud.speech.v2.RecognizeRequest.config_mask]: crate::model::RecognizeRequest::config_mask
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.RecognizeRequest.config] that override the
    /// values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all non-default valued fields in
    /// [config][google.cloud.speech.v2.RecognizeRequest.config] override the
    /// values in the recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.RecognizeRequest.config] completely
    /// overrides and replaces the config in the recognizer for this recognition
    /// request.
    ///
    /// [google.cloud.speech.v2.RecognizeRequest.config]: crate::model::RecognizeRequest::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// The audio source, which is either inline content or a Google Cloud
    /// Storage URI.
    pub audio_source: std::option::Option<crate::model::recognize_request::AudioSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::RecognizeRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [config][crate::model::RecognizeRequest::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::RecognizeRequest::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_mask][crate::model::RecognizeRequest::config_mask].
    pub fn set_config_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_mask][crate::model::RecognizeRequest::config_mask].
    pub fn set_or_clear_config_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audio_source][crate::model::RecognizeRequest::audio_source].
    ///
    /// Note that all the setters affecting `audio_source` are mutually
    /// exclusive.
    pub fn set_audio_source<
        T: std::convert::Into<std::option::Option<crate::model::recognize_request::AudioSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.audio_source = v.into();
        self
    }

    /// The value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.audio_source.as_ref().and_then(|v| match v {
            crate::model::recognize_request::AudioSource::Content(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `audio_source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audio_source = std::option::Option::Some(
            crate::model::recognize_request::AudioSource::Content(v.into()),
        );
        self
    }

    /// The value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.audio_source.as_ref().and_then(|v| match v {
            crate::model::recognize_request::AudioSource::Uri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [audio_source][crate::model::RecognizeRequest::audio_source]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `audio_source` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_source =
            std::option::Option::Some(crate::model::recognize_request::AudioSource::Uri(v.into()));
        self
    }
}

impl wkt::message::Message for RecognizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognizeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecognizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognizer,
            __config,
            __config_mask,
            __content,
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecognizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognizer" => Ok(__FieldTag::__recognizer),
                            "config" => Ok(__FieldTag::__config),
                            "configMask" => Ok(__FieldTag::__config_mask),
                            "config_mask" => Ok(__FieldTag::__config_mask),
                            "content" => Ok(__FieldTag::__content),
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecognizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecognizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognizer => {
                            if !fields.insert(__FieldTag::__recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognizer",
                                ));
                            }
                            result.recognizer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::RecognitionConfig>>(
                                )?;
                        }
                        __FieldTag::__config_mask => {
                            if !fields.insert(__FieldTag::__config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_mask",
                                ));
                            }
                            result.config_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.audio_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `audio_source`, a oneof with full ID .google.cloud.speech.v2.RecognizeRequest.content, latest field was content",
                                ));
                            }
                            result.audio_source = std::option::Option::Some(
                                crate::model::recognize_request::AudioSource::Content(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            if result.audio_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `audio_source`, a oneof with full ID .google.cloud.speech.v2.RecognizeRequest.uri, latest field was uri",
                                ));
                            }
                            result.audio_source = std::option::Option::Some(
                                crate::model::recognize_request::AudioSource::Uri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecognizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.recognizer.is_empty() {
            state.serialize_entry("recognizer", &self.recognizer)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.config_mask.is_some() {
            state.serialize_entry("configMask", &self.config_mask)?;
        }
        if let Some(value) = self.content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(value))?;
        }
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RecognizeRequest].
pub mod recognize_request {
    #[allow(unused_imports)]
    use super::*;

    /// The audio source, which is either inline content or a Google Cloud
    /// Storage URI.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AudioSource {
        /// The audio data bytes encoded as specified in
        /// [RecognitionConfig][google.cloud.speech.v2.RecognitionConfig]. As
        /// with all bytes fields, proto buffers use a pure binary representation,
        /// whereas JSON representations use base64.
        ///
        /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
        Content(::bytes::Bytes),
        /// URI that points to a file that contains audio data bytes as specified in
        /// [RecognitionConfig][google.cloud.speech.v2.RecognitionConfig]. The file
        /// must not be compressed (for example, gzip). Currently, only Google Cloud
        /// Storage URIs are supported, which must be specified in the following
        /// format: `gs://bucket_name/object_name` (other URI formats return
        /// [INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]). For more
        /// information, see [Request
        /// URIs](https://cloud.google.com/storage/docs/reference-uris).
        ///
        /// [google.cloud.speech.v2.RecognitionConfig]: crate::model::RecognitionConfig
        Uri(std::string::String),
    }
}

/// Metadata about the recognition request and response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecognitionResponseMetadata {
    /// Global request identifier auto-generated by the API.
    pub request_id: std::string::String,

    /// When available, billed audio seconds for the corresponding request.
    pub total_billed_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionResponseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_id][crate::model::RecognitionResponseMetadata::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [total_billed_duration][crate::model::RecognitionResponseMetadata::total_billed_duration].
    pub fn set_total_billed_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_billed_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_billed_duration][crate::model::RecognitionResponseMetadata::total_billed_duration].
    pub fn set_or_clear_total_billed_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_billed_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecognitionResponseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionResponseMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecognitionResponseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request_id,
            __total_billed_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecognitionResponseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "totalBilledDuration" => Ok(__FieldTag::__total_billed_duration),
                            "total_billed_duration" => Ok(__FieldTag::__total_billed_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecognitionResponseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecognitionResponseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_billed_duration => {
                            if !fields.insert(__FieldTag::__total_billed_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_billed_duration",
                                ));
                            }
                            result.total_billed_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecognitionResponseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if self.total_billed_duration.is_some() {
            state.serialize_entry("totalBilledDuration", &self.total_billed_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Alternative hypotheses (a.k.a. n-best list).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechRecognitionAlternative {
    /// Transcript text representing the words that the user spoke.
    pub transcript: std::string::String,

    /// The confidence estimate between 0.0 and 1.0. A higher number
    /// indicates an estimated greater likelihood that the recognized words are
    /// correct. This field is set only for the top alternative of a non-streaming
    /// result or, of a streaming result where
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final] is
    /// set to `true`. This field is not guaranteed to be accurate and users should
    /// not rely on it to be always provided. The default of 0.0 is a sentinel
    /// value indicating `confidence` was not set.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    pub confidence: f32,

    /// A list of word-specific information for each recognized word.
    /// When the
    /// [SpeakerDiarizationConfig][google.cloud.speech.v2.SpeakerDiarizationConfig]
    /// is set, you will see all the words from the beginning of the audio.
    ///
    /// [google.cloud.speech.v2.SpeakerDiarizationConfig]: crate::model::SpeakerDiarizationConfig
    pub words: std::vec::Vec<crate::model::WordInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechRecognitionAlternative {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcript][crate::model::SpeechRecognitionAlternative::transcript].
    pub fn set_transcript<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transcript = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SpeechRecognitionAlternative::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [words][crate::model::SpeechRecognitionAlternative::words].
    pub fn set_words<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WordInfo>,
    {
        use std::iter::Iterator;
        self.words = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SpeechRecognitionAlternative {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeechRecognitionAlternative"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechRecognitionAlternative {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transcript,
            __confidence,
            __words,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechRecognitionAlternative")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transcript" => Ok(__FieldTag::__transcript),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "words" => Ok(__FieldTag::__words),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechRecognitionAlternative;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechRecognitionAlternative")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            result.transcript = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__words => {
                            if !fields.insert(__FieldTag::__words) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for words",
                                ));
                            }
                            result.words = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WordInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpeechRecognitionAlternative {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transcript.is_empty() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.words.is_empty() {
            state.serialize_entry("words", &self.words)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Word-specific information for recognized words.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WordInfo {
    /// Time offset relative to the beginning of the audio,
    /// and corresponding to the start of the spoken word.
    /// This field is only set if
    /// [enable_word_time_offsets][google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]
    /// is `true` and only in the top hypothesis. This is an experimental feature
    /// and the accuracy of the time offset can vary.
    ///
    /// [google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]: crate::model::RecognitionFeatures::enable_word_time_offsets
    pub start_offset: std::option::Option<wkt::Duration>,

    /// Time offset relative to the beginning of the audio,
    /// and corresponding to the end of the spoken word.
    /// This field is only set if
    /// [enable_word_time_offsets][google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]
    /// is `true` and only in the top hypothesis. This is an experimental feature
    /// and the accuracy of the time offset can vary.
    ///
    /// [google.cloud.speech.v2.RecognitionFeatures.enable_word_time_offsets]: crate::model::RecognitionFeatures::enable_word_time_offsets
    pub end_offset: std::option::Option<wkt::Duration>,

    /// The word corresponding to this set of information.
    pub word: std::string::String,

    /// The confidence estimate between 0.0 and 1.0. A higher number
    /// indicates an estimated greater likelihood that the recognized words are
    /// correct. This field is set only for the top alternative of a non-streaming
    /// result or, of a streaming result where
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final] is
    /// set to `true`. This field is not guaranteed to be accurate and users should
    /// not rely on it to be always provided. The default of 0.0 is a sentinel
    /// value indicating `confidence` was not set.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    pub confidence: f32,

    /// A distinct label is assigned for every speaker within the audio. This field
    /// specifies which one of those speakers was detected to have spoken this
    /// word. `speaker_label` is set if
    /// [SpeakerDiarizationConfig][google.cloud.speech.v2.SpeakerDiarizationConfig]
    /// is given and only in the top alternative.
    ///
    /// [google.cloud.speech.v2.SpeakerDiarizationConfig]: crate::model::SpeakerDiarizationConfig
    pub speaker_label: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WordInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_offset][crate::model::WordInfo::start_offset].
    pub fn set_start_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_offset][crate::model::WordInfo::start_offset].
    pub fn set_or_clear_start_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_offset][crate::model::WordInfo::end_offset].
    pub fn set_end_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_offset][crate::model::WordInfo::end_offset].
    pub fn set_or_clear_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [word][crate::model::WordInfo::word].
    pub fn set_word<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.word = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::WordInfo::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [speaker_label][crate::model::WordInfo::speaker_label].
    pub fn set_speaker_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.speaker_label = v.into();
        self
    }
}

impl wkt::message::Message for WordInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.WordInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WordInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_offset,
            __end_offset,
            __word,
            __confidence,
            __speaker_label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WordInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startOffset" => Ok(__FieldTag::__start_offset),
                            "start_offset" => Ok(__FieldTag::__start_offset),
                            "endOffset" => Ok(__FieldTag::__end_offset),
                            "end_offset" => Ok(__FieldTag::__end_offset),
                            "word" => Ok(__FieldTag::__word),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "speakerLabel" => Ok(__FieldTag::__speaker_label),
                            "speaker_label" => Ok(__FieldTag::__speaker_label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WordInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WordInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_offset => {
                            if !fields.insert(__FieldTag::__start_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_offset",
                                ));
                            }
                            result.start_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__end_offset => {
                            if !fields.insert(__FieldTag::__end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_offset",
                                ));
                            }
                            result.end_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__word => {
                            if !fields.insert(__FieldTag::__word) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for word",
                                ));
                            }
                            result.word = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__speaker_label => {
                            if !fields.insert(__FieldTag::__speaker_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaker_label",
                                ));
                            }
                            result.speaker_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WordInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_offset.is_some() {
            state.serialize_entry("startOffset", &self.start_offset)?;
        }
        if self.end_offset.is_some() {
            state.serialize_entry("endOffset", &self.end_offset)?;
        }
        if !self.word.is_empty() {
            state.serialize_entry("word", &self.word)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.speaker_label.is_empty() {
            state.serialize_entry("speakerLabel", &self.speaker_label)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A speech recognition result corresponding to a portion of the audio.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechRecognitionResult {
    /// May contain one or more recognition hypotheses. These alternatives are
    /// ordered in terms of accuracy, with the top (first) alternative being the
    /// most probable, as ranked by the recognizer.
    pub alternatives: std::vec::Vec<crate::model::SpeechRecognitionAlternative>,

    /// For multi-channel audio, this is the channel number corresponding to the
    /// recognized result for the audio from that channel.
    /// For `audio_channel_count` = `N`, its output values can range from `1` to
    /// `N`.
    pub channel_tag: i32,

    /// Time offset of the end of this result relative to the beginning of the
    /// audio.
    pub result_end_offset: std::option::Option<wkt::Duration>,

    /// Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag of the language in this result. This language code was
    /// detected to have the most likelihood of being spoken in the audio.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SpeechRecognitionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alternatives][crate::model::SpeechRecognitionResult::alternatives].
    pub fn set_alternatives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionAlternative>,
    {
        use std::iter::Iterator;
        self.alternatives = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [channel_tag][crate::model::SpeechRecognitionResult::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [result_end_offset][crate::model::SpeechRecognitionResult::result_end_offset].
    pub fn set_result_end_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result_end_offset][crate::model::SpeechRecognitionResult::result_end_offset].
    pub fn set_or_clear_result_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::SpeechRecognitionResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

impl wkt::message::Message for SpeechRecognitionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SpeechRecognitionResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechRecognitionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alternatives,
            __channel_tag,
            __result_end_offset,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechRecognitionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alternatives" => Ok(__FieldTag::__alternatives),
                            "channelTag" => Ok(__FieldTag::__channel_tag),
                            "channel_tag" => Ok(__FieldTag::__channel_tag),
                            "resultEndOffset" => Ok(__FieldTag::__result_end_offset),
                            "result_end_offset" => Ok(__FieldTag::__result_end_offset),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechRecognitionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechRecognitionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alternatives => {
                            if !fields.insert(__FieldTag::__alternatives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alternatives",
                                ));
                            }
                            result.alternatives = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SpeechRecognitionAlternative>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel_tag => {
                            if !fields.insert(__FieldTag::__channel_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_tag",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.channel_tag = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__result_end_offset => {
                            if !fields.insert(__FieldTag::__result_end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_end_offset",
                                ));
                            }
                            result.result_end_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SpeechRecognitionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.alternatives.is_empty() {
            state.serialize_entry("alternatives", &self.alternatives)?;
        }
        if !wkt::internal::is_default(&self.channel_tag) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("channelTag", &__With(&self.channel_tag))?;
        }
        if self.result_end_offset.is_some() {
            state.serialize_entry("resultEndOffset", &self.result_end_offset)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the
/// [Recognize][google.cloud.speech.v2.Speech.Recognize] method.
///
/// [google.cloud.speech.v2.Speech.Recognize]: crate::client::Speech::recognize
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecognizeResponse {
    /// Sequential list of transcription results corresponding to sequential
    /// portions of audio.
    pub results: std::vec::Vec<crate::model::SpeechRecognitionResult>,

    /// Metadata about the recognition.
    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::RecognizeResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::RecognizeResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::RecognizeResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RecognizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognizeResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecognizeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecognizeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecognizeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecognizeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SpeechRecognitionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::RecognitionResponseMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecognizeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Available recognition features specific to streaming recognition requests.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingRecognitionFeatures {
    /// If `true`, responses with voice activity speech events will be returned as
    /// they are detected.
    pub enable_voice_activity_events: bool,

    /// Whether or not to stream interim results to the client. If set to true,
    /// interim results will be streamed to the client. Otherwise, only the final
    /// response will be streamed back.
    pub interim_results: bool,

    /// If set, the server will automatically close the stream after the specified
    /// duration has elapsed after the last VOICE_ACTIVITY speech event has been
    /// sent. The field `voice_activity_events` must also be set to true.
    pub voice_activity_timeout:
        std::option::Option<crate::model::streaming_recognition_features::VoiceActivityTimeout>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognitionFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_voice_activity_events][crate::model::StreamingRecognitionFeatures::enable_voice_activity_events].
    pub fn set_enable_voice_activity_events<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_voice_activity_events = v.into();
        self
    }

    /// Sets the value of [interim_results][crate::model::StreamingRecognitionFeatures::interim_results].
    pub fn set_interim_results<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.interim_results = v.into();
        self
    }

    /// Sets the value of [voice_activity_timeout][crate::model::StreamingRecognitionFeatures::voice_activity_timeout].
    pub fn set_voice_activity_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::streaming_recognition_features::VoiceActivityTimeout>,
    {
        self.voice_activity_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [voice_activity_timeout][crate::model::StreamingRecognitionFeatures::voice_activity_timeout].
    pub fn set_or_clear_voice_activity_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::streaming_recognition_features::VoiceActivityTimeout>,
    {
        self.voice_activity_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StreamingRecognitionFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionFeatures"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingRecognitionFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_voice_activity_events,
            __interim_results,
            __voice_activity_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognitionFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableVoiceActivityEvents" => {
                                Ok(__FieldTag::__enable_voice_activity_events)
                            }
                            "enable_voice_activity_events" => {
                                Ok(__FieldTag::__enable_voice_activity_events)
                            }
                            "interimResults" => Ok(__FieldTag::__interim_results),
                            "interim_results" => Ok(__FieldTag::__interim_results),
                            "voiceActivityTimeout" => Ok(__FieldTag::__voice_activity_timeout),
                            "voice_activity_timeout" => Ok(__FieldTag::__voice_activity_timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingRecognitionFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognitionFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_voice_activity_events => {
                            if !fields.insert(__FieldTag::__enable_voice_activity_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_voice_activity_events",
                                ));
                            }
                            result.enable_voice_activity_events = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interim_results => {
                            if !fields.insert(__FieldTag::__interim_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interim_results",
                                ));
                            }
                            result.interim_results = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__voice_activity_timeout => {
                            if !fields.insert(__FieldTag::__voice_activity_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice_activity_timeout",
                                ));
                            }
                            result.voice_activity_timeout = map.next_value::<std::option::Option<
                                crate::model::streaming_recognition_features::VoiceActivityTimeout,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingRecognitionFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_voice_activity_events) {
            state.serialize_entry(
                "enableVoiceActivityEvents",
                &self.enable_voice_activity_events,
            )?;
        }
        if !wkt::internal::is_default(&self.interim_results) {
            state.serialize_entry("interimResults", &self.interim_results)?;
        }
        if self.voice_activity_timeout.is_some() {
            state.serialize_entry("voiceActivityTimeout", &self.voice_activity_timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingRecognitionFeatures].
pub mod streaming_recognition_features {
    #[allow(unused_imports)]
    use super::*;

    /// Events that a timeout can be set on for voice activity.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VoiceActivityTimeout {
        /// Duration to timeout the stream if no speech begins. If this is set and
        /// no speech is detected in this duration at the start of the stream, the
        /// server will close the stream.
        pub speech_start_timeout: std::option::Option<wkt::Duration>,

        /// Duration to timeout the stream after speech ends. If this is set and no
        /// speech is detected in this duration after speech was detected, the server
        /// will close the stream.
        pub speech_end_timeout: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VoiceActivityTimeout {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [speech_start_timeout][crate::model::streaming_recognition_features::VoiceActivityTimeout::speech_start_timeout].
        pub fn set_speech_start_timeout<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.speech_start_timeout = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [speech_start_timeout][crate::model::streaming_recognition_features::VoiceActivityTimeout::speech_start_timeout].
        pub fn set_or_clear_speech_start_timeout<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.speech_start_timeout = v.map(|x| x.into());
            self
        }

        /// Sets the value of [speech_end_timeout][crate::model::streaming_recognition_features::VoiceActivityTimeout::speech_end_timeout].
        pub fn set_speech_end_timeout<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.speech_end_timeout = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [speech_end_timeout][crate::model::streaming_recognition_features::VoiceActivityTimeout::speech_end_timeout].
        pub fn set_or_clear_speech_end_timeout<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.speech_end_timeout = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for VoiceActivityTimeout {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionFeatures.VoiceActivityTimeout"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VoiceActivityTimeout {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __speech_start_timeout,
                __speech_end_timeout,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VoiceActivityTimeout")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "speechStartTimeout" => Ok(__FieldTag::__speech_start_timeout),
                                "speech_start_timeout" => Ok(__FieldTag::__speech_start_timeout),
                                "speechEndTimeout" => Ok(__FieldTag::__speech_end_timeout),
                                "speech_end_timeout" => Ok(__FieldTag::__speech_end_timeout),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VoiceActivityTimeout;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VoiceActivityTimeout")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__speech_start_timeout => {
                                if !fields.insert(__FieldTag::__speech_start_timeout) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for speech_start_timeout",
                                    ));
                                }
                                result.speech_start_timeout =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__speech_end_timeout => {
                                if !fields.insert(__FieldTag::__speech_end_timeout) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for speech_end_timeout",
                                    ));
                                }
                                result.speech_end_timeout =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VoiceActivityTimeout {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.speech_start_timeout.is_some() {
                state.serialize_entry("speechStartTimeout", &self.speech_start_timeout)?;
            }
            if self.speech_end_timeout.is_some() {
                state.serialize_entry("speechEndTimeout", &self.speech_end_timeout)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Provides configuration information for the StreamingRecognize request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingRecognitionConfig {
    /// Required. Features and audio metadata to use for the Automatic Speech
    /// Recognition. This field in combination with the
    /// [config_mask][google.cloud.speech.v2.StreamingRecognitionConfig.config_mask]
    /// field can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource.
    ///
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    /// [google.cloud.speech.v2.StreamingRecognitionConfig.config_mask]: crate::model::StreamingRecognitionConfig::config_mask
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.StreamingRecognitionConfig.config] that
    /// override the values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all non-default valued fields in
    /// [config][google.cloud.speech.v2.StreamingRecognitionConfig.config] override
    /// the values in the Recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// Recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.StreamingRecognitionConfig.config]
    /// completely overrides and replaces the config in the recognizer for this
    /// recognition request.
    ///
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    /// [google.cloud.speech.v2.StreamingRecognitionConfig.config]: crate::model::StreamingRecognitionConfig::config
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// Speech recognition features to enable specific to streaming audio
    /// recognition requests.
    pub streaming_features: std::option::Option<crate::model::StreamingRecognitionFeatures>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognitionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::StreamingRecognitionConfig::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::StreamingRecognitionConfig::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_mask][crate::model::StreamingRecognitionConfig::config_mask].
    pub fn set_config_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_mask][crate::model::StreamingRecognitionConfig::config_mask].
    pub fn set_or_clear_config_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [streaming_features][crate::model::StreamingRecognitionConfig::streaming_features].
    pub fn set_streaming_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamingRecognitionFeatures>,
    {
        self.streaming_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [streaming_features][crate::model::StreamingRecognitionConfig::streaming_features].
    pub fn set_or_clear_streaming_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamingRecognitionFeatures>,
    {
        self.streaming_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StreamingRecognitionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingRecognitionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __config_mask,
            __streaming_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognitionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "configMask" => Ok(__FieldTag::__config_mask),
                            "config_mask" => Ok(__FieldTag::__config_mask),
                            "streamingFeatures" => Ok(__FieldTag::__streaming_features),
                            "streaming_features" => Ok(__FieldTag::__streaming_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingRecognitionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognitionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::RecognitionConfig>>(
                                )?;
                        }
                        __FieldTag::__config_mask => {
                            if !fields.insert(__FieldTag::__config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_mask",
                                ));
                            }
                            result.config_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__streaming_features => {
                            if !fields.insert(__FieldTag::__streaming_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_features",
                                ));
                            }
                            result.streaming_features = map.next_value::<std::option::Option<crate::model::StreamingRecognitionFeatures>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingRecognitionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.config_mask.is_some() {
            state.serialize_entry("configMask", &self.config_mask)?;
        }
        if self.streaming_features.is_some() {
            state.serialize_entry("streamingFeatures", &self.streaming_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [StreamingRecognize][google.cloud.speech.v2.Speech.StreamingRecognize]
/// method. Multiple
/// [StreamingRecognizeRequest][google.cloud.speech.v2.StreamingRecognizeRequest]
/// messages are sent in one call.
///
/// If the [Recognizer][google.cloud.speech.v2.Recognizer] referenced by
/// [recognizer][google.cloud.speech.v2.StreamingRecognizeRequest.recognizer]
/// contains a fully specified request configuration then the stream may only
/// contain messages with only
/// [audio][google.cloud.speech.v2.StreamingRecognizeRequest.audio] set.
///
/// Otherwise the first message must contain a
/// [recognizer][google.cloud.speech.v2.StreamingRecognizeRequest.recognizer] and
/// a
/// [streaming_config][google.cloud.speech.v2.StreamingRecognizeRequest.streaming_config]
/// message that together fully specify the request configuration and must not
/// contain [audio][google.cloud.speech.v2.StreamingRecognizeRequest.audio]. All
/// subsequent messages must only have
/// [audio][google.cloud.speech.v2.StreamingRecognizeRequest.audio] set.
///
/// [google.cloud.speech.v2.Recognizer]: crate::model::Recognizer
/// [google.cloud.speech.v2.StreamingRecognizeRequest]: crate::model::StreamingRecognizeRequest
/// [google.cloud.speech.v2.StreamingRecognizeRequest.audio]: crate::model::StreamingRecognizeRequest::streaming_request
/// [google.cloud.speech.v2.StreamingRecognizeRequest.recognizer]: crate::model::StreamingRecognizeRequest::recognizer
/// [google.cloud.speech.v2.StreamingRecognizeRequest.streaming_config]: crate::model::StreamingRecognizeRequest::streaming_request
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingRecognizeRequest {
    /// Required. The name of the Recognizer to use during recognition. The
    /// expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`. The
    /// {recognizer} segment may be set to `_` to use an empty implicit Recognizer.
    pub recognizer: std::string::String,

    pub streaming_request:
        std::option::Option<crate::model::streaming_recognize_request::StreamingRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::StreamingRecognizeRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request].
    ///
    /// Note that all the setters affecting `streaming_request` are mutually
    /// exclusive.
    pub fn set_streaming_request<
        T: std::convert::Into<
                std::option::Option<crate::model::streaming_recognize_request::StreamingRequest>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_request = v.into();
        self
    }

    /// The value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// if it holds a `StreamingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn streaming_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamingRecognitionConfig>> {
        #[allow(unreachable_patterns)]
        self.streaming_request.as_ref().and_then(|v| match v {
            crate::model::streaming_recognize_request::StreamingRequest::StreamingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// to hold a `StreamingConfig`.
    ///
    /// Note that all the setters affecting `streaming_request` are
    /// mutually exclusive.
    pub fn set_streaming_config<
        T: std::convert::Into<std::boxed::Box<crate::model::StreamingRecognitionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_request = std::option::Option::Some(
            crate::model::streaming_recognize_request::StreamingRequest::StreamingConfig(v.into()),
        );
        self
    }

    /// The value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// if it holds a `Audio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn audio(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.streaming_request.as_ref().and_then(|v| match v {
            crate::model::streaming_recognize_request::StreamingRequest::Audio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [streaming_request][crate::model::StreamingRecognizeRequest::streaming_request]
    /// to hold a `Audio`.
    ///
    /// Note that all the setters affecting `streaming_request` are
    /// mutually exclusive.
    pub fn set_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.streaming_request = std::option::Option::Some(
            crate::model::streaming_recognize_request::StreamingRequest::Audio(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StreamingRecognizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognizeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingRecognizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognizer,
            __streaming_config,
            __audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognizer" => Ok(__FieldTag::__recognizer),
                            "streamingConfig" => Ok(__FieldTag::__streaming_config),
                            "streaming_config" => Ok(__FieldTag::__streaming_config),
                            "audio" => Ok(__FieldTag::__audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingRecognizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognizer => {
                            if !fields.insert(__FieldTag::__recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognizer",
                                ));
                            }
                            result.recognizer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__streaming_config => {
                            if !fields.insert(__FieldTag::__streaming_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_config",
                                ));
                            }
                            if result.streaming_request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `streaming_request`, a oneof with full ID .google.cloud.speech.v2.StreamingRecognizeRequest.streaming_config, latest field was streamingConfig",
                                ));
                            }
                            result.streaming_request = std::option::Option::Some(
                                crate::model::streaming_recognize_request::StreamingRequest::StreamingConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamingRecognitionConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.streaming_request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `streaming_request`, a oneof with full ID .google.cloud.speech.v2.StreamingRecognizeRequest.audio, latest field was audio",
                                ));
                            }
                            result.streaming_request = std::option::Option::Some(
                                crate::model::streaming_recognize_request::StreamingRequest::Audio(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingRecognizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.recognizer.is_empty() {
            state.serialize_entry("recognizer", &self.recognizer)?;
        }
        if let Some(value) = self.streaming_config() {
            state.serialize_entry("streamingConfig", value)?;
        }
        if let Some(value) = self.audio() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingRecognizeRequest].
pub mod streaming_recognize_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StreamingRequest {
        /// StreamingRecognitionConfig to be used in this recognition attempt.
        /// If provided, it will override the default RecognitionConfig stored in the
        /// Recognizer.
        StreamingConfig(std::boxed::Box<crate::model::StreamingRecognitionConfig>),
        /// Inline audio bytes to be Recognized.
        /// Maximum size for this field is 15 KB per request.
        Audio(::bytes::Bytes),
    }
}

/// Request message for the
/// [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize]
/// method.
///
/// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRecognizeRequest {
    /// Required. The name of the Recognizer to use during recognition. The
    /// expected format is
    /// `projects/{project}/locations/{location}/recognizers/{recognizer}`. The
    /// {recognizer} segment may be set to `_` to use an empty implicit Recognizer.
    pub recognizer: std::string::String,

    /// Features and audio metadata to use for the Automatic Speech Recognition.
    /// This field in combination with the
    /// [config_mask][google.cloud.speech.v2.BatchRecognizeRequest.config_mask]
    /// field can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeRequest.config_mask]: crate::model::BatchRecognizeRequest::config_mask
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] that override
    /// the values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all given fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] override the
    /// values in the recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] completely
    /// overrides and replaces the config in the recognizer for this recognition
    /// request.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeRequest.config]: crate::model::BatchRecognizeRequest::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// Audio files with file metadata for ASR.
    /// The maximum number of files allowed to be specified is 15.
    pub files: std::vec::Vec<crate::model::BatchRecognizeFileMetadata>,

    /// Configuration options for where to output the transcripts of each file.
    pub recognition_output_config: std::option::Option<crate::model::RecognitionOutputConfig>,

    /// Processing strategy to use for this request.
    pub processing_strategy: crate::model::batch_recognize_request::ProcessingStrategy,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognizer][crate::model::BatchRecognizeRequest::recognizer].
    pub fn set_recognizer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recognizer = v.into();
        self
    }

    /// Sets the value of [config][crate::model::BatchRecognizeRequest::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::BatchRecognizeRequest::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_mask][crate::model::BatchRecognizeRequest::config_mask].
    pub fn set_config_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_mask][crate::model::BatchRecognizeRequest::config_mask].
    pub fn set_or_clear_config_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [files][crate::model::BatchRecognizeRequest::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BatchRecognizeFileMetadata>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [recognition_output_config][crate::model::BatchRecognizeRequest::recognition_output_config].
    pub fn set_recognition_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionOutputConfig>,
    {
        self.recognition_output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recognition_output_config][crate::model::BatchRecognizeRequest::recognition_output_config].
    pub fn set_or_clear_recognition_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionOutputConfig>,
    {
        self.recognition_output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [processing_strategy][crate::model::BatchRecognizeRequest::processing_strategy].
    pub fn set_processing_strategy<
        T: std::convert::Into<crate::model::batch_recognize_request::ProcessingStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.processing_strategy = v.into();
        self
    }
}

impl wkt::message::Message for BatchRecognizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRecognizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognizer,
            __config,
            __config_mask,
            __files,
            __recognition_output_config,
            __processing_strategy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRecognizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognizer" => Ok(__FieldTag::__recognizer),
                            "config" => Ok(__FieldTag::__config),
                            "configMask" => Ok(__FieldTag::__config_mask),
                            "config_mask" => Ok(__FieldTag::__config_mask),
                            "files" => Ok(__FieldTag::__files),
                            "recognitionOutputConfig" => {
                                Ok(__FieldTag::__recognition_output_config)
                            }
                            "recognition_output_config" => {
                                Ok(__FieldTag::__recognition_output_config)
                            }
                            "processingStrategy" => Ok(__FieldTag::__processing_strategy),
                            "processing_strategy" => Ok(__FieldTag::__processing_strategy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRecognizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRecognizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognizer => {
                            if !fields.insert(__FieldTag::__recognizer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognizer",
                                ));
                            }
                            result.recognizer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::RecognitionConfig>>(
                                )?;
                        }
                        __FieldTag::__config_mask => {
                            if !fields.insert(__FieldTag::__config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_mask",
                                ));
                            }
                            result.config_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__files => {
                            if !fields.insert(__FieldTag::__files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for files",
                                ));
                            }
                            result.files = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BatchRecognizeFileMetadata>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recognition_output_config => {
                            if !fields.insert(__FieldTag::__recognition_output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognition_output_config",
                                ));
                            }
                            result.recognition_output_config = map.next_value::<std::option::Option<crate::model::RecognitionOutputConfig>>()?
                                ;
                        }
                        __FieldTag::__processing_strategy => {
                            if !fields.insert(__FieldTag::__processing_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for processing_strategy",
                                ));
                            }
                            result.processing_strategy = map
                                .next_value::<std::option::Option<
                                    crate::model::batch_recognize_request::ProcessingStrategy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchRecognizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.recognizer.is_empty() {
            state.serialize_entry("recognizer", &self.recognizer)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.config_mask.is_some() {
            state.serialize_entry("configMask", &self.config_mask)?;
        }
        if !self.files.is_empty() {
            state.serialize_entry("files", &self.files)?;
        }
        if self.recognition_output_config.is_some() {
            state.serialize_entry("recognitionOutputConfig", &self.recognition_output_config)?;
        }
        if !wkt::internal::is_default(&self.processing_strategy) {
            state.serialize_entry("processingStrategy", &self.processing_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchRecognizeRequest].
pub mod batch_recognize_request {
    #[allow(unused_imports)]
    use super::*;

    /// Possible processing strategies for batch requests.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProcessingStrategy {
        /// Default value for the processing strategy. The request is processed as
        /// soon as its received.
        Unspecified,
        /// If selected, processes the request during lower utilization periods for a
        /// price discount. The request is fulfilled within 24 hours.
        DynamicBatching,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProcessingStrategy::value] or
        /// [ProcessingStrategy::name].
        UnknownValue(processing_strategy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod processing_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ProcessingStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DynamicBatching => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROCESSING_STRATEGY_UNSPECIFIED"),
                Self::DynamicBatching => std::option::Option::Some("DYNAMIC_BATCHING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ProcessingStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ProcessingStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ProcessingStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DynamicBatching,
                _ => Self::UnknownValue(processing_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ProcessingStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROCESSING_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "DYNAMIC_BATCHING" => Self::DynamicBatching,
                _ => Self::UnknownValue(processing_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ProcessingStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DynamicBatching => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ProcessingStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProcessingStrategy>::new(
                ".google.cloud.speech.v2.BatchRecognizeRequest.ProcessingStrategy",
            ))
        }
    }
}

/// Output configurations for Cloud Storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsOutputConfig {
    /// The Cloud Storage URI prefix with which recognition results will be
    /// written.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsOutputConfig::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GcsOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output configurations for inline response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InlineOutputConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InlineOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.InlineOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InlineOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InlineOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InlineOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InlineOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InlineOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output configurations for serialized `BatchRecognizeResults` protos.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NativeOutputFileFormatConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NativeOutputFileFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for NativeOutputFileFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.NativeOutputFileFormatConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NativeOutputFileFormatConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NativeOutputFileFormatConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NativeOutputFileFormatConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NativeOutputFileFormatConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NativeOutputFileFormatConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output configurations for [WebVTT](https://www.w3.org/TR/webvtt1/) formatted
/// subtitle file.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VttOutputFileFormatConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VttOutputFileFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VttOutputFileFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.VttOutputFileFormatConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VttOutputFileFormatConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VttOutputFileFormatConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VttOutputFileFormatConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VttOutputFileFormatConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VttOutputFileFormatConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output configurations [SubRip
/// Text](https://www.matroska.org/technical/subtitles.html#srt-subtitles)
/// formatted subtitle file.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SrtOutputFileFormatConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SrtOutputFileFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SrtOutputFileFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.SrtOutputFileFormatConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SrtOutputFileFormatConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SrtOutputFileFormatConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SrtOutputFileFormatConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SrtOutputFileFormatConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SrtOutputFileFormatConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for the format of the results stored to `output`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputFormatConfig {
    /// Configuration for the native output format. If this field is set or if no
    /// other output format field is set, then transcripts will be written to the
    /// sink in the native format.
    pub native: std::option::Option<crate::model::NativeOutputFileFormatConfig>,

    /// Configuration for the VTT output format. If this field is set, then
    /// transcripts will be written to the sink in the VTT format.
    pub vtt: std::option::Option<crate::model::VttOutputFileFormatConfig>,

    /// Configuration for the SRT output format. If this field is set, then
    /// transcripts will be written to the sink in the SRT format.
    pub srt: std::option::Option<crate::model::SrtOutputFileFormatConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputFormatConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [native][crate::model::OutputFormatConfig::native].
    pub fn set_native<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NativeOutputFileFormatConfig>,
    {
        self.native = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [native][crate::model::OutputFormatConfig::native].
    pub fn set_or_clear_native<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NativeOutputFileFormatConfig>,
    {
        self.native = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vtt][crate::model::OutputFormatConfig::vtt].
    pub fn set_vtt<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VttOutputFileFormatConfig>,
    {
        self.vtt = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vtt][crate::model::OutputFormatConfig::vtt].
    pub fn set_or_clear_vtt<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VttOutputFileFormatConfig>,
    {
        self.vtt = v.map(|x| x.into());
        self
    }

    /// Sets the value of [srt][crate::model::OutputFormatConfig::srt].
    pub fn set_srt<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SrtOutputFileFormatConfig>,
    {
        self.srt = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [srt][crate::model::OutputFormatConfig::srt].
    pub fn set_or_clear_srt<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SrtOutputFileFormatConfig>,
    {
        self.srt = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OutputFormatConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.OutputFormatConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputFormatConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __native,
            __vtt,
            __srt,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputFormatConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "native" => Ok(__FieldTag::__native),
                            "vtt" => Ok(__FieldTag::__vtt),
                            "srt" => Ok(__FieldTag::__srt),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputFormatConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputFormatConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__native => {
                            if !fields.insert(__FieldTag::__native) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for native",
                                ));
                            }
                            result.native = map.next_value::<std::option::Option<crate::model::NativeOutputFileFormatConfig>>()?
                                ;
                        }
                        __FieldTag::__vtt => {
                            if !fields.insert(__FieldTag::__vtt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vtt",
                                ));
                            }
                            result.vtt = map.next_value::<std::option::Option<crate::model::VttOutputFileFormatConfig>>()?
                                ;
                        }
                        __FieldTag::__srt => {
                            if !fields.insert(__FieldTag::__srt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for srt",
                                ));
                            }
                            result.srt = map.next_value::<std::option::Option<crate::model::SrtOutputFileFormatConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputFormatConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.native.is_some() {
            state.serialize_entry("native", &self.native)?;
        }
        if self.vtt.is_some() {
            state.serialize_entry("vtt", &self.vtt)?;
        }
        if self.srt.is_some() {
            state.serialize_entry("srt", &self.srt)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration options for the output(s) of recognition.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RecognitionOutputConfig {
    /// Optional. Configuration for the format of the results stored to `output`.
    /// If unspecified transcripts will be written in the `NATIVE` format only.
    pub output_format_config: std::option::Option<crate::model::OutputFormatConfig>,

    pub output: std::option::Option<crate::model::recognition_output_config::Output>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecognitionOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_format_config][crate::model::RecognitionOutputConfig::output_format_config].
    pub fn set_output_format_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputFormatConfig>,
    {
        self.output_format_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_format_config][crate::model::RecognitionOutputConfig::output_format_config].
    pub fn set_or_clear_output_format_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputFormatConfig>,
    {
        self.output_format_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output][crate::model::RecognitionOutputConfig::output].
    ///
    /// Note that all the setters affecting `output` are mutually
    /// exclusive.
    pub fn set_output<
        T: std::convert::Into<std::option::Option<crate::model::recognition_output_config::Output>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = v.into();
        self
    }

    /// The value of [output][crate::model::RecognitionOutputConfig::output]
    /// if it holds a `GcsOutputConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_output_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsOutputConfig>> {
        #[allow(unreachable_patterns)]
        self.output.as_ref().and_then(|v| match v {
            crate::model::recognition_output_config::Output::GcsOutputConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output][crate::model::RecognitionOutputConfig::output]
    /// to hold a `GcsOutputConfig`.
    ///
    /// Note that all the setters affecting `output` are
    /// mutually exclusive.
    pub fn set_gcs_output_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = std::option::Option::Some(
            crate::model::recognition_output_config::Output::GcsOutputConfig(v.into()),
        );
        self
    }

    /// The value of [output][crate::model::RecognitionOutputConfig::output]
    /// if it holds a `InlineResponseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_response_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineOutputConfig>> {
        #[allow(unreachable_patterns)]
        self.output.as_ref().and_then(|v| match v {
            crate::model::recognition_output_config::Output::InlineResponseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [output][crate::model::RecognitionOutputConfig::output]
    /// to hold a `InlineResponseConfig`.
    ///
    /// Note that all the setters affecting `output` are
    /// mutually exclusive.
    pub fn set_inline_response_config<
        T: std::convert::Into<std::boxed::Box<crate::model::InlineOutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output = std::option::Option::Some(
            crate::model::recognition_output_config::Output::InlineResponseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RecognitionOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.RecognitionOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecognitionOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_output_config,
            __inline_response_config,
            __output_format_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecognitionOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsOutputConfig" => Ok(__FieldTag::__gcs_output_config),
                            "gcs_output_config" => Ok(__FieldTag::__gcs_output_config),
                            "inlineResponseConfig" => Ok(__FieldTag::__inline_response_config),
                            "inline_response_config" => Ok(__FieldTag::__inline_response_config),
                            "outputFormatConfig" => Ok(__FieldTag::__output_format_config),
                            "output_format_config" => Ok(__FieldTag::__output_format_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecognitionOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecognitionOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_output_config => {
                            if !fields.insert(__FieldTag::__gcs_output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_output_config",
                                ));
                            }
                            if result.output.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output`, a oneof with full ID .google.cloud.speech.v2.RecognitionOutputConfig.gcs_output_config, latest field was gcsOutputConfig",
                                ));
                            }
                            result.output = std::option::Option::Some(
                                crate::model::recognition_output_config::Output::GcsOutputConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsOutputConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__inline_response_config => {
                            if !fields.insert(__FieldTag::__inline_response_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline_response_config",
                                ));
                            }
                            if result.output.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `output`, a oneof with full ID .google.cloud.speech.v2.RecognitionOutputConfig.inline_response_config, latest field was inlineResponseConfig",
                                ));
                            }
                            result.output = std::option::Option::Some(
                                crate::model::recognition_output_config::Output::InlineResponseConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InlineOutputConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__output_format_config => {
                            if !fields.insert(__FieldTag::__output_format_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_format_config",
                                ));
                            }
                            result.output_format_config = map.next_value::<std::option::Option<crate::model::OutputFormatConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecognitionOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_output_config() {
            state.serialize_entry("gcsOutputConfig", value)?;
        }
        if let Some(value) = self.inline_response_config() {
            state.serialize_entry("inlineResponseConfig", value)?;
        }
        if self.output_format_config.is_some() {
            state.serialize_entry("outputFormatConfig", &self.output_format_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RecognitionOutputConfig].
pub mod recognition_output_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Output {
        /// If this message is populated, recognition results are written to the
        /// provided Google Cloud Storage URI.
        GcsOutputConfig(std::boxed::Box<crate::model::GcsOutputConfig>),
        /// If this message is populated, recognition results are provided in the
        /// [BatchRecognizeResponse][google.cloud.speech.v2.BatchRecognizeResponse]
        /// message of the Operation when completed. This is only supported when
        /// calling [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize]
        /// with just one audio file.
        ///
        /// [google.cloud.speech.v2.BatchRecognizeResponse]: crate::model::BatchRecognizeResponse
        /// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
        InlineResponseConfig(std::boxed::Box<crate::model::InlineOutputConfig>),
    }
}

/// Response message for
/// [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize] that is
/// packaged into a longrunning [Operation][google.longrunning.Operation].
///
/// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
/// [google.longrunning.Operation]: longrunning::model::Operation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRecognizeResponse {
    /// Map from filename to the final result for that file.
    pub results:
        std::collections::HashMap<std::string::String, crate::model::BatchRecognizeFileResult>,

    /// When available, billed audio seconds for the corresponding request.
    pub total_billed_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::BatchRecognizeResponse::results].
    pub fn set_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BatchRecognizeFileResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [total_billed_duration][crate::model::BatchRecognizeResponse::total_billed_duration].
    pub fn set_total_billed_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_billed_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_billed_duration][crate::model::BatchRecognizeResponse::total_billed_duration].
    pub fn set_or_clear_total_billed_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_billed_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchRecognizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRecognizeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __total_billed_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRecognizeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "totalBilledDuration" => Ok(__FieldTag::__total_billed_duration),
                            "total_billed_duration" => Ok(__FieldTag::__total_billed_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRecognizeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRecognizeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::BatchRecognizeFileResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_billed_duration => {
                            if !fields.insert(__FieldTag::__total_billed_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_billed_duration",
                                ));
                            }
                            result.total_billed_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchRecognizeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if self.total_billed_duration.is_some() {
            state.serialize_entry("totalBilledDuration", &self.total_billed_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output type for Cloud Storage of BatchRecognize transcripts. Though this
/// proto isn't returned in this API anywhere, the Cloud Storage transcripts will
/// be this proto serialized and should be parsed as such.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRecognizeResults {
    /// Sequential list of transcription results corresponding to sequential
    /// portions of audio.
    pub results: std::vec::Vec<crate::model::SpeechRecognitionResult>,

    /// Metadata about the recognition.
    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::BatchRecognizeResults::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::BatchRecognizeResults::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::BatchRecognizeResults::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchRecognizeResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeResults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRecognizeResults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRecognizeResults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRecognizeResults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRecognizeResults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SpeechRecognitionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::RecognitionResponseMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchRecognizeResults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Final results written to Cloud Storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudStorageResult {
    /// The Cloud Storage URI to which recognition results were written.
    pub uri: std::string::String,

    /// The Cloud Storage URI to which recognition results were written as VTT
    /// formatted captions. This is populated only when `VTT` output is requested.
    pub vtt_format_uri: std::string::String,

    /// The Cloud Storage URI to which recognition results were written as SRT
    /// formatted captions. This is populated only when `SRT` output is requested.
    pub srt_format_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudStorageResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::CloudStorageResult::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [vtt_format_uri][crate::model::CloudStorageResult::vtt_format_uri].
    pub fn set_vtt_format_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vtt_format_uri = v.into();
        self
    }

    /// Sets the value of [srt_format_uri][crate::model::CloudStorageResult::srt_format_uri].
    pub fn set_srt_format_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.srt_format_uri = v.into();
        self
    }
}

impl wkt::message::Message for CloudStorageResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CloudStorageResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudStorageResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __vtt_format_uri,
            __srt_format_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudStorageResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "vttFormatUri" => Ok(__FieldTag::__vtt_format_uri),
                            "vtt_format_uri" => Ok(__FieldTag::__vtt_format_uri),
                            "srtFormatUri" => Ok(__FieldTag::__srt_format_uri),
                            "srt_format_uri" => Ok(__FieldTag::__srt_format_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudStorageResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudStorageResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vtt_format_uri => {
                            if !fields.insert(__FieldTag::__vtt_format_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vtt_format_uri",
                                ));
                            }
                            result.vtt_format_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__srt_format_uri => {
                            if !fields.insert(__FieldTag::__srt_format_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for srt_format_uri",
                                ));
                            }
                            result.srt_format_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudStorageResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.vtt_format_uri.is_empty() {
            state.serialize_entry("vttFormatUri", &self.vtt_format_uri)?;
        }
        if !self.srt_format_uri.is_empty() {
            state.serialize_entry("srtFormatUri", &self.srt_format_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Final results returned inline in the recognition response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InlineResult {
    /// The transcript for the audio file.
    pub transcript: std::option::Option<crate::model::BatchRecognizeResults>,

    /// The transcript for the audio file as VTT formatted captions. This is
    /// populated only when `VTT` output is requested.
    pub vtt_captions: std::string::String,

    /// The transcript for the audio file as SRT formatted captions. This is
    /// populated only when `SRT` output is requested.
    pub srt_captions: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InlineResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcript][crate::model::InlineResult::transcript].
    pub fn set_transcript<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BatchRecognizeResults>,
    {
        self.transcript = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transcript][crate::model::InlineResult::transcript].
    pub fn set_or_clear_transcript<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BatchRecognizeResults>,
    {
        self.transcript = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vtt_captions][crate::model::InlineResult::vtt_captions].
    pub fn set_vtt_captions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vtt_captions = v.into();
        self
    }

    /// Sets the value of [srt_captions][crate::model::InlineResult::srt_captions].
    pub fn set_srt_captions<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.srt_captions = v.into();
        self
    }
}

impl wkt::message::Message for InlineResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.InlineResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InlineResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transcript,
            __vtt_captions,
            __srt_captions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InlineResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transcript" => Ok(__FieldTag::__transcript),
                            "vttCaptions" => Ok(__FieldTag::__vtt_captions),
                            "vtt_captions" => Ok(__FieldTag::__vtt_captions),
                            "srtCaptions" => Ok(__FieldTag::__srt_captions),
                            "srt_captions" => Ok(__FieldTag::__srt_captions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InlineResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InlineResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            result.transcript = map.next_value::<std::option::Option<crate::model::BatchRecognizeResults>>()?
                                ;
                        }
                        __FieldTag::__vtt_captions => {
                            if !fields.insert(__FieldTag::__vtt_captions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vtt_captions",
                                ));
                            }
                            result.vtt_captions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__srt_captions => {
                            if !fields.insert(__FieldTag::__srt_captions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for srt_captions",
                                ));
                            }
                            result.srt_captions = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InlineResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transcript.is_some() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !self.vtt_captions.is_empty() {
            state.serialize_entry("vttCaptions", &self.vtt_captions)?;
        }
        if !self.srt_captions.is_empty() {
            state.serialize_entry("srtCaptions", &self.srt_captions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Final results for a single file.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRecognizeFileResult {
    /// Error if one was encountered.
    pub error: std::option::Option<rpc::model::Status>,

    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    /// Deprecated. Use `cloud_storage_result.native_format_uri` instead.
    #[deprecated]
    pub uri: std::string::String,

    /// Deprecated. Use `inline_result.transcript` instead.
    #[deprecated]
    pub transcript: std::option::Option<crate::model::BatchRecognizeResults>,

    pub result: std::option::Option<crate::model::batch_recognize_file_result::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeFileResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::BatchRecognizeFileResult::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::BatchRecognizeFileResult::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::BatchRecognizeFileResult::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::BatchRecognizeFileResult::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uri][crate::model::BatchRecognizeFileResult::uri].
    #[deprecated]
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [transcript][crate::model::BatchRecognizeFileResult::transcript].
    #[deprecated]
    pub fn set_transcript<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BatchRecognizeResults>,
    {
        self.transcript = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transcript][crate::model::BatchRecognizeFileResult::transcript].
    #[deprecated]
    pub fn set_or_clear_transcript<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BatchRecognizeResults>,
    {
        self.transcript = v.map(|x| x.into());
        self
    }

    /// Sets the value of [result][crate::model::BatchRecognizeFileResult::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::batch_recognize_file_result::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::BatchRecognizeFileResult::result]
    /// if it holds a `CloudStorageResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudStorageResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::batch_recognize_file_result::Result::CloudStorageResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::BatchRecognizeFileResult::result]
    /// to hold a `CloudStorageResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_cloud_storage_result<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudStorageResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::batch_recognize_file_result::Result::CloudStorageResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::BatchRecognizeFileResult::result]
    /// if it holds a `InlineResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn inline_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::batch_recognize_file_result::Result::InlineResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::BatchRecognizeFileResult::result]
    /// to hold a `InlineResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_inline_result<T: std::convert::Into<std::boxed::Box<crate::model::InlineResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::batch_recognize_file_result::Result::InlineResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchRecognizeFileResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeFileResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRecognizeFileResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error,
            __metadata,
            __cloud_storage_result,
            __inline_result,
            __uri,
            __transcript,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRecognizeFileResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "error" => Ok(__FieldTag::__error),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "cloudStorageResult" => Ok(__FieldTag::__cloud_storage_result),
                            "cloud_storage_result" => Ok(__FieldTag::__cloud_storage_result),
                            "inlineResult" => Ok(__FieldTag::__inline_result),
                            "inline_result" => Ok(__FieldTag::__inline_result),
                            "uri" => Ok(__FieldTag::__uri),
                            "transcript" => Ok(__FieldTag::__transcript),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRecognizeFileResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRecognizeFileResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::RecognitionResponseMetadata>>()?
                                ;
                        }
                        __FieldTag::__cloud_storage_result => {
                            if !fields.insert(__FieldTag::__cloud_storage_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.speech.v2.BatchRecognizeFileResult.cloud_storage_result, latest field was cloudStorageResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::batch_recognize_file_result::Result::CloudStorageResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::CloudStorageResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__inline_result => {
                            if !fields.insert(__FieldTag::__inline_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inline_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.speech.v2.BatchRecognizeFileResult.inline_result, latest field was inlineResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::batch_recognize_file_result::Result::InlineResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InlineResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            result.transcript = map.next_value::<std::option::Option<crate::model::BatchRecognizeResults>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchRecognizeFileResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if let Some(value) = self.cloud_storage_result() {
            state.serialize_entry("cloudStorageResult", value)?;
        }
        if let Some(value) = self.inline_result() {
            state.serialize_entry("inlineResult", value)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if self.transcript.is_some() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchRecognizeFileResult].
pub mod batch_recognize_file_result {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Recognition results written to Cloud Storage. This is
        /// populated only when
        /// [GcsOutputConfig][google.cloud.speech.v2.GcsOutputConfig] is set in
        /// the
        /// [RecognitionOutputConfig][[google.cloud.speech.v2.RecognitionOutputConfig].
        ///
        /// [google.cloud.speech.v2.GcsOutputConfig]: crate::model::GcsOutputConfig
        CloudStorageResult(std::boxed::Box<crate::model::CloudStorageResult>),
        /// Recognition results. This is populated only when
        /// [InlineOutputConfig][google.cloud.speech.v2.InlineOutputConfig] is set in
        /// the
        /// [RecognitionOutputConfig][[google.cloud.speech.v2.RecognitionOutputConfig].
        ///
        /// [google.cloud.speech.v2.InlineOutputConfig]: crate::model::InlineOutputConfig
        InlineResult(std::boxed::Box<crate::model::InlineResult>),
    }
}

/// Metadata about transcription for a single file (for example, progress
/// percent).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRecognizeTranscriptionMetadata {
    /// How much of the file has been transcribed so far.
    pub progress_percent: i32,

    /// Error if one was encountered.
    pub error: std::option::Option<rpc::model::Status>,

    /// The Cloud Storage URI to which recognition results will be written.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeTranscriptionMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_percent][crate::model::BatchRecognizeTranscriptionMetadata::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error][crate::model::BatchRecognizeTranscriptionMetadata::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::BatchRecognizeTranscriptionMetadata::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uri][crate::model::BatchRecognizeTranscriptionMetadata::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for BatchRecognizeTranscriptionMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeTranscriptionMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRecognizeTranscriptionMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __progress_percent,
            __error,
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRecognizeTranscriptionMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "error" => Ok(__FieldTag::__error),
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRecognizeTranscriptionMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRecognizeTranscriptionMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchRecognizeTranscriptionMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Operation metadata for
/// [BatchRecognize][google.cloud.speech.v2.Speech.BatchRecognize].
///
/// [google.cloud.speech.v2.Speech.BatchRecognize]: crate::client::Speech::batch_recognize
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRecognizeMetadata {
    /// Map from provided filename to the transcription metadata for that file.
    pub transcription_metadata: std::collections::HashMap<
        std::string::String,
        crate::model::BatchRecognizeTranscriptionMetadata,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transcription_metadata][crate::model::BatchRecognizeMetadata::transcription_metadata].
    pub fn set_transcription_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BatchRecognizeTranscriptionMetadata>,
    {
        use std::iter::Iterator;
        self.transcription_metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchRecognizeMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRecognizeMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transcription_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRecognizeMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transcriptionMetadata" => Ok(__FieldTag::__transcription_metadata),
                            "transcription_metadata" => Ok(__FieldTag::__transcription_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRecognizeMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRecognizeMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transcription_metadata => {
                            if !fields.insert(__FieldTag::__transcription_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcription_metadata",
                                ));
                            }
                            result.transcription_metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::BatchRecognizeTranscriptionMetadata,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchRecognizeMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transcription_metadata.is_empty() {
            state.serialize_entry("transcriptionMetadata", &self.transcription_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata about a single file in a batch for BatchRecognize.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRecognizeFileMetadata {
    /// Features and audio metadata to use for the Automatic Speech Recognition.
    /// This field in combination with the
    /// [config_mask][google.cloud.speech.v2.BatchRecognizeFileMetadata.config_mask]
    /// field can be used to override parts of the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the Recognizer resource as well as the
    /// [config][google.cloud.speech.v2.BatchRecognizeRequest.config] at the
    /// request level.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeFileMetadata.config_mask]: crate::model::BatchRecognizeFileMetadata::config_mask
    /// [google.cloud.speech.v2.BatchRecognizeRequest.config]: crate::model::BatchRecognizeRequest::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    pub config: std::option::Option<crate::model::RecognitionConfig>,

    /// The list of fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeFileMetadata.config] that
    /// override the values in the
    /// [default_recognition_config][google.cloud.speech.v2.Recognizer.default_recognition_config]
    /// of the recognizer during this recognition request. If no mask is provided,
    /// all non-default valued fields in
    /// [config][google.cloud.speech.v2.BatchRecognizeFileMetadata.config] override
    /// the values in the recognizer for this recognition request. If a mask is
    /// provided, only the fields listed in the mask override the config in the
    /// recognizer for this recognition request. If a wildcard (`*`) is provided,
    /// [config][google.cloud.speech.v2.BatchRecognizeFileMetadata.config]
    /// completely overrides and replaces the config in the recognizer for this
    /// recognition request.
    ///
    /// [google.cloud.speech.v2.BatchRecognizeFileMetadata.config]: crate::model::BatchRecognizeFileMetadata::config
    /// [google.cloud.speech.v2.Recognizer.default_recognition_config]: crate::model::Recognizer::default_recognition_config
    pub config_mask: std::option::Option<wkt::FieldMask>,

    /// The audio source, which is a Google Cloud Storage URI.
    pub audio_source: std::option::Option<crate::model::batch_recognize_file_metadata::AudioSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchRecognizeFileMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::BatchRecognizeFileMetadata::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::BatchRecognizeFileMetadata::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_mask][crate::model::BatchRecognizeFileMetadata::config_mask].
    pub fn set_config_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_mask][crate::model::BatchRecognizeFileMetadata::config_mask].
    pub fn set_or_clear_config_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.config_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audio_source][crate::model::BatchRecognizeFileMetadata::audio_source].
    ///
    /// Note that all the setters affecting `audio_source` are mutually
    /// exclusive.
    pub fn set_audio_source<
        T: std::convert::Into<
                std::option::Option<crate::model::batch_recognize_file_metadata::AudioSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.audio_source = v.into();
        self
    }

    /// The value of [audio_source][crate::model::BatchRecognizeFileMetadata::audio_source]
    /// if it holds a `Uri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.audio_source.as_ref().and_then(|v| match v {
            crate::model::batch_recognize_file_metadata::AudioSource::Uri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [audio_source][crate::model::BatchRecognizeFileMetadata::audio_source]
    /// to hold a `Uri`.
    ///
    /// Note that all the setters affecting `audio_source` are
    /// mutually exclusive.
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.audio_source = std::option::Option::Some(
            crate::model::batch_recognize_file_metadata::AudioSource::Uri(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchRecognizeFileMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.BatchRecognizeFileMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRecognizeFileMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __config,
            __config_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRecognizeFileMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "config" => Ok(__FieldTag::__config),
                            "configMask" => Ok(__FieldTag::__config_mask),
                            "config_mask" => Ok(__FieldTag::__config_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRecognizeFileMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRecognizeFileMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            if result.audio_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `audio_source`, a oneof with full ID .google.cloud.speech.v2.BatchRecognizeFileMetadata.uri, latest field was uri",
                                ));
                            }
                            result.audio_source = std::option::Option::Some(
                                crate::model::batch_recognize_file_metadata::AudioSource::Uri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::RecognitionConfig>>(
                                )?;
                        }
                        __FieldTag::__config_mask => {
                            if !fields.insert(__FieldTag::__config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_mask",
                                ));
                            }
                            result.config_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchRecognizeFileMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uri() {
            state.serialize_entry("uri", value)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.config_mask.is_some() {
            state.serialize_entry("configMask", &self.config_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchRecognizeFileMetadata].
pub mod batch_recognize_file_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The audio source, which is a Google Cloud Storage URI.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AudioSource {
        /// Cloud Storage URI for the audio file.
        Uri(std::string::String),
    }
}

/// A streaming speech recognition result corresponding to a portion of the audio
/// that is currently being processed.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingRecognitionResult {
    /// May contain one or more recognition hypotheses. These alternatives are
    /// ordered in terms of accuracy, with the top (first) alternative being the
    /// most probable, as ranked by the recognizer.
    pub alternatives: std::vec::Vec<crate::model::SpeechRecognitionAlternative>,

    /// If `false`, this
    /// [StreamingRecognitionResult][google.cloud.speech.v2.StreamingRecognitionResult]
    /// represents an interim result that may change. If `true`, this is the final
    /// time the speech service will return this particular
    /// [StreamingRecognitionResult][google.cloud.speech.v2.StreamingRecognitionResult],
    /// the recognizer will not return any further hypotheses for this portion of
    /// the transcript and corresponding audio.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult]: crate::model::StreamingRecognitionResult
    pub is_final: bool,

    /// An estimate of the likelihood that the recognizer will not change its guess
    /// about this interim result. Values range from 0.0 (completely unstable)
    /// to 1.0 (completely stable). This field is only provided for interim results
    /// ([is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final]=`false`).
    /// The default of 0.0 is a sentinel value indicating `stability` was not set.
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    pub stability: f32,

    /// Time offset of the end of this result relative to the beginning of the
    /// audio.
    pub result_end_offset: std::option::Option<wkt::Duration>,

    /// For multi-channel audio, this is the channel number corresponding to the
    /// recognized result for the audio from that channel.
    /// For
    /// `audio_channel_count` = `N`, its output values can range from `1` to `N`.
    pub channel_tag: i32,

    /// Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag of the language in this result. This language code was
    /// detected to have the most likelihood of being spoken in the audio.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognitionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alternatives][crate::model::StreamingRecognitionResult::alternatives].
    pub fn set_alternatives<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechRecognitionAlternative>,
    {
        use std::iter::Iterator;
        self.alternatives = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [is_final][crate::model::StreamingRecognitionResult::is_final].
    pub fn set_is_final<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_final = v.into();
        self
    }

    /// Sets the value of [stability][crate::model::StreamingRecognitionResult::stability].
    pub fn set_stability<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.stability = v.into();
        self
    }

    /// Sets the value of [result_end_offset][crate::model::StreamingRecognitionResult::result_end_offset].
    pub fn set_result_end_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result_end_offset][crate::model::StreamingRecognitionResult::result_end_offset].
    pub fn set_or_clear_result_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [channel_tag][crate::model::StreamingRecognitionResult::channel_tag].
    pub fn set_channel_tag<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.channel_tag = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::StreamingRecognitionResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

impl wkt::message::Message for StreamingRecognitionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognitionResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingRecognitionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alternatives,
            __is_final,
            __stability,
            __result_end_offset,
            __channel_tag,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognitionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alternatives" => Ok(__FieldTag::__alternatives),
                            "isFinal" => Ok(__FieldTag::__is_final),
                            "is_final" => Ok(__FieldTag::__is_final),
                            "stability" => Ok(__FieldTag::__stability),
                            "resultEndOffset" => Ok(__FieldTag::__result_end_offset),
                            "result_end_offset" => Ok(__FieldTag::__result_end_offset),
                            "channelTag" => Ok(__FieldTag::__channel_tag),
                            "channel_tag" => Ok(__FieldTag::__channel_tag),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingRecognitionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognitionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alternatives => {
                            if !fields.insert(__FieldTag::__alternatives) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alternatives",
                                ));
                            }
                            result.alternatives = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SpeechRecognitionAlternative>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_final => {
                            if !fields.insert(__FieldTag::__is_final) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_final",
                                ));
                            }
                            result.is_final = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stability => {
                            if !fields.insert(__FieldTag::__stability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stability",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stability = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__result_end_offset => {
                            if !fields.insert(__FieldTag::__result_end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_end_offset",
                                ));
                            }
                            result.result_end_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__channel_tag => {
                            if !fields.insert(__FieldTag::__channel_tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel_tag",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.channel_tag = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingRecognitionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.alternatives.is_empty() {
            state.serialize_entry("alternatives", &self.alternatives)?;
        }
        if !wkt::internal::is_default(&self.is_final) {
            state.serialize_entry("isFinal", &self.is_final)?;
        }
        if !wkt::internal::is_default(&self.stability) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("stability", &__With(&self.stability))?;
        }
        if self.result_end_offset.is_some() {
            state.serialize_entry("resultEndOffset", &self.result_end_offset)?;
        }
        if !wkt::internal::is_default(&self.channel_tag) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("channelTag", &__With(&self.channel_tag))?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `StreamingRecognizeResponse` is the only message returned to the client by
/// `StreamingRecognize`. A series of zero or more `StreamingRecognizeResponse`
/// messages are streamed back to the client. If there is no recognizable
/// audio then no messages are streamed back to the client.
///
/// Here are some examples of `StreamingRecognizeResponse`s that might
/// be returned while processing audio:
///
/// 1. results { alternatives { transcript: "tube" } stability: 0.01 }
///
/// 1. results { alternatives { transcript: "to be a" } stability: 0.01 }
///
/// 1. results { alternatives { transcript: "to be" } stability: 0.9 }
///    results { alternatives { transcript: " or not to be" } stability: 0.01 }
///
/// 1. results { alternatives { transcript: "to be or not to be"
///    confidence: 0.92 }
///    alternatives { transcript: "to bee or not to bee" }
///    is_final: true }
///
/// 1. results { alternatives { transcript: " that's" } stability: 0.01 }
///
/// 1. results { alternatives { transcript: " that is" } stability: 0.9 }
///    results { alternatives { transcript: " the question" } stability: 0.01 }
///
/// 1. results { alternatives { transcript: " that is the question"
///    confidence: 0.98 }
///    alternatives { transcript: " that was the question" }
///    is_final: true }
///
///
/// Notes:
///
/// - Only two of the above responses #4 and #7 contain final results; they are
///   indicated by `is_final: true`. Concatenating these together generates the
///   full transcript: "to be or not to be that is the question".
///
/// - The others contain interim `results`. #3 and #6 contain two interim
///   `results`: the first portion has a high stability and is less likely to
///   change; the second portion has a low stability and is very likely to
///   change. A UI designer might choose to show only high stability `results`.
///
/// - The specific `stability` and `confidence` values shown above are only for
///   illustrative purposes. Actual values may vary.
///
/// - In each response, only one of these fields will be set:
///   `error`,
///   `speech_event_type`, or
///   one or more (repeated) `results`.
///
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingRecognizeResponse {
    /// This repeated list contains zero or more results that
    /// correspond to consecutive portions of the audio currently being processed.
    /// It contains zero or one
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final]=`true`
    /// result (the newly settled portion), followed by zero or more
    /// [is_final][google.cloud.speech.v2.StreamingRecognitionResult.is_final]=`false`
    /// results (the interim results).
    ///
    /// [google.cloud.speech.v2.StreamingRecognitionResult.is_final]: crate::model::StreamingRecognitionResult::is_final
    pub results: std::vec::Vec<crate::model::StreamingRecognitionResult>,

    /// Indicates the type of speech event.
    pub speech_event_type: crate::model::streaming_recognize_response::SpeechEventType,

    /// Time offset between the beginning of the audio and event emission.
    pub speech_event_offset: std::option::Option<wkt::Duration>,

    /// Metadata about the recognition.
    pub metadata: std::option::Option<crate::model::RecognitionResponseMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingRecognizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::StreamingRecognizeResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StreamingRecognitionResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [speech_event_type][crate::model::StreamingRecognizeResponse::speech_event_type].
    pub fn set_speech_event_type<
        T: std::convert::Into<crate::model::streaming_recognize_response::SpeechEventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.speech_event_type = v.into();
        self
    }

    /// Sets the value of [speech_event_offset][crate::model::StreamingRecognizeResponse::speech_event_offset].
    pub fn set_speech_event_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.speech_event_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_event_offset][crate::model::StreamingRecognizeResponse::speech_event_offset].
    pub fn set_or_clear_speech_event_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.speech_event_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::StreamingRecognizeResponse::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::StreamingRecognizeResponse::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecognitionResponseMetadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StreamingRecognizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.StreamingRecognizeResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingRecognizeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __speech_event_type,
            __speech_event_offset,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognizeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "speechEventType" => Ok(__FieldTag::__speech_event_type),
                            "speech_event_type" => Ok(__FieldTag::__speech_event_type),
                            "speechEventOffset" => Ok(__FieldTag::__speech_event_offset),
                            "speech_event_offset" => Ok(__FieldTag::__speech_event_offset),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingRecognizeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognizeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StreamingRecognitionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_event_type => {
                            if !fields.insert(__FieldTag::__speech_event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_event_type",
                                ));
                            }
                            result.speech_event_type = map
                                .next_value::<std::option::Option<
                                    crate::model::streaming_recognize_response::SpeechEventType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_event_offset => {
                            if !fields.insert(__FieldTag::__speech_event_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_event_offset",
                                ));
                            }
                            result.speech_event_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map.next_value::<std::option::Option<crate::model::RecognitionResponseMetadata>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingRecognizeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !wkt::internal::is_default(&self.speech_event_type) {
            state.serialize_entry("speechEventType", &self.speech_event_type)?;
        }
        if self.speech_event_offset.is_some() {
            state.serialize_entry("speechEventOffset", &self.speech_event_offset)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingRecognizeResponse].
pub mod streaming_recognize_response {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the type of speech event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SpeechEventType {
        /// No speech event specified.
        Unspecified,
        /// This event indicates that the server has detected the end of the user's
        /// speech utterance and expects no additional speech. Therefore, the server
        /// will not process additional audio and will close the gRPC bidirectional
        /// stream. This event is only sent if there was a force cutoff due to
        /// silence being detected early. This event is only available through the
        /// `latest_short` [model][google.cloud.speech.v2.Recognizer.model].
        ///
        /// [google.cloud.speech.v2.Recognizer.model]: crate::model::Recognizer::model
        EndOfSingleUtterance,
        /// This event indicates that the server has detected the beginning of human
        /// voice activity in the stream. This event can be returned multiple times
        /// if speech starts and stops repeatedly throughout the stream. This event
        /// is only sent if `voice_activity_events` is set to true.
        SpeechActivityBegin,
        /// This event indicates that the server has detected the end of human voice
        /// activity in the stream. This event can be returned multiple times if
        /// speech starts and stops repeatedly throughout the stream. This event is
        /// only sent if `voice_activity_events` is set to true.
        SpeechActivityEnd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SpeechEventType::value] or
        /// [SpeechEventType::name].
        UnknownValue(speech_event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod speech_event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SpeechEventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EndOfSingleUtterance => std::option::Option::Some(1),
                Self::SpeechActivityBegin => std::option::Option::Some(2),
                Self::SpeechActivityEnd => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SPEECH_EVENT_TYPE_UNSPECIFIED"),
                Self::EndOfSingleUtterance => std::option::Option::Some("END_OF_SINGLE_UTTERANCE"),
                Self::SpeechActivityBegin => std::option::Option::Some("SPEECH_ACTIVITY_BEGIN"),
                Self::SpeechActivityEnd => std::option::Option::Some("SPEECH_ACTIVITY_END"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SpeechEventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SpeechEventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SpeechEventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EndOfSingleUtterance,
                2 => Self::SpeechActivityBegin,
                3 => Self::SpeechActivityEnd,
                _ => Self::UnknownValue(speech_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SpeechEventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SPEECH_EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "END_OF_SINGLE_UTTERANCE" => Self::EndOfSingleUtterance,
                "SPEECH_ACTIVITY_BEGIN" => Self::SpeechActivityBegin,
                "SPEECH_ACTIVITY_END" => Self::SpeechActivityEnd,
                _ => Self::UnknownValue(speech_event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SpeechEventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EndOfSingleUtterance => serializer.serialize_i32(1),
                Self::SpeechActivityBegin => serializer.serialize_i32(2),
                Self::SpeechActivityEnd => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SpeechEventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SpeechEventType>::new(
                ".google.cloud.speech.v2.StreamingRecognizeResponse.SpeechEventType",
            ))
        }
    }
}

/// Message representing the config for the Speech-to-Text API. This includes an
/// optional [KMS key](https://cloud.google.com/kms/docs/resource-hierarchy#keys)
/// with which incoming data will be encrypted.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Config {
    /// Output only. Identifier. The name of the config resource. There is exactly
    /// one config resource per project per location. The expected format is
    /// `projects/{project}/locations/{location}/config`.
    pub name: std::string::String,

    /// Optional. An optional [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) that if
    /// present, will be used to encrypt Speech-to-Text resources at-rest. Updating
    /// this key will not encrypt existing resources using this key; only new
    /// resources will be encrypted using this key. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    pub kms_key_name: std::string::String,

    /// Output only. The most recent time this resource was modified.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Config::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Config::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Config::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Config::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.Config"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Config {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __kms_key_name,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Config")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Config;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Config")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Config {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [GetConfig][google.cloud.speech.v2.Speech.GetConfig] method.
///
/// [google.cloud.speech.v2.Speech.GetConfig]: crate::client::Speech::get_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConfigRequest {
    /// Required. The name of the config to retrieve. There is exactly one config
    /// resource per project per location. The expected format is
    /// `projects/{project}/locations/{location}/config`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [UpdateConfig][google.cloud.speech.v2.Speech.UpdateConfig] method.
///
/// [google.cloud.speech.v2.Speech.UpdateConfig]: crate::client::Speech::update_config
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConfigRequest {
    /// Required. The config to update.
    ///
    /// The config's `name` field is used to identify the config to be updated.
    /// The expected format is `projects/{project}/locations/{location}/config`.
    pub config: std::option::Option<crate::model::Config>,

    /// The list of fields to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::UpdateConfigRequest::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Config>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::UpdateConfigRequest::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Config>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdateConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config =
                                map.next_value::<std::option::Option<crate::model::Config>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// CustomClass for biasing in speech recognition. Used to define a set of words
/// or phrases that represents a common concept or theme likely to appear in your
/// audio, for example a list of passenger ship names.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomClass {
    /// Output only. Identifier. The resource name of the CustomClass.
    /// Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`.
    pub name: std::string::String,

    /// Output only. System-assigned unique identifier for the CustomClass.
    pub uid: std::string::String,

    /// Optional. User-settable, human-readable name for the CustomClass. Must be
    /// 63 characters or less.
    pub display_name: std::string::String,

    /// A collection of class items.
    pub items: std::vec::Vec<crate::model::custom_class::ClassItem>,

    /// Output only. The CustomClass lifecycle state.
    pub state: crate::model::custom_class::State,

    /// Output only. Creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time this resource was modified.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource was requested for deletion.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource will be purged.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Allows users to store small amounts of arbitrary data.
    /// Both the key and the value must be 63 characters or less each.
    /// At most 100 annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields. This may be sent on update, undelete, and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. Whether or not this CustomClass is in the process of being
    /// updated.
    pub reconciling: bool,

    /// Output only. The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the CustomClass is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    pub kms_key_name: std::string::String,

    /// Output only. The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which the CustomClass is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    pub kms_key_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomClass {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CustomClass::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::CustomClass::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CustomClass::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [items][crate::model::CustomClass::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::custom_class::ClassItem>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::CustomClass::state].
    pub fn set_state<T: std::convert::Into<crate::model::custom_class::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CustomClass::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CustomClass::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CustomClass::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CustomClass::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::CustomClass::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::CustomClass::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::CustomClass::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::CustomClass::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::CustomClass::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::CustomClass::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::CustomClass::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::CustomClass::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::CustomClass::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }
}

impl wkt::message::Message for CustomClass {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CustomClass"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomClass {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __display_name,
            __items,
            __state,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __annotations,
            __etag,
            __reconciling,
            __kms_key_name,
            __kms_key_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomClass")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "items" => Ok(__FieldTag::__items),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "etag" => Ok(__FieldTag::__etag),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomClass;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomClass")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__items => {
                            if !fields.insert(__FieldTag::__items) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for items",
                                ));
                            }
                            result.items = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::custom_class::ClassItem>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::custom_class::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomClass {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CustomClass].
pub mod custom_class {
    #[allow(unused_imports)]
    use super::*;

    /// An item of the class.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClassItem {
        /// The class item's value.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClassItem {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::custom_class::ClassItem::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for ClassItem {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.CustomClass.ClassItem"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClassItem {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClassItem")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClassItem;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClassItem")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClassItem {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Set of states that define the lifecycle of a CustomClass.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.  This is only used/useful for distinguishing
        /// unset values.
        Unspecified,
        /// The normal and active state.
        Active,
        /// This CustomClass has been deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Active,
                4 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.speech.v2.CustomClass.State",
            ))
        }
    }
}

/// PhraseSet for biasing in speech recognition. A PhraseSet is used to provide
/// "hints" to the speech recognizer to favor specific words and phrases in the
/// results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PhraseSet {
    /// Output only. Identifier. The resource name of the PhraseSet.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`.
    pub name: std::string::String,

    /// Output only. System-assigned unique identifier for the PhraseSet.
    pub uid: std::string::String,

    /// A list of word and phrases.
    pub phrases: std::vec::Vec<crate::model::phrase_set::Phrase>,

    /// Hint Boost. Positive value will increase the probability that a specific
    /// phrase will be recognized over other similar sounding phrases. The higher
    /// the boost, the higher the chance of false positive recognition as well.
    /// Valid `boost` values are between 0 (exclusive) and 20. We recommend using a
    /// binary search approach to finding the optimal value for your use case as
    /// well as adding phrases both with and without boost to your requests.
    pub boost: f32,

    /// User-settable, human-readable name for the PhraseSet. Must be 63
    /// characters or less.
    pub display_name: std::string::String,

    /// Output only. The PhraseSet lifecycle state.
    pub state: crate::model::phrase_set::State,

    /// Output only. Creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most recent time this resource was modified.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource was requested for deletion.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this resource will be purged.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Allows users to store small amounts of arbitrary data.
    /// Both the key and the value must be 63 characters or less each.
    /// At most 100 annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. This checksum is computed by the server based on the value of
    /// other fields. This may be sent on update, undelete, and delete requests to
    /// ensure the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Output only. Whether or not this PhraseSet is in the process of being
    /// updated.
    pub reconciling: bool,

    /// Output only. The [KMS key
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#keys) with which
    /// the PhraseSet is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    pub kms_key_name: std::string::String,

    /// Output only. The [KMS key version
    /// name](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions)
    /// with which the PhraseSet is encrypted. The expected format is
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{crypto_key_version}`.
    pub kms_key_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PhraseSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PhraseSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::PhraseSet::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [phrases][crate::model::PhraseSet::phrases].
    pub fn set_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::phrase_set::Phrase>,
    {
        use std::iter::Iterator;
        self.phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [boost][crate::model::PhraseSet::boost].
    pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.boost = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PhraseSet::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PhraseSet::state].
    pub fn set_state<T: std::convert::Into<crate::model::phrase_set::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PhraseSet::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PhraseSet::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PhraseSet::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PhraseSet::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::PhraseSet::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::PhraseSet::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::PhraseSet::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::PhraseSet::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [annotations][crate::model::PhraseSet::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::PhraseSet::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::PhraseSet::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::PhraseSet::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key_version_name][crate::model::PhraseSet::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }
}

impl wkt::message::Message for PhraseSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.PhraseSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PhraseSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __phrases,
            __boost,
            __display_name,
            __state,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __annotations,
            __etag,
            __reconciling,
            __kms_key_name,
            __kms_key_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PhraseSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "phrases" => Ok(__FieldTag::__phrases),
                            "boost" => Ok(__FieldTag::__boost),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "etag" => Ok(__FieldTag::__etag),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PhraseSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PhraseSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrases => {
                            if !fields.insert(__FieldTag::__phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrases",
                                ));
                            }
                            result.phrases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::phrase_set::Phrase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boost => {
                            if !fields.insert(__FieldTag::__boost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boost",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::phrase_set::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PhraseSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self.phrases.is_empty() {
            state.serialize_entry("phrases", &self.phrases)?;
        }
        if !wkt::internal::is_default(&self.boost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boost", &__With(&self.boost))?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PhraseSet].
pub mod phrase_set {
    #[allow(unused_imports)]
    use super::*;

    /// A Phrase contains words and phrase "hints" so that the speech recognition
    /// is more likely to recognize them. This can be used to improve the accuracy
    /// for specific words and phrases, for example, if specific commands are
    /// typically spoken by the user. This can also be used to add additional words
    /// to the vocabulary of the recognizer.
    ///
    /// List items can also include CustomClass references containing groups of
    /// words that represent common concepts that occur in natural language.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Phrase {
        /// The phrase itself.
        pub value: std::string::String,

        /// Hint Boost. Overrides the boost set at the phrase set level.
        /// Positive value will increase the probability that a specific phrase will
        /// be recognized over other similar sounding phrases. The higher the boost,
        /// the higher the chance of false positive recognition as well. Negative
        /// boost values would correspond to anti-biasing. Anti-biasing is not
        /// enabled, so negative boost values will return an error. Boost values must
        /// be between 0 and 20. Any values outside that range will return an error.
        /// We recommend using a binary search approach to finding the optimal value
        /// for your use case as well as adding phrases both with and without boost
        /// to your requests.
        pub boost: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Phrase {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::phrase_set::Phrase::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [boost][crate::model::phrase_set::Phrase::boost].
        pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.boost = v.into();
            self
        }
    }

    impl wkt::message::Message for Phrase {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.speech.v2.PhraseSet.Phrase"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Phrase {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                __boost,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Phrase")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                "boost" => Ok(__FieldTag::__boost),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Phrase;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Phrase")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__boost => {
                                if !fields.insert(__FieldTag::__boost) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for boost",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.boost = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Phrase {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !wkt::internal::is_default(&self.boost) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("boost", &__With(&self.boost))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Set of states that define the lifecycle of a PhraseSet.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state.  This is only used/useful for distinguishing
        /// unset values.
        Unspecified,
        /// The normal and active state.
        Active,
        /// This PhraseSet has been deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Active,
                4 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.speech.v2.PhraseSet.State",
            ))
        }
    }
}

/// Request message for the
/// [CreateCustomClass][google.cloud.speech.v2.Speech.CreateCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.CreateCustomClass]: crate::client::Speech::create_custom_class
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCustomClassRequest {
    /// Required. The CustomClass to create.
    pub custom_class: std::option::Option<crate::model::CustomClass>,

    /// If set, validate the request and preview the CustomClass, but do not
    /// actually create it.
    pub validate_only: bool,

    /// The ID to use for the CustomClass, which will become the final component of
    /// the CustomClass's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    pub custom_class_id: std::string::String,

    /// Required. The project and location where this CustomClass will be created.
    /// The expected format is `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_class][crate::model::CreateCustomClassRequest::custom_class].
    pub fn set_custom_class<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomClass>,
    {
        self.custom_class = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_class][crate::model::CreateCustomClassRequest::custom_class].
    pub fn set_or_clear_custom_class<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomClass>,
    {
        self.custom_class = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [custom_class_id][crate::model::CreateCustomClassRequest::custom_class_id].
    pub fn set_custom_class_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_class_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreateCustomClassRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CreateCustomClassRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCustomClassRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_class,
            __validate_only,
            __custom_class_id,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCustomClassRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customClass" => Ok(__FieldTag::__custom_class),
                            "custom_class" => Ok(__FieldTag::__custom_class),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "customClassId" => Ok(__FieldTag::__custom_class_id),
                            "custom_class_id" => Ok(__FieldTag::__custom_class_id),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCustomClassRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCustomClassRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_class => {
                            if !fields.insert(__FieldTag::__custom_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_class",
                                ));
                            }
                            result.custom_class =
                                map.next_value::<std::option::Option<crate::model::CustomClass>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_class_id => {
                            if !fields.insert(__FieldTag::__custom_class_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_class_id",
                                ));
                            }
                            result.custom_class_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCustomClassRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_class.is_some() {
            state.serialize_entry("customClass", &self.custom_class)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.custom_class_id.is_empty() {
            state.serialize_entry("customClassId", &self.custom_class_id)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] method.
///
/// [google.cloud.speech.v2.Speech.ListCustomClasses]: crate::client::Speech::list_custom_classes
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomClassesRequest {
    /// Required. The project and location of CustomClass resources to list. The
    /// expected format is `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// Number of results per requests. A valid page_size ranges from 0 to 100
    /// inclusive. If the page_size is zero or unspecified, a page size of 5 will
    /// be chosen. If the page size exceeds 100, it will be coerced down to 100.
    /// Note that a call might return fewer results than the requested page size.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] must
    /// match the call that provided the page token.
    ///
    /// [google.cloud.speech.v2.Speech.ListCustomClasses]: crate::client::Speech::list_custom_classes
    pub page_token: std::string::String,

    /// Whether, or not, to show resources that have been deleted.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomClassesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCustomClassesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCustomClassesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCustomClassesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListCustomClassesRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomClassesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListCustomClassesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomClassesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomClassesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomClassesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomClassesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomClassesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the
/// [ListCustomClasses][google.cloud.speech.v2.Speech.ListCustomClasses] method.
///
/// [google.cloud.speech.v2.Speech.ListCustomClasses]: crate::client::Speech::list_custom_classes
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCustomClassesResponse {
    /// The list of requested CustomClasses.
    pub custom_classes: std::vec::Vec<crate::model::CustomClass>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.speech.v2.ListCustomClassesRequest.page_token] to
    /// retrieve the next page. If this field is omitted, there are no subsequent
    /// pages. This token expires after 72 hours.
    ///
    /// [google.cloud.speech.v2.ListCustomClassesRequest.page_token]: crate::model::ListCustomClassesRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCustomClassesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_classes][crate::model::ListCustomClassesResponse::custom_classes].
    pub fn set_custom_classes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomClass>,
    {
        use std::iter::Iterator;
        self.custom_classes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCustomClassesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCustomClassesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListCustomClassesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCustomClassesResponse {
    type PageItem = crate::model::CustomClass;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.custom_classes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCustomClassesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_classes,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCustomClassesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customClasses" => Ok(__FieldTag::__custom_classes),
                            "custom_classes" => Ok(__FieldTag::__custom_classes),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCustomClassesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCustomClassesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_classes => {
                            if !fields.insert(__FieldTag::__custom_classes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_classes",
                                ));
                            }
                            result.custom_classes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CustomClass>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCustomClassesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.custom_classes.is_empty() {
            state.serialize_entry("customClasses", &self.custom_classes)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [GetCustomClass][google.cloud.speech.v2.Speech.GetCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.GetCustomClass]: crate::client::Speech::get_custom_class
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCustomClassRequest {
    /// Required. The name of the CustomClass to retrieve. The expected format is
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCustomClassRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetCustomClassRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCustomClassRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCustomClassRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCustomClassRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCustomClassRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCustomClassRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [UpdateCustomClass][google.cloud.speech.v2.Speech.UpdateCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.UpdateCustomClass]: crate::client::Speech::update_custom_class
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCustomClassRequest {
    /// Required. The CustomClass to update.
    ///
    /// The CustomClass's `name` field is used to identify the CustomClass to
    /// update. Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`.
    pub custom_class: std::option::Option<crate::model::CustomClass>,

    /// The list of fields to be updated. If empty, all fields are considered for
    /// update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the updated CustomClass, but do
    /// not actually update it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_class][crate::model::UpdateCustomClassRequest::custom_class].
    pub fn set_custom_class<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomClass>,
    {
        self.custom_class = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_class][crate::model::UpdateCustomClassRequest::custom_class].
    pub fn set_or_clear_custom_class<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomClass>,
    {
        self.custom_class = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCustomClassRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCustomClassRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdateCustomClassRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCustomClassRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_class,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCustomClassRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customClass" => Ok(__FieldTag::__custom_class),
                            "custom_class" => Ok(__FieldTag::__custom_class),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCustomClassRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCustomClassRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_class => {
                            if !fields.insert(__FieldTag::__custom_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_class",
                                ));
                            }
                            result.custom_class =
                                map.next_value::<std::option::Option<crate::model::CustomClass>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCustomClassRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_class.is_some() {
            state.serialize_entry("customClass", &self.custom_class)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [DeleteCustomClass][google.cloud.speech.v2.Speech.DeleteCustomClass] method.
///
/// [google.cloud.speech.v2.Speech.DeleteCustomClass]: crate::client::Speech::delete_custom_class
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCustomClassRequest {
    /// Required. The name of the CustomClass to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`
    pub name: std::string::String,

    /// If set, validate the request and preview the deleted CustomClass, but do
    /// not actually delete it.
    pub validate_only: bool,

    /// If set to true, and the CustomClass is not found, the request will succeed
    /// and  be a no-op (no Operation is recorded in this case).
    pub allow_missing: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCustomClassRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeleteCustomClassRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteCustomClassRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.DeleteCustomClassRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCustomClassRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __allow_missing,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCustomClassRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCustomClassRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCustomClassRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCustomClassRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [UndeleteCustomClass][google.cloud.speech.v2.Speech.UndeleteCustomClass]
/// method.
///
/// [google.cloud.speech.v2.Speech.UndeleteCustomClass]: crate::client::Speech::undelete_custom_class
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteCustomClassRequest {
    /// Required. The name of the CustomClass to undelete.
    /// Format:
    /// `projects/{project}/locations/{location}/customClasses/{custom_class}`
    pub name: std::string::String,

    /// If set, validate the request and preview the undeleted CustomClass, but do
    /// not actually undelete it.
    pub validate_only: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteCustomClassRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteCustomClassRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UndeleteCustomClassRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UndeleteCustomClassRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteCustomClassRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UndeleteCustomClassRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteCustomClassRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteCustomClassRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteCustomClassRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteCustomClassRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteCustomClassRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [CreatePhraseSet][google.cloud.speech.v2.Speech.CreatePhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.CreatePhraseSet]: crate::client::Speech::create_phrase_set
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePhraseSetRequest {
    /// Required. The PhraseSet to create.
    pub phrase_set: std::option::Option<crate::model::PhraseSet>,

    /// If set, validate the request and preview the PhraseSet, but do not
    /// actually create it.
    pub validate_only: bool,

    /// The ID to use for the PhraseSet, which will become the final component of
    /// the PhraseSet's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-/.
    pub phrase_set_id: std::string::String,

    /// Required. The project and location where this PhraseSet will be created.
    /// The expected format is `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_set][crate::model::CreatePhraseSetRequest::phrase_set].
    pub fn set_phrase_set<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhraseSet>,
    {
        self.phrase_set = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phrase_set][crate::model::CreatePhraseSetRequest::phrase_set].
    pub fn set_or_clear_phrase_set<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhraseSet>,
    {
        self.phrase_set = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreatePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [phrase_set_id][crate::model::CreatePhraseSetRequest::phrase_set_id].
    pub fn set_phrase_set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phrase_set_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::CreatePhraseSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreatePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.CreatePhraseSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePhraseSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase_set,
            __validate_only,
            __phrase_set_id,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePhraseSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phraseSet" => Ok(__FieldTag::__phrase_set),
                            "phrase_set" => Ok(__FieldTag::__phrase_set),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "phraseSetId" => Ok(__FieldTag::__phrase_set_id),
                            "phrase_set_id" => Ok(__FieldTag::__phrase_set_id),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePhraseSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePhraseSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase_set => {
                            if !fields.insert(__FieldTag::__phrase_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_set",
                                ));
                            }
                            result.phrase_set =
                                map.next_value::<std::option::Option<crate::model::PhraseSet>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_set_id => {
                            if !fields.insert(__FieldTag::__phrase_set_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_set_id",
                                ));
                            }
                            result.phrase_set_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePhraseSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.phrase_set.is_some() {
            state.serialize_entry("phraseSet", &self.phrase_set)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.phrase_set_id.is_empty() {
            state.serialize_entry("phraseSetId", &self.phrase_set_id)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] method.
///
/// [google.cloud.speech.v2.Speech.ListPhraseSets]: crate::client::Speech::list_phrase_sets
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPhraseSetsRequest {
    /// Required. The project and location of PhraseSet resources to list. The
    /// expected format is `projects/{project}/locations/{location}`.
    pub parent: std::string::String,

    /// The maximum number of PhraseSets to return. The service may return fewer
    /// than this value. If unspecified, at most 5 PhraseSets will be returned.
    /// The maximum value is 100; values above 100 will be coerced to 100.
    pub page_size: i32,

    /// A page token, received from a previous
    /// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] must match
    /// the call that provided the page token.
    ///
    /// [google.cloud.speech.v2.Speech.ListPhraseSets]: crate::client::Speech::list_phrase_sets
    pub page_token: std::string::String,

    /// Whether, or not, to show resources that have been deleted.
    pub show_deleted: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPhraseSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPhraseSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPhraseSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [show_deleted][crate::model::ListPhraseSetsRequest::show_deleted].
    pub fn set_show_deleted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.show_deleted = v.into();
        self
    }
}

impl wkt::message::Message for ListPhraseSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListPhraseSetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPhraseSetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __show_deleted,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPhraseSetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "showDeleted" => Ok(__FieldTag::__show_deleted),
                            "show_deleted" => Ok(__FieldTag::__show_deleted),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPhraseSetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPhraseSetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__show_deleted => {
                            if !fields.insert(__FieldTag::__show_deleted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for show_deleted",
                                ));
                            }
                            result.show_deleted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPhraseSetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.show_deleted) {
            state.serialize_entry("showDeleted", &self.show_deleted)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the
/// [ListPhraseSets][google.cloud.speech.v2.Speech.ListPhraseSets] method.
///
/// [google.cloud.speech.v2.Speech.ListPhraseSets]: crate::client::Speech::list_phrase_sets
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPhraseSetsResponse {
    /// The list of requested PhraseSets.
    pub phrase_sets: std::vec::Vec<crate::model::PhraseSet>,

    /// A token, which can be sent as
    /// [page_token][google.cloud.speech.v2.ListPhraseSetsRequest.page_token] to
    /// retrieve the next page. If this field is omitted, there are no subsequent
    /// pages. This token expires after 72 hours.
    ///
    /// [google.cloud.speech.v2.ListPhraseSetsRequest.page_token]: crate::model::ListPhraseSetsRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPhraseSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_sets][crate::model::ListPhraseSetsResponse::phrase_sets].
    pub fn set_phrase_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PhraseSet>,
    {
        use std::iter::Iterator;
        self.phrase_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPhraseSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPhraseSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ListPhraseSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPhraseSetsResponse {
    type PageItem = crate::model::PhraseSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.phrase_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPhraseSetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase_sets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPhraseSetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phraseSets" => Ok(__FieldTag::__phrase_sets),
                            "phrase_sets" => Ok(__FieldTag::__phrase_sets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPhraseSetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPhraseSetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase_sets => {
                            if !fields.insert(__FieldTag::__phrase_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_sets",
                                ));
                            }
                            result.phrase_sets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PhraseSet>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPhraseSetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.phrase_sets.is_empty() {
            state.serialize_entry("phraseSets", &self.phrase_sets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [GetPhraseSet][google.cloud.speech.v2.Speech.GetPhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.GetPhraseSet]: crate::client::Speech::get_phrase_set
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPhraseSetRequest {
    /// Required. The name of the PhraseSet to retrieve. The expected format is
    /// `projects/{project}/locations/{location}/phraseSets/{phrase_set}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPhraseSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.GetPhraseSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPhraseSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPhraseSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPhraseSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPhraseSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPhraseSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [UpdatePhraseSet][google.cloud.speech.v2.Speech.UpdatePhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.UpdatePhraseSet]: crate::client::Speech::update_phrase_set
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePhraseSetRequest {
    /// Required. The PhraseSet to update.
    ///
    /// The PhraseSet's `name` field is used to identify the PhraseSet to update.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`.
    pub phrase_set: std::option::Option<crate::model::PhraseSet>,

    /// The list of fields to update. If empty, all non-default valued fields are
    /// considered for update. Use `*` to update the entire PhraseSet resource.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set, validate the request and preview the updated PhraseSet, but do not
    /// actually update it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdatePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase_set][crate::model::UpdatePhraseSetRequest::phrase_set].
    pub fn set_phrase_set<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PhraseSet>,
    {
        self.phrase_set = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phrase_set][crate::model::UpdatePhraseSetRequest::phrase_set].
    pub fn set_or_clear_phrase_set<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PhraseSet>,
    {
        self.phrase_set = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePhraseSetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePhraseSetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdatePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UpdatePhraseSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePhraseSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase_set,
            __update_mask,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePhraseSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phraseSet" => Ok(__FieldTag::__phrase_set),
                            "phrase_set" => Ok(__FieldTag::__phrase_set),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePhraseSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePhraseSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase_set => {
                            if !fields.insert(__FieldTag::__phrase_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_set",
                                ));
                            }
                            result.phrase_set =
                                map.next_value::<std::option::Option<crate::model::PhraseSet>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdatePhraseSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.phrase_set.is_some() {
            state.serialize_entry("phraseSet", &self.phrase_set)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [DeletePhraseSet][google.cloud.speech.v2.Speech.DeletePhraseSet] method.
///
/// [google.cloud.speech.v2.Speech.DeletePhraseSet]: crate::client::Speech::delete_phrase_set
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePhraseSetRequest {
    /// Required. The name of the PhraseSet to delete.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`
    pub name: std::string::String,

    /// If set, validate the request and preview the deleted PhraseSet, but do not
    /// actually delete it.
    pub validate_only: bool,

    /// If set to true, and the PhraseSet is not found, the request will succeed
    /// and  be a no-op (no Operation is recorded in this case).
    pub allow_missing: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePhraseSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeletePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::DeletePhraseSetRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePhraseSetRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeletePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.DeletePhraseSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePhraseSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __allow_missing,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePhraseSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePhraseSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePhraseSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePhraseSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the
/// [UndeletePhraseSet][google.cloud.speech.v2.Speech.UndeletePhraseSet]
/// method.
///
/// [google.cloud.speech.v2.Speech.UndeletePhraseSet]: crate::client::Speech::undelete_phrase_set
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeletePhraseSetRequest {
    /// Required. The name of the PhraseSet to undelete.
    /// Format: `projects/{project}/locations/{location}/phraseSets/{phrase_set}`
    pub name: std::string::String,

    /// If set, validate the request and preview the undeleted PhraseSet, but do
    /// not actually undelete it.
    pub validate_only: bool,

    /// This checksum is computed by the server based on the value of other
    /// fields. This may be sent on update, undelete, and delete requests to ensure
    /// the client has an up-to-date value before proceeding.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeletePhraseSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeletePhraseSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UndeletePhraseSetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::UndeletePhraseSetRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for UndeletePhraseSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.UndeletePhraseSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeletePhraseSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeletePhraseSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeletePhraseSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeletePhraseSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeletePhraseSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a singular feature of a model. If the feature is `recognizer`,
/// the release_state of the feature represents the release_state of the model
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModelFeature {
    /// The name of the feature (Note: the feature can be `recognizer`)
    pub feature: std::string::String,

    /// The release state of the feature
    pub release_state: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelFeature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [feature][crate::model::ModelFeature::feature].
    pub fn set_feature<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.feature = v.into();
        self
    }

    /// Sets the value of [release_state][crate::model::ModelFeature::release_state].
    pub fn set_release_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_state = v.into();
        self
    }
}

impl wkt::message::Message for ModelFeature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ModelFeature"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModelFeature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __feature,
            __release_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelFeature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "feature" => Ok(__FieldTag::__feature),
                            "releaseState" => Ok(__FieldTag::__release_state),
                            "release_state" => Ok(__FieldTag::__release_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModelFeature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelFeature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__feature => {
                            if !fields.insert(__FieldTag::__feature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature",
                                ));
                            }
                            result.feature = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_state => {
                            if !fields.insert(__FieldTag::__release_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_state",
                                ));
                            }
                            result.release_state = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModelFeature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.feature.is_empty() {
            state.serialize_entry("feature", &self.feature)?;
        }
        if !self.release_state.is_empty() {
            state.serialize_entry("releaseState", &self.release_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the collection of features belonging to a model
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModelFeatures {
    /// Repeated field that contains all features of the model
    pub model_feature: std::vec::Vec<crate::model::ModelFeature>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_feature][crate::model::ModelFeatures::model_feature].
    pub fn set_model_feature<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ModelFeature>,
    {
        use std::iter::Iterator;
        self.model_feature = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModelFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ModelFeatures"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModelFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_feature,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelFeature" => Ok(__FieldTag::__model_feature),
                            "model_feature" => Ok(__FieldTag::__model_feature),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModelFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_feature => {
                            if !fields.insert(__FieldTag::__model_feature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_feature",
                                ));
                            }
                            result.model_feature = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ModelFeature>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModelFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_feature.is_empty() {
            state.serialize_entry("modelFeature", &self.model_feature)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata about the models in a given region for a specific locale.
/// Currently this is just the features of the model
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModelMetadata {
    /// Map of the model name -> features of that model
    pub model_features: std::collections::HashMap<std::string::String, crate::model::ModelFeatures>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_features][crate::model::ModelMetadata::model_features].
    pub fn set_model_features<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ModelFeatures>,
    {
        use std::iter::Iterator;
        self.model_features = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.ModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelFeatures" => Ok(__FieldTag::__model_features),
                            "model_features" => Ok(__FieldTag::__model_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_features => {
                            if !fields.insert(__FieldTag::__model_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_features",
                                ));
                            }
                            result.model_features = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ModelFeatures,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model_features.is_empty() {
            state.serialize_entry("modelFeatures", &self.model_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata about locales available in a given region. Currently this is
/// just the models that are available for each locale
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LanguageMetadata {
    /// Map of locale (language code) -> models
    pub models: std::collections::HashMap<std::string::String, crate::model::ModelMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LanguageMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [models][crate::model::LanguageMetadata::models].
    pub fn set_models<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ModelMetadata>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for LanguageMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.LanguageMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LanguageMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __models,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LanguageMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "models" => Ok(__FieldTag::__models),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LanguageMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LanguageMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ModelMetadata,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LanguageMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The access metadata for a particular region. This can be applied if the org
/// policy for the given project disallows a particular region.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessMetadata {
    /// Describes the different types of constraints that are applied.
    pub constraint_type: crate::model::access_metadata::ConstraintType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraint_type][crate::model::AccessMetadata::constraint_type].
    pub fn set_constraint_type<
        T: std::convert::Into<crate::model::access_metadata::ConstraintType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.constraint_type = v.into();
        self
    }
}

impl wkt::message::Message for AccessMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.AccessMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __constraint_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "constraintType" => Ok(__FieldTag::__constraint_type),
                            "constraint_type" => Ok(__FieldTag::__constraint_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__constraint_type => {
                            if !fields.insert(__FieldTag::__constraint_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint_type",
                                ));
                            }
                            result.constraint_type =
                                map.next_value::<std::option::Option<
                                    crate::model::access_metadata::ConstraintType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.constraint_type) {
            state.serialize_entry("constraintType", &self.constraint_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AccessMetadata].
pub mod access_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the different types of constraints that can be applied on a
    /// region.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConstraintType {
        /// Unspecified constraint applied.
        Unspecified,
        /// The project's org policy disallows the given region.
        ResourceLocationsOrgPolicyCreateConstraint,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConstraintType::value] or
        /// [ConstraintType::name].
        UnknownValue(constraint_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod constraint_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConstraintType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceLocationsOrgPolicyCreateConstraint => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONSTRAINT_TYPE_UNSPECIFIED"),
                Self::ResourceLocationsOrgPolicyCreateConstraint => {
                    std::option::Option::Some("RESOURCE_LOCATIONS_ORG_POLICY_CREATE_CONSTRAINT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConstraintType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConstraintType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConstraintType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResourceLocationsOrgPolicyCreateConstraint,
                _ => Self::UnknownValue(constraint_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConstraintType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONSTRAINT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_LOCATIONS_ORG_POLICY_CREATE_CONSTRAINT" => {
                    Self::ResourceLocationsOrgPolicyCreateConstraint
                }
                _ => Self::UnknownValue(constraint_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConstraintType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceLocationsOrgPolicyCreateConstraint => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConstraintType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConstraintType>::new(
                ".google.cloud.speech.v2.AccessMetadata.ConstraintType",
            ))
        }
    }
}

/// Main metadata for the Locations API for STT V2. Currently this is just the
/// metadata about locales, models, and features
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationsMetadata {
    /// Information about available locales, models, and features represented in
    /// the hierarchical structure of locales -> models -> features
    pub languages: std::option::Option<crate::model::LanguageMetadata>,

    /// Information about access metadata for the region and given project.
    pub access_metadata: std::option::Option<crate::model::AccessMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [languages][crate::model::LocationsMetadata::languages].
    pub fn set_languages<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LanguageMetadata>,
    {
        self.languages = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [languages][crate::model::LocationsMetadata::languages].
    pub fn set_or_clear_languages<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LanguageMetadata>,
    {
        self.languages = v.map(|x| x.into());
        self
    }

    /// Sets the value of [access_metadata][crate::model::LocationsMetadata::access_metadata].
    pub fn set_access_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AccessMetadata>,
    {
        self.access_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_metadata][crate::model::LocationsMetadata::access_metadata].
    pub fn set_or_clear_access_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AccessMetadata>,
    {
        self.access_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LocationsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.speech.v2.LocationsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __languages,
            __access_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languages" => Ok(__FieldTag::__languages),
                            "accessMetadata" => Ok(__FieldTag::__access_metadata),
                            "access_metadata" => Ok(__FieldTag::__access_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__languages => {
                            if !fields.insert(__FieldTag::__languages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for languages",
                                ));
                            }
                            result.languages = map
                                .next_value::<std::option::Option<crate::model::LanguageMetadata>>(
                                )?;
                        }
                        __FieldTag::__access_metadata => {
                            if !fields.insert(__FieldTag::__access_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_metadata",
                                ));
                            }
                            result.access_metadata = map
                                .next_value::<std::option::Option<crate::model::AccessMetadata>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.languages.is_some() {
            state.serialize_entry("languages", &self.languages)?;
        }
        if self.access_metadata.is_some() {
            state.serialize_entry("accessMetadata", &self.access_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
